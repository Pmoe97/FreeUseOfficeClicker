<!-- Top Bar -->
<div id="topBar" style="position:sticky; top:0; z-index:1000; display:flex; justify-content:space-between; align-items:center; padding:10px 20px; background:#1a1a2e; color:white; box-shadow:0 2px 10px rgba(0,0,0,0.5); transition:all 0.3s ease;">
  <div style="display:flex; gap:20px; align-items:center;">
    <div>Cash: $<span id="cashEl">0</span></div>
    <div>$/sec: $<span id="cashPerSecEl">0</span></div>
    <div>Employees: <span id="employeeCountEl">0</span></div>
    <div>Products: <span id="productCountEl">0</span></div>
    <div id="game-time-display" style="font-size:0.9rem; opacity:0.9; border-left:1px solid rgba(255,255,255,0.21); padding-left:20px; margin-left:10px;">
      ğŸŒ… Loading...
    </div>
  </div>
  <div style="display:flex; gap:10px; align-items:center;">
    <a href="https://discord.com/invite/E6N9WKpGPA" target="_blank" rel="noopener noreferrer" style="background:transparent; border:none; color:#5865F2; cursor:pointer; display:flex; align-items:center; text-decoration:none;" title="Join our Discord">
      <svg width="24" height="24" viewBox="0 0 71 55" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z" fill="currentColor"/>
      </svg>
    </a>
    <button id="fullscreenBtn" style="background:transparent; border:none; color:white; font-size:1.3rem; cursor:pointer;" title="Toggle Fullscreen">â›¶</button>
    <button id="settingsBtn" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âš™ï¸</button>
  </div>
</div>

<!-- News Ticker -->
<div id="newsTicker" style="position:sticky; top:49px; z-index:999; background:#0f3460; color:#e94560; padding:8px 20px; white-space:nowrap; overflow:hidden; font-size:0.9rem; transition:all 0.3s ease;">
  <span id="newsContent">Welcome to your new business venture! Start clicking products to earn cash.</span>
</div>

<!-- Tab Navigation -->
<div id="tabNav" style="position:sticky; top:82px; z-index:998; display:flex; background:#16213e; padding:0; overflow-x:auto; transition:all 0.3s ease;">
  <button class="tab-btn active" data-tab="dashboard" style="padding:15px 20px; background:transparent; border:none; color:#e94560; cursor:pointer; font-weight:bold;">Dashboard</button>
  <button class="tab-btn" data-tab="business" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">Business</button>
  <button class="tab-btn" data-tab="upgrades" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">âš¡ Upgrades</button>
  <button class="tab-btn" data-tab="people" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">People</button>
  <button class="tab-btn" data-tab="meetings" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">ğŸ’¬ Meetings</button>
  <button class="tab-btn" data-tab="social" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">Social</button>
  <button class="tab-btn" data-tab="gifts" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">Gifts</button>
  <button class="tab-btn" data-tab="hr" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">HR</button>
  <button class="tab-btn" data-tab="invest" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">Invest</button>
  <button class="tab-btn" data-tab="ceocorner" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">ğŸ‘‘ CEO Corner</button>
</div>

<!-- Header Collapse Toggle Button -->
<button id="toggleHeaderBtn" style="position:fixed; top:0px; left:60%; transform:translateX(-50%); z-index:1001; width:40px; height:20px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:0 0 10px 10px; cursor:pointer; display:flex; align-items:center; justify-content:center; color:white; font-size:12px; box-shadow:0 2px 8px rgba(0,0,0,0.3); transition:all 0.3s ease;" title="Collapse/Expand Header">
  <span id="toggleHeaderIcon">â–²</span>
</button>

<!-- Main Content Area -->
<div id="mainContent" style="padding:20px; background:#0f1419; min-height:calc(100vh - 140px); color:white; transition:min-height 0.3s ease;">
  
  <!-- Dashboard Tab -->
  <div id="dashboardTab" class="tab-content active">
    <h2 style="margin-top:0;">ğŸ“Š Command Center</h2>
    
    <!-- Top Stats Row - Key Metrics -->
    <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:15px; margin-bottom:25px;">
      <!-- Cash -->
      <div class="card dashboard-card" onclick="switchTab('business')" style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius:12px; padding:20px; box-shadow:0 4px 20px rgba(102,126,234,0.3); cursor:pointer; transition:transform 0.2s;">
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
          <div>
            <div style="color:rgba(255,255,255,0.8); font-size:0.85rem; margin-bottom:5px;">CURRENT CASH</div>
            <div style="font-size:1.8rem; font-weight:700; margin-bottom:5px;">$<span id="dashCash">0</span></div>
            <div style="color:rgba(255,255,255,0.7); font-size:0.8rem;">ğŸ’° <span id="dashCashPerSec">0</span>/sec</div>
          </div>
          <div style="font-size:2.5rem; opacity:0.3;">ğŸ’µ</div>
        </div>
      </div>
      
      <!-- Lifetime Earnings -->
      <div class="card dashboard-card" onclick="switchTab('invest')" style="background:linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius:12px; padding:20px; box-shadow:0 4px 20px rgba(245,87,108,0.3); cursor:pointer; transition:transform 0.2s;">
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
          <div>
            <div style="color:rgba(255,255,255,0.8); font-size:0.85rem; margin-bottom:5px;">LIFETIME EARNINGS</div>
            <div style="font-size:1.8rem; font-weight:700; margin-bottom:5px;">$<span id="dashLifetimeEarnings">0</span></div>
            <div style="color:rgba(255,255,255,0.7); font-size:0.8rem;">âœ¨ Level <span id="dashPrestigeLevel">0</span> Prestige</div>
          </div>
          <div style="font-size:2.5rem; opacity:0.3;">ğŸŒŸ</div>
        </div>
      </div>
      
      <!-- Employees -->
      <div class="card dashboard-card" onclick="switchTab('people')" style="background:linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); border-radius:12px; padding:20px; box-shadow:0 4px 20px rgba(79,172,254,0.3); cursor:pointer; transition:transform 0.2s;">
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
          <div>
            <div style="color:rgba(255,255,255,0.8); font-size:0.85rem; margin-bottom:5px;">EMPLOYEES</div>
            <div style="font-size:1.8rem; font-weight:700; margin-bottom:5px;"><span id="dashEmployeeCount">0</span></div>
            <div style="color:rgba(255,255,255,0.7); font-size:0.8rem;">ğŸ’¼ <span id="dashManagerCount">0</span> Managers</div>
          </div>
          <div style="font-size:2.5rem; opacity:0.3;">ğŸ‘¥</div>
        </div>
      </div>
      
      <!-- Products -->
      <div class="card dashboard-card" onclick="switchTab('business')" style="background:linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); border-radius:12px; padding:20px; box-shadow:0 4px 20px rgba(67,233,123,0.3); cursor:pointer; transition:transform 0.2s;">
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
          <div>
            <div style="color:rgba(255,255,255,0.8); font-size:0.85rem; margin-bottom:5px;">PRODUCTS</div>
            <div style="font-size:1.8rem; font-weight:700; margin-bottom:5px;"><span id="dashProductCount">0</span></div>
            <div style="color:rgba(255,255,255,0.7); font-size:0.8rem;">ğŸ“¦ <span id="dashRunningProducts">0</span> Running</div>
          </div>
          <div style="font-size:2.5rem; opacity:0.3;">ğŸ­</div>
        </div>
      </div>
    </div>
    
    <!-- Main Content Grid -->
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:20px;">
      
      <!-- Left Column -->
      <div style="display:flex; flex-direction:column; gap:20px;">
        
        <!-- Unread Messages -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#00d4ff;">ğŸ’¬ Recent Messages</h3>
            <button onclick="switchTab('people')" style="background:#0f3460; border:none; padding:6px 12px; border-radius:6px; color:#00d4ff; cursor:pointer; font-size:0.85rem;">View All â†’</button>
          </div>
          <div id="dashRecentMessages" style="max-height:250px; overflow-y:auto;">
            <!-- Messages will be populated here -->
          </div>
        </div>
        
        <!-- Boss Fights Progress -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#e94560;">âš”ï¸ Boss Fights</h3>
            <button onclick="switchTab('business')" style="background:#0f3460; border:none; padding:6px 12px; border-radius:6px; color:#e94560; cursor:pointer; font-size:0.85rem;">View Map â†’</button>
          </div>
          <div id="dashBossProgress">
            <!-- Boss progress will be populated here -->
          </div>
        </div>
        
        <!-- Quick Stats -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 15px 0; color:#ffd700;">ğŸ“ˆ Quick Stats</h3>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
            <div style="background:#0f3460; padding:12px; border-radius:8px;">
              <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Locations</div>
              <div style="font-size:1.3rem; font-weight:600;"><span id="dashLocationCount">0</span>/<span id="dashTotalLocations">0</span></div>
            </div>
            <div style="background:#0f3460; padding:12px; border-radius:8px;">
              <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Avg Efficiency</div>
              <div style="font-size:1.3rem; font-weight:600;"><span id="dashEfficiency">100</span>%</div>
            </div>
            <div style="background:#0f3460; padding:12px; border-radius:8px;">
              <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Influence Points</div>
              <div style="font-size:1.3rem; font-weight:600; color:#ffd700;"><span id="dashInfluencePoints">0</span> IP</div>
            </div>
            <div style="background:#0f3460; padding:12px; border-radius:8px;">
              <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Income Bonus</div>
              <div style="font-size:1.3rem; font-weight:600; color:#4ecca3;"><span id="dashIncomeMultiplier">1.0</span>x</div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Right Column -->
      <div style="display:flex; flex-direction:column; gap:20px;">
        
        <!-- Social Feed Mentions -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#ff6b9d;">ğŸ“± @TheBoss Mentions</h3>
            <button onclick="switchTab('social')" style="background:#0f3460; border:none; padding:6px 12px; border-radius:6px; color:#ff6b9d; cursor:pointer; font-size:0.85rem;">View Feed â†’</button>
          </div>
          <div id="dashSocialMentions" style="max-height:300px; overflow-y:auto;">
            <!-- Mentions will be populated here -->
          </div>
        </div>
        
        <!-- AI Quality Training Stats -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#c77dff;">ğŸ¤– AI Quality Training</h3>
            <button onclick="switchTab('social')" style="background:#0f3460; border:none; padding:6px 12px; border-radius:6px; color:#c77dff; cursor:pointer; font-size:0.85rem;">Vote on Content â†’</button>
          </div>
          
          <!-- Summary Stats -->
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;">
            <div style="background:#0f3460; padding:12px; border-radius:8px; text-align:center;">
              <div style="color:#aaa; font-size:0.75rem; margin-bottom:4px;">TOTAL VOTES</div>
              <div style="font-size:1.5rem; font-weight:700; color:#c77dff;" id="dashTotalVotes">0</div>
            </div>
            <div style="background:#0f3460; padding:12px; border-radius:8px; text-align:center;">
              <div style="color:#aaa; font-size:0.75rem; margin-bottom:4px;">QUALITY SCORE</div>
              <div style="font-size:1.5rem; font-weight:700; color:#ffd700;" id="dashQualityScore">--%</div>
            </div>
          </div>
          
          <!-- Upvote/Downvote Breakdown -->
          <div style="background:#0f3460; padding:12px; border-radius:8px; margin-bottom:15px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
              <div style="display:flex; align-items:center; gap:6px;">
                <svg width="14" height="14" viewBox="0 0 24 24" style="transform:translateY(-1px);">
                  <path fill="#ff4500" d="M12 4l8 8h-6v8h-4v-8H4z"/>
                </svg>
                <span style="color:#ff4500; font-weight:600;">Upvotes</span>
              </div>
              <span style="font-weight:700; font-size:1.1rem;" id="dashUpvotes">0</span>
            </div>
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <div style="display:flex; align-items:center; gap:6px;">
                <svg width="14" height="14" viewBox="0 0 24 24" style="transform:translateY(1px);">
                  <path fill="#7193ff" d="M12 20l-8-8h6V4h4v8h6z"/>
                </svg>
                <span style="color:#7193ff; font-weight:600;">Downvotes</span>
              </div>
              <span style="font-weight:700; font-size:1.1rem;" id="dashDownvotes">0</span>
            </div>
          </div>
          
          <!-- Content Type Breakdown -->
          <div style="background:#0f3460; padding:12px; border-radius:8px;">
            <div style="color:#aaa; font-size:0.8rem; margin-bottom:8px; font-weight:600;">VOTES BY TYPE</div>
            <div style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="font-size:0.85rem;">ğŸ“ Posts</span>
              <span style="font-weight:600;" id="dashPostsVoted">0</span>
            </div>
            <div style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="font-size:0.85rem;">ğŸ’¬ Comments</span>
              <span style="font-weight:600;" id="dashCommentsVoted">0</span>
            </div>
            <div style="display:flex; justify-content:space-between;">
              <span style="font-size:0.85rem;">ğŸ’­ Chats</span>
              <span style="font-weight:600;" id="dashChatsVoted">0</span>
            </div>
          </div>
        </div>
        
        <!-- Top Performers -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#4ecca3;">ğŸ† Top Performers</h3>
          </div>
          <div id="dashTopPerformers">
            <!-- Top performers will be populated here -->
          </div>
        </div>
        
        <!-- Company News -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 15px 0; color:#00d4ff;">ğŸ“° Company News</h3>
          <div id="newsFeed" style="max-height:250px; overflow-y:auto;">
            <!-- News items will be populated here -->
          </div>
        </div>
      </div>
      
    </div>
  </div>
  
  <!-- Business Tab -->
  <div id="businessTab" class="tab-content" hidden style="user-select:none; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h2 style="margin:0;">Business Operations</h2>
      
      <!-- Upgrade Multiplier Toggle -->
      <div style="display:flex; align-items:center; gap:10px;">
        <span style="color:#aaa; font-size:0.9rem;">Bulk Buy:</span>
        <button id="upgradeMultiplierBtn" style="padding:8px 16px; background:#0f3460; border:2px solid #e94560; border-radius:6px; color:#e94560; cursor:pointer; font-weight:bold; min-width:80px;">
          x1
        </button>
      </div>
    </div>
    
    <!-- Location Subtabs -->
    <div id="locationSubtabs" style="display:flex; gap:8px; margin-bottom:20px; overflow-x:auto; padding-bottom:5px; border-bottom:2px solid #0f3460;">
      <!-- Location subtabs will be populated here -->
    </div>
    
    <!-- Current Location Info -->
    <div id="locationInfo" style="margin-bottom:20px; padding:15px; background:rgba(15, 52, 96, 0.3); border-radius:8px; border-left:4px solid #e94560; display:none;">
      <!-- Location description will be populated here -->
    </div>
    
    <!-- Products Section -->
    <div style="margin-top:20px;">
      <div id="productsList" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(280px, 1fr)); gap:15px;">
        <!-- Product cards will be populated here -->
      </div>
    </div>
  </div>
  
  <!-- Upgrades Tab -->
  <div id="upgradesTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">âš¡ Global Upgrades</h2>
    <p style="color:#aaa; margin-bottom:30px;">Permanent upgrades that boost your entire operation. <span style="color:#ff6b6b;">âš ï¸ These reset on prestige!</span></p>
    
    <!-- Click Power Section -->
    <div style="background:#16213e; border-radius:10px; padding:20px; margin-bottom:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
        <div>
          <h3 style="margin:0 0 5px 0;">ğŸ‘† Click Power</h3>
          <p style="color:#aaa; margin:0; font-size:0.9rem;">Each upgrade reduces production time by -0.1 seconds per click</p>
        </div>
        <div style="text-align:right;">
          <div style="font-size:1.5rem; font-weight:bold; color:#4caf50;" id="clickPowerLevel">Level 0</div>
          <div style="color:#aaa; font-size:0.9rem;" id="clickPowerEffect">-1.0s per click</div>
        </div>
      </div>
      <button id="buyClickPowerBtn" style="width:100%; padding:15px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:bold; font-size:1.1rem;">
        Upgrade Click Power - <span id="clickPowerCost">$1,000</span>
      </button>
    </div>
    
    <!-- Income Boost Section -->
    <div style="background:#16213e; border-radius:10px; padding:20px; margin-bottom:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
      <h3 style="margin:0 0 15px 0;">ğŸ’° Income Boost</h3>
      <p style="color:#aaa; margin:0 0 15px 0; font-size:0.9rem;">Permanently increase income for all products in a location. +10% per level, scales to 1000%+! Costs scale by location value.</p>
      <div id="incomeBoostList" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(200px, 1fr)); gap:10px;">
        <!-- Income boost buttons will be populated here -->
      </div>
    </div>
    
    <!-- Cost Reduction Section -->
    <div style="background:#16213e; border-radius:10px; padding:20px; margin-bottom:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
      <h3 style="margin:0 0 15px 0;">ğŸ’¸ Cost Reduction</h3>
      <p style="color:#aaa; margin:0 0 15px 0; font-size:0.9rem;">Reduces ALL costs in a location: product unlocks, upgrades, manager hires & upgrades. -5% per level, caps at 95% (level 19). Costs scale by location value.</p>
      <div id="costReductionList" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(200px, 1fr)); gap:10px;">
        <!-- Cost reduction buttons will be populated here -->
      </div>
    </div>
    
    <!-- LATE-GAME UPGRADES (High-cost cash sinks) -->
    <div style="background:linear-gradient(135deg, #1e3a5f 0%, #16213e 100%); border-radius:10px; padding:20px; margin-bottom:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3); border:2px solid #ffd700;">
      <h3 style="margin:0 0 5px 0; color:#ffd700;">ğŸŒŸ Elite Upgrades</h3>
      <p style="color:#aaa; margin:0 0 20px 0; font-size:0.85rem;">Expensive late-game upgrades for massive bonuses</p>
      
      <!-- Golden Touch -->
      <div style="background:#0f1419; border-radius:8px; padding:15px; margin-bottom:15px;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h4 style="margin:0 0 5px 0; color:#ffd700;">ğŸ¤š Golden Touch</h4>
            <p style="color:#aaa; margin:0; font-size:0.85rem;">All income +5% per level (compounds!)</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:1.3rem; font-weight:bold; color:#4caf50;" id="goldenTouchLevel">Level 0</div>
            <div style="color:#ffd700; font-size:0.9rem;" id="goldenTouchBonus">+0%</div>
          </div>
        </div>
        <button id="buyGoldenTouchBtn" style="width:100%; padding:12px; background:linear-gradient(135deg, #ffd700, #ffed4e); border:none; border-radius:6px; color:#0f1419; cursor:pointer; font-weight:bold; font-size:1rem;">
          Upgrade - <span id="goldenTouchCost">$1 Qi</span>
        </button>
      </div>
      
      <!-- Time Dilation -->
      <div style="background:#0f1419; border-radius:8px; padding:15px; margin-bottom:15px;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h4 style="margin:0 0 5px 0; color:#00d4ff;">â±ï¸ Time Dilation</h4>
            <p style="color:#aaa; margin:0; font-size:0.85rem;">All products produce 3% faster per level</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:1.3rem; font-weight:bold; color:#4caf50;" id="timeDilationLevel">Level 0</div>
            <div style="color:#00d4ff; font-size:0.9rem;" id="timeDilationBonus">+0% speed</div>
          </div>
        </div>
        <button id="buyTimeDilationBtn" style="width:100%; padding:12px; background:linear-gradient(135deg, #00d4ff, #0099ff); border:none; border-radius:6px; color:white; cursor:pointer; font-weight:bold; font-size:1rem;">
          Upgrade - <span id="timeDilationCost">$5 Qi</span>
        </button>
      </div>
      
      <!-- Empire Builder -->
      <div style="background:#0f1419; border-radius:8px; padding:15px;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h4 style="margin:0 0 5px 0; color:#e94560;">ğŸ‘‘ Empire Builder</h4>
            <p style="color:#aaa; margin:0; font-size:0.85rem;">Employee productivity +10% per level</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:1.3rem; font-weight:bold; color:#4caf50;" id="empireBuilderLevel">Level 0</div>
            <div style="color:#e94560; font-size:0.9rem;" id="empireBuilderBonus">+0% productivity</div>
          </div>
        </div>
        <button id="buyEmpireBuilderBtn" style="width:100%; padding:12px; background:linear-gradient(135deg, #e94560, #ff6b9d); border:none; border-radius:6px; color:white; cursor:pointer; font-weight:bold; font-size:1rem;">
          Upgrade - <span id="empireBuilderCost">$10 Qi</span>
        </button>
      </div>
    </div>
  </div>
  
  <!-- People Tab -->
  <div id="peopleTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">Team Management</h2>
    
    <!-- Pyramid Button -->
    <div style="margin-bottom:15px;">
      <button onclick="openCorporatePyramidModal()" style="padding:12px 24px; background:linear-gradient(135deg, #ffd700, #ffed4e); border:none; border-radius:8px; color:#0f1419; cursor:pointer; font-weight:700; font-size:1rem; box-shadow:0 4px 12px rgba(255,215,0,0.3); display:inline-flex; align-items:center; gap:10px; transition:all 0.3s;"
           onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(255,215,0,0.5)';"
           onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(255,215,0,0.3)';">
        <span style="font-size:1.3rem;">ğŸ¢</span>
        <span>Corporate Pyramid</span>
      </button>
    </div>
    
    <!-- Sorting Controls -->
    <div style="background:#16213e; border-radius:10px; padding:15px; margin-bottom:20px; box-shadow:0 4px 10px rgba(0,0,0,0.2);">
      <div style="display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:12px;">
        <div style="display:flex; align-items:center; gap:8px;">
          <label style="color:#aaa; font-size:0.9rem; font-weight:600;">Sort By:</label>
          <select id="peopleSortSelect" style="padding:8px 12px; background:#0f3460; border:1px solid #00d4ff; border-radius:6px; color:#fff; cursor:pointer; font-size:0.9rem;">
            <option value="newest">â° Newest First</option>
            <option value="oldest">ğŸ“… Oldest First</option>
            <option value="recentMessages">ğŸ’¬ Recent Messages</option>
            <option value="relationshipHigh">ğŸ’– Highest Relationship</option>
            <option value="relationshipLow">ğŸ’” Lowest Relationship</option>
            <option value="location">ğŸ“ By Location</option>
            <option value="name">ğŸ”¤ Alphabetical</option>
          </select>
        </div>
        
        <div style="display:flex; align-items:center; gap:8px;">
          <button id="toggleFavoritesOnly" style="padding:8px 16px; background:#0f3460; border:1px solid #ffd700; border-radius:6px; color:#ffd700; cursor:pointer; font-size:0.9rem; font-weight:600; transition:all 0.3s;">
            â­ Show Favorites Only
          </button>
          <span id="employeeCount" style="color:#aaa; font-size:0.85rem; margin-left:8px;">0 employees</span>
        </div>
      </div>
    </div>
    
    <!-- Company-Wide Development Actions -->
    <div style="background:linear-gradient(135deg, #16213e 0%, #0f1419 100%); border-radius:10px; padding:20px; margin-bottom:20px; box-shadow:0 4px 10px rgba(0,0,0,0.2); border:2px solid #4ecca3;">
      <h3 style="margin:0 0 15px 0; color:#4ecca3; display:flex; align-items:center; gap:8px;">
        <span style="font-size:1.2rem;">ğŸ“ˆ</span>
        Employee Development Programs
      </h3>
      <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px;">
        
        <!-- Training Workshop -->
        <div style="background:#0f1419; border-radius:8px; padding:15px; border:1px solid #533483;">
          <div style="font-size:1.2rem; margin-bottom:8px;">ğŸ“</div>
          <h4 style="margin:0 0 8px 0; color:#fff; font-size:1rem;">Training Workshop</h4>
          <p style="margin:0 0 12px 0; color:#aaa; font-size:0.8rem;">All employees gain +5-10 productivity and management XP</p>
          <button id="conductTrainingBtn" onclick="conductTrainingWorkshop()" style="width:100%; padding:10px; background:linear-gradient(135deg, #533483, #7b5ba6); border:none; border-radius:6px; color:#fff; cursor:pointer; font-weight:600; font-size:0.9rem; transition:all 0.3s;" onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(83,52,131,0.4)'" onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
            Conduct Workshop
          </button>
          <div style="margin-top:8px; color:#4ecca3; font-size:0.75rem; text-align:center;" id="workshopCostDisplay">Cost: $500 per employee</div>
        </div>
        
        <!-- Team Building -->
        <div style="background:#0f1419; border-radius:8px; padding:15px; border:1px solid #e94560;">
          <div style="font-size:1.2rem; margin-bottom:8px;">ğŸ‰</div>
          <h4 style="margin:0 0 8px 0; color:#fff; font-size:1rem;">Team Building</h4>
          <p style="margin:0 0 12px 0; color:#aaa; font-size:0.8rem;">Boost productivity +3-7, morale +8, social skills for all</p>
          <button id="conductTeamBuildingBtn" onclick="conductTeamBuilding()" style="width:100%; padding:10px; background:linear-gradient(135deg, #e94560, #ff6b9d); border:none; border-radius:6px; color:#fff; cursor:pointer; font-weight:600; font-size:0.9rem; transition:all 0.3s;" onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(233,69,96,0.4)'" onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
            Host Event
          </button>
          <div style="margin-top:8px; color:#4ecca3; font-size:0.75rem; text-align:center;" id="teamBuildingCostDisplay">Cost: $800 per employee â€¢ 14 day cooldown</div>
        </div>
        
        <!-- Performance Review Note -->
        <div style="background:#0f1419; border-radius:8px; padding:15px; border:1px solid #00d4ff;">
          <div style="font-size:1.2rem; margin-bottom:8px;">ğŸ“Š</div>
          <h4 style="margin:0 0 8px 0; color:#fff; font-size:1rem;">Performance Reviews</h4>
          <p style="margin:0 0 12px 0; color:#aaa; font-size:0.8rem;">Individual reviews: +5-20 productivity based on current level</p>
          <div style="padding:10px; background:rgba(0,212,255,0.1); border-radius:6px; text-align:center;">
            <div style="color:#00d4ff; font-size:0.85rem; font-weight:600;">Use "ğŸ“Š Review" button</div>
            <div style="color:#aaa; font-size:0.75rem; margin-top:4px;">on each employee card</div>
          </div>
          <div style="margin-top:8px; color:#4ecca3; font-size:0.75rem; text-align:center;">Cost: $200 â€¢ 7 day cooldown per employee</div>
        </div>
        
      </div>
    </div>
    
    <div style="margin-top:20px;">
      <h3>Employees</h3>
      <div id="employeesList" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(250px, 1fr)); gap:15px; margin-top:10px;">
        <!-- Employee cards will be populated here -->
      </div>
    </div>
  </div>
  
  <!-- Meetings Tab -->
  <div id="meetingsTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">ğŸ’¬ Group Meetings</h2>
    <p style="color:#aaa; margin-bottom:20px;">Create meetings with up to 5 employees. They'll interact with each other naturally!</p>
    
    <div style="display:flex; gap:20px; height:calc(100vh - 200px); min-height:0; position:relative;">
      <!-- Left Sidebar - Meeting List -->
      <div id="meetingsSidebar" style="flex:0 0 300px; display:flex; flex-direction:column; gap:12px; overflow-y:auto; background:#16213e; border-radius:12px; padding:15px;">
        
        <!-- Mobile sidebar toggle tab (hidden on desktop) -->
        <button id="toggleMeetingsSidebarBtn" style="display:none; position:absolute; top:0px; right:-30px; width:30px; height:3px; background:linear-gradient(230deg, #75787f 0%, #0f3460 100%); border:none; border-radius:0 6px 6px 0; color:white; cursor:pointer; font-size:1.1rem; box-shadow:2px 0 8px rgba(0,0,0,0.3); z-index:101; transition:all 0.3s; align-items:center; justify-content:center; padding:0;">
        </button>
        
        <!-- Create New Meeting Button -->
        <button id="createMeetingBtn" style="width:100%; padding:15px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:10px; color:white; cursor:pointer; font-weight:bold; font-size:1rem; display:flex; align-items:center; justify-content:center; gap:10px; box-shadow:0 4px 15px rgba(102,126,234,0.4); transition:all 0.3s;"
                onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102,126,234,0.6)'"
                onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102,126,234,0.4)'">
          <span style="font-size:1.3rem;">â•</span>
          <span>Create New Meeting</span>
        </button>
        
        <!-- Meeting List -->
        <div id="meetingsList" style="display:flex; flex-direction:column; gap:10px;">
          <div style="text-align:center; color:#666; padding:40px 20px; font-style:italic;">
            No meetings yet.<br>
            <span style="font-size:2rem; margin-top:10px; display:block;">ğŸ’¼</span>
            Click "Create New Meeting" to start!
          </div>
        </div>
      </div>
      
      <!-- Right Side - Meeting Chat View -->
      <div id="meetingChatView" style="flex:1; background:#0f3460; border-radius:12px; display:flex; flex-direction:column; overflow:hidden; min-height:0;">
        <!-- Placeholder when no meeting selected -->
        <div id="meetingPlaceholder" style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; color:#666; text-align:center; padding:40px;">
          <div style="font-size:4rem; margin-bottom:20px;">ğŸ’¬</div>
          <h3 style="color:#aaa; margin:0 0 10px 0;">Select a Meeting</h3>
          <p style="margin:0;">Choose a meeting from the left or create a new one</p>
        </div>
        
        <!-- Meeting Chat Container (hidden by default) -->
        <div id="meetingChatContainer" style="display:none; flex:1; flex-direction:column; min-height:0; overflow:hidden;">
          <!-- Meeting Header -->
          <div id="meetingHeader" style="padding:12px; border-bottom:2px solid #16213e; background:#0f3460; flex-shrink:0; position:relative;">
            <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:8px;">
              <div style="flex:1; min-width:0;">
                <h3 id="meetingTitle" style="margin:0 0 8px 0; font-size:1rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Meeting Name</h3>
                <div id="meetingParticipants" style="display:flex; gap:6px; flex-wrap:wrap;">
                  <!-- Participant avatars will go here -->
                </div>
              </div>
              <div style="display:flex; gap:6px; flex-shrink:0;">
                <button id="generateMeetingSummaryBtn" style="background:#16213e; border:none; padding:8px 10px; border-radius:6px; color:#aaa; cursor:pointer; transition:all 0.2s; font-size:1.2rem;" 
                        onmouseenter="this.style.color='#4ecca3'" onmouseleave="this.style.color='#aaa'" title="Generate AI Summary">ğŸ“</button>
                <button id="meetingSettingsBtn" style="background:#16213e; border:none; padding:8px 10px; border-radius:6px; color:#aaa; cursor:pointer; transition:all 0.2s; font-size:1.2rem;" 
                        onmouseenter="this.style.color='#4ecca3'" onmouseleave="this.style.color='#aaa'" title="Meeting Settings">âš™ï¸</button>
                <button id="deleteMeetingBtn" style="background:#16213e; border:none; padding:8px 10px; border-radius:6px; color:#aaa; cursor:pointer; transition:all 0.2s; font-size:1.2rem;" 
                        onmouseenter="this.style.color='#e94560'" onmouseleave="this.style.color='#aaa'" title="Delete Meeting">ğŸ—‘ï¸</button>
              </div>
            </div>
            
            <!-- Meeting Attachments Menu (hidden by default) -->
            <div id="meetingAttachmentMenu" style="display:none; position:absolute; top:100%; left:50%; transform:translateX(-50%); margin-top:10px; background:#0f3460; border-radius:8px; box-shadow:0 4px 15px rgba(0,0,0,0.4); min-width:200px; z-index:1000; border:2px solid #667eea;">
              <!-- Arrow pointing up to selected participant -->
              <div id="meetingAttachmentArrow" style="position:absolute; top:-10px; left:50%; transform:translateX(-50%); width:0; height:0; border-left:10px solid transparent; border-right:10px solid transparent; border-bottom:10px solid #667eea;"></div>
              
              <div style="padding:12px; border-bottom:1px solid #16213e; background:#16213e; border-radius:6px 6px 0 0;">
                <div style="display:flex; align-items:center; gap:8px;">
                  <img id="meetingAttachmentTargetImage" src="" style="width:24px; height:24px; border-radius:50%; object-fit:cover;">
                  <span id="meetingAttachmentTargetName" style="font-weight:600; color:#fff; font-size:0.9rem;">Select participant</span>
                </div>
              </div>
              
              <button class="meeting-attach-item" data-action="send-money" style="width:100%; padding:12px 16px; background:transparent; border:none; color:#4ecca3; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px; font-weight:600;">
                <span style="font-size:1.2rem;">ğŸ’°</span> Send Money
              </button>
              <button class="meeting-attach-item" data-action="give-gift" style="width:100%; padding:12px 16px; background:transparent; border:none; color:#ff6b9d; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px; font-weight:600;">
                <span style="font-size:1.2rem;">ğŸ</span> Give Gift
              </button>
              <button class="meeting-attach-item" data-action="request" style="width:100%; padding:12px 16px; background:transparent; border:none; color:white; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px;">
                <span style="font-size:1.2rem;">ğŸ“·</span> Request Image
              </button>
              <button class="meeting-attach-item" data-action="send" style="width:100%; padding:12px 16px; background:transparent; border:none; color:white; text-align:left; cursor:pointer; display:flex; align-items:center; gap:10px;">
                <span style="font-size:1.2rem;">ğŸ“¤</span> Send Image
              </button>
            </div>
          </div>
          
          <!-- Meeting Messages -->
          <div id="meetingMessages" style="flex:1; padding:20px; overflow-y:auto; overflow-x:hidden; display:flex; flex-direction:column; gap:15px; min-height:0;">
            <!-- Messages will be added here -->
          </div>
          
          <!-- Message Input -->
          <div style="padding:20px; border-top:2px solid #16213e; background:#0f3460; flex-shrink:0; position:relative;">
            <!-- Player Attachment Menu -->
            <div id="meetingPlayerAttachmentMenu" style="display:none; position:absolute; bottom:100%; left:20px; margin-bottom:10px; width:280px; background:#0f3460; border:2px solid #4ecca3; border-radius:12px; box-shadow:0 8px 32px rgba(0,0,0,0.4); z-index:1000; overflow:hidden;">
              <div style="padding:12px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; font-weight:700; font-size:14px; text-align:center; border-bottom:2px solid #16213e;">
                Meeting Actions
              </div>
              <div style="max-height:400px; overflow-y:auto;">
                <button class="meeting-player-attach-item" data-action="send-money-group" style="width:100%; padding:12px 16px; background:transparent; border:none; color:#4ecca3; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px; font-weight:600;">
                  <span style="font-size:1.2rem;">ğŸ’°</span> Send Money (Group)
                </button>
                <button class="meeting-player-attach-item" data-action="order-food" style="width:100%; padding:12px 16px; background:transparent; border:none; color:#ff9f43; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px; font-weight:600;">
                  <span style="font-size:1.2rem;">ğŸ•</span> Order Food/Drinks
                </button>
                <button class="meeting-player-attach-item" data-action="visualize-scene" style="width:100%; padding:12px 16px; background:transparent; border:none; color:white; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px;">
                  <span style="font-size:1.2rem;">ğŸ¬</span> Visualize Current Scene
                </button>
                <button class="meeting-player-attach-item" data-action="request-group-selfie" style="width:100%; padding:12px 16px; background:transparent; border:none; color:white; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px;">
                  <span style="font-size:1.2rem;">ğŸ“·</span> Request Group Selfie
                </button>
                <button class="meeting-player-attach-item" data-action="read-the-room" style="width:100%; padding:12px 16px; background:transparent; border:none; color:#ffeaa7; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px; font-weight:600;">
                  <span style="font-size:1.2rem;">ğŸ‘ï¸</span> Read the Room
                </button>
                <button class="meeting-player-attach-item" data-action="team-building" style="width:100%; padding:12px 16px; background:transparent; border:none; color:#a29bfe; text-align:left; cursor:pointer; display:flex; align-items:center; gap:10px; font-weight:600;">
                  <span style="font-size:1.2rem;">ğŸ®</span> Start Team Building Activity
                </button>
              </div>
            </div>
            
            <div style="display:flex; gap:10px;">
              <button id="meetingPlayerAttachBtn" style="width:45px; height:45px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; border:none; border-radius:8px; cursor:pointer; font-size:24px; display:flex; align-items:center; justify-content:center; flex-shrink:0;">â•</button>
              <input id="meetingInput" type="text" placeholder="Type your message..." 
                     style="flex:1; padding:12px 15px; background:#16213e; border:none; border-radius:8px; color:white; font-size:1rem;">
              <button id="sendMeetingMessageBtn" style="padding:12px 20px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:bold; font-size:1rem;">
                Send
              </button>
              <button id="stopMeetingRepliesBtn" style="padding:12px 20px; background:#ff6b6b; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:bold; font-size:1rem; display:none;">
                â¹ï¸ Stop
              </button>
            </div>
            <div style="margin-top:10px; font-size:0.85rem; color:#aaa;">
              <span id="meetingReplyStatus">Reply limit: <span id="meetingRepliesLeft">5</span> responses remaining</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Social Tab -->
  <div id="socialTab" class="tab-content" hidden>
    <div style="display:flex; gap:15px; height:calc(100vh - 160px);">
      
      <!-- Left Sidebar - Player Post Composer & Filters -->
      <div style="flex:0 0 220px; display:flex; flex-direction:column; gap:8px; overflow-y:auto; max-height:calc(100vh - 160px);">
        
        <!-- Player Post Composer -->
        <div style="background:#16213e; border-radius:8px; padding:8px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 6px 0; color:#00d4ff; font-size:0.85rem;">Create Post</h3>
          
          <button id="playerPostBtn" style="width:100%; padding:8px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; font-size:0.85rem; display:flex; align-items:center; justify-content:center; gap:6px;">
            <span style="font-size:1rem;">âœï¸</span> New Post
          </button>
        </div>
        
        <!-- THE ALGORITHMâ„¢ - Main Sort -->
        <div style="background:#16213e; border-radius:8px; padding:8px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 6px 0; color:#00d4ff; font-size:0.85rem; display:flex; align-items:center; gap:6px;">
            <span>ğŸ¤–</span> The Algorithm
          </h3>
          
          <div style="display:flex; flex-direction:column; gap:4px;">
            <button class="algo-sort-btn active" data-sort="hot" style="padding:6px 8px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer; text-align:left; transition:all 0.2s; font-size:0.85rem; display:flex; align-items:center; justify-content:space-between;">
              <span>ğŸ”¥ Hot</span>
              <span style="font-size:0.7rem; opacity:0.6;">Rising</span>
            </button>
            <button class="algo-sort-btn" data-sort="best" style="padding:6px 8px; background:#0f3460; border:none; border-radius:6px; color:#aaa; cursor:pointer; text-align:left; transition:all 0.2s; font-size:0.85rem; display:flex; align-items:center; justify-content:space-between;">
              <span>â­ Best</span>
              <span id="bestTimeFrame" style="font-size:0.7rem; opacity:0.6;">All Time</span>
            </button>
            <button class="algo-sort-btn" data-sort="recent" style="padding:6px 8px; background:#0f3460; border:none; border-radius:6px; color:#aaa; cursor:pointer; text-align:left; transition:all 0.2s; font-size:0.85rem; display:flex; align-items:center; justify-content:space-between;">
              <span>ğŸ†• Recent</span>
              <span style="font-size:0.7rem; opacity:0.6;">New First</span>
            </button>
            <button class="algo-sort-btn" data-sort="controversial" style="padding:6px 8px; background:#0f3460; border:none; border-radius:6px; color:#aaa; cursor:pointer; text-align:left; transition:all 0.2s; font-size:0.85rem; display:flex; align-items:center; justify-content:space-between;">
              <span>âš”ï¸ Controversial</span>
              <span style="font-size:0.7rem; opacity:0.6;">Spicy</span>
            </button>
          </div>
          
          <!-- Best Time Frame Selector (shown when Best is active) -->
          <div id="bestTimeFrameSelector" style="display:none; margin-top:6px; padding:6px; background:#0a0e14; border-radius:6px;">
            <div style="font-size:0.75rem; color:#8899a6; margin-bottom:4px;">Time Frame:</div>
            <select id="bestTimeFrameSelect" style="width:100%; padding:4px; background:#16213e; border:1px solid #00d4ff; border-radius:4px; color:white; font-size:0.8rem;">
              <option value="hour">Past Hour</option>
              <option value="day">Past 24 Hours</option>
              <option value="week">Past Week</option>
              <option value="month">Past Month</option>
              <option value="all" selected>All Time</option>
            </select>
          </div>
        </div>
        
        <!-- Content Filters -->
        <div style="background:#16213e; border-radius:8px; padding:8px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 6px 0; color:#00d4ff; font-size:0.85rem;">Content Rating</h3>
          
          <div style="display:flex; flex-direction:column; gap:4px;">
            <button class="content-filter-btn active" data-rating="all" style="padding:6px 8px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer; text-align:left; transition:all 0.2s; font-size:0.85rem;">
              ğŸ“± All
            </button>
            <button class="content-filter-btn" data-rating="sfw" style="padding:6px 8px; background:#0f3460; border:none; border-radius:6px; color:#aaa; cursor:pointer; text-align:left; transition:all 0.2s; font-size:0.85rem;">
              âœ… SFW
            </button>
            <button class="content-filter-btn" data-rating="nsfw" style="padding:6px 8px; background:#0f3460; border:none; border-radius:6px; color:#aaa; cursor:pointer; text-align:left; transition:all 0.2s; font-size:0.85rem;">
              ğŸŒ¶ï¸ NSFW
            </button>
            <button class="content-filter-btn" data-rating="explicit" style="padding:6px 8px; background:#0f3460; border:none; border-radius:6px; color:#aaa; cursor:pointer; text-align:left; transition:all 0.2s; font-size:0.85rem;">
              ğŸ” Explicit
            </button>
          </div>
        </div>
        
        <!-- Advanced Filters -->
        <div style="background:#16213e; border-radius:8px; padding:8px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 6px 0; color:#00d4ff; font-size:0.85rem;">Filters</h3>
          
          <!-- Post Type Filter -->
          <div style="margin-bottom:6px;">
            <label style="font-size:0.75rem; color:#8899a6; display:block; margin-bottom:3px;">Post Type:</label>
            <select id="postTypeFilter" style="width:100%; padding:4px; background:#0f3460; border:1px solid #2f3336; border-radius:4px; color:white; font-size:0.8rem;">
              <option value="all">All Types</option>
              <option value="text">Text Only</option>
              <option value="image">With Images</option>
              <option value="selfie">Selfies</option>
              <option value="work">Work Updates</option>
            </select>
          </div>
          
          <!-- Author Filter -->
          <div style="margin-bottom:6px;">
            <label style="font-size:0.75rem; color:#8899a6; display:block; margin-bottom:3px;">Author:</label>
            <select id="authorFilter" style="width:100%; padding:4px; background:#0f3460; border:1px solid #2f3336; border-radius:4px; color:white; font-size:0.8rem;">
              <option value="all">Everyone</option>
              <option value="player">My Posts</option>
              <option value="following">Following</option>
              <!-- Employee options will be added dynamically -->
            </select>
          </div>
          
          <!-- Engagement Filter -->
          <div>
            <label style="font-size:0.75rem; color:#8899a6; display:block; margin-bottom:3px;">Engagement:</label>
            <select id="engagementFilter" style="width:100%; padding:4px; background:#0f3460; border:1px solid #2f3336; border-radius:4px; color:white; font-size:0.8rem;">
              <option value="all">All Posts</option>
              <option value="popular">Popular (5+)</option>
              <option value="viral">Viral (20+)</option>
              <option value="active">Active (5+ comments)</option>
            </select>
          </div>
        </div>
        
        <!-- Search -->
        <div style="background:#16213e; border-radius:8px; padding:8px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 6px 0; color:#00d4ff; font-size:0.85rem;">Search</h3>
          
          <div style="position:relative;">
            <input id="feedSearchInput" type="text" placeholder="Search..." style="width:100%; padding:6px 28px 6px 8px; background:#0f3460; border:1px solid #2f3336; border-radius:6px; color:white; font-size:0.8rem;">
            <button id="clearSearchBtn" style="position:absolute; right:4px; top:50%; transform:translateY(-50%); background:transparent; border:none; color:#8899a6; cursor:pointer; padding:2px 6px; font-size:1rem; display:none;">Ã—</button>
          </div>
          
          <div id="searchResultsCount" style="margin-top:4px; font-size:0.7rem; color:#8899a6; display:none;">
            <!-- Search results count will appear here -->
          </div>
        </div>
        
        <!-- Feed Stats -->
        <div style="background:#16213e; border-radius:8px; padding:8px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 6px 0; color:#00d4ff; font-size:0.85rem;">Stats</h3>
          
          <div style="display:flex; flex-direction:column; gap:4px; font-size:0.8rem;">
            <div style="display:flex; justify-content:space-between;">
              <span style="color:#aaa;">Posts:</span>
              <span id="totalPostsCount" style="color:#00d4ff; font-weight:600;">0</span>
            </div>
            <div style="display:flex; justify-content:space-between;">
              <span style="color:#aaa;">Users:</span>
              <span id="activeUsersCount" style="color:#4ecca3; font-weight:600;">0</span>
            </div>
            <div style="display:flex; justify-content:space-between;">
              <span style="color:#aaa;">Today:</span>
              <span id="todayPostsCount" style="color:#e94560; font-weight:600;">0</span>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Main Feed -->
      <div style="flex:1; display:flex; flex-direction:column; background:#16213e; border-radius:10px; box-shadow:0 4px 15px rgba(0,0,0,0.3); overflow:hidden;">
        
        <!-- Feed Header -->
        <div style="padding:15px 20px; border-bottom:1px solid #0f3460; display:flex; justify-content:space-between; align-items:center;">
          <div>
            <h2 style="margin:0; color:#00d4ff; font-size:1.3rem;">ğŸŒ The Social Feed</h2>
            <div id="feedStatsText" style="color:#8899a6; font-size:0.85rem; margin-top:4px;">Loading...</div>
          </div>
          <button id="refreshFeedBtn" style="padding:8px 16px; background:#0f3460; border:1px solid #00d4ff; border-radius:6px; color:#00d4ff; cursor:pointer; font-weight:600; display:flex; align-items:center; gap:6px; transition:all 0.2s;">
            <span style="font-size:1.1rem;">ğŸ”„</span> Refresh
          </button>
        </div>
        
        <!-- Feed Content -->
        <div id="socialFeedContent" style="flex:1; overflow-y:auto; padding:20px;">
          <!-- Posts will be rendered here -->
          <div id="feedEmptyState" style="text-align:center; padding:60px 20px; color:#aaa;">
            <div style="font-size:4rem; margin-bottom:20px; opacity:0.3;">ğŸ“±</div>
            <h3 style="margin:0 0 10px 0; color:#666;">No Posts Yet</h3>
            <p style="margin:0; font-size:0.95rem;">Posts from your employees will appear here. Start hiring employees and they'll begin posting!</p>
            <button id="testGeneratePostBtn" style="margin-top:20px; padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">
              Generate Test Post
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Gifts Tab -->
  <div id="giftsTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">ğŸ Gift Store</h2>
    
    <!-- Gift Genie Section -->
    <div style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius:15px; padding:25px; margin-bottom:25px; border:2px solid #667eea;">
      <h3 style="margin:0 0 10px 0; color:#fff; display:flex; align-items:center; gap:10px;">
        <span style="font-size:2rem;">âœ¨</span>
        Gift Genie
      </h3>
      <p style="color:#f0f0f0; margin:0 0 20px 0; font-size:0.95rem;">
        Describe any gift you can imagine - from candy bars to private islands - and the genie will create it for you!
      </p>
      
      <div style="position:relative;">
        <input 
          type="text" 
          id="giftGenieInput" 
          style="
            width:100%; 
            padding:15px; 
            border-radius:10px; 
            border:none; 
            font-size:1.1rem; 
            background:#fff; 
            color:#333;
            box-shadow:0 4px 15px rgba(0,0,0,0.2);
          ">
        <div id="giftGenieSuggestion" style="
          position:absolute;
          top:15px;
          left:15px;
          color:#aaa;
          font-size:1.1rem;
          pointer-events:none;
          transition:opacity 0.3s;
        "></div>
      </div>
      
      <div style="display:flex; gap:10px; margin-top:15px; flex-wrap:wrap;">
        <button id="generateGiftBtn" style="
          flex:1;
          min-width:200px;
          padding:15px 25px;
          background:#e94560;
          border:none;
          border-radius:10px;
          color:white;
          font-size:1.1rem;
          font-weight:bold;
          cursor:pointer;
          box-shadow:0 4px 15px rgba(233,69,96,0.3);
          transition:all 0.3s;
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(233,69,96,0.4)'"
           onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(233,69,96,0.3)'">
          âœ¨ Create Gift
        </button>
        
        <div style="display:flex; gap:10px; align-items:center; background:rgba(255,255,255,0.1); padding:10px 15px; border-radius:10px;">
          <label style="color:#fff; white-space:nowrap;">Max Budget:</label>
          <select id="giftBudgetLimit" style="
            padding:8px 12px;
            border-radius:6px;
            border:none;
            background:#fff;
            color:#333;
            font-size:0.95rem;
            cursor:pointer;
          ">
            <option value="Infinity">No Limit</option>
            <option value="100">$100</option>
            <option value="1000">$1,000</option>
            <option value="10000">$10,000</option>
            <option value="100000">$100,000</option>
            <option value="1000000">$1M</option>
            <option value="10000000">$10M</option>
            <option value="100000000">$100M</option>
          </select>
        </div>
      </div>
      
      <!-- Company scale info -->
      <div id="giftScaleInfo" style="margin-top:15px; padding:12px; background:rgba(255,255,255,0.15); border-radius:8px; color:#f0f0f0; font-size:0.9rem;">
        ğŸ’¡ Based on your company's progress, recommended gift range: <span id="recommendedGiftRange">$10 - $10,000</span>
      </div>
    </div>
    
    <!-- Gift Preview Modal (shown after generating) -->
    <div id="giftPreviewModal" style="display:none; background:#0f3460; border-radius:15px; padding:25px; margin-bottom:25px; border:2px solid #00d4ff;">
      <h3 style="margin:0 0 15px 0; color:#00d4ff;">ğŸ§â€â™‚ï¸ Gift Genie Created This</h3>
      
      <div id="giftPreviewContent" style="display:grid; grid-template-columns:1fr 2fr; gap:20px;">
        <!-- Image placeholder -->
        <div>
          <div id="giftPreviewImage" style="
            width:100%;
            aspect-ratio:1;
            background:#16213e;
            border-radius:10px;
            display:flex;
            align-items:center;
            justify-content:center;
            font-size:4rem;
          ">ğŸ</div>
          <button id="generateGiftImageBtn" style="
            width:100%;
            margin-top:10px;
            padding:10px;
            background:#667eea;
            border:none;
            border-radius:8px;
            color:white;
            cursor:pointer;
            font-size:0.9rem;
          ">ğŸ“¸ Generate Image</button>
        </div>
        
        <!-- Gift details -->
        <div>
          <h4 id="giftPreviewName" style="margin:0 0 10px 0; color:#fff; font-size:1.5rem;"></h4>
          <div style="display:flex; gap:15px; margin-bottom:15px; flex-wrap:wrap;">
            <div style="background:rgba(233,69,96,0.2); padding:8px 15px; border-radius:8px; border:1px solid #e94560;">
              <span style="color:#e94560; font-weight:bold; font-size:1.2rem;" id="giftPreviewPrice"></span>
            </div>
            <div style="background:rgba(102,126,234,0.2); padding:8px 15px; border-radius:8px; border:1px solid #667eea;">
              <span id="giftPreviewCategory" style="color:#667eea;"></span>
            </div>
          </div>
          
          <p id="giftPreviewDescription" style="color:#ddd; line-height:1.6; margin-bottom:15px;"></p>
          
          <div id="giftPreviewUnique" style="display:none; background:rgba(255,215,0,0.1); border:2px solid gold; border-radius:8px; padding:12px; margin-bottom:15px;">
            <strong style="color:gold;">â­ ONE-OF-A-KIND GIFT</strong>
            <p style="margin:5px 0 0 0; font-size:0.9rem; color:#ddd;">This unique gift can only be created once! After you stock it in the store and someone purchases it, you can never create it again.</p>
          </div>
          
          <div style="display:flex; gap:10px; margin-top:20px; flex-wrap:wrap;">
            <button id="approveGiftBtn" style="
              flex:1;
              min-width:180px;
              padding:12px 20px;
              background:#4ecca3;
              border:none;
              border-radius:8px;
              color:#0f1419;
              font-weight:bold;
              cursor:pointer;
              font-size:1rem;
            ">âœ… Approve - Stock in Store</button>
            
            <button id="redoGiftBtn" style="
              padding:12px 20px;
              background:#667eea;
              border:none;
              border-radius:8px;
              color:white;
              font-weight:bold;
              cursor:pointer;
            ">ğŸ”„ Redo</button>
            
            <button id="denyGiftBtn" style="
              padding:12px 20px;
              background:#e94560;
              border:none;
              border-radius:8px;
              color:white;
              font-weight:bold;
              cursor:pointer;
            ">âŒ Deny - Delete</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Gift Store (Available for Purchase) -->
    <div style="margin-top:30px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
        <h3 style="margin:0; color:#00d4ff;">ğŸª Gift Store - Available Gifts</h3>
        <div style="color:#aaa;">
          <span id="giftStoreCount">0</span> gifts in stock
        </div>
      </div>
      
      <div id="giftStoreGrid" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(200px, 1fr)); gap:15px; margin-bottom:30px;"></div>
    </div>
    
    <!-- Gift Inventory -->
    <div style="margin-top:30px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
        <h3 style="margin:0; color:#00d4ff;">ğŸ“¦ Your Purchased Gifts (Ready to Give)</h3>
        <div style="color:#aaa;">
          <span id="giftInventoryCount">0</span> gifts ready
        </div>
      </div>
      
      <div id="giftInventoryGrid" style="
        display:grid;
        grid-template-columns:repeat(auto-fill, minmax(220px, 1fr));
        gap:15px;
        min-height:200px;
      ">
        <!-- Gift inventory items will be populated here -->
        <div style="
          grid-column:1/-1;
          text-align:center;
          padding:60px 20px;
          color:#666;
          font-size:1.1rem;
        ">
          Your inventory is empty. Create gifts above to get started! âœ¨
        </div>
      </div>
    </div>
  </div>
  
  <!-- HR Tab -->
  <div id="hrTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">HR Policies & Office Culture</h2>
    
    <div style="margin-top:20px;">
      <h3>Office Culture Settings</h3>
      <p style="color:#aaa; font-size:0.9rem; margin-bottom:15px;">
        These settings control how employees interact with you and respond to conversations. 
        Adjust these to create the office atmosphere you prefer.
      </p>
      
      <div style="background:#16213e; border-radius:10px; padding:20px; margin-top:10px;">
        <!-- Office Atmosphere -->
        <div style="margin-bottom:25px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <label style="font-weight:600; color:#00d4ff;">Office Atmosphere</label>
            <span id="atmosphereValue" style="color:#e94560; font-weight:600;">Balanced</span>
          </div>
          <input type="range" id="atmosphereSlider" min="0" max="100" value="50" style="width:100%; margin-bottom:10px;">
          <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:#aaa; margin-bottom:10px;">
            <span>â† Professional</span>
            <span>Relaxed â†’</span>
          </div>
          <div style="background:#0f3460; padding:12px; border-radius:6px; font-size:0.85rem; color:#ddd;">
            <strong>What this affects:</strong>
            <ul style="margin:8px 0 0 20px; padding:0;">
              <li><strong>0-33 (Professional):</strong> Formal workplace. NPCs keep professional distance, maintain boundaries, and focus on work topics.</li>
              <li><strong>34-66 (Balanced):</strong> Friendly workplace. NPCs are approachable and personable while maintaining appropriate boundaries.</li>
              <li><strong>67-100 (Relaxed):</strong> Casual workplace. NPCs are very comfortable, open about personal topics, and boundaries are more flexible.</li>
            </ul>
          </div>
        </div>
        
        <!-- Interaction Style -->
        <div style="margin-bottom:25px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <label style="font-weight:600; color:#00d4ff;">Interaction Style</label>
            <span id="guidelinesValue" style="color:#e94560; font-weight:600;">Standard</span>
          </div>
          <input type="range" id="guidelinesSlider" min="0" max="100" value="50" style="width:100%; margin-bottom:10px;">
          <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:#aaa; margin-bottom:10px;">
            <span>â† Reserved</span>
            <span>Outgoing â†’</span>
          </div>
          <div style="background:#0f3460; padding:12px; border-radius:6px; font-size:0.85rem; color:#ddd;">
            <strong>What this affects:</strong>
            <ul style="margin:8px 0 0 20px; padding:0;">
              <li><strong>0-33 (Reserved):</strong> NPCs are more distant and may seem cold, tsundere-like, or defensive. Harder to build relationships.</li>
              <li><strong>34-66 (Standard):</strong> NPCs have balanced personalities - some warm, some cool, all realistic and varied.</li>
              <li><strong>67-100 (Outgoing):</strong> NPCs are friendly, expressive, and eager to connect. Relationships develop more easily.</li>
            </ul>
          </div>
        </div>
        
        <!-- Consent Model -->
        <div style="margin-bottom:15px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <label style="font-weight:600; color:#00d4ff;">Consent Model</label>
            <span id="policyValue" style="color:#e94560; font-weight:600;">Professional</span>
          </div>
          <div style="background:#0f3460; padding:12px; border-radius:6px; font-size:0.85rem; color:#ddd; margin-bottom:15px;">
            <strong>What this affects:</strong>
            <ul style="margin:8px 0 0 20px; padding:0;">
              <li><strong>Professional:</strong> NPCs maintain professional boundaries. Flirting/advances require high relationship stats and are met cautiously.</li>
              <li><strong>Casual:</strong> NPCs are open to personal connections once comfortable. Flirting is welcome when trust/affection are moderate.</li>
              <li><strong>Enthusiastic:</strong> NPCs are receptive and interested in all interactions. Everyone's consenting and relationships develop naturally without barriers.</li>
            </ul>
          </div>
          <div style="display:flex; gap:10px; flex-wrap:wrap;">
            <button class="policy-btn" data-policy="professional" style="flex:1; padding:12px 15px; background:#0f3460; border:2px solid #00d4ff; border-radius:5px; color:white; cursor:pointer; font-weight:600; transition:all 0.2s;">Professional</button>
            <button class="policy-btn" data-policy="casual" style="flex:1; padding:12px 15px; background:#0f3460; border:2px solid #00d4ff; border-radius:5px; color:white; cursor:pointer; font-weight:600; transition:all 0.2s;">Casual</button>
            <button class="policy-btn" data-policy="open" style="flex:1; padding:12px 15px; background:#0f3460; border:2px solid #00d4ff; border-radius:5px; color:white; cursor:pointer; font-weight:600; transition:all 0.2s;">Enthusiastic</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- STARTING STATS CONFIGURATION -->
    <div style="margin-top:30px;">
      <h3>Employee Starting Stats</h3>
      <p style="color:#aaa; font-size:0.9rem; margin-bottom:15px;">
        Control the starting stat ranges for new hires. Lower values make relationships feel more earned, while higher values create an easier, more welcoming workplace.
      </p>
      
      <div style="background:#16213e; border-radius:10px; padding:20px; margin-top:10px;">
        <div style="margin-bottom:20px; padding:15px; background:#0f3460; border-radius:6px;">
          <div style="color:#00d4ff; font-weight:600; margin-bottom:8px;">âš™ï¸ Presets</div>
          <div style="display:flex; gap:10px; flex-wrap:wrap;">
            <button onclick="applyStatPreset('challenging')" style="flex:1; padding:10px; background:#16213e; border:2px solid #e94560; border-radius:5px; color:white; cursor:pointer; font-weight:600;">
              ğŸ˜¤ Challenging (20-50)
            </button>
            <button onclick="applyStatPreset('balanced')" style="flex:1; padding:10px; background:#16213e; border:2px solid #00d4ff; border-radius:5px; color:white; cursor:pointer; font-weight:600;">
              âš–ï¸ Balanced (30-60)
            </button>
            <button onclick="applyStatPreset('welcoming')" style="flex:1; padding:10px; background:#16213e; border:2px solid #4ecca3; border-radius:5px; color:white; cursor:pointer; font-weight:600;">
              ğŸ˜Š Welcoming (50-75)
            </button>
          </div>
          <div style="margin-top:10px; font-size:0.85rem; color:#aaa;">
            Presets apply to all stats. You can fine-tune individual stats below.
          </div>
        </div>
        
        <!-- Individual Stat Controls -->
        <div id="statRangeControls" style="display:grid; gap:15px;">
          <!-- Will be populated by JS -->
        </div>
      </div>
    </div>
    
    <!-- GENDER DIVERSITY SECTION -->
    <div style="margin-top:30px;">
      <h3>Gender Diversity Options</h3>
      <p style="color:#aaa; font-size:0.9rem; margin-bottom:15px;">
        Control the gender distribution of new hires. All employees will still be female by default (100%), but you can adjust these sliders to introduce variety.
        Sliders are automatically proportional - they will always add up to 100%.
      </p>
      
      <div style="background:#16213e; border-radius:10px; padding:20px; margin-top:10px;">
        <button id="genderOptionsBtn" style="width:100%; padding:15px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:8px; color:white; font-size:1.1rem; font-weight:700; cursor:pointer; box-shadow:0 4px 15px rgba(102,126,234,0.4); transition:transform 0.2s; margin-bottom:15px;">
          âš§ï¸ Configure Gender & Race Options
        </button>
        
        <!-- Current Distribution Display -->
        <div style="background:#0f3460; padding:15px; border-radius:6px;">
          <div style="margin-bottom:8px; color:#aaa; font-size:0.9rem; font-weight:600;">Current Distribution:</div>
          <div id="genderDistributionDisplay" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(120px, 1fr)); gap:10px;">
            <!-- Will be populated by JS -->
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Invest Tab -->
  <div id="investTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">Investment & Prestige</h2>
    
    <!-- Prestige Overview Section -->
    <div style="background:#0f3460; border-radius:15px; padding:25px; margin-bottom:20px; border:2px solid #00d4ff;">
      <h3 style="margin:0 0 15px 0; color:#00d4ff;">ğŸŒŸ Prestige System</h3>
      <p style="color:#aaa; margin-bottom:20px; line-height:1.6;">
        Reset your progress to gain <strong style="color:#ffd700;">Influence Points</strong>, which unlock permanent bonuses that persist across all future runs. The more you've earned, the more influence you'll gain!
      </p>
      
      <!-- Current Stats -->
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:20px;">
        <div style="background:#16213e; border-radius:10px; padding:15px; text-align:center;">
          <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Prestige Level</div>
          <div style="font-size:2rem; font-weight:700; color:#00d4ff;" id="currentPrestigeLevel">0</div>
        </div>
        <div style="background:#16213e; border-radius:10px; padding:15px; text-align:center;">
          <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Lifetime Earnings</div>
          <div style="font-size:1.5rem; font-weight:700; color:#2ecc71;" id="lifetimeEarningsDisplay">$0</div>
        </div>
        <div style="background:#16213e; border-radius:10px; padding:15px; text-align:center;">
          <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Influence Points</div>
          <div style="font-size:1.5rem; font-weight:700; color:#ffd700;" id="currentInfluencePoints">0</div>
        </div>
        <div style="background:#16213e; border-radius:10px; padding:15px; text-align:center;">
          <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Income Multiplier</div>
          <div style="font-size:1.5rem; font-weight:700; color:#e74c3c;" id="currentMultiplier">1.0x</div>
        </div>
      </div>
      
      <!-- Prestige Button -->
      <div style="background:#16213e; border-radius:10px; padding:20px; text-align:center;">
        <div style="margin-bottom:15px;">
          <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Next Prestige Will Grant</div>
          <div style="font-size:2rem; font-weight:700; color:#ffd700;" id="nextPrestigeInfluence">0</div>
          <div style="color:#ffd700; font-size:0.9rem;">Influence Points</div>
        </div>
        <button id="prestigeBtn" style="padding:15px 40px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:10px; color:white; font-size:1.2rem; font-weight:700; cursor:pointer; box-shadow:0 4px 15px rgba(102,126,234,0.4); transition:transform 0.2s;">
          âœ¨ Prestige Now
        </button>
        <div id="prestigeRequirement" style="margin-top:10px; color:#e74c3c; font-size:0.9rem;"></div>
      </div>
    </div>
    
    <!-- Influence Points Upgrade Shop -->
    <div style="background:#0f3460; border-radius:15px; padding:25px;">
      <h3 style="margin:0 0 15px 0; color:#ffd700;">ğŸ’ Permanent Upgrades</h3>
      <p style="color:#aaa; margin-bottom:20px; line-height:1.6;">
        Spend Influence Points on permanent bonuses that carry through all prestige runs.
      </p>
      
      <div id="influenceUpgradesContainer" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(280px, 1fr)); gap:15px;">
        <!-- Upgrades will be dynamically populated here -->
      </div>
    </div>
  </div>
  
  <!-- CEO Corner Tab -->
  <div id="ceocornerTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">ğŸ‘‘ CEO Corner - Global Chatroom</h2>
    
    <div style="background:#0f3460; border-radius:15px; padding:25px; margin-bottom:20px; border:2px solid #ffd700;">
      <div style="display:flex; align-items:center; gap:15px; margin-bottom:15px;">
        <div style="font-size:3rem;">ğŸ’¬</div>
        <div>
          <h3 style="margin:0; color:#ffd700;">Welcome to the CEO Corner!</h3>
          <p style="color:#aaa; margin:5px 0 0 0; line-height:1.5;">
            Chat with other players from around the world. Share tips, strategies, and stories from your business empire!
          </p>
        </div>
      </div>
      
      <div style="background:#16213e; border-radius:10px; padding:15px; margin-top:15px;">
        <h4 style="margin:0 0 10px 0; color:#00d4ff;">ğŸ“œ Chat Rules</h4>
        <ul style="color:#aaa; font-size:0.9rem; margin:0; padding-left:20px; line-height:1.8;">
          <li>Be respectful to all players</li>
          <li>No spam or excessive caps</li>
          <li>Share game tips and help others</li>
          <li>Have fun and make friends! ğŸ‰</li>
        </ul>
      </div>
    </div>
    
    <!-- Chatroom Container -->
    <div style="background:#16213e; border-radius:15px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
      <div id="ceoChatroom" style="width:100%; height:600px;">
        [commentsPlugin(ceoChatOptions)]
      </div>
    </div>
  </div>
</div>

<!-- Settings Panel -->
<div id="settingsPanel" class="settings-panel" hidden style="position:fixed; top:0; right:0; width:350px; height:100%; background:#16213e; color:white; z-index:1000; box-shadow:-5px 0 15px rgba(0,0,0,0.5); overflow-y:auto;">
  <div style="padding:20px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h2 style="margin:0;">Settings</h2>
      <button id="closeSettingsBtn" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âœ•</button>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>Game Preferences</h3>
      <div style="background:#0f3460; border-radius:10px; padding:15px; margin-top:10px;">
        <div style="margin-bottom:15px;">
          <label>UI Density: <span id="densityValue">Normal</span></label>
          <input type="range" id="densitySlider" min="0" max="100" value="50" style="width:100%; margin-top:5px;">
        </div>
        <div style="margin-bottom:15px;">
          <label style="display:flex; align-items:center; gap:10px;">
            <input type="checkbox" id="autosaveToggle" checked style="width:18px; height:18px;">
            <span>Autosave</span>
          </label>
        </div>
      </div>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>âš¡ Performance Settings</h3>
      <div style="background:#0f3460; border-radius:10px; padding:15px; margin-top:10px;">
        <p style="color:#aaa; font-size:0.85rem; margin:0 0 12px 0;">Adjust these settings if you experience lag or freezing, especially with large social feeds.</p>
        <div style="margin-bottom:15px;">
          <label style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <span>Posts Per Page</span>
            <span id="postsPerPageValue" style="color:#00d4ff; font-weight:600;">20</span>
          </label>
          <input type="range" id="postsPerPageSlider" min="10" max="50" value="20" step="5" style="width:100%;">
          <div style="color:#8899a6; font-size:0.75rem; margin-top:4px;">Lower = Better performance</div>
        </div>
      </div>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>ğŸ¤– AI Request Management</h3>
      <div style="background:#0f3460; border-radius:10px; padding:15px; margin-top:10px;">
        <p style="color:#aaa; font-size:0.85rem; margin:0 0 12px 0;">Control how many AI text requests are sent simultaneously to prevent "Max Requests Exceeded" errors.</p>
        <div style="margin-bottom:15px;">
          <label style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <span>Max Concurrent Requests</span>
            <span id="maxAiRequestsValue" style="color:#00d4ff; font-weight:600;">15</span>
          </label>
          <input type="range" id="maxAiRequestsSlider" min="5" max="50" value="15" step="1" style="width:100%;">
          <div style="color:#8899a6; font-size:0.75rem; margin-top:4px;">Lower = More stable, Higher = Faster but risk errors</div>
        </div>
        <div style="margin-top:10px; padding:8px; background:#16213e; border-radius:6px; border-left:3px solid #ffd700;">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <span style="font-size:0.8rem; color:#aaa;">Queue Status:</span>
            <span id="aiQueueStatus" style="font-size:0.8rem; color:#4ecca3;">Ready</span>
          </div>
          <div style="display:flex; justify-content:space-between; align-items:center; margin-top:4px;">
            <span style="font-size:0.8rem; color:#aaa;">Active/Queued:</span>
            <span id="aiQueueCounts" style="font-size:0.8rem; color:#00d4ff;">0/0</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Image Queue Management -->
    <div style="margin-bottom:20px;">
      <h3>ğŸ–¼ï¸ Image Request Queue</h3>
      <div style="background:#0f3460; border-radius:10px; padding:15px; margin-top:10px;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
          <div>
            <div style="font-size:0.9rem; color:#ff6b9d; font-weight:600;">Max Concurrent Images</div>
            <div style="color:#8899a6; font-size:0.75rem; margin-top:2px;">Lower values = more stable generation</div>
          </div>
          <div style="display:flex; align-items:center; gap:10px;">
            <input type="range" id="maxImageRequestsSlider" min="1" max="25" value="8" 
                   style="width:120px; height:6px; background:#232931; outline:none; border-radius:3px; cursor:pointer;"
                   oninput="this.nextElementSibling.textContent = this.value; ImageRequestQueue.updateMaxConcurrent(parseInt(this.value));">
            <span style="color:#ff6b9d; font-weight:600; font-size:1rem; min-width:30px; text-align:center;">8</span>
          </div>
        </div>
        <div style="color:#8899a6; font-size:0.75rem; margin-top:4px;">Images take more resources - keep lower than text requests</div>
        <div style="margin-top:10px; padding:8px; background:#16213e; border-radius:6px; border-left:3px solid #ff6b9d;">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <span style="font-size:0.8rem; color:#aaa;">Queue Status:</span>
            <span id="imageQueueStatus" style="font-size:0.8rem; color:#4ecca3;">Ready</span>
          </div>
          <div style="display:flex; justify-content:space-between; align-items:center; margin-top:4px;">
            <span style="font-size:0.8rem; color:#aaa;">Active/Queued:</span>
            <span id="imageQueueCounts" style="font-size:0.8rem; color:#ff6b9d;">0/0</span>
          </div>
        </div>
      </div>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>ğŸ¨ Image Generation Style</h3>
      <div style="background:#0f3460; border-radius:10px; padding:15px; margin-top:10px;">
        <p style="color:#aaa; font-size:0.85rem; margin:0 0 12px 0;">Choose the default art style for ALL generated images (profiles, conversations, social posts, scenes).</p>
        <select id="imageStyleSelect" style="width:100%; padding:10px; background:#16213e; border:1px solid #667eea; border-radius:6px; color:white; font-size:0.95rem; cursor:pointer;">
          <optgroup label="ğŸŒŸ Realistic Styles">
            <option value="photorealistic">ğŸ“¸ Photorealistic</option>
            <option value="professional">ğŸ’¼ Professional Studio</option>
            <option value="cinematic">ï¿½ Cinematic Film</option>
            <option value="portrait">ğŸ–¼ï¸ Fine Art Portrait</option>
            <option value="fashion">ğŸ‘— Fashion Photography</option>
          </optgroup>
          <optgroup label="ğŸ¨ Artistic Styles">
            <option value="artistic">ğŸ¨ Artistic Painterly</option>
            <option value="watercolor">ğŸ’§ Watercolor</option>
            <option value="oilpainting">ğŸ–Œï¸ Oil Painting</option>
            <option value="vintage">ğŸ“» Vintage Pinup</option>
            <option value="noir">ğŸ© Film Noir</option>
          </optgroup>
          <optgroup label="âœ¨ Stylized Renderings">
            <option value="3d">ğŸ’ 3D Rendered (Octane)</option>
            <option value="celshaded">ğŸ® Cel-Shaded 3D</option>
            <option value="anime">ğŸŒ Anime/Manga</option>
            <option value="cartoon">ï¿½ Cartoon/Comic</option>
            <option value="digital">ğŸ–¥ï¸ Digital Illustration</option>
          </optgroup>
          <optgroup label="ğŸŒˆ Special Effects">
            <option value="fantasy">ğŸ§™ Fantasy Art</option>
            <option value="scifi">ï¿½ Sci-Fi Concept Art</option>
            <option value="neon">ğŸ’œ Neon/Cyberpunk</option>
            <option value="dreamy">ğŸŒ™ Soft Dreamy</option>
          </optgroup>
          <optgroup label="âš™ï¸ Custom">
            <option value="custom">âœï¸ Custom Prompt</option>
          </optgroup>
        </select>
        <div id="customPromptContainer" style="display:none; margin-top:12px;">
          <label style="display:block; color:#aaa; font-size:0.85rem; margin-bottom:6px;">Custom Style Prompt:</label>
          <textarea id="customStylePrompt" placeholder="Enter your custom style directive (e.g., 'watercolor painting, soft colors, dreamy atmosphere')" style="width:100%; min-height:80px; padding:10px; background:#16213e; border:1px solid #667eea; border-radius:6px; color:white; font-size:0.9rem; resize:vertical; font-family:inherit;"></textarea>
          <div style="color:#8899a6; font-size:0.75rem; margin-top:4px;">This will be appended to all image generation prompts.</div>
        </div>
        <div style="color:#8899a6; font-size:0.75rem; margin-top:8px;">This style will be applied to all future image generations consistently.</div>
      </div>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>Player Profile</h3>
      <div style="background:#0f3460; border-radius:10px; padding:15px; margin-top:10px;">
        <p style="color:#aaa; font-size:0.9rem; margin:0 0 10px 0;">Set up your detailed profile so NPCs can reference you accurately in conversations, image generation, and social posts.</p>
        <button id="openPlayerProfileBtn" style="width:100%; padding:12px; background:#00d4ff; border:none; border-radius:6px; color:#0f1419; cursor:pointer; font-weight:600; font-size:1rem; display:flex; align-items:center; justify-content:center; gap:8px;">
          <span style="font-size:1.3rem;">ğŸ‘¤</span> Edit Your Profile
        </button>
      </div>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>ğŸ® Cheats & Debugging</h3>
      <div style="background:#0f3460; border-radius:10px; padding:15px; margin-top:10px;">
        <p style="color:#aaa; font-size:0.85rem; margin:0 0 10px 0;">Modify game values for testing or just having fun!</p>
        <button id="openCheatsBtn" style="width:100%; padding:12px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; font-size:1rem; display:flex; align-items:center; justify-content:center; gap:8px;">
          <span style="font-size:1.3rem;">âš¡</span> Open Cheats Panel
        </button>
      </div>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>ğŸ“‹ Patch Notes</h3>
      <div style="background:#0f3460; border-radius:10px; padding:15px; margin-top:10px;">
        <p style="color:#aaa; font-size:0.85rem; margin:0 0 10px 0;">View update history and recent changes.</p>
        <button id="openPatchNotesBtn" style="width:100%; padding:12px; background:#667eea; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; font-size:1rem; display:flex; align-items:center; justify-content:center; gap:8px;">
          <span style="font-size:1.3rem;">ğŸ“</span> View Patch Notes
        </button>
      </div>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>Data Management</h3>
      <div style="display:flex; flex-direction:column; gap:10px; margin-top:10px;">
        <button id="openSaveManagerBtn" style="width:100%; padding:12px; background:linear-gradient(135deg, #00d4ff 0%, #667eea 100%); border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; font-size:1rem; display:flex; align-items:center; justify-content:center; gap:8px; box-shadow:0 4px 15px rgba(0,212,255,0.3); transition:transform 0.2s;">
          <span style="font-size:1.3rem;">ï¿½</span> Save/Load Manager
        </button>
        <div style="color:#8899a6; font-size:0.75rem; text-align:center; margin-top:-5px;">
          Press <span style="background:#0f3460; padding:2px 6px; border-radius:3px; font-weight:600;">F5</span> for Quick Save â€¢ 
          <span style="background:#0f3460; padding:2px 6px; border-radius:3px; font-weight:600;">F9</span> for Quick Load
        </div>
        <button id="resetBtn" style="width:100%; padding:10px; background:#e94560; border:none; border-radius:5px; color:white; cursor:pointer; font-weight:600; margin-top:5px;">ğŸ—‘ï¸ Reset Game</button>
      </div>
    </div>
  </div>
</div>

<!-- Hidden file input for importing saves -->
<input type="file" id="importFileInput" accept=".json" style="display:none;">

<!-- Chat Modal -->
<div id="chatModal" class="modal" style="position:fixed !important; top:0 !important; left:0 !important; width:100% !important; height:100% !important; background:rgba(0,0,0,0.7) !important; z-index:999999 !important; display:none !important; justify-content:center !important; align-items:center !important; pointer-events:none !important;">
  <div id="chatContainer" style="background:#16213e; width:90%; max-width:500px; height:80%; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); display:flex; flex-direction:column; pointer-events:auto;">
    <div style="padding:15px; border-bottom:1px solid #0f3460; display:flex; justify-content:space-between; align-items:center;">
      <div style="display:flex; align-items:center; gap:10px;">
        <img id="chatAvatar" src="" style="width:40px; height:40px; border-radius:50%; object-fit:cover;">
        <div>
          <h3 id="chatName" style="margin:0;"></h3>
          <p id="chatStatus" style="margin:0; font-size:0.8rem; color:#aaa;">Online</p>
        </div>
      </div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="chatSettingsBtn" style="background:#0f3460; border:none; padding:8px 12px; border-radius:5px; color:#aaa; cursor:pointer; font-size:1rem; transition:all 0.2s;" onmouseenter="this.style.background='#16213e'; this.style.color='#4ecca3'" onmouseleave="this.style.background='#0f3460'; this.style.color='#aaa'" title="Chat Display Settings">âš™ï¸</button>
        <button id="clearChatBtn" style="background:#0f3460; border:none; padding:8px 12px; border-radius:5px; color:#aaa; cursor:pointer; font-size:0.8rem; transition:all 0.2s;" onmouseenter="this.style.background='#16213e'; this.style.color='#e94560'" onmouseleave="this.style.background='#0f3460'; this.style.color='#aaa'">ğŸ—‘ï¸ Clear</button>
        <button id="closeChatBtn" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âœ•</button>
      </div>
    </div>
    
    <!-- Chat Display Settings Panel (hidden by default) -->
    <div id="chatSettingsPanel" style="display:none; padding:15px; border-bottom:1px solid #0f3460; background:#0f1419;">
      <h4 style="margin:0 0 15px 0; color:#4ecca3; font-size:0.9rem;">ğŸ’» Display Settings</h4>
      
      <div style="margin-bottom:12px;">
        <label style="display:block; margin-bottom:5px; font-size:0.85rem; color:#aaa;">Chat Width: <span id="chatWidthValue2" style="color:#4ecca3; font-weight:bold;">500px</span></label>
        <input type="range" id="chatWidthSlider2" min="300" max="800" value="500" step="10" style="width:100%;">
      </div>
      
      <div style="margin-bottom:12px;">
        <label style="display:block; margin-bottom:5px; font-size:0.85rem; color:#aaa;">Chat Height: <span id="chatHeightValue2" style="color:#4ecca3; font-weight:bold;">80%</span></label>
        <input type="range" id="chatHeightSlider2" min="50" max="95" value="80" step="5" style="width:100%;">
      </div>
      
      <div style="margin-bottom:12px;">
        <label style="display:block; margin-bottom:5px; font-size:0.85rem; color:#aaa;">Text Size: <span id="textSizeValue2" style="color:#4ecca3; font-weight:bold;">100%</span></label>
        <input type="range" id="textSizeSlider2" min="70" max="150" value="100" step="5" style="width:100%;">
      </div>
      
      <div style="margin-bottom:0;">
        <label style="display:block; margin-bottom:5px; font-size:0.85rem; color:#aaa;">Image Size: <span id="imagePreviewSizeValue2" style="color:#4ecca3; font-weight:bold;">300px</span></label>
        <input type="range" id="imagePreviewSizeSlider2" min="200" max="600" value="300" step="25" style="width:100%;">
      </div>
      
      <div style="margin-top:15px; padding-top:12px; border-top:1px solid #333;">
        <label style="display:block; margin-bottom:8px; font-size:0.85rem; color:#aaa;">ğŸ“ Communication Mode:</label>
        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <label style="display:flex; align-items:center; gap:5px; cursor:pointer; color:#ccc; font-size:0.85rem;">
            <input type="radio" name="chatCommMode" value="auto" checked style="accent-color:#4ecca3;"> Auto
          </label>
          <label style="display:flex; align-items:center; gap:5px; cursor:pointer; color:#ccc; font-size:0.85rem;">
            <input type="radio" name="chatCommMode" value="in-person" style="accent-color:#4ecca3;"> ğŸ‘¥ In-Person
          </label>
          <label style="display:flex; align-items:center; gap:5px; cursor:pointer; color:#ccc; font-size:0.85rem;">
            <input type="radio" name="chatCommMode" value="remote" style="accent-color:#4ecca3;"> ğŸ“± Remote
          </label>
        </div>
        <p style="margin:6px 0 0 0; font-size:0.7rem; color:#666;">Tells the NPC if you're chatting face-to-face or via text/phone.</p>
      </div>
    </div>
    
    <div id="chatMessages" style="flex:1; padding:15px; overflow-y:auto; display:flex; flex-direction:column; gap:10px;">
      <!-- Chat messages will appear here -->
    </div>
    
    <!-- NPC Action Buttons Container (Collapsible) -->
    <div id="npcActionButtonsWrapper" style="border-top:1px solid #0f3460; background:rgba(15,52,96,0.3);">
      <!-- Collapse Toggle Header -->
      <div id="npcActionToggle" style="padding:6px 15px; display:flex; justify-content:space-between; align-items:center; cursor:pointer; user-select:none;" onclick="toggleNpcActionBar()">
        <span style="font-size:0.75rem; color:#666;">âš¡ Actions</span>
        <span id="npcActionToggleIcon" style="font-size:0.7rem; color:#666; transition:transform 0.2s;">â–¼</span>
      </div>
      <!-- Collapsible Content -->
      <div id="npcActionButtonsContainer" style="padding:4px 15px 10px 15px; display:flex; gap:6px; flex-wrap:wrap; align-items:center; max-height:200px; overflow-y:auto; transition:max-height 0.3s ease, padding 0.3s ease, opacity 0.3s ease;">
        <!-- Action buttons will be dynamically inserted here -->
      </div>
    </div>
    
    <div style="padding:15px; border-top:1px solid #0f3460; display:flex; gap:10px; position:relative;">
      <button id="chatAttachBtn" style="padding:8px 12px; background:#0f3460; border:none; border-radius:5px; color:white; cursor:pointer; font-weight:bold; font-size:1.2rem;">+</button>
      <button id="chatEmojiBtn" class="emoji-picker-trigger" style="padding:8px 12px; background:#0f3460; border:none; border-radius:5px; cursor:pointer; font-size:1.2rem;">ğŸ˜Š</button>
      <input id="chatInput" type="text" placeholder="Type a message..." style="flex:1; padding:10px; background:#0f1419; border:none; border-radius:5px; color:white;">
      <button id="chatSendBtn" style="padding:8px 15px; background:#e94560; border:none; border-radius:5px; color:white; cursor:pointer;">Send</button>
      
      <!-- Attachment Menu (hidden by default) -->
      <div id="attachmentMenu" style="display:none; position:absolute; bottom:60px; left:0; background:#0f3460; border-radius:8px; box-shadow:0 4px 15px rgba(0,0,0,0.4); min-width:200px; z-index:10;">
        <button class="attach-menu-item" data-action="send-money" style="width:100%; padding:12px 16px; background:transparent; border:none; color:#4ecca3; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px; font-weight:600;">
          <span style="font-size:1.2rem;">ğŸ’°</span> Send Money
        </button>
        <button class="attach-menu-item" data-action="give-gift" style="width:100%; padding:12px 16px; background:transparent; border:none; color:#ff6b9d; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px; font-weight:600;">
          <span style="font-size:1.2rem;">ğŸ</span> Give Gift
        </button>
        <button class="attach-menu-item" data-action="request" style="width:100%; padding:12px 16px; background:transparent; border:none; color:white; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.2rem;">ğŸ“·</span> Request Image
        </button>
        <button class="attach-menu-item" data-action="send" style="width:100%; padding:12px 16px; background:transparent; border:none; color:white; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.2rem;">ğŸ“¤</span> Send Image
        </button>
        <button class="attach-menu-item" data-action="request-post" style="width:100%; padding:12px 16px; background:transparent; border:none; color:white; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.2rem;">ğŸ“±</span> Request Social Post
        </button>
        <button class="attach-menu-item" data-action="visualize" style="width:100%; padding:12px 16px; background:transparent; border:none; color:white; text-align:left; cursor:pointer; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.2rem;">ğŸ¬</span> Visual Current Scene
        </button>
      </div>
    </div>
    
    <div id="chatTypingIndicator" style="padding:10px 15px; color:#aaa; font-style:italic; display:none;">
      <span id="chatTypingName"></span> is typing...
    </div>
  </div>
</div>

<!-- Patch Notes Modal -->
<div id="patchNotesModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:10000; justify-content:center; align-items:center; overflow-y:auto;">
  <div style="background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); width:95%; max-width:900px; max-height:90vh; border-radius:20px; box-shadow:0 10px 40px rgba(102,126,234,0.4); border:2px solid #667eea; overflow-y:auto; margin:20px;">
    <div style="position:sticky; top:0; background:linear-gradient(135deg, #16213e 0%, #0f3460 100%); padding:20px; border-bottom:2px solid #667eea; z-index:10; border-radius:20px 20px 0 0;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="display:flex; align-items:center; gap:12px;">
          <span style="font-size:2rem;">ğŸ“</span>
          <h2 style="margin:0; color:#667eea; text-shadow:0 0 10px rgba(102,126,234,0.5);">Patch Notes</h2>
        </div>
        <button id="closePatchNotesBtn" style="background:transparent; border:2px solid #667eea; color:#667eea; font-size:1.5rem; cursor:pointer; width:40px; height:40px; border-radius:50%; transition:all 0.3s;" onmouseenter="this.style.background='#667eea'; this.style.color='white'" onmouseleave="this.style.background='transparent'; this.style.color='#667eea'">âœ•</button>
      </div>
    </div>
    
    <div id="patchNotesContent" style="padding:25px; color:white;">
      <!-- Patch notes will be dynamically inserted here -->
      <p style="color:#aaa; text-align:center;">Loading patch notes...</p>
    </div>
  </div>
</div>

<!-- Create Meeting Modal -->
<div id="createMeetingModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:700px; max-height:95vh; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px; margin:20px; overflow-y:auto;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#667eea;">ğŸ’¬ Create New Meeting</h3>
      <button id="closeCreateMeetingModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âœ•</button>
    </div>
    
    <!-- Meeting Name -->
    <div style="margin-bottom:20px;">
      <label style="display:block; margin-bottom:8px; color:#aaa; font-weight:600;">Meeting Name</label>
      <input id="meetingNameInput" type="text" placeholder="e.g., Q4 Planning, Pool Party, Friday Drinks..." 
             style="width:100%; padding:12px; background:#0f3460; border:1px solid #667eea; border-radius:8px; color:white; font-size:1rem;">
    </div>
    
    <!-- Scenario Description -->
    <div style="margin-bottom:20px;">
      <label style="display:block; margin-bottom:8px; color:#aaa; font-weight:600;">
        Scenario/Context <span style="color:#666; font-weight:400; font-size:0.85rem;">(Optional - sets the vibe)</span>
      </label>
      <textarea id="meetingScenarioInput" placeholder="e.g., 'Casual hangout at the boss's house' or 'Formal quarterly review' or 'Late night party getting wild'..." 
             style="width:100%; padding:12px; background:#0f3460; border:1px solid #667eea; border-radius:8px; color:white; font-size:0.95rem; min-height:80px; resize:vertical; font-family:inherit;"></textarea>
      <p style="color:#666; font-size:0.8rem; margin:6px 0 0 0;">
        ğŸ’¡ Tip: Describe the setting, mood, or purpose. NPCs will match the vibe instead of defaulting to "work meeting" mode.
      </p>
    </div>
    
    <!-- Reply Limit Setting -->
    <div style="margin-bottom:20px; background:#0f3460; padding:15px; border-radius:8px;">
      <label style="display:block; margin-bottom:10px; color:#aaa; font-weight:600;">
        Reply Limit per Message: <span id="replyLimitValue" style="color:#4ecca3; font-size:1.2rem;">5</span>
      </label>
      <input id="replyLimitSlider" type="range" min="1" max="10" value="5" 
             style="width:100%; cursor:pointer;">
      <p style="color:#666; font-size:0.85rem; margin:8px 0 0 0;">
        Max number of NPC replies after each player message. Lower = faster, Higher = more detailed conversations.
      </p>
    </div>
    
    <!-- Participant Selection -->
    <div style="margin-bottom:20px;">
      <label style="display:block; margin-bottom:10px; color:#aaa; font-weight:600;">
        Select Participants (Max 5): <span id="selectedCount" style="color:#4ecca3;">0/5</span>
      </label>
      
      <!-- Search Box -->
      <input id="participantSearch" type="text" placeholder="Search employees..." 
             style="width:100%; padding:10px; background:#0f3460; border:1px solid #667eea; border-radius:8px; color:white; margin-bottom:12px;">
      
      <!-- Participant Grid -->
      <div id="participantGrid" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(150px, 1fr)); gap:10px; max-height:400px; overflow-y:auto; padding:10px; background:#0f3460; border-radius:8px;">
        <!-- Participant cards will be added here -->
      </div>
    </div>
    
    <!-- Create Button -->
    <button id="confirmCreateMeeting" style="width:100%; padding:15px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:8px; color:white; cursor:pointer; font-weight:bold; font-size:1.1rem; transition:all 0.3s;"
            onmouseenter="this.style.transform='translateY(-2px)'"
            onmouseleave="this.style.transform='translateY(0)'">
      Create Meeting
    </button>
  </div>
</div>

<!-- Meeting Settings Modal -->
<div id="meetingSettingsModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:600px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px; max-height:90vh; overflow-y:auto;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#667eea;">âš™ï¸ Meeting Settings</h3>
      <button id="closeMeetingSettingsModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âœ•</button>
    </div>
    
    <!-- Meeting Name -->
    <div style="margin-bottom:20px; background:#0f3460; padding:15px; border-radius:8px;">
      <label style="display:block; margin-bottom:8px; color:#aaa; font-weight:600;">Meeting Name</label>
      <input id="meetingSettingsName" type="text" placeholder="Meeting name..." 
             style="width:100%; padding:12px; background:#16213e; border:1px solid #667eea; border-radius:8px; color:white; font-size:1rem;">
    </div>
    
    <!-- Scenario Description -->
    <div style="margin-bottom:20px; background:#0f3460; padding:15px; border-radius:8px;">
      <label style="display:block; margin-bottom:8px; color:#aaa; font-weight:600;">
        Scenario/Context <span style="color:#666; font-weight:400; font-size:0.85rem;">(Optional)</span>
      </label>
      <textarea id="meetingSettingsScenario" placeholder="Describe the setting, mood, or purpose..." 
             style="width:100%; padding:12px; background:#16213e; border:1px solid #667eea; border-radius:8px; color:white; font-size:0.95rem; min-height:70px; resize:vertical; font-family:inherit;"></textarea>
      <p style="color:#666; font-size:0.8rem; margin:6px 0 0 0;">
        ğŸ’¡ NPCs will match the vibe you describe (party, meeting, hangout, etc.)
      </p>
    </div>
    
    <!-- Reply Limit Setting -->
    <div style="margin-bottom:20px; background:#0f3460; padding:15px; border-radius:8px;">
      <label style="display:block; margin-bottom:10px; color:#aaa; font-weight:600;">
        Reply Limit per Message: <span id="meetingSettingsReplyLimitValue" style="color:#4ecca3; font-size:1.2rem;">5</span>
      </label>
      <input id="meetingSettingsReplyLimitSlider" type="range" min="1" max="10" value="5" 
             style="width:100%; cursor:pointer;">
      <p style="color:#666; font-size:0.85rem; margin:8px 0 0 0;">
        Max number of NPC replies after each player message. Lower = faster, Higher = more detailed conversations.
      </p>
    </div>
    
    <!-- Display Settings -->
    <div style="margin-bottom:20px; background:#0f3460; padding:15px; border-radius:8px;">
      <h4 style="margin:0 0 15px 0; color:#4ecca3; font-size:0.95rem;">ğŸ’» Display Settings</h4>
      
      <div style="margin-bottom:12px;">
        <label style="display:block; margin-bottom:5px; font-size:0.85rem; color:#aaa;">Text Size: <span id="meetingTextSizeValue" style="color:#4ecca3; font-weight:bold;">100%</span></label>
        <input type="range" id="meetingTextSizeSlider" min="70" max="150" value="100" step="5" style="width:100%;">
      </div>
      
      <div style="margin-bottom:0;">
        <label style="display:block; margin-bottom:5px; font-size:0.85rem; color:#aaa;">Image Size: <span id="meetingImageSizeValue" style="color:#4ecca3; font-weight:bold;">300px</span></label>
        <input type="range" id="meetingImageSizeSlider" min="200" max="600" value="300" step="25" style="width:100%;">
      </div>
    </div>
    
    <!-- Participants List (Read-only) -->
    <div style="margin-bottom:20px; background:#0f3460; padding:15px; border-radius:8px;">
      <h4 style="margin:0 0 10px 0; color:#aaa; font-weight:600;">Participants</h4>
      <div id="meetingSettingsParticipants" style="display:flex; flex-wrap:wrap; gap:8px;">
        <!-- Participant badges will be added here -->
      </div>
    </div>
    
    <!-- Action Buttons -->
    <div style="display:flex; gap:10px; justify-content:flex-end;">
      <button id="cancelMeetingSettings" style="padding:12px 24px; background:#0f3460; border:none; border-radius:8px; color:#aaa; cursor:pointer; font-size:1rem;">
        Cancel
      </button>
      <button id="saveMeetingSettings" style="padding:12px 24px; background:#667eea; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; font-size:1rem;">
        ğŸ’¾ Save Changes
      </button>
    </div>
  </div>
</div>

<!-- Send Money Modal -->
<div id="sendMoneyModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:500px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#4ecca3;">ğŸ’° Send Money</h3>
      <button id="closeSendMoneyModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âœ•</button>
    </div>
    
    <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:20px;">
      <p style="color:#aaa; margin:0 0 5px 0; font-size:0.9rem;">Your Balance:</p>
      <p id="sendMoneyBalance" style="color:#4ecca3; margin:0; font-size:1.4rem; font-weight:600;">$0</p>
    </div>
    
    <p style="color:#aaa; margin-bottom:15px;">Choose an amount to send or enter a custom value:</p>
    
    <!-- Quick Amount Presets -->
    <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; margin-bottom:15px;">
      <button class="money-preset" data-preset="small" style="padding:12px; background:#0f3460; border:1px solid #4ecca3; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
        <div style="font-size:0.85rem; color:#aaa;">Small</div>
        <div id="moneySmall" style="font-weight:600; color:#4ecca3; margin-top:3px;">$0</div>
      </button>
      <button class="money-preset" data-preset="medium" style="padding:12px; background:#0f3460; border:1px solid #4ecca3; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
        <div style="font-size:0.85rem; color:#aaa;">Medium</div>
        <div id="moneyMedium" style="font-weight:600; color:#4ecca3; margin-top:3px;">$0</div>
      </button>
      <button class="money-preset" data-preset="large" style="padding:12px; background:#0f3460; border:1px solid #4ecca3; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
        <div style="font-size:0.85rem; color:#aaa;">Large</div>
        <div id="moneyLarge" style="font-weight:600; color:#4ecca3; margin-top:3px;">$0</div>
      </button>
    </div>
    
    <!-- Custom Amount Input -->
    <div style="margin-bottom:15px;">
      <label style="color:#aaa; font-size:0.9rem; display:block; margin-bottom:8px;">Custom Amount:</label>
      <div style="position:relative;">
        <span style="position:absolute; left:12px; top:50%; transform:translateY(-50%); color:#4ecca3; font-weight:600; font-size:1.1rem;">$</span>
        <input type="number" id="customMoneyAmount" placeholder="0" min="1" style="width:100%; padding:12px 12px 12px 30px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; font-size:1.1rem;" />
      </div>
    </div>
    
    <!-- Message/Purpose Input -->
    <div style="margin-bottom:15px;">
      <label style="color:#aaa; font-size:0.9rem; display:block; margin-bottom:8px;">What's this for? (Optional)</label>
      <textarea id="moneyMessage" placeholder="E.g., 'For your hard work', 'Buy yourself something nice', 'Just because', etc." style="width:100%; height:60px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical;"></textarea>
    </div>
    
    <div style="display:flex; gap:10px; justify-content:flex-end;">
      <button id="cancelSendMoney" style="padding:10px 20px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">Cancel</button>
      <button id="confirmSendMoney" style="padding:10px 20px; background:#4ecca3; border:none; border-radius:6px; color:#16213e; cursor:pointer; font-weight:600;">Send Money</button>
    </div>
  </div>
</div>

<!-- Gift Selection Modal -->
<div id="giftSelectionModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999999; justify-content:center; align-items:center; overflow-y:auto;">
  <div style="background:#16213e; width:95%; max-width:700px; max-height:90vh; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); display:flex; flex-direction:column;">
    <div style="padding:20px; border-bottom:1px solid #0f3460; display:flex; justify-content:space-between; align-items:center;">
      <div>
        <h3 style="margin:0; color:#ff6b9d; display:flex; align-items:center; gap:10px;">
          ğŸ Give a Gift
        </h3>
        <p id="giftRecipientName" style="margin:5px 0 0 0; color:#aaa; font-size:0.9rem;"></p>
      </div>
      <button id="closeGiftSelectionModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âœ•</button>
    </div>
    
    <!-- Gift Preferences Hint -->
    <div id="giftPreferencesHint" style="padding:15px 20px; background:#0f3460; border-bottom:1px solid #16213e;">
      <p style="margin:0 0 8px 0; color:#aaa; font-size:0.85rem; font-weight:600;">ğŸ“Š Their Preferences:</p>
      <p style="margin:0 0 10px 0; color:#888; font-size:0.75rem; font-style:italic;">ğŸ’¡ Give gifts to discover what they love and hate!</p>
      <div style="display:flex; gap:20px; flex-wrap:wrap;">
        <div>
          <span style="color:#4ecca3; font-size:0.9rem;">ğŸ’• Loves:</span>
          <span id="giftLovesHint" style="color:white; font-size:0.9rem; margin-left:5px;"></span>
        </div>
        <div>
          <span style="color:#e94560; font-size:0.9rem;">ğŸ’” Hates:</span>
          <span id="giftHatesHint" style="color:white; font-size:0.9rem; margin-left:5px;"></span>
        </div>
      </div>
    </div>
    
    <!-- Gift Inventory Grid -->
    <div id="giftSelectionGrid" style="flex:1; padding:20px; overflow-y:auto; display:grid; grid-template-columns:repeat(auto-fill, minmax(180px, 1fr)); gap:15px; max-height:500px;">
      <!-- Gifts will be populated here -->
    </div>
    
    <!-- Empty State -->
    <div id="giftSelectionEmpty" style="display:none; padding:40px; text-align:center; color:#aaa;">
      <div style="font-size:4rem; margin-bottom:15px;">ğŸ</div>
      <p style="font-size:1.1rem; margin:0 0 10px 0;">No gifts in inventory</p>
      <p style="font-size:0.9rem; margin:0;">Visit the Gifts tab to create and purchase gifts!</p>
    </div>
    
    <!-- Personal Message Input -->
    <div style="padding:15px 20px; border-top:1px solid #0f3460; background:#0f1419;">
      <label style="color:#aaa; font-size:0.9rem; display:block; margin-bottom:8px;">ğŸ’Œ Add a personal message (optional):</label>
      <textarea 
        id="giftPersonalMessage" 
        placeholder="Type a message to send with your gift..."
        style="width:100%; min-height:60px; padding:10px; background:#16213e; border:1px solid #0f3460; border-radius:8px; color:white; font-size:0.9rem; resize:vertical; font-family:inherit;"
        maxlength="500"
      ></textarea>
      <div style="text-align:right; color:#666; font-size:0.75rem; margin-top:4px;">
        <span id="giftMessageCharCount">0</span>/500
      </div>
    </div>
    
    <div style="padding:15px 20px; border-top:1px solid #0f3460; background:#0f1419; border-radius:0 0 15px 15px; display:flex; gap:10px; justify-content:flex-end;">
      <button id="cancelGiftSelection" style="padding:10px 20px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">Cancel</button>
      <button id="sendGiftBtn" disabled style="padding:10px 20px; background:#4ecca3; border:none; border-radius:6px; color:#0f1419; font-weight:600; cursor:pointer; opacity:0.5; transition:all 0.2s;">
        ğŸ Send Gift
      </button>
    </div>
  </div>
</div>

<!-- Counter Offer Modal -->
<div id="counterOfferModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:10000000; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:500px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#ff9800;">â†”ï¸ Counter Offer</h3>
      <button id="closeCounterOfferModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âœ•</button>
    </div>
    
    <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
      <p style="color:#aaa; margin:0 0 5px 0; font-size:0.9rem;">They requested:</p>
      <p id="counterOriginalAmount" style="color:#ff9800; margin:0; font-size:1.3rem; font-weight:600;">$0</p>
    </div>
    
    <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:20px;">
      <p style="color:#aaa; margin:0 0 5px 0; font-size:0.9rem;">Your Balance:</p>
      <p id="counterYourBalance" style="color:#4ecca3; margin:0; font-size:1.4rem; font-weight:600;">$0</p>
    </div>
    
    <p style="color:#aaa; margin-bottom:15px;">Enter the amount you want to send instead:</p>
    
    <!-- Counter Amount Input -->
    <div style="margin-bottom:15px;">
      <label style="color:#aaa; font-size:0.9rem; display:block; margin-bottom:8px;">Counter Amount:</label>
      <div style="position:relative;">
        <span style="position:absolute; left:12px; top:50%; transform:translateY(-50%); color:#4ecca3; font-weight:600; font-size:1.1rem;">$</span>
        <input type="number" id="counterAmount" placeholder="0" min="1" style="width:100%; padding:12px 12px 12px 30px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; font-size:1.1rem;" />
      </div>
    </div>
    
    <!-- Justification Input -->
    <div style="margin-bottom:15px;">
      <label style="color:#aaa; font-size:0.9rem; display:block; margin-bottom:8px;">Why this amount? (Optional)</label>
      <textarea id="counterJustification" placeholder="E.g., 'This is all I can spare right now', 'I think this should be enough', 'Here's a bit extra because I care', etc." style="width:100%; height:80px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical;"></textarea>
    </div>
    
    <div style="display:flex; gap:10px; justify-content:flex-end;">
      <button id="cancelCounterOffer" style="padding:10px 20px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">Cancel</button>
      <button id="confirmCounterOffer" style="padding:10px 20px; background:#ff9800; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">Send Counter</button>
    </div>
  </div>
</div>

<!-- Send Image Modal -->
<div id="sendImageModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:500px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#00d4ff;">ğŸ“¤ Send an Image</h3>
      <button id="closeSendImageModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âœ•</button>
    </div>
    <p style="color:#aaa; margin-bottom:15px;">Describe what image you want to send. The AI will respond based on your description and conversation context.</p>
    <div style="position:relative;">
      <textarea id="sendImagePrompt" placeholder="E.g., '@TheBoss at the beach' or '@player and @Sarah at dinner'. Type @ to autocomplete - use @TheBoss or @player for yourself!" style="width:100%; height:100px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; margin-bottom:15px;"></textarea>
      
      <!-- Mention Suggestions Dropdown for Send Image -->
      <div id="sendImageMentionSuggestions" style="display:none; position:absolute; bottom:100%; left:0; width:100%; max-height:200px; overflow-y:auto; background:#16213e; border:2px solid #00d4ff; border-radius:8px; box-shadow:0 -4px 15px rgba(0,0,0,0.5); z-index:1000; margin-bottom:20px;">
        <!-- Dynamically populated -->
      </div>
    </div>
    <div style="display:flex; gap:10px; justify-content:flex-end;">
      <button id="cancelSendImage" style="padding:10px 20px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">Cancel</button>
      <button id="confirmSendImage" style="padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">Send Image</button>
    </div>
  </div>
</div>

<!-- Request Image Modal -->
<div id="requestImageModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:550px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#00d4ff;">ğŸ“· Request an Image</h3>
      <button id="closeRequestImageModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âœ•</button>
    </div>
    
    <div id="requestImageMode" style="margin-bottom:20px;">
      <p style="color:#aaa; margin-bottom:15px;">Choose a preset or create a custom request:</p>
      
      <!-- Auto Presets -->
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;">
        <button class="request-preset" data-preset="casual" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          ğŸ˜Š Casual Selfie
        </button>
        <button class="request-preset" data-preset="work" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          ğŸ‘” Work Selfie
        </button>
        <button class="request-preset" data-preset="lewd" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          ğŸ˜ Lewd Selfie
        </button>
        <button class="request-preset" data-preset="nude" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          ğŸ” Nude Selfie
        </button>
        <button class="request-preset" data-preset="explicit" style="padding:12px; background:#0f3460; border:1px solid #ff0055; border-radius:8px; color:#ff0055; cursor:pointer; transition:all 0.2s; grid-column:1/-1; font-weight:600;">
          ğŸ”¥ Explicit Content
        </button>
      </div>
      
      <!-- Manual Option -->
      <button id="requestManualBtn" style="width:100%; padding:12px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; margin-bottom:15px;">
        âœï¸ Custom Request
      </button>
      
      <!-- Manual Input (hidden by default) -->
      <div id="requestManualInput" style="display:none;">
        <div style="position:relative;">
          <textarea id="requestImagePrompt" placeholder="Describe what you'd like them to send (e.g., 'a photo of you and @TheBoss' or 'a selfie with @player'). Type @ to autocomplete - use @TheBoss or @player for yourself!" style="width:100%; height:100px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; margin-bottom:15px;"></textarea>
          
          <!-- Mention Suggestions Dropdown for Request Image -->
          <div id="requestImageMentionSuggestions" style="display:none; position:absolute; bottom:100%; left:0; width:100%; max-height:200px; overflow-y:auto; background:#16213e; border:2px solid #00d4ff; border-radius:8px; box-shadow:0 -4px 15px rgba(0,0,0,0.5); z-index:1000; margin-bottom:20px;">
            <!-- Dynamically populated -->
          </div>
        </div>
        <div style="display:flex; gap:10px; justify-content:flex-end;">
          <button id="cancelRequestManual" style="padding:10px 20px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">Back</button>
          <button id="confirmRequestManual" style="padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">Request</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Request Social Post Modal -->
<div id="requestPostModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:550px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#00d4ff;">ğŸ“± Request a Social Post</h3>
      <button id="closeRequestPostModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âœ•</button>
    </div>
    
    <div id="requestPostMode" style="margin-bottom:20px;">
      <p style="color:#aaa; margin-bottom:15px;">Choose what kind of post you want them to make:</p>
      
      <!-- Post Type Presets -->
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;">
        <button class="request-post-preset" data-preset="text" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          ğŸ“ Status Update
        </button>
        <button class="request-post-preset" data-preset="selfie" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          ğŸ¤³ Selfie
        </button>
        <button class="request-post-preset" data-preset="thirst_trap" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          ğŸ”¥ Thirst Trap
        </button>
        <button class="request-post-preset" data-preset="nude" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          ğŸ” Nude Photo
        </button>
        <button class="request-post-preset" data-preset="explicit" style="padding:12px; background:#0f3460; border:1px solid #ff0055; border-radius:8px; color:#ff0055; cursor:pointer; transition:all 0.2s; grid-column:1/-1; font-weight:600;">
          ğŸ”¥ Explicit Sexual Content
        </button>
      </div>
      
      <!-- Custom Request Option -->
      <button id="requestPostCustomBtn" style="width:100%; padding:12px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; margin-bottom:15px;">
        âœï¸ Custom Request
      </button>
      
      <!-- Custom Input (hidden by default) -->
      <div id="requestPostCustomInput" style="display:none;">
        <textarea id="requestPostPrompt" placeholder="Describe what you want them to post (e.g., 'Post a picture of you masturbating' or 'Write about how you're feeling right now')" style="width:100%; height:100px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; margin-bottom:15px;"></textarea>
        <div style="display:flex; gap:10px; justify-content:flex-end;">
          <button id="cancelRequestPostCustom" style="padding:10px 20px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">Back</button>
          <button id="confirmRequestPostCustom" style="padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">Request</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Player Post Composer Modal -->
<div id="playerPostModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:600px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px; max-height:90vh; overflow-y:auto;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#00d4ff;">âœï¸ Create a Post</h3>
      <button id="closePlayerPostModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âœ•</button>
    </div>
    
    <!-- Post Type Selection -->
    <div style="margin-bottom:20px;">
      <label style="display:block; margin-bottom:8px; color:#aaa; font-size:0.9rem;">Post Type</label>
      <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:10px;">
        <button class="post-type-btn active" data-type="text" style="padding:10px; background:#0f3460; border:2px solid #00d4ff; border-radius:6px; color:white; cursor:pointer; transition:all 0.2s;">
          ğŸ“ Text
        </button>
        <button class="post-type-btn" data-type="image" style="padding:10px; background:#0f3460; border:2px solid #0f3460; border-radius:6px; color:#aaa; cursor:pointer; transition:all 0.2s;">
          ğŸ–¼ï¸ Image
        </button>
        <button class="post-type-btn" data-type="selfie" style="padding:10px; background:#0f3460; border:2px solid #0f3460; border-radius:6px; color:#aaa; cursor:pointer; transition:all 0.2s;">
          ğŸ¤³ Selfie
        </button>
      </div>
    </div>
    
    <!-- Caption Input -->
    <div style="margin-bottom:20px;">
      <label style="display:block; margin-bottom:8px; color:#aaa; font-size:0.9rem;">Caption <span style="color:#666; font-size:0.85rem;">(Type @ to mention someone)</span></label>
      <div style="position:relative;">
        <textarea id="playerPostCaption" placeholder="What's on your mind? Type @ to mention someone (including @TheBoss for yourself)..." style="width:100%; height:100px; padding:12px; padding-right:45px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; font-family:inherit; font-size:1rem;"></textarea>
        <button id="postCaptionEmojiBtn" class="emoji-picker-trigger" style="position:absolute; right:8px; top:8px; padding:6px 10px; background:#0f3460; border:none; border-radius:6px; cursor:pointer; font-size:1.2rem; transition:all 0.2s;" onmouseenter="this.style.background='#16213e'" onmouseleave="this.style.background='#0f3460'">ğŸ˜Š</button>
        
        <!-- Mention Suggestions Dropdown -->
        <div id="mentionSuggestions" style="display:none; position:absolute; bottom:100%; left:0; width:100%; max-height:200px; overflow-y:auto; background:#16213e; border:2px solid #00d4ff; border-radius:8px; box-shadow:0 -4px 15px rgba(0,0,0,0.5); z-index:1000; margin-bottom:5px;">
          <!-- Dynamically populated -->
        </div>
      </div>
      <div style="margin-top:6px; font-size:0.8rem; color:#666;">
        <span id="captionCharCount">0</span>/500 characters
      </div>
    </div>
    
    <!-- Image Section (shown for image/selfie posts) -->
    <div id="playerPostImageSection" style="display:none; margin-bottom:20px;">
      <label style="display:block; margin-bottom:8px; color:#aaa; font-size:0.9rem;">Image Prompt</label>
      <div style="position:relative;">
        <textarea id="playerPostImagePrompt" placeholder="Describe the image (e.g., '@TheBoss at the beach' or '@player and @Sarah at the party'). Type @ to autocomplete names - use @TheBoss or @player for yourself!" style="width:100%; height:80px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; font-family:inherit; font-size:0.95rem;"></textarea>
        
        <!-- Mention Suggestions Dropdown for Image Prompt -->
        <div id="postImageMentionSuggestions" style="display:none; position:absolute; bottom:100%; left:0; width:100%; max-height:200px; overflow-y:auto; background:#16213e; border:2px solid #00d4ff; border-radius:8px; box-shadow:0 -4px 15px rgba(0,0,0,0.5); z-index:1000; margin-bottom:5px;">
          <!-- Dynamically populated -->
        </div>
      </div>
      
      <div style="margin-top:15px;">
        <label style="display:block; margin-bottom:8px; color:#aaa; font-size:0.9rem;">
          Alt Text (What NPCs "see")
          <span style="color:#666; font-size:0.85rem;">- Describe what's in the image for NPCs</span>
        </label>
        <textarea id="playerPostAltText" placeholder="E.g., 'Picture of me smiling at the beach, wearing a blue swimsuit and sunglasses, sunset in background'" style="width:100%; height:80px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; font-family:inherit; font-size:0.95rem;"></textarea>
      </div>
      
      <!-- Preview Image -->
      <div id="playerPostImagePreview" style="display:none; margin-top:15px;">
        <img id="playerPostPreviewImg" style="width:100%; border-radius:10px; box-shadow:0 2px 10px rgba(0,0,0,0.3);">
        <button id="playerPostRegenerateImg" style="width:100%; margin-top:10px; padding:8px; background:#0f3460; border:1px solid #00d4ff; border-radius:6px; color:#00d4ff; cursor:pointer;">
          ğŸ”„ Regenerate Image
        </button>
      </div>
    </div>
    
    <!-- Explicit Content Warning -->
    <div style="margin-bottom:20px; background:#0f3460; padding:12px; border-radius:6px; border-left:3px solid #e94560;">
      <label style="display:flex; align-items:center; gap:10px; cursor:pointer;">
        <input type="checkbox" id="playerPostExplicit" style="width:18px; height:18px;">
        <span style="font-size:0.9rem; color:#ddd;">
          ğŸ” This post contains explicit/NSFW content
        </span>
      </label>
    </div>
    
    <!-- Action Buttons -->
    <div style="display:flex; gap:10px; justify-content:flex-end;">
      <button id="cancelPlayerPost" style="padding:12px 24px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">
        Cancel
      </button>
      <button id="generatePlayerPostImage" style="display:none; padding:12px 24px; background:#533483; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">
        ğŸ¨ Generate Image
      </button>
      <button id="submitPlayerPost" style="padding:12px 24px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">
        ğŸ“¤ Post
      </button>
    </div>
  </div>
</div>

<!-- AFK Income Modal -->
<div id="afkIncomeModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:linear-gradient(135deg, #0f1419 0%, #16213e 100%); width:90%; max-width:500px; border-radius:20px; padding:30px; box-shadow:0 10px 50px rgba(76,204,163,0.3); border:2px solid #4ecca3; position:relative;">
    
    <!-- Close button -->
    <button id="closeAfkIncome" style="position:absolute; top:15px; right:15px; background:transparent; border:none; color:#aaa; font-size:1.5rem; cursor:pointer; width:30px; height:30px; display:flex; align-items:center; justify-content:center; border-radius:50%; transition:all 0.2s;">
      âœ•
    </button>
    
    <!-- Icon -->
    <div style="text-align:center; margin-bottom:20px;">
      <div style="font-size:4rem; margin-bottom:10px;">ğŸ’°</div>
      <h2 style="margin:0 0 10px 0; color:#4ecca3; font-size:1.8rem;">Welcome Back!</h2>
      <p style="color:#aaa; margin:0; font-size:0.95rem;">You've been away for a while...</p>
    </div>
    
    <!-- Time Away -->
    <div style="background:#0f1419; padding:15px; border-radius:12px; margin-bottom:20px; text-align:center;">
      <div style="color:#666; font-size:0.85rem; margin-bottom:5px;">TIME AWAY</div>
      <div id="afkTimeAway" style="color:#00d4ff; font-size:1.4rem; font-weight:bold;">0h 0m</div>
    </div>
    
    <!-- Earnings Breakdown -->
    <div style="background:#0f1419; padding:15px; border-radius:12px; margin-bottom:20px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
        <span style="color:#aaa; font-size:0.9rem;">Your Income Rate:</span>
        <span id="afkIncomeRate" style="color:white; font-weight:600;">$0/sec</span>
      </div>
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
        <span style="color:#aaa; font-size:0.9rem;">Full Earnings:</span>
        <span id="afkFullEarnings" style="color:#666; text-decoration:line-through;">$0</span>
      </div>
      <div style="display:flex; justify-content:space-between; align-items:center; padding-top:12px; border-top:1px solid #2a3f5f;">
        <span style="color:#4ecca3; font-size:1.1rem; font-weight:600;">AFK Earnings (<span id="afkRate">50</span>%):</span>
        <span id="afkEarnings" style="color:#4ecca3; font-size:1.4rem; font-weight:bold;">$0</span>
      </div>
    </div>
    
    <!-- Claim Button -->
    <button id="claimAfkIncome" style="width:100%; padding:15px; background:linear-gradient(135deg, #4ecca3 0%, #00d4ff 100%); border:none; border-radius:12px; color:white; font-size:1.2rem; font-weight:bold; cursor:pointer; box-shadow:0 4px 20px rgba(76,204,163,0.4); transition:all 0.3s;">
      ğŸ’° Claim Earnings
    </button>
    
    <div style="text-align:center; margin-top:15px; color:#666; font-size:0.8rem;">
      * AFK earnings are capped at 50% of your income rate and 24 hours maximum
    </div>
  </div>
</div>

<!-- Prestige Confirmation Modal -->
<div id="prestigeModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:10000000; justify-content:center; align-items:center; overflow-y:auto; padding:20px;">
  <div style="background:linear-gradient(135deg, #0f1419 0%, #16213e 100%); width:90%; max-width:600px; max-height:90vh; overflow-y:auto; border-radius:20px; padding:35px; box-shadow:0 10px 60px rgba(102,126,234,0.5); border:3px solid #667eea; position:relative; margin:auto;">
    
    <!-- Close button -->
    <button id="closePrestigeModal" style="position:absolute; top:15px; right:15px; background:transparent; border:none; color:#aaa; font-size:1.5rem; cursor:pointer; width:30px; height:30px; display:flex; align-items:center; justify-content:center; border-radius:50%; transition:all 0.2s;">
      âœ•
    </button>
    
    <!-- Icon -->
    <div style="text-align:center; margin-bottom:25px;">
      <div style="font-size:5rem; margin-bottom:10px;">âœ¨</div>
      <h2 style="margin:0 0 10px 0; color:#667eea; font-size:2rem; font-weight:700;">Prestige Confirmation</h2>
      <p style="color:#aaa; margin:0; font-size:1rem; line-height:1.6;">
        Are you sure you want to prestige? This action cannot be undone!
      </p>
    </div>
    
    <!-- What You'll Lose Section -->
    <div style="background:#1a0f0f; padding:20px; border-radius:12px; margin-bottom:20px; border-left:4px solid #e74c3c;">
      <h3 style="margin:0 0 15px 0; color:#e74c3c; font-size:1.2rem;">âš ï¸ What You'll Lose:</h3>
      <ul style="margin:0; padding-left:20px; color:#aaa; line-height:1.8;">
        <li>All current cash</li>
        <li>All products and progress</li>
        <li>All employees and their relationships</li>
        <li>All owned locations (except Garage)</li>
        <li>All boss fight progress</li>
        <li>Chat history and social feed</li>
      </ul>
    </div>
    
    <!-- What You'll Keep Section -->
    <div style="background:#0f1a0f; padding:20px; border-radius:12px; margin-bottom:20px; border-left:4px solid #2ecc71;">
      <h3 style="margin:0 0 15px 0; color:#2ecc71; font-size:1.2rem;">âœ… What You'll Keep:</h3>
      <ul style="margin:0; padding-left:20px; color:#aaa; line-height:1.8;">
        <li>All Influence Points (current + new)</li>
        <li>Lifetime earnings total</li>
        <li>Prestige level (increases by 1)</li>
        <li>All permanent upgrades</li>
        <li>Player bio and settings</li>
      </ul>
    </div>
    
    <!-- What You'll Gain Section -->
    <div style="background:#1a1a0f; padding:20px; border-radius:12px; margin-bottom:25px; border-left:4px solid #ffd700;">
      <h3 style="margin:0 0 15px 0; color:#ffd700; font-size:1.2rem;">ğŸŒŸ What You'll Gain:</h3>
      <div style="text-align:center; margin-top:15px;">
        <div style="font-size:3rem; color:#ffd700; font-weight:bold; margin-bottom:10px;" id="prestigeGainAmount">+0</div>
        <div style="color:#ffd700; font-size:1.1rem; font-weight:600;">Influence Points</div>
        <div style="color:#aaa; font-size:0.9rem; margin-top:10px;">
          Use these to purchase permanent upgrades that boost all future runs!
        </div>
      </div>
    </div>
    
    <!-- Confirmation Buttons -->
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px;">
      <button id="cancelPrestige" style="padding:15px; background:#2c3e50; border:none; border-radius:12px; color:white; font-size:1.1rem; font-weight:600; cursor:pointer; transition:all 0.3s;">
        âŒ Cancel
      </button>
      <button id="confirmPrestige" style="padding:15px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:12px; color:white; font-size:1.1rem; font-weight:700; cursor:pointer; box-shadow:0 4px 20px rgba(102,126,234,0.4); transition:all 0.3s;">
        âœ¨ Prestige Now
      </button>
    </div>
    
    <div style="text-align:center; margin-top:20px; color:#666; font-size:0.85rem; line-height:1.5;">
      ğŸ’¡ Tip: Prestige when you feel your progress has slowed down. The more you've earned, the more influence you'll gain!
    </div>
  </div>
</div>

<!-- Boss Fight Modal -->
<div id="bossFightModal" class="modal" style="position:fixed !important; top:0 !important; left:0 !important; width:100% !important; height:100% !important; background:rgba(0,0,0,0.9) !important; z-index:999999 !important; display:none !important; justify-content:center !important; align-items:center !important; padding:20px !important; overflow-y:auto !important;">
  <div style="background:linear-gradient(135deg, #0f1419 0%, #1a1f2e 100%); width:90%; max-width:800px; max-height:90vh; overflow-y:auto; border-radius:20px; padding:20px; box-shadow:0 10px 50px rgba(255,0,0,0.3); border:2px solid #e94560; margin:auto;">
    
    <!-- Boss Info Header -->
    <div id="bossHeader" style="text-align:center; margin-bottom:15px;">
      <h2 id="bossName" style="margin:0 0 5px 0; font-size:1.6rem; color:#e94560;">Boss Name</h2>
      <div id="bossTitle" style="color:#00d4ff; font-size:1rem; margin-bottom:8px;">Title</div>
      <div id="bossDescription" style="color:#aaa; font-size:0.85rem; max-width:600px; margin:0 auto;">Description</div>
    </div>
    
    <!-- Boss Image -->
    <div style="text-align:center; margin-bottom:15px;">
      <div id="bossImageContainer" style="width:200px; height:200px; margin:0 auto; border-radius:15px; overflow:hidden; background:#0f1419; display:flex; align-items:center; justify-content:center; border:3px solid #e94560; box-shadow:0 0 30px rgba(233,69,96,0.5);">
        <div id="bossImagePlaceholder" style="color:#666; font-size:2rem;">ğŸ‘¤</div>
        <img id="bossImage" style="width:100%; height:100%; object-fit:cover; display:none;">
      </div>
    </div>
    
    <!-- Dialogue -->
    <div id="bossDialogue" style="background:#16213e; padding:12px; border-radius:10px; margin-bottom:15px; text-align:center; font-style:italic; color:#ddd; font-size:0.95rem; min-height:50px; display:flex; align-items:center; justify-content:center; border-left:4px solid #e94560;">
      "Boss dialogue appears here..."
    </div>
    
    <!-- Health Bars -->
    <div style="margin-bottom:20px;">
      <!-- Boss Health -->
      <div style="margin-bottom:12px;">
        <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
          <span style="color:#e94560; font-weight:bold; font-size:0.9rem;">Boss Health</span>
          <span id="bossHealthText" style="color:#e94560; font-weight:bold; font-size:0.9rem;">100%</span>
        </div>
        <div style="background:#0f1419; height:25px; border-radius:15px; overflow:hidden; border:2px solid #e94560;">
          <div id="bossHealthBar" style="width:100%; height:100%; background:linear-gradient(90deg, #e94560 0%, #ff6b9d 100%); transition:width 0.3s ease;"></div>
        </div>
      </div>
      
      <!-- Player Stamina (based on income) -->
      <div>
        <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
          <span style="color:#4ecca3; font-weight:bold; font-size:0.9rem;">Your Stamina</span>
          <span id="playerStaminaText" style="color:#4ecca3; font-weight:bold; font-size:0.9rem;">100%</span>
        </div>
        <div style="background:#0f1419; height:25px; border-radius:15px; overflow:hidden; border:2px solid #4ecca3;">
          <div id="playerStaminaBar" style="width:100%; height:100%; background:linear-gradient(90deg, #4ecca3 0%, #00d4ff 100%); transition:width 0.3s ease;"></div>
        </div>
      </div>
    </div>
    
    <!-- Combat Stats -->
    <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px; margin-bottom:15px;">
      <div style="background:#16213e; padding:12px; border-radius:10px; text-align:center;">
        <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Your Attack Power</div>
        <div id="playerAttack" style="color:#e94560; font-size:1.4rem; font-weight:bold;">0</div>
        <div style="color:#666; font-size:0.75rem;">Total Damage/Click</div>
      </div>
      <div style="background:#16213e; padding:12px; border-radius:10px; text-align:center;">
        <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Team Support</div>
        <div id="playerTeamPower" style="color:#ff6b9d; font-size:1.4rem; font-weight:bold;">0</div>
        <div style="color:#666; font-size:0.75rem;"><span id="playerTeamCount">0</span> Employees</div>
      </div>
      <div style="background:#16213e; padding:12px; border-radius:10px; text-align:center;">
        <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Defense/Regen</div>
        <div id="playerDefense" style="color:#4ecca3; font-size:1.4rem; font-weight:bold;">0/sec</div>
        <div style="color:#666; font-size:0.75rem;">Income Per Second</div>
      </div>
    </div>
    
    <!-- Combat Log -->
    <div style="background:#0f1419; padding:12px; border-radius:10px; margin-bottom:15px; max-height:100px; overflow-y:auto;" id="combatLog">
      <div style="color:#666; text-align:center; font-size:0.85rem;">Combat log will appear here...</div>
    </div>
    
    <!-- Action Buttons -->
    <div style="display:flex; gap:12px; justify-content:center;">
      <button id="attackBtn" onclick="bossFightAttack()" style="padding:12px 30px; background:#e94560; border:none; border-radius:10px; color:white; font-size:1.1rem; font-weight:bold; cursor:pointer; box-shadow:0 4px 15px rgba(233,69,96,0.4); transition:all 0.2s;">
        âš”ï¸ ATTACK
      </button>
      <button id="retreatBtn" onclick="bossFightRetreat()" style="padding:12px 30px; background:#666; border:none; border-radius:10px; color:white; font-size:1.1rem; font-weight:bold; cursor:pointer; transition:all 0.2s;">
        ğŸƒ Retreat
      </button>
    </div>
    
    <!-- Timer -->
    <div id="bossTimer" style="text-align:center; margin-top:15px; font-size:1rem; color:#00d4ff;">
      Time Remaining: <span id="bossTimeRemaining">60</span>s
    </div>
  </div>
</div>

<!-- Player Profile Modal -->
<div id="playerProfileModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:10000000; justify-content:center; align-items:center; overflow-y:auto; padding:20px;">
  <div style="background:#16213e; width:90%; max-width:700px; max-height:90vh; overflow-y:auto; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:30px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:25px;">
      <h2 style="margin:0; color:#00d4ff; display:flex; align-items:center; gap:10px;">
        <span style="font-size:1.8rem;">ğŸ‘¤</span> Your Profile
      </h2>
      <button id="closePlayerProfileModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âœ•</button>
    </div>
    
    <!-- Company Name (Special Section) -->
    <div style="background:#0f1419; padding:15px; border-radius:8px; margin-bottom:25px; border:2px solid #00d4ff;">
      <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px;">
        <span style="font-size:1.3rem;">ğŸ¢</span>
        <h3 style="margin:0; color:#00d4ff; font-size:1.1rem;">Company Name</h3>
      </div>
      <input id="playerCompanyName" type="text" placeholder="e.g., Quantum Dynamics Inc." style="width:100%; padding:12px; background:#16213e; border:1px solid #0f3460; border-radius:6px; color:white; font-size:1rem;">
      <p style="margin:8px 0 0 0; color:#8899a6; font-size:0.85rem;">This will be used by NPCs when they refer to the company</p>
    </div>
    
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:20px;">
      <!-- Basic Info -->
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">First Name</label>
        <input id="playerFirstName" type="text" placeholder="e.g., Alex" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Last Name</label>
        <input id="playerLastName" type="text" placeholder="e.g., Smith" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Age</label>
        <input id="playerAge" type="number" min="18" max="99" placeholder="e.g., 28" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Gender</label>
        <select id="playerGender" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white; cursor:pointer;">
          <option value="">Select...</option>
          <option value="male">Male</option>
          <option value="female">Female</option>
          <option value="non-binary">Non-Binary</option>
          <option value="other">Other</option>
        </select>
      </div>
    </div>
    
    <!-- Physical Description -->
    <h3 style="margin:20px 0 15px 0; color:#00d4ff; font-size:1.2rem;">Physical Description</h3>
    
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:20px;">
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Ethnicity/Race</label>
        <input id="playerEthnicity" type="text" placeholder="e.g., Caucasian, Asian, Hispanic..." style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Skin Tone</label>
        <input id="playerSkinTone" type="text" placeholder="e.g., fair, tan, brown, dark" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Height</label>
        <input id="playerHeight" type="text" placeholder="e.g., 5'10&quot;, 178cm" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Body Type</label>
        <input id="playerBodyType" type="text" placeholder="e.g., athletic, slim, curvy, muscular" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Hair Color</label>
        <input id="playerHairColor" type="text" placeholder="e.g., brown, blonde, black" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Hair Style</label>
        <input id="playerHairStyle" type="text" placeholder="e.g., short, long, wavy, bald" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Eye Color</label>
        <input id="playerEyeColor" type="text" placeholder="e.g., blue, brown, green" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Facial Hair</label>
        <input id="playerFacialHair" type="text" placeholder="e.g., beard, mustache, clean shaven" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
    </div>
    
    <!-- Intimate Details -->
    <h3 style="margin:20px 0 15px 0; color:#e94560; font-size:1.2rem;">ğŸ” Intimate Details</h3>
    
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:20px;">
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Genital Type</label>
        <select id="playerGenitalType" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white; cursor:pointer;">
          <option value="">Select...</option>
          <option value="penis">Penis</option>
          <option value="vagina">Vagina</option>
          <option value="both">Both (Intersex)</option>
          <option value="other">Other</option>
        </select>
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Size/Details</label>
        <input id="playerGenitalDetails" type="text" placeholder="e.g., average, large, small, specific measurements" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Breast/Chest Size</label>
        <input id="playerChestSize" type="text" placeholder="e.g., flat, C-cup, muscular pecs" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Build Details</label>
        <input id="playerBuildDetails" type="text" placeholder="e.g., toned abs, soft curves, broad shoulders" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
    </div>
    
    <!-- Additional Details -->
    <div style="margin-bottom:20px;">
      <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Additional Physical Details</label>
      <textarea id="playerAdditionalDetails" placeholder="Any other details... tattoos, piercings, scars, distinctive features, fashion style, etc." style="width:100%; height:80px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; font-family:inherit;"></textarea>
    </div>
    
    <!-- Personality/Background -->
    <div style="margin-bottom:20px;">
      <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Personality & Background (Optional)</label>
      <textarea id="playerPersonality" placeholder="Your personality traits, background, how you present yourself..." style="width:100%; height:80px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; font-family:inherit;"></textarea>
    </div>
    
    <!-- Save Button -->
    <div style="display:flex; gap:10px; justify-content:flex-end;">
      <button id="cancelPlayerProfile" style="padding:12px 24px; background:#0f3460; border:none; border-radius:8px; color:#aaa; cursor:pointer; font-size:1rem;">
        Cancel
      </button>
      <button id="savePlayerProfile" style="padding:12px 24px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; font-size:1rem;">
        ğŸ’¾ Save Profile
      </button>
    </div>
  </div>
</div>

<!-- Gender Options Modal -->
<div id="genderOptionsModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:10000000; justify-content:center; align-items:center; overflow-y:auto; padding:20px;">
  <div style="background:#16213e; width:90%; max-width:800px; max-height:90vh; overflow-y:auto; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:30px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:25px;">
      <h2 style="margin:0; color:#00d4ff; display:flex; align-items:center; gap:10px;">
        <span style="font-size:1.8rem;">âš§ï¸</span> Gender Diversity Options
      </h2>
      <button id="closeGenderOptionsModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âœ•</button>
    </div>
    
    <p style="color:#aaa; margin-bottom:25px; line-height:1.6;">
      Control the gender distribution of new hires. By default, all employees are female (100%). 
      Adjust these sliders to introduce more diversity. <strong>The sliders are proportional and will always total 100%.</strong>
    </p>
    
    <!-- Gender Sliders -->
    <div style="display:flex; flex-direction:column; gap:20px;">
      <!-- Female Slider -->
      <div style="background:#0f3460; padding:20px; border-radius:10px; border-left:4px solid #ff6b9d;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h3 style="margin:0; color:#ff6b9d; font-size:1.2rem;">ğŸ‘© Female</h3>
            <p style="margin:5px 0 0 0; color:#aaa; font-size:0.85rem;">Standard female employees</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:2rem; font-weight:700; color:#ff6b9d;" id="femalePercentage">100</div>
            <div style="color:#aaa; font-size:0.9rem;">%</div>
          </div>
        </div>
        <input type="range" id="femaleSlider" min="0" max="100" value="100" style="width:100%;">
      </div>
      
      <!-- Male Slider -->
      <div style="background:#0f3460; padding:20px; border-radius:10px; border-left:4px solid #00d4ff;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h3 style="margin:0; color:#00d4ff; font-size:1.2rem;">ğŸ‘¨ Male</h3>
            <p style="margin:5px 0 0 0; color:#aaa; font-size:0.85rem;">Standard male employees</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:2rem; font-weight:700; color:#00d4ff;" id="malePercentage">0</div>
            <div style="color:#aaa; font-size:0.9rem;">%</div>
          </div>
        </div>
        <input type="range" id="maleSlider" min="0" max="100" value="0" style="width:100%;">
      </div>
      
      <!-- Female Futa Slider -->
      <div style="background:#0f3460; padding:20px; border-radius:10px; border-left:4px solid #c77dff;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h3 style="margin:0; color:#c77dff; font-size:1.2rem;">ğŸ‘©â€ğŸ¦° Female Futa</h3>
            <p style="margin:5px 0 0 0; color:#aaa; font-size:0.85rem;">Female with male genitalia (no transition)</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:2rem; font-weight:700; color:#c77dff;" id="femaleFutaPercentage">0</div>
            <div style="color:#aaa; font-size:0.9rem;">%</div>
          </div>
        </div>
        <input type="range" id="femaleFutaSlider" min="0" max="100" value="0" style="width:100%;">
      </div>
      
      <!-- Trans Man Slider -->
      <div style="background:#0f3460; padding:20px; border-radius:10px; border-left:4px solid #4ecca3;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h3 style="margin:0; color:#4ecca3; font-size:1.2rem;">âš§ï¸ Trans Man</h3>
            <p style="margin:5px 0 0 0; color:#aaa; font-size:0.85rem;">Female to male (masculine with vagina)</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:2rem; font-weight:700; color:#4ecca3;" id="transManPercentage">0</div>
            <div style="color:#aaa; font-size:0.9rem;">%</div>
          </div>
        </div>
        <input type="range" id="transManSlider" min="0" max="100" value="0" style="width:100%;">
      </div>
      
      <!-- Trans Woman Slider -->
      <div style="background:#0f3460; padding:20px; border-radius:10px; border-left:4px solid #ffd700;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h3 style="margin:0; color:#ffd700; font-size:1.2rem;">âš§ï¸ Trans Woman</h3>
            <p style="margin:5px 0 0 0; color:#aaa; font-size:0.85rem;">Male to female (feminine with penis)</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:2rem; font-weight:700; color:#ffd700;" id="transWomanPercentage">0</div>
            <div style="color:#aaa; font-size:0.9rem;">%</div>
          </div>
        </div>
        <input type="range" id="transWomanSlider" min="0" max="100" value="0" style="width:100%;">
      </div>
    </div>
    
    <!-- RACE/SPECIES OPTIONS (PLAYER FEATURE REQUEST) -->
    <div style="margin-top:30px; padding-top:25px; border-top:2px solid #0f3460;">
      <h2 style="margin:0 0 15px 0; color:#00d4ff; display:flex; align-items:center; gap:10px;">
        <span style="font-size:1.6rem;">ğŸ§¬</span> Race & Species Options
      </h2>
      <p style="color:#aaa; margin-bottom:20px; line-height:1.6;">
        Control the species distribution of new hires. By default, all employees are human (100%). 
        Adjust these sliders to introduce fantasy and anthropomorphic races. <strong>The sliders are proportional and will always total 100%.</strong>
      </p>
      
      <!-- Race Sliders -->
      <div style="display:flex; flex-direction:column; gap:15px;">
        <!-- Human -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; border-left:4px solid #00d4ff;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <div>
              <h3 style="margin:0; color:#00d4ff; font-size:1rem;">ğŸ‘¤ Human</h3>
              <p style="margin:5px 0 0 0; color:#aaa; font-size:0.75rem;">Standard humans</p>
            </div>
            <div style="text-align:right;">
              <div style="font-size:1.5rem; font-weight:700; color:#00d4ff;" id="raceHumanPercentage">100</div>
              <div style="color:#aaa; font-size:0.9rem;">%</div>
            </div>
          </div>
          <input type="range" id="raceHumanSlider" min="0" max="100" value="100" style="width:100%;">
        </div>
        
        <!-- Fantasy Races Header -->
        <div style="padding:10px 0; margin-top:10px;">
          <h3 style="margin:0; color:#9d4edd; font-size:1rem; text-transform:uppercase; letter-spacing:1px;">âœ¨ Fantasy Races</h3>
        </div>
        
        <!-- Elf -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; border-left:4px solid #90ee90;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <div>
              <h3 style="margin:0; color:#90ee90; font-size:1rem;">ğŸ§ Elf</h3>
              <p style="margin:5px 0 0 0; color:#aaa; font-size:0.75rem;">Graceful, pointed ears, ethereal beauty</p>
            </div>
            <div style="text-align:right;">
              <div style="font-size:1.5rem; font-weight:700; color:#90ee90;" id="raceElfPercentage">0</div>
              <div style="color:#aaa; font-size:0.9rem;">%</div>
            </div>
          </div>
          <input type="range" id="raceElfSlider" min="0" max="100" value="0" style="width:100%;">
        </div>
        
        <!-- Orc -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; border-left:4px solid #7ccd7c;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <div>
              <h3 style="margin:0; color:#7ccd7c; font-size:1rem;">ğŸ’ª Orc</h3>
              <p style="margin:5px 0 0 0; color:#aaa; font-size:0.75rem;">Athletic, green skin, cute tusks</p>
            </div>
            <div style="text-align:right;">
              <div style="font-size:1.5rem; font-weight:700; color:#7ccd7c;" id="raceOrcPercentage">0</div>
              <div style="color:#aaa; font-size:0.9rem;">%</div>
            </div>
          </div>
          <input type="range" id="raceOrcSlider" min="0" max="100" value="0" style="width:100%;">
        </div>
        
        <!-- Demon -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; border-left:4px solid #b83b5e;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <div>
              <h3 style="margin:0; color:#b83b5e; font-size:1rem;">ğŸ˜ˆ Demon</h3>
              <p style="margin:5px 0 0 0; color:#aaa; font-size:0.75rem;">Horns, spaded tail, intense features</p>
            </div>
            <div style="text-align:right;">
              <div style="font-size:1.5rem; font-weight:700; color:#b83b5e;" id="raceDemonPercentage">0</div>
              <div style="color:#aaa; font-size:0.9rem;">%</div>
            </div>
          </div>
          <input type="range" id="raceDemonSlider" min="0" max="100" value="0" style="width:100%;">
        </div>
        
        <!-- Anthropomorphic Races Header -->
        <div style="padding:10px 0; margin-top:10px;">
          <h3 style="margin:0; color:#ff6b9d; font-size:1rem; text-transform:uppercase; letter-spacing:1px;">ğŸ¾ Anthropomorphic Races</h3>
        </div>
        
        <!-- Foxkin -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; border-left:4px solid #ff6b35;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <div>
              <h3 style="margin:0; color:#ff6b35; font-size:1rem;">ğŸ¦Š Foxkin</h3>
              <p style="margin:5px 0 0 0; color:#aaa; font-size:0.75rem;">Fox ears, fluffy tail, sharp features</p>
            </div>
            <div style="text-align:right;">
              <div style="font-size:1.5rem; font-weight:700; color:#ff6b35;" id="raceFoxPercentage">0</div>
              <div style="color:#aaa; font-size:0.9rem;">%</div>
            </div>
          </div>
          <input type="range" id="raceFoxSlider" min="0" max="100" value="0" style="width:100%;">
        </div>
        
        <!-- Wolfkin -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; border-left:4px solid #a8dadc;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <div>
              <h3 style="margin:0; color:#a8dadc; font-size:1rem;">ğŸº Wolfkin</h3>
              <p style="margin:5px 0 0 0; color:#aaa; font-size:0.75rem;">Wolf ears, tail, fierce eyes</p>
            </div>
            <div style="text-align:right;">
              <div style="font-size:1.5rem; font-weight:700; color:#a8dadc;" id="raceWolfPercentage">0</div>
              <div style="color:#aaa; font-size:0.9rem;">%</div>
            </div>
          </div>
          <input type="range" id="raceWolfSlider" min="0" max="100" value="0" style="width:100%;">
        </div>
        
        <!-- Catkin -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; border-left:4px solid #ff9ff3;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <div>
              <h3 style="margin:0; color:#ff9ff3; font-size:1rem;">ğŸ˜º Catkin</h3>
              <p style="margin:5px 0 0 0; color:#aaa; font-size:0.75rem;">Cat ears, tail, feline eyes</p>
            </div>
            <div style="text-align:right;">
              <div style="font-size:1.5rem; font-weight:700; color:#ff9ff3;" id="raceCatPercentage">0</div>
              <div style="color:#aaa; font-size:0.9rem;">%</div>
            </div>
          </div>
          <input type="range" id="raceCatSlider" min="0" max="100" value="0" style="width:100%;">
        </div>
        
        <!-- Rabbitkin -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; border-left:4px solid #ffc2d1;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <div>
              <h3 style="margin:0; color:#ffc2d1; font-size:1rem;">ğŸ° Rabbitkin</h3>
              <p style="margin:5px 0 0 0; color:#aaa; font-size:0.75rem;">Long ears, cotton tail, soft features</p>
            </div>
            <div style="text-align:right;">
              <div style="font-size:1.5rem; font-weight:700; color:#ffc2d1;" id="raceRabbitPercentage">0</div>
              <div style="color:#aaa; font-size:0.9rem;">%</div>
            </div>
          </div>
          <input type="range" id="raceRabbitSlider" min="0" max="100" value="0" style="width:100%;">
        </div>
      </div>
      
      <!-- Total Display -->
      <div style="margin-top:20px; padding:15px; background:#0f3460; border-radius:10px; text-align:center;">
        <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Total Distribution</div>
        <div style="font-size:1.8rem; font-weight:700;" id="raceTotalDisplay">
          <span id="raceTotalValue" style="color:#00d4ff;">100</span>%
        </div>
        <div id="raceWarning" style="display:none; color:#e94560; font-size:0.9rem; margin-top:5px;">
          âš ï¸ Total must equal 100%
        </div>
      </div>
    </div>
    
    <!-- Total Display -->
    <div style="margin-top:25px; padding:15px; background:#0f3460; border-radius:10px; text-align:center;">
      <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Total Distribution</div>
      <div style="font-size:1.8rem; font-weight:700;" id="genderTotalDisplay">
        <span id="genderTotalValue" style="color:#00d4ff;">100</span>%
      </div>
      <div id="genderWarning" style="display:none; color:#e94560; font-size:0.9rem; margin-top:5px;">
        âš ï¸ Total must equal 100%
      </div>
    </div>
    
    <!-- Save Button -->
    <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:25px;">
      <button id="cancelGenderOptions" style="padding:12px 24px; background:#0f3460; border:none; border-radius:8px; color:#aaa; cursor:pointer; font-size:1rem;">
        Cancel
      </button>
      <button id="saveGenderOptions" style="padding:12px 24px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; font-size:1rem;">
        ğŸ’¾ Save Settings
      </button>
    </div>
  </div>
</div>

<!-- Emoji Picker Tray -->
<div id="emojiPickerTray" style="display:none; position:fixed; background:#1a1d23; border-radius:12px; box-shadow:0 8px 30px rgba(0,0,0,0.5); border:1px solid #2f3336; width:300px; max-height:380px; overflow:hidden; z-index:9999999;">
  <div style="padding:10px; border-bottom:1px solid #2f3336; background:#16181c;">
    <div style="display:flex; gap:6px; overflow-x:auto; scrollbar-width:none;">
      <button class="emoji-category-btn active" data-category="recent" style="padding:6px 10px; background:#2f3336; border:none; border-radius:6px; color:white; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">ğŸ•</button>
      <button class="emoji-category-btn" data-category="smileys" style="padding:6px 10px; background:transparent; border:none; border-radius:6px; color:#aaa; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">ğŸ˜Š</button>
      <button class="emoji-category-btn" data-category="gestures" style="padding:6px 10px; background:transparent; border:none; border-radius:6px; color:#aaa; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">ğŸ‘‹</button>
      <button class="emoji-category-btn" data-category="hearts" style="padding:6px 10px; background:transparent; border:none; border-radius:6px; color:#aaa; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">â¤ï¸</button>
      <button class="emoji-category-btn" data-category="objects" style="padding:6px 10px; background:transparent; border:none; border-radius:6px; color:#aaa; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">ğŸ‰</button>
      <button class="emoji-category-btn" data-category="symbols" style="padding:6px 10px; background:transparent; border:none; border-radius:6px; color:#aaa; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">âœ¨</button>
    </div>
  </div>
  
  <div id="emojiPickerContent" style="padding:8px; max-height:310px; overflow-y:auto; overflow-x:hidden; display:flex; flex-wrap:wrap; gap:2px; align-content:flex-start;">
    <!-- Emojis will be populated here -->
  </div>
</div>

<!-- Cheats Modal -->
<div id="cheatsModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:10000; justify-content:center; align-items:center; overflow-y:auto;">
  <div style="background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); width:95%; max-width:900px; max-height:90vh; border-radius:20px; box-shadow:0 10px 40px rgba(233,69,96,0.4); border:2px solid #e94560; overflow-y:auto; margin:20px;">
    <div style="position:sticky; top:0; background:linear-gradient(135deg, #16213e 0%, #0f3460 100%); padding:20px; border-bottom:2px solid #e94560; z-index:10; border-radius:20px 20px 0 0;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="display:flex; align-items:center; gap:12px;">
          <span style="font-size:2rem;">âš¡</span>
          <h2 style="margin:0; color:#e94560; text-shadow:0 0 10px rgba(233,69,96,0.5);">Cheats & Debugging</h2>
        </div>
        <button id="closeCheatsBtn" style="background:transparent; border:2px solid #e94560; color:#e94560; font-size:1.5rem; cursor:pointer; width:40px; height:40px; border-radius:50%; transition:all 0.3s;" onmouseenter="this.style.background='#e94560'; this.style.color='white'" onmouseleave="this.style.background='transparent'; this.style.color='#e94560'">âœ•</button>
      </div>
    </div>
    
    <div style="padding:25px;">
      
      <!-- Money Setter -->
      <div style="background:#0f3460; border-radius:12px; padding:20px; margin-bottom:20px; border:1px solid #00d4ff;">
        <h3 style="margin:0 0 15px 0; color:#00d4ff; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.5rem;">ğŸ’°</span> Set Money
        </h3>
        <div style="display:flex; gap:15px; align-items:end;">
          <div style="flex:1;">
            <label style="display:block; margin-bottom:8px; color:#aaa; font-size:0.9rem;">Base Number (1-999)</label>
            <input type="number" id="cheatMoneyBase" min="1" max="999" value="100" style="width:100%; padding:12px; background:#16213e; border:1px solid #00d4ff; border-radius:8px; color:white; font-size:1.2rem; font-weight:600;">
          </div>
          <div style="flex:1;">
            <label style="display:block; margin-bottom:8px; color:#aaa; font-size:0.9rem;">Magnitude</label>
            <select id="cheatMoneyMagnitude" style="width:100%; padding:12px; background:#16213e; border:1px solid #00d4ff; border-radius:8px; color:white; font-size:1.1rem; cursor:pointer;">
              <option value="1">Ones (1)</option>
              <option value="1000">Thousand (K)</option>
              <option value="1000000" selected>Million (M)</option>
              <option value="1000000000">Billion (B)</option>
              <option value="1000000000000">Trillion (T)</option>
              <option value="1000000000000000">Quadrillion (Q)</option>
              <option value="1000000000000000000">Quintillion (Qi)</option>
            </select>
          </div>
          <button id="cheatSetMoneyBtn" style="padding:12px 24px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; font-size:1rem; transition:all 0.3s; white-space:nowrap;" onmouseenter="this.style.background='#ff0055'" onmouseleave="this.style.background='#e94560'">
            Set Balance
          </button>
        </div>
        <div style="margin-top:12px; padding:12px; background:#16213e; border-radius:8px; border-left:3px solid #00d4ff;">
          <span style="color:#aaa; font-size:0.9rem;">Preview: $</span><span id="cheatMoneyPreview" style="color:#00d4ff; font-weight:600; font-size:1.1rem;">100,000,000</span>
        </div>
      </div>
      
      <!-- Stat Multipliers -->
      <div style="background:#0f3460; border-radius:12px; padding:20px; margin-bottom:20px; border:1px solid #00d4ff;">
        <h3 style="margin:0 0 15px 0; color:#00d4ff; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.5rem;">ğŸ“Š</span> Stat Gain Multipliers
        </h3>
        <p style="color:#aaa; font-size:0.85rem; margin:0 0 15px 0;">Multiply how fast stats increase. 1x = normal, 10x = 10 times faster</p>
        
        <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(250px, 1fr)); gap:15px;">
          <!-- Affection -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#ff69b4;">ğŸ’– Affection</span>
              <span id="affectionMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="affectionMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Trust -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#4ecdc4;">ğŸ¤ Trust</span>
              <span id="trustMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="trustMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Comfort -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#95e1d3;">ğŸ›‹ï¸ Comfort</span>
              <span id="comfortMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="comfortMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Desire -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#ff6b6b;">ğŸ”¥ Desire</span>
              <span id="desireMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="desireMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Productivity -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#f9ca24;">âš¡ Productivity</span>
              <span id="productivityMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="productivityMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Confidence -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#00d4ff;">ğŸ’ª Confidence</span>
              <span id="confidenceMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="confidenceMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Obedience -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#a29bfe;">ğŸ™‡ Obedience</span>
              <span id="obedienceMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="obedienceMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Flirtiness -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#fd79a8;">ğŸ˜˜ Flirtiness</span>
              <span id="flirtinessMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="flirtinessMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Professionalism -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#74b9ff;">ğŸ’¼ Professionalism</span>
              <span id="professionalismMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="professionalismMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
          
          <!-- Humor -->
          <div>
            <label style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span style="color:#ffeaa7;">ğŸ˜‚ Humor</span>
              <span id="humorMultValue" style="color:#00d4ff; font-weight:600;">1.0x</span>
            </label>
            <input type="range" id="humorMultSlider" min="0" max="50" value="10" step="1" style="width:100%;">
          </div>
        </div>
        
        <div style="display:flex; gap:10px; margin-top:15px;">
          <button id="resetMultipliersBtn" style="flex:1; padding:10px; background:#533483; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600;">Reset All to 1x</button>
          <button id="maxMultipliersBtn" style="flex:1; padding:10px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600;">Set All to 5x</button>
        </div>
      </div>
      
      <!-- Set Stats Max -->
      <div style="background:#0f3460; border-radius:12px; padding:20px; margin-bottom:20px; border:1px solid #e94560;">
        <h3 style="margin:0 0 15px 0; color:#e94560; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.5rem;">ğŸ¯</span> Set All NPCs' Stats
        </h3>
        <p style="color:#aaa; font-size:0.85rem; margin:0 0 15px 0;">Instantly set a specific stat to a chosen value for ALL active employees</p>
        
        <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px;">
          <div>
            <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Stat Type</label>
            <select id="cheatStatType" style="width:100%; padding:10px; background:#16213e; border:1px solid #e94560; border-radius:8px; color:white; cursor:pointer;">
              <option value="affection">ğŸ’– Affection</option>
              <option value="trust">ğŸ¤ Trust</option>
              <option value="comfort">ğŸ›‹ï¸ Comfort</option>
              <option value="desire">ğŸ”¥ Desire</option>
              <option value="productivity">âš¡ Productivity</option>
              <option value="confidence">ğŸ’ª Confidence</option>
              <option value="obedience">ğŸ™‡ Obedience</option>
              <option value="flirty">ğŸ˜˜ Flirtiness</option>
              <option value="professional">ğŸ’¼ Professionalism</option>
              <option value="humor">ğŸ˜‚ Humor</option>
            </select>
          </div>
          
          <div>
            <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Value (0-100)</label>
            <input type="number" id="cheatStatValue" min="0" max="100" value="100" style="width:100%; padding:10px; background:#16213e; border:1px solid #e94560; border-radius:8px; color:white; font-size:1.1rem;">
          </div>
          
          <div style="display:flex; align-items:end;">
            <button id="cheatSetStatBtn" style="width:100%; padding:10px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;" onmouseenter="this.style.background='#ff0055'" onmouseleave="this.style.background='#e94560'">
              Set for All NPCs
            </button>
          </div>
        </div>
        
        <div style="margin-top:15px; padding:12px; background:#16213e; border-radius:8px; border-left:3px solid #e94560;">
          <span style="color:#aaa; font-size:0.85rem;">âš ï¸ This will affect all active employees at once</span>
        </div>
      </div>
      
      <!-- Quick Actions -->
      <div style="background:#0f3460; border-radius:12px; padding:20px; border:1px solid #00d4ff;">
        <h3 style="margin:0 0 15px 0; color:#00d4ff; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.5rem;">âš¡</span> Quick Actions
        </h3>
        
        <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px;">
          <button id="cheatMaxAllStatsBtn" style="padding:12px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
            ğŸŒŸ Max All Stats (All NPCs)
          </button>
          
          <button id="cheatUnlockAllLocationsBtn" style="padding:12px; background:linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
            ğŸ¢ Unlock All Locations
          </button>
          
          <button id="cheatUnlockAllProductsBtn" style="padding:12px; background:linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
            ğŸ“¦ Unlock All Products
          </button>
          
          <button id="cheatHireAllBtn" style="padding:12px; background:linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
            ğŸ‘¥ Hire All Candidates
          </button>
          
          <button id="cheatClearPostsBtn" style="padding:12px; background:linear-gradient(135deg, #fa709a 0%, #fee140 100%); border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;" title="Clear all social posts - helps with performance if you have many posts">
            ğŸ—‘ï¸ Clear All Posts
          </button>
          
          <button id="cheatSpawnPostsBtn" style="padding:12px; background:linear-gradient(135deg, #30cfd0 0%, #330867 100%); border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
            ğŸ“± Spawn 10 NPC Posts
          </button>
        </div>
      </div>
      
      <!-- Time Controls -->
      <div style="background:#0f3460; border-radius:12px; padding:20px; margin-top:20px; border:1px solid #c77dff;">
        <h3 style="margin:0 0 15px 0; color:#c77dff; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.5rem;">â°</span> Time Controls
        </h3>
        <p style="color:#aaa; font-size:0.85rem; margin:0 0 15px 0;">Control the speed of in-game time progression. Default is 20:1 (20 game minutes = 1 real minute)</p>
        
        <!-- Time Scale Slider -->
        <div style="margin-bottom:20px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <label style="color:#c77dff; font-weight:600;">Time Scale</label>
            <span id="timeScaleValue" style="color:#00d4ff; font-weight:600; font-size:1.2rem;">20x</span>
          </div>
          <input type="range" id="timeScaleSlider" min="1" max="100" value="20" step="1" style="width:100%; margin-bottom:10px;">
          <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:#aaa;">
            <span>1x (Slowest)</span>
            <span>50x (Fast)</span>
            <span>100x (Fastest)</span>
          </div>
          <div style="margin-top:12px; padding:10px; background:#16213e; border-radius:6px; border-left:3px solid #c77dff;">
            <div style="color:#aaa; font-size:0.85rem; margin-bottom:4px;">Current Speed:</div>
            <div id="timeScaleDescription" style="color:#ddd; font-size:0.9rem;">20 game minutes = 1 real minute</div>
          </div>
        </div>
        
        <!-- Quick Presets -->
        <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:10px; margin-bottom:15px;">
          <button class="time-preset-btn" data-scale="1" style="padding:10px; background:#0f1419; border:1px solid #c77dff; border-radius:6px; color:#c77dff; cursor:pointer; font-weight:600; transition:all 0.2s;">
            ğŸŒ 1x (Real Time)
          </button>
          <button class="time-preset-btn" data-scale="20" style="padding:10px; background:#0f1419; border:1px solid #c77dff; border-radius:6px; color:#c77dff; cursor:pointer; font-weight:600; transition:all 0.2s;">
            âš–ï¸ 20x (Default)
          </button>
          <button class="time-preset-btn" data-scale="60" style="padding:10px; background:#0f1419; border:1px solid #c77dff; border-radius:6px; color:#c77dff; cursor:pointer; font-weight:600; transition:all 0.2s;">
            ğŸš€ 60x (Fast)
          </button>
        </div>
        
        <!-- Time Control Buttons -->
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
          <button id="pauseTimeBtn" style="padding:12px; background:linear-gradient(135deg, #e94560 0%, #ff6b9d 100%); border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
            â¸ï¸ Pause Time
          </button>
          <button id="skipTimeBtn" style="padding:12px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
            â­ï¸ Skip 1 Day
          </button>
        </div>
        
        <!-- Current Time Display -->
        <div style="margin-top:15px; padding:12px; background:#16213e; border-radius:8px; border-left:3px solid #00d4ff;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
            <span style="color:#aaa; font-size:0.85rem;">Game Time:</span>
            <span id="cheatGameTime" style="color:#00d4ff; font-weight:600;">Loading...</span>
          </div>
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <span style="color:#aaa; font-size:0.85rem;">Time Status:</span>
            <span id="cheatTimeStatus" style="color:#4ecca3; font-weight:600;">Running</span>
          </div>
        </div>
      </div>
      
      <!-- Context Windows -->
      <div style="background:#0f3460; border-radius:12px; padding:20px; margin-top:20px; border:1px solid #ffd700;">
        <h3 style="margin:0 0 15px 0; color:#ffd700; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.5rem;">ğŸ§ </span> Context Windows
        </h3>
        <p style="color:#aaa; font-size:0.85rem; margin:0 0 15px 0;">View and edit what NPCs "know" - Company-Wide Context and Gossip Engine data</p>
        
        <!-- Company-Wide Context -->
        <div style="margin-bottom:20px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
            <h4 style="margin:0; color:#00d4ff; display:flex; align-items:center; gap:8px;">
              <span style="font-size:1.2rem;">ğŸ¢</span> Company-Wide Context
              <span id="contextCountLabel" style="font-size:0.9rem; color:#aaa; font-weight:normal;">(0/40)</span>
            </h4>
            <div style="display:flex; gap:8px;">
              <button id="cheatRefreshContextBtn" style="padding:6px 12px; background:#00d4ff; border:none; border-radius:6px; color:#0f1419; cursor:pointer; font-weight:600; font-size:0.85rem;">
                ğŸ”„ Refresh
              </button>
              <button id="cheatClearContextBtn" style="padding:6px 12px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; font-size:0.85rem;">
                ğŸ—‘ï¸ Clear All
              </button>
            </div>
          </div>
          <div id="contextList" style="max-height:300px; overflow-y:auto; background:#16213e; border-radius:8px; padding:10px;">
            <p style="color:#aaa; text-align:center; margin:20px 0;">Loading context...</p>
          </div>
        </div>
        
        <!-- Gossip Engine -->
        <div>
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
            <h4 style="margin:0; color:#ff69b4; display:flex; align-items:center; gap:8px;">
              <span style="font-size:1.2rem;">ğŸ’¬</span> Gossip Engine
              <span id="gossipCountLabel" style="font-size:0.9rem; color:#aaa; font-weight:normal;">(0 NPCs)</span>
            </h4>
            <div style="display:flex; gap:8px;">
              <button id="cheatRefreshGossipBtn" style="padding:6px 12px; background:#ff69b4; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; font-size:0.85rem;">
                ğŸ”„ Refresh
              </button>
              <button id="cheatClearGossipBtn" style="padding:6px 12px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; font-size:0.85rem;">
                ğŸ—‘ï¸ Clear All
              </button>
            </div>
          </div>
          <div id="gossipList" style="max-height:300px; overflow-y:auto; background:#16213e; border-radius:8px; padding:10px;">
            <p style="color:#aaa; text-align:center; margin:20px 0;">Loading gossip...</p>
          </div>
        </div>
      </div>
      
    </div>
  </div>
</div>

<!-- Corporate Pyramid Modal -->
<div id="pyramidModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:10000001; justify-content:center; align-items:center; overflow:hidden;">
  <!-- Content will be populated dynamically -->
</div>

<script>
  // Minimal modal registry (for clean close/cleanup)
  window.modalRegistry = window.modalRegistry || new Map();

  function debugModal() {
    const m = document.getElementById('hiringModal');
    if (!m) { console.warn('No #hiringModal in DOM'); return; }
    const cs = getComputedStyle(m);
    console.table({
      display: cs.display, visibility: cs.visibility, opacity: cs.opacity,
      position: cs.position, zIndex: cs.zIndex, pointerEvents: cs.pointerEvents
    });
    console.log('Modal rect:', m.getBoundingClientRect());
  }

  function closeHiringModal() {
    const overlay = document.getElementById('hiringModal');
    if (overlay) overlay.remove();
    const esc = window.__hiringEscHandler__;
    if (esc) { window.removeEventListener('keydown', esc); window.__hiringEscHandler__ = null; }
    modalRegistry.delete('hiring');
  }

  // Game Constants
  const GAME_TICK_INTERVAL = 100; // ms
  const INITIAL_CASH = 100;
  const NEWS_UPDATE_INTERVAL = 30000; // ms
  
  // ----- CASCADING MANAGER BONUS SYSTEM -----
  /**
   * Calculate cumulative bonuses from all managers in the chain above a product's staff
   * Returns an object with speed, income, and training multipliers
   */
  function getManagerialBonuses(product) {
    const bonuses = {
      speedMultiplier: 1.0,    // Faster production cycles
      incomeMultiplier: 1.0,   // Higher revenue per cycle
      trainingMultiplier: 1.0, // Faster skill/XP growth (future feature)
      managerChain: []         // For debugging/display
    };
    
    if (!product || !product.managerId) return bonuses;
    
    // Find the staff member working on this product
    const staff = gameState.employees.find(e => e.id === product.managerId);
    if (!staff || staff.employmentStatus !== 'active') return bonuses;
    
    // Find the pyramid position this staff occupies
    const staffPosition = gameState.corporatePyramid?.positions?.[1]?.find(
      pos => pos.employeeId === staff.id
    );
    
    if (!staffPosition) return bonuses;
    
    // Traverse up the management chain
    const visitedPositions = new Set(); // Prevent infinite loops
    let currentPosition = staffPosition;
    
    while (currentPosition && currentPosition.reportsTo && !visitedPositions.has(currentPosition.positionId)) {
      visitedPositions.add(currentPosition.positionId);
      
      // Find the manager this position reports to
      const managerPosition = findPositionById(currentPosition.reportsTo);
      
      if (!managerPosition || !managerPosition.employeeId) {
        break; // No manager in this position
      }
      
      // Get the manager employee
      const manager = gameState.employees.find(e => e.id === managerPosition.employeeId);
      
      if (!manager || manager.employmentStatus !== 'active') {
        break; // Manager not found or inactive
      }
      
      // Calculate bonuses based on manager's level
      const managerLevel = manager.career?.level || managerPosition.level;
      const levelInfo = gameState.hierarchyLevels?.[managerLevel];
      
      if (levelInfo) {
        // Each management level provides bonuses
        // Higher levels = bigger bonuses
        const levelBonus = {
          2: { speed: 1.05, income: 1.05, training: 1.03 },  // Local Manager: +5% speed/income, +3% training
          3: { speed: 1.08, income: 1.08, training: 1.05 },  // Regional Manager: +8% speed/income, +5% training
          4: { speed: 1.12, income: 1.12, training: 1.08 },  // Branch Manager: +12% speed/income, +8% training
          5: { speed: 1.15, income: 1.15, training: 1.10 },  // CFO/COO: +15% speed/income, +10% training
          6: { speed: 1.20, income: 1.20, training: 1.15 },  // Senior Executive: +20% speed/income, +15% training
          7: { speed: 1.25, income: 1.25, training: 1.20 }   // CEO: +25% speed/income, +20% training
        };
        
        const bonus = levelBonus[managerLevel] || { speed: 1.0, income: 1.0, training: 1.0 };
        
        // Apply manager's skill bonuses (management skill enhances their effectiveness)
        let effectivenessMultiplier = 1.0;
        if (manager.skills?.management) {
          const managementLevel = manager.skills.management.level || 1;
          effectivenessMultiplier = 1 + (managementLevel * 0.02); // +2% per management skill level
        }
        
        // Apply bonuses with effectiveness multiplier
        bonuses.speedMultiplier *= Math.pow(bonus.speed, effectivenessMultiplier);
        bonuses.incomeMultiplier *= Math.pow(bonus.income, effectivenessMultiplier);
        bonuses.trainingMultiplier *= Math.pow(bonus.training, effectivenessMultiplier);
        
        // Track for debugging
        bonuses.managerChain.push({
          name: manager.name,
          title: levelInfo.title,
          level: managerLevel,
          speedBonus: bonus.speed,
          incomeBonus: bonus.income,
          effectiveness: effectivenessMultiplier
        });
      }
      
      // Move up to the next level
      currentPosition = managerPosition;
    }
    
    return bonuses;
  }
  
  /**
   * Helper function to find a position by its ID across all levels
   */
  function findPositionById(positionId) {
    if (!gameState.corporatePyramid?.positions) return null;
    
    // Check CEO position
    if (positionId === 'ceo' && gameState.corporatePyramid.ceoPosition) {
      return gameState.corporatePyramid.ceoPosition;
    }
    
    // Check secretary position
    if (positionId === 'secretary' && gameState.corporatePyramid.secretaryPosition) {
      return gameState.corporatePyramid.secretaryPosition;
    }
    
    // Search through all levels
    for (let level = 1; level <= 7; level++) {
      const positions = gameState.corporatePyramid.positions[level];
      if (Array.isArray(positions)) {
        const found = positions.find(pos => pos.positionId === positionId);
        if (found) return found;
      }
    }
    
    return null;
  }
  
  // ----- PRODUCT HELPERS -----
  function getManagerSpeedMultiplier(p) {
    // Continuous scaling without hard cap
    // Each level reduces time by ~8%, stacking multiplicatively
    // Level 1: 92% time, Level 10: 43% time, Level 30: 9% time, Level 50: 2% time
    if (!p.managerHired || p.managerLevel === 0) return 1.0;
    
    let multiplier = Math.pow(0.92, p.managerLevel);
    
    // Apply automation boost from influence upgrades
    const autoBoostLevel = gameState.influenceUpgrades?.autoProgress || 0;
    const autoBoostMultiplier = influenceUpgrades.autoProgress.effect(autoBoostLevel);
    
    // This makes managers work FASTER (reduces cycle time further)
    multiplier /= autoBoostMultiplier;
    
    // Apply Time Dilation elite upgrade (+3% speed per level)
    const timeDilationLevel = gameState.globalUpgrades?.timeDilation || 0;
    if (timeDilationLevel > 0) {
      const timeDilationMultiplier = 1 / (1 + (timeDilationLevel * 0.03));
      multiplier *= timeDilationMultiplier;
    }
    
    // Apply loyalty bonus if manager is a rehired former employee
    const manager = gameState.employees.find(e => e.productManaged === p.name && e.hired);
    if (manager && manager.loyaltyBonus) {
      // Loyalty bonus further reduces cycle time
      multiplier /= (1 + manager.loyaltyBonus);
    }
    
    // ===== CASCADING MANAGER BONUSES =====
    // All managers in the chain above this product provide speed bonuses
    const managerialBonuses = getManagerialBonuses(p);
    multiplier /= managerialBonuses.speedMultiplier; // Divide to make it faster
    
    // ===== EMPLOYEE STAT IMPACT =====
    // Productivity and Trust directly affect manager efficiency
    if (manager) {
      // Productivity Impact: 0.85x to 1.0x (at 0 to 100 productivity)
      // Low productivity = slower cycles, high productivity = baseline speed
      const productivity = manager.productivity || 50; // Default 50 if not set
      const productivityMultiplier = 0.85 + (productivity * 0.15 / 100); // 0.85 at 0, 1.0 at 100
      multiplier /= productivityMultiplier; // DIVIDE to make high productivity = faster
      
      // Trust Impact: 0.85x to 1.15x (at 0 to 100 trust)
      // Low trust = hesitant/inefficient, high trust = empowered/faster
      // Baseline at 70 trust, bonus above 70
      const trust = manager.trust || 50; // Default 50 if not set
      const trustMultiplier = trust <= 70 
        ? 0.85 + (trust * 0.15 / 70)           // 0.85 at 0 â†’ 1.0 at 70
        : 1.0 + ((trust - 70) * 0.15 / 30);    // 1.0 at 70 â†’ 1.15 at 100
      multiplier /= trustMultiplier; // DIVIDE to make high trust = faster
      
      // Obedience Impact: Affects consistency (reliability)
      // Low obedience = occasional delays, high obedience = perfectly consistent
      // This is a subtle effect (0.92x to 1.0x)
      const obedience = manager.obedience || 50;
      const obedienceMultiplier = 0.92 + (obedience / 1250); // 0.92 at 0, 1.0 at 100
      multiplier /= obedienceMultiplier; // DIVIDE to make high obedience = faster
    }
    
    return multiplier;
  }

  function currentCycleTimeMs(p) {
    // Base cycle time with manager speed multiplier
    let cycleTime = Math.floor(p.baseTimeMs * getManagerSpeedMultiplier(p));
    
    // ===== SKILL-BASED SPEED BONUS (Phase 3) =====
    const manager = gameState.employees.find(e => e.productManaged === p.name && e.hired);
    if (manager && p.managerHired && manager.skills) {
      let speedBonus = 1.0;
      
      // Technical skill = faster tech/software products (up to 50% faster at level 10)
      if (p.name && (p.name.toLowerCase().includes('software') || p.name.toLowerCase().includes('tech') || p.name.toLowerCase().includes('app'))) {
        const techLevel = manager.skills.technical?.level || 0;
        speedBonus *= (1 - (techLevel * 0.05)); // -5% cycle time per level
      }
      
      // Creative skill = faster creative products
      if (p.name && (p.name.toLowerCase().includes('design') || p.name.toLowerCase().includes('art') || p.name.toLowerCase().includes('creative'))) {
        const creativeLevel = manager.skills.creative?.level || 0;
        speedBonus *= (1 - (creativeLevel * 0.05));
      }
      
      // Management skill = universal 2% speed boost per level
      const mgmtLevel = manager.skills.management?.level || 0;
      speedBonus *= (1 - (mgmtLevel * 0.02));
      
      cycleTime = Math.floor(cycleTime * speedBonus);
    }
    
    // Minimum 100ms
    return Math.max(100, cycleTime);
  }

  function currentValue(p) {
  // Balanced value growth with global multiplier for better progression
  const level = p.level || 0;
  const baseValue = p.valuePerUnit || 3;
  const growthLinear = 1 + (p.valuePerUpgrade || 0.10) * level;
  const exp = p.valueExponent ?? gameBalance.productIncomeExponent;
  
  // Apply global income multiplier
  let value = baseValue * Math.pow(growthLinear, exp) * gameBalance.globalIncomeMultiplier;
  
  // Apply location-specific income boost from upgrades - LINEAR SCALING
  const incomeBoostLevel = gameState.globalUpgrades?.incomeBoost?.[p.locationId] || 0;
  if (incomeBoostLevel > 0) {
    // Linear formula: +10% per level, can scale to 1000%+
    const boostPercentage = incomeBoostLevel * 10;
    const boostMultiplier = 1 + (boostPercentage / 100);
    value *= boostMultiplier;
  }
  
  // ===== CORPORATE HIERARCHY BONUS =====
  // Apply corporate level bonus from manager
  const manager = gameState.employees.find(e => e.productManaged === p.name && e.hired);
  if (manager && manager.career && p.managerHired) {
    const careerLevel = manager.career.level || 1;
    const levelData = gameState.hierarchyLevels?.[careerLevel];
    
    if (levelData && levelData.productBonusPercent) {
      // Apply product bonus based on manager's corporate level
      const bonusMultiplier = 1 + (levelData.productBonusPercent / 100);
      value *= bonusMultiplier;
    }
  }
  
  // ===== CASCADING MANAGER INCOME BONUSES =====
  // All managers in the chain above this product provide income bonuses
  const managerialBonuses = getManagerialBonuses(p);
  value *= managerialBonuses.incomeMultiplier;
  
  // ===== EXECUTIVE GLOBAL BONUSES =====
  // COO and CFO provide company-wide income multipliers
  if (gameState.corporateHierarchy && gameState.corporateHierarchy.executiveRoles) {
    let executiveMultiplier = 1.0;
    
    // Check for COO (Chief Operating Officer) - +10% global income
    if (gameState.corporateHierarchy.executiveRoles.COO) {
      const coo = gameState.employees.find(e => e.id === gameState.corporateHierarchy.executiveRoles.COO);
      if (coo && coo.employmentStatus === 'active') {
        executiveMultiplier *= 1.10;
      }
    }
    
    // Check for CFO (Chief Financial Officer) - +10% global income
    if (gameState.corporateHierarchy.executiveRoles.CFO) {
      const cfo = gameState.employees.find(e => e.id === gameState.corporateHierarchy.executiveRoles.CFO);
      if (cfo && cfo.employmentStatus === 'active') {
        executiveMultiplier *= 1.10;
      }
    }
    
    // Apply executive bonuses
    value *= executiveMultiplier;
    
    // Update global multiplier for UI display
    gameState.globalIncomeMultiplier = executiveMultiplier;
  }
  
  // ===== EMPLOYEE PRODUCTIVITY INCOME BONUS =====
  // Productivity directly increases income generated
  if (manager && p.managerHired) {
    const baseProductivity = manager.stats?.productivity || 50;
    
    // ===== EMPIRE BUILDER ELITE UPGRADE =====
    // +10% employee productivity per level
    let productivityBonus = 1;
    const empireBuilderLevel = gameState.globalUpgrades?.empireBuilder || 0;
    if (empireBuilderLevel > 0) {
      productivityBonus = 1 + (empireBuilderLevel * 0.1);
    }
    
    // ===== SKILL BONUSES (Phase 3) =====
    // Skills add to effective productivity
    let skillBonus = 0;
    if (manager.skills) {
      // Technical skill boosts tech products
      if (p.name && (p.name.toLowerCase().includes('software') || p.name.toLowerCase().includes('tech') || p.name.toLowerCase().includes('app'))) {
        skillBonus += getSkillBonus(manager, 'technical');
      }
      // Creative skill boosts creative products
      if (p.name && (p.name.toLowerCase().includes('design') || p.name.toLowerCase().includes('art') || p.name.toLowerCase().includes('creative'))) {
        skillBonus += getSkillBonus(manager, 'creative');
      }
      // Management skill gives universal boost
      skillBonus += getSkillBonus(manager, 'management') * 0.5; // Half bonus from management
    }
    
    // Combine base productivity + skill bonuses (cap at 150)
    const totalProductivity = Math.min(150, (baseProductivity + skillBonus) * productivityBonus);
    
    // 1.0x to 1.3x income bonus (0 to 150 effective productivity)
    const productivityIncomeBonus = 1 + (totalProductivity / 500);
    value *= productivityIncomeBonus;
  }
  
  // ===== PRESTIGE INCOME MULTIPLIER =====
  // Apply prestige income multiplier from influence upgrades
  const incomeUpgradeLevel = gameState.influenceUpgrades?.incomeMultiplier || 0;
  if (incomeUpgradeLevel > 0) {
    const prestigeMultiplier = influenceUpgrades.incomeMultiplier.effect(incomeUpgradeLevel);
    value *= prestigeMultiplier;
  }
  
  // ===== ELITE GLOBAL UPGRADES =====
  // Golden Touch: +5% all income per level (compounds)
  const goldenTouchLevel = gameState.globalUpgrades?.goldenTouch || 0;
  if (goldenTouchLevel > 0) {
    const goldenTouchMultiplier = Math.pow(1.05, goldenTouchLevel);
    value *= goldenTouchMultiplier;
  }
  
  return +value.toFixed(2);
  }

  function clickReductionMs(p) {
    // Use globalUpgrades.clickPower which gives +0.1s per level
    const baseSeconds = p.clickSecondsBase || 1.0;
    const globalUpgradeBonus = (gameState.globalUpgrades?.clickPower || 0) * 0.1;
    
    // Add prestige influence upgrade bonus
    const influenceClickLevel = gameState.influenceUpgrades?.clickPower || 0;
    const influenceClickBonus = influenceUpgrades.clickPower.effect(influenceClickLevel);
    
    const perClickSeconds = baseSeconds + globalUpgradeBonus + influenceClickBonus;
    return perClickSeconds * 1000;
  }

  // ============================================
  // GAME BALANCE CONFIGURATION
  // ============================================
  // Central control for all economy tuning
  const gameBalance = {
    // Global multipliers
    globalIncomeMultiplier: 2.5,     // Make everything 2.5x faster for better pacing
    globalCostReduction: 0.7,        // Reduce costs to 70% (was too aggressive at 60%)
    
    // Product scaling
    productCostMultiplier: 1.22,     // Each level costs 1.20x more (reduced from 1.35 for smoother progression to 999)
    productIncomeMultiplier: 1.20,   // Each level gives 1.15x more income
    productIncomeExponent: 0.95,     // Diminishing returns on income growth
    
    // Starting values
    startingCash: 150,               // Start with more cash (was 100)
    firstProductUnlockCost: 80,      // Cheaper to unlock second product (was 100)
    
    // Click power
    baseClickReduction: 1,           // Seconds removed per click
    clickPowerGrowth: 1,             // Additional seconds per upgrade level
    
    // Manager costs  
    managerCostReduction: 0.7,       // Managers cost 70% of original
    
    // Boss fights (for future use)
    bossHealthMultiplier: 2.0,       // Boss health = unlock cost * this
    bossTimeLimit: 60,               // Default time limit in seconds
    bossRewardMultiplier: 5.0,       // Reward = unlock cost * this
    
    // Player upgrades - now scales by location
    upgradeBaseCosts: {
      clickPower: 10000,           // $10K base for click power (scales with 2.0x)
      // Income boost and cost reduction now scale per location based on unlock cost
      incomeBoost: {
        garage: 50000,                    // $50K
        home_office: 150000,              // $150K
        office_suite: 5000000,            // $5M
        factory: 250000000,               // $250M
        rnd: 50000000000,                 // $50B
        creative_studio: 5000000000000,   // $5T
        private_club: 500000000000000,    // $500T
        velvet_room: 50000000000000000,   // $50Q
        inner_sanctum: 500000000000000000 // $500Q (same as Inner Sanctum unlock cost)
      },
      costReduction: {
        garage: 100000,                   // $100K
        home_office: 300000,              // $300K
        office_suite: 10000000,           // $10M
        factory: 500000000,               // $500M
        rnd: 100000000000,                // $100B
        creative_studio: 10000000000000,  // $10T
        private_club: 1000000000000000,   // $1Q
        velvet_room: 100000000000000000,  // $100Q
        inner_sanctum: 1000000000000000000 // $1Qt (2x Inner Sanctum unlock cost)
      }
    }
  };

  // ============================================
  // EMOJI PICKER SYSTEM
  // ============================================
  const emojiPicker = {
    recentEmojis: [], // Store recently used emojis (no duplicates)
    maxRecent: 24,
    currentTarget: null, // The input/textarea that will receive the emoji
    
    emojis: {
      smileys: ['ğŸ˜€','ğŸ˜ƒ','ğŸ˜„','ğŸ˜','ğŸ˜†','ğŸ˜…','ğŸ¤£','ğŸ˜‚','ğŸ™‚','ğŸ™ƒ','ğŸ˜‰','ğŸ˜Š','ğŸ˜‡','ğŸ¥°','ğŸ˜','ğŸ¤©','ğŸ˜˜','ğŸ˜—','ğŸ˜š','ğŸ˜™','ğŸ¥²','ğŸ˜‹','ğŸ˜›','ğŸ˜œ','ğŸ¤ª','ğŸ˜','ğŸ¤‘','ğŸ¤—','ğŸ¤­','ğŸ¤«','ğŸ¤”','ğŸ¤','ğŸ¤¨','ğŸ˜','ğŸ˜‘','ğŸ˜¶','ğŸ˜','ğŸ˜’','ğŸ™„','ğŸ˜¬','ğŸ¤¥','ğŸ˜Œ','ğŸ˜”','ğŸ˜ª','ğŸ¤¤','ğŸ˜´','ğŸ˜·','ğŸ¤’','ğŸ¤•','ğŸ¤¢','ğŸ¤®','ğŸ¤§','ğŸ¥µ','ğŸ¥¶','ğŸ¥´','ğŸ˜µ','ğŸ¤¯','ğŸ¤ ','ğŸ¥³','ğŸ¥¸','ğŸ˜','ğŸ¤“','ğŸ§'],
      gestures: ['ğŸ‘‹','ğŸ¤š','ğŸ–','âœ‹','ğŸ––','ğŸ‘Œ','ğŸ¤Œ','ğŸ¤','âœŒï¸','ğŸ¤','ğŸ¤Ÿ','ğŸ¤˜','ğŸ¤™','ğŸ‘ˆ','ğŸ‘‰','ğŸ‘†','ğŸ–•','ğŸ‘‡','â˜ï¸','ğŸ‘','ğŸ‘','âœŠ','ğŸ‘Š','ğŸ¤›','ğŸ¤œ','ğŸ‘','ğŸ™Œ','ğŸ‘','ğŸ¤²','ğŸ¤','ğŸ™','ğŸ’ª','ğŸ¦¾','ğŸ¦¿','ğŸ¦µ','ğŸ¦¶','ğŸ‘‚','ğŸ¦»','ğŸ‘ƒ','ğŸ§ ','ğŸ«€','ğŸ«','ğŸ¦·','ğŸ¦´','ğŸ‘€','ğŸ‘','ğŸ‘…','ğŸ‘„','ğŸ’‹'],
      hearts: ['â¤ï¸','ğŸ§¡','ğŸ’›','ğŸ’š','ğŸ’™','ğŸ’œ','ğŸ–¤','ğŸ¤','ğŸ¤','ğŸ’”','â¤ï¸â€ğŸ”¥','â¤ï¸â€ğŸ©¹','ğŸ’•','ğŸ’','ğŸ’“','ğŸ’—','ğŸ’–','ğŸ’˜','ğŸ’','ğŸ’Ÿ','ğŸ’Œ','ğŸ’¢','ğŸ’¥','ğŸ’«','ğŸ’¦','ğŸ’¨','ğŸ•³ï¸','ğŸ’¬','ğŸ‘ï¸â€ğŸ—¨ï¸','ğŸ—¨ï¸','ğŸ—¯ï¸','ğŸ’­'],
      objects: ['ğŸ‰','ğŸŠ','ğŸˆ','ğŸ','ğŸ€','ğŸ†','ğŸ¥‡','ğŸ¥ˆ','ğŸ¥‰','âš½','ğŸ€','ğŸˆ','âš¾','ğŸ¾','ğŸ','ğŸ‰','ğŸ±','ğŸ“','ğŸ¸','ğŸ¥…','ğŸ¥Š','ğŸ¥‹','â›³','â›¸ï¸','ğŸ£','ğŸ½','ğŸ¿','ğŸ›·','ğŸ¥Œ','ğŸ¯','ğŸª€','ğŸª','ğŸ±','ğŸ®','ğŸ•¹ï¸','ğŸ°','ğŸ²','ğŸ§©','â™Ÿï¸','ğŸ­','ğŸ¨','ğŸ§µ','ğŸª¡','ğŸ§¶','ğŸª¢','ğŸ“·','ğŸ“¸','ğŸ“¹','ğŸ¥','ğŸ“½ï¸','ğŸ¬','ğŸ“º','ğŸ“»','ğŸ™ï¸','ğŸšï¸','ğŸ›ï¸','ğŸ§','ğŸ·','ğŸª—','ğŸ¸','ğŸ¹','ğŸº','ğŸ»','ğŸª•','ğŸ¥','ğŸª˜','ğŸ“±','ğŸ“²','â˜ï¸','ğŸ“','ğŸ“Ÿ','ğŸ“ ','ğŸ”‹','ğŸ”Œ','ğŸ’»','ğŸ–¥ï¸','ğŸ–¨ï¸','âŒ¨ï¸','ğŸ–±ï¸','ğŸ–²ï¸','ğŸ’¾','ğŸ’¿','ğŸ“€','ğŸ§®','ğŸ¥'],
      symbols: ['âœ¨','â­','ğŸŒŸ','ğŸ’«','âœ…','âŒ','â­•','ğŸ”¥','ğŸ’¯','ğŸ¯','ğŸ’¢','ğŸ’¤','ğŸ’¨','ğŸ•³ï¸','âœ”ï¸','â˜‘ï¸','âœ–ï¸','â•','â–','â—','â“','â”','â•','â—','ã€°ï¸','ğŸ’±','ğŸ’²','âš ï¸','ğŸš¸','ğŸ”±','ğŸ“›','ğŸ”°','âœ³ï¸','â‡ï¸','â™»ï¸','ğŸ’ ','ğŸ”·','ğŸ”¶','ğŸ”¹','ğŸ”¸','ğŸ”º','ğŸ”»','ğŸ’','ğŸ”˜','ğŸ”²','ğŸ”³']
    },
    
    init() {
      // Load recent emojis from localStorage
      const saved = localStorage.getItem('recentEmojis');
      if (saved) {
        try {
          this.recentEmojis = JSON.parse(saved);
        } catch (e) {
          this.recentEmojis = [];
        }
      }
      
      // Setup category buttons
      document.querySelectorAll('.emoji-category-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.switchCategory(btn.dataset.category);
        });
      });
      
      // Close on outside click
      document.addEventListener('click', (e) => {
        const picker = document.getElementById('emojiPickerTray');
        if (picker.style.display === 'block' && !picker.contains(e.target)) {
          // Check if click was on an emoji button
          if (!e.target.classList.contains('emoji-picker-trigger')) {
            this.hide();
          }
        }
      });
      
      // Initial render
      this.renderRecent();
    },
    
    show(targetInput, triggerButton) {
      console.log('EmojiPicker.show() called', {targetInput, triggerButton});
      this.currentTarget = targetInput;
      const picker = document.getElementById('emojiPickerTray');
      console.log('Picker element:', picker);
      const rect = triggerButton.getBoundingClientRect();
      console.log('Button rect:', rect);
      
      // Position picker near the trigger button
      const spaceBelow = window.innerHeight - rect.bottom;
      const spaceAbove = rect.top;
      
      // Prefer positioning below, but if not enough space, position above
      if (spaceBelow > 420 || spaceBelow > spaceAbove) {
        picker.style.top = `${rect.bottom + 5}px`;
        picker.style.bottom = 'auto';
      } else {
        picker.style.bottom = `${window.innerHeight - rect.top + 5}px`;
        picker.style.top = 'auto';
      }
      
      // Position horizontally (try to align with button, but stay in viewport)
      let left = rect.left;
      const pickerWidth = 320;
      if (left + pickerWidth > window.innerWidth) {
        left = window.innerWidth - pickerWidth - 10;
      }
      picker.style.left = `${Math.max(10, left)}px`;
      
      picker.style.display = 'block';
      console.log('Picker display set to block, styles:', {
        display: picker.style.display,
        top: picker.style.top,
        left: picker.style.left,
        zIndex: picker.style.zIndex
      });
      
      // Show recent category by default
      this.switchCategory('recent');
    },
    
    hide() {
      document.getElementById('emojiPickerTray').style.display = 'none';
      this.currentTarget = null;
    },
    
    switchCategory(category) {
      // Update button states
      document.querySelectorAll('.emoji-category-btn').forEach(btn => {
        if (btn.dataset.category === category) {
          btn.style.background = '#2f3336';
          btn.style.color = 'white';
          btn.classList.add('active');
        } else {
          btn.style.background = 'transparent';
          btn.style.color = '#aaa';
          btn.classList.remove('active');
        }
      });
      
      // Render emojis for this category
      if (category === 'recent') {
        this.renderRecent();
      } else {
        this.renderCategory(category);
      }
    },
    
    renderRecent() {
      const content = document.getElementById('emojiPickerContent');
      if (this.recentEmojis.length === 0) {
        content.innerHTML = '<div style="width:100%; text-align:center; padding:40px 20px; color:#666;">No recent emojis yet<br><span style="font-size:2rem; margin-top:10px; display:block;">ğŸ•</span></div>';
        return;
      }
      
      content.innerHTML = this.recentEmojis.map(emoji => 
        `<button class="emoji-btn" data-emoji="${emoji}" style="padding:4px; background:transparent; border:none; font-size:1.1rem; cursor:pointer; border-radius:4px; transition:all 0.15s; flex-shrink:0; width:32px; height:32px; display:flex; align-items:center; justify-content:center;" onmouseenter="this.style.background='#2f3336'; this.style.transform='scale(1.15)'" onmouseleave="this.style.background='transparent'; this.style.transform='scale(1)'">${emoji}</button>`
      ).join('');
      
      this.attachEmojiClickHandlers();
    },
    
    renderCategory(category) {
      const content = document.getElementById('emojiPickerContent');
      const emojis = this.emojis[category] || [];
      
      content.innerHTML = emojis.map(emoji => 
        `<button class="emoji-btn" data-emoji="${emoji}" style="padding:4px; background:transparent; border:none; font-size:1.1rem; cursor:pointer; border-radius:4px; transition:all 0.15s; flex-shrink:0; width:32px; height:32px; display:flex; align-items:center; justify-content:center;" onmouseenter="this.style.background='#2f3336'; this.style.transform='scale(1.15)'" onmouseleave="this.style.background='transparent'; this.style.transform='scale(1)'">${emoji}</button>`
      ).join('');
      
      this.attachEmojiClickHandlers();
    },
    
    attachEmojiClickHandlers() {
      document.querySelectorAll('.emoji-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.insertEmoji(btn.dataset.emoji);
        });
      });
    },
    
    insertEmoji(emoji) {
      if (!this.currentTarget) return;
      
      const input = this.currentTarget;
      const start = input.selectionStart || 0;
      const end = input.selectionEnd || 0;
      const text = input.value;
      
      // Insert emoji at cursor position
      input.value = text.substring(0, start) + emoji + text.substring(end);
      
      // Move cursor after emoji
      const newPos = start + emoji.length;
      input.setSelectionRange(newPos, newPos);
      input.focus();
      
      // Add to recent (remove if exists first to avoid duplicates)
      this.recentEmojis = this.recentEmojis.filter(e => e !== emoji);
      this.recentEmojis.unshift(emoji);
      
      // Keep only max recent
      if (this.recentEmojis.length > this.maxRecent) {
        this.recentEmojis = this.recentEmojis.slice(0, this.maxRecent);
      }
      
      // Save to localStorage
      localStorage.setItem('recentEmojis', JSON.stringify(this.recentEmojis));
      
      // Don't hide picker - let user pick multiple
      // If they want to close, they can click outside
    }
  };

  // ============================================
  // AI REQUEST QUEUE SYSTEM
  // ============================================
  const AIRequestQueue = {
    activeRequests: 0,
    requestQueue: [],
    maxConcurrent: 15,
    
    // Initialize the queue system
    init() {
      this.maxConcurrent = gameState?.settings?.maxAiRequests || 15;
      console.log(`[AI Queue] Initialized with max ${this.maxConcurrent} concurrent requests`);
    },
    
    // Update max concurrent requests from settings
    updateMaxConcurrent(max) {
      this.maxConcurrent = Math.max(1, Math.min(50, max));
      if (gameState.settings) {
        gameState.settings.maxAiRequests = this.maxConcurrent;
      }
      this.processQueue();
      this.updateUI();
      console.log(`[AI Queue] Updated max concurrent to ${this.maxConcurrent}`);
    },
    
    // Add a request to the queue
    async enqueue(requestFunction, description = 'AI Request') {
      return new Promise((resolve, reject) => {
        const request = {
          id: Date.now() + Math.random(),
          function: requestFunction,
          description: description,
          resolve: resolve,
          reject: reject,
          timestamp: Date.now()
        };
        
        this.requestQueue.push(request);
        console.log(`[AI Queue] Queued: ${description} (Queue: ${this.requestQueue.length})`);
        this.updateUI();
        this.processQueue();
      });
    },
    
    // Process the queue, starting new requests if under the limit
    async processQueue() {
      while (this.activeRequests < this.maxConcurrent && this.requestQueue.length > 0) {
        const request = this.requestQueue.shift();
        this.activeRequests++;
        this.updateUI();
        
        console.log(`[AI Queue] Starting: ${request.description} (Active: ${this.activeRequests}, Queued: ${this.requestQueue.length})`);
        
        // Execute the request with retry logic
        try {
          const result = await this.executeWithRetry(request);
          request.resolve(result);
        } catch (error) {
          console.error(`[AI Queue] Final error in ${request.description}:`, error);
          // Provide fallback response instead of rejecting
          const fallbackResponse = this.getFallbackResponse(request.description, error);
          request.resolve(fallbackResponse);
        } finally {
          this.activeRequests--;
          this.updateUI();
          console.log(`[AI Queue] Completed: ${request.description} (Active: ${this.activeRequests}, Queued: ${this.requestQueue.length})`);
          
          // Process next in queue
          this.processQueue();
        }
      }
    },
    
    // Execute request with retry logic
    async executeWithRetry(request, maxRetries = 2) {
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          const result = await request.function();
          return result;
        } catch (error) {
          console.warn(`[AI Queue] Attempt ${attempt}/${maxRetries} failed for ${request.description}:`, error);
          
          // Detect "Max Requests" error specifically
          const errorMessage = error?.message || '';
          const isMaxRequestsError = /max.*request|too.*many.*request|request.*limit|rate.*limit|exceeded.*limit/i.test(errorMessage);
          
          if (isMaxRequestsError) {
            // Log detailed failure state for debugging
            this.logMaxRequestsFailure(request, error, attempt);
            
            if (attempt === 1) {
              // On first attempt, wait longer and potentially adjust queue
              console.warn(`[AI Queue] ğŸš¨ Max Requests detected on first attempt - extending wait time`);
              await new Promise(resolve => setTimeout(resolve, 5000)); // 5 second wait
            }
          }
          
          if (attempt === maxRetries) {
            // Log final failure state if it's a Max Requests error
            if (isMaxRequestsError) {
              this.logMaxRequestsFailure(request, error, attempt, true);
            }
            throw error; // Final attempt failed
          }
          
          // Wait before retry (exponential backoff)
          const waitTime = isMaxRequestsError 
            ? Math.pow(2, attempt) * 2000 // Longer wait for rate limit errors: 4s, 8s...
            : Math.pow(2, attempt - 1) * 1000; // Normal wait: 1s, 2s...
          
          console.log(`[AI Queue] Retrying ${request.description} in ${waitTime}ms...`);
          await new Promise(resolve => setTimeout(resolve, waitTime));
        }
      }
    },
    
    // Log Max Requests failure with detailed queue state
    logMaxRequestsFailure(request, error, attempt, isFinalFailure = false) {
      const timestamp = new Date().toISOString();
      const queueState = {
        activeRequests: this.activeRequests,
        queuedRequests: this.requestQueue.length,
        maxConcurrent: this.maxConcurrent,
        totalPending: this.activeRequests + this.requestQueue.length,
        failedRequest: request.description,
        attempt: attempt,
        error: error.message || 'Unknown error',
        timestamp: timestamp
      };
      
      console.error('ğŸš¨ [AI QUEUE] MAX REQUESTS ERROR DETECTED:');
      console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.error(`ğŸ“ Request: ${request.description}`);
      console.error(`ğŸ”¢ Queue State: ${this.activeRequests} active, ${this.requestQueue.length} queued`);
      console.error(`âš™ï¸ Max Concurrent: ${this.maxConcurrent}`);
      console.error(`ğŸ“Š Total Pending: ${queueState.totalPending}`);
      console.error(`ğŸ¯ Attempt: ${attempt}${isFinalFailure ? ' (FINAL)' : ''}`);
      console.error(`âš ï¸ Error: ${error.message}`);
      console.error(`ğŸ• Time: ${timestamp}`);
      console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      
      // Store failure data for potential analysis
      if (!window.aiQueueFailures) {
        window.aiQueueFailures = [];
      }
      window.aiQueueFailures.push(queueState);
      
      // Keep only last 20 failures to prevent memory bloat
      if (window.aiQueueFailures.length > 20) {
        window.aiQueueFailures.shift();
      }
      
      // Show user-friendly notification for final failures
      if (isFinalFailure && typeof showNotification === 'function') {
        showNotification(
          `ğŸš¨ AI Rate Limit Hit!\nQueue: ${this.activeRequests} active, ${this.requestQueue.length} waiting\nConsider lowering max requests to ${Math.max(5, this.maxConcurrent - 5)}`,
          'warning',
          8000
        );
      }
      
      return queueState;
    },
    
    // Get fallback response for failed AI generation
    getFallbackResponse(description, error) {
      const errorType = error?.message || 'Unknown error';
      console.log(`[AI Queue] Using fallback for ${description}: ${errorType}`);
      
      // Context-aware fallbacks based on description
      if (description.toLowerCase().includes('chat') || description.toLowerCase().includes('response')) {
        return "I'm having some difficulty with my words right now. Could you try asking again?";
      } else if (description.toLowerCase().includes('gift')) {
        return { 
          name: 'Thoughtful Note', 
          description: 'A handwritten note expressing appreciation. Sometimes the simplest gestures mean the most.',
          price: 5,
          type: 'misc'
        };
      } else if (description.toLowerCase().includes('profile') || description.toLowerCase().includes('manager')) {
        return "This person has a warm personality and brings positive energy to any workplace.";
      } else if (description.toLowerCase().includes('meeting')) {
        return "The discussion was productive, though some technical details need to be worked out later.";
      } else {
        return "I'm experiencing some technical difficulties. Please try again in a moment.";
      }
    },
    
    // Update the UI status indicators
    updateUI() {
      const statusEl = document.getElementById('aiQueueStatus');
      const countsEl = document.getElementById('aiQueueCounts');
      
      if (statusEl) {
        if (this.activeRequests === 0 && this.requestQueue.length === 0) {
          statusEl.textContent = 'Ready';
          statusEl.style.color = '#4ecca3';
        } else if (this.requestQueue.length > 0) {
          statusEl.textContent = 'Busy (Queued)';
          statusEl.style.color = '#ffd700';
        } else {
          statusEl.textContent = 'Processing';
          statusEl.style.color = '#00d4ff';
        }
      }
      
      if (countsEl) {
        countsEl.textContent = `${this.activeRequests}/${this.requestQueue.length}`;
      }
    },
    
    // Get queue statistics
    getStats() {
      return {
        active: this.activeRequests,
        queued: this.requestQueue.length,
        maxConcurrent: this.maxConcurrent,
        totalWaiting: this.activeRequests + this.requestQueue.length
      };
    },
    
    // Analyze Max Requests failures and suggest optimal settings
    analyzeFailures() {
      if (!window.aiQueueFailures || window.aiQueueFailures.length === 0) {
        console.log('ğŸ” [AI Queue Analysis] No Max Requests failures recorded yet.');
        return null;
      }
      
      const failures = window.aiQueueFailures;
      const analysis = {
        totalFailures: failures.length,
        avgActiveAtFailure: failures.reduce((sum, f) => sum + f.activeRequests, 0) / failures.length,
        avgQueuedAtFailure: failures.reduce((sum, f) => sum + f.queuedRequests, 0) / failures.length,
        avgMaxConcurrentAtFailure: failures.reduce((sum, f) => sum + f.maxConcurrent, 0) / failures.length,
        maxActiveAtFailure: Math.max(...failures.map(f => f.activeRequests)),
        recentFailures: failures.slice(-5) // Last 5 failures
      };
      
      // Calculate suggested optimal max concurrent
      const safeMaxConcurrent = Math.floor(analysis.avgActiveAtFailure * 0.8); // 20% buffer
      const recommendedMax = Math.max(5, Math.min(25, safeMaxConcurrent));
      
      console.log('ğŸ” [AI QUEUE FAILURE ANALYSIS]');
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.log(`ğŸ“Š Total Max Requests failures: ${analysis.totalFailures}`);
      console.log(`ğŸ“ˆ Average active requests at failure: ${analysis.avgActiveAtFailure.toFixed(1)}`);
      console.log(`ğŸ“‹ Average queued requests at failure: ${analysis.avgQueuedAtFailure.toFixed(1)}`);
      console.log(`âš™ï¸ Average max concurrent setting: ${analysis.avgMaxConcurrentAtFailure.toFixed(1)}`);
      console.log(`ğŸ¯ Highest active count at failure: ${analysis.maxActiveAtFailure}`);
      console.log(`ğŸ’¡ RECOMMENDED max concurrent: ${recommendedMax} (current: ${this.maxConcurrent})`);
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      
      if (analysis.recentFailures.length > 0) {
        console.log('ğŸ• Recent failures:');
        analysis.recentFailures.forEach((f, i) => {
          console.log(`  ${i + 1}. ${f.activeRequests} active, ${f.queuedRequests} queued (max: ${f.maxConcurrent}) - ${f.failedRequest}`);
        });
      }
      
      if (recommendedMax < this.maxConcurrent) {
        console.log(`\nğŸ›ï¸ Consider lowering max concurrent to ${recommendedMax} for better stability.`);
        console.log(`   Use: AIRequestQueue.updateMaxConcurrent(${recommendedMax})`);
      }
      
      return analysis;
    },
    
    // Clear failure tracking data
    clearFailureData() {
      if (window.aiQueueFailures) {
        const count = window.aiQueueFailures.length;
        window.aiQueueFailures = [];
        console.log(`ğŸ—‘ï¸ [AI Queue] Cleared ${count} failure records.`);
      }
    }
  };

  // Wrapper function for queued generateText calls
  async function queuedGenerateText(prompt, options = {}, description = 'Text Generation') {
    if (typeof generateText !== 'function') {
      console.warn('[AI Queue] generateText not available, using fallback');
      return AIRequestQueue.getFallbackResponse(description, new Error('generateText not available'));
    }
    
    try {
      return await AIRequestQueue.enqueue(
        () => generateText(prompt, options),
        description
      );
    } catch (error) {
      console.error(`[AI Queue] Final fallback for ${description}:`, error);
      return AIRequestQueue.getFallbackResponse(description, error);
    }
  }
  
  // Convenience functions for console debugging
  window.aiQueueDebug = {
    // Show current queue status
    status: () => {
      const stats = AIRequestQueue.getStats();
      console.log('ğŸ” [AI Queue Status]');
      console.log(`Active: ${stats.active}, Queued: ${stats.queued}, Max: ${stats.maxConcurrent}`);
      console.log(`Total pending: ${stats.totalWaiting}`);
      return stats;
    },
    
    // Analyze failures and get recommendations
    analyze: () => AIRequestQueue.analyzeFailures(),
    
    // Clear failure tracking data
    clearFailures: () => AIRequestQueue.clearFailureData(),
    
    // Get raw failure data
    getFailures: () => window.aiQueueFailures || [],
    
    // Adjust max concurrent requests
    setMax: (max) => {
      AIRequestQueue.updateMaxConcurrent(max);
      console.log(`âœ… Max concurrent requests set to ${max}`);
    },
    
    // Show help
    help: () => {
      console.log('ğŸ”§ [AI Queue Debug Commands]');
      console.log('aiQueueDebug.status()      - Show current queue status');
      console.log('aiQueueDebug.analyze()     - Analyze Max Requests failures');
      console.log('aiQueueDebug.setMax(15)    - Set max concurrent requests');
      console.log('aiQueueDebug.clearFailures() - Clear failure tracking data');
      console.log('aiQueueDebug.getFailures() - Get raw failure data');
      console.log('aiQueueDebug.help()        - Show this help');
    }
  };

  // ============================================
  // IMAGE REQUEST QUEUE SYSTEM
  // ============================================
  const ImageRequestQueue = {
    activeRequests: 0,
    requestQueue: [],
    maxConcurrent: 8, // Lower default for images since they're typically more resource-intensive
    
    // Initialize the image queue system
    init() {
      this.maxConcurrent = gameState?.settings?.maxImageRequests || 8;
      console.log(`[Image Queue] Initialized with max ${this.maxConcurrent} concurrent requests`);
    },
    
    // Update max concurrent requests from settings
    updateMaxConcurrent(max) {
      this.maxConcurrent = Math.max(1, Math.min(25, max)); // Lower upper bound for images
      if (gameState.settings) {
        gameState.settings.maxImageRequests = this.maxConcurrent;
      }
      this.processQueue();
      this.updateUI();
      console.log(`[Image Queue] Updated max concurrent to ${this.maxConcurrent}`);
    },
    
    // Add a request to the queue
    async enqueue(requestFunction, description = 'Image Generation') {
      return new Promise((resolve, reject) => {
        const request = {
          id: Date.now() + Math.random(),
          function: requestFunction,
          description: description,
          resolve: resolve,
          reject: reject,
          timestamp: Date.now()
        };
        
        this.requestQueue.push(request);
        console.log(`[Image Queue] Queued: ${description} (Queue: ${this.requestQueue.length})`);
        this.updateUI();
        this.processQueue();
      });
    },
    
    // Process the queue, starting new requests if under the limit
    async processQueue() {
      while (this.activeRequests < this.maxConcurrent && this.requestQueue.length > 0) {
        const request = this.requestQueue.shift();
        this.activeRequests++;
        this.updateUI();
        
        console.log(`[Image Queue] Starting: ${request.description} (Active: ${this.activeRequests}, Queued: ${this.requestQueue.length})`);
        
        // Execute the request with retry logic
        try {
          const result = await this.executeWithRetry(request);
          request.resolve(result);
        } catch (error) {
          console.error(`[Image Queue] Final error in ${request.description}:`, error);
          // Provide fallback response instead of rejecting
          const fallbackResponse = this.getFallbackResponse(request.description, error);
          request.resolve(fallbackResponse);
        } finally {
          this.activeRequests--;
          this.updateUI();
          console.log(`[Image Queue] Completed: ${request.description} (Active: ${this.activeRequests}, Queued: ${this.requestQueue.length})`);
          
          // Process next in queue
          this.processQueue();
        }
      }
    },
    
    // Execute request with retry logic
    async executeWithRetry(request, maxRetries = 3) { // One more retry for images due to potential network issues
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          const result = await request.function();
          return result;
        } catch (error) {
          console.warn(`[Image Queue] Attempt ${attempt}/${maxRetries} failed for ${request.description}:`, error);
          
          // Detect image-specific errors
          const errorMessage = error?.message || '';
          const isRateLimitError = /max.*request|too.*many.*request|request.*limit|rate.*limit|exceeded.*limit|quota.*exceeded/i.test(errorMessage);
          const isContentPolicyError = /content.*policy|inappropriate.*content|unsafe.*content|violation|blocked/i.test(errorMessage);
          const isNetworkError = /network|timeout|connection|fetch/i.test(errorMessage);
          
          if (isRateLimitError || isContentPolicyError) {
            // Log detailed failure state for debugging
            this.logImageFailure(request, error, attempt, { 
              type: isRateLimitError ? 'rate_limit' : 'content_policy',
              isRateLimit: isRateLimitError,
              isContentPolicy: isContentPolicyError
            });
            
            if (attempt === 1 && isRateLimitError) {
              // On first attempt with rate limit, wait longer and potentially adjust queue
              console.warn(`[Image Queue] ğŸš¨ Rate limit detected on first attempt - extending wait time`);
              await new Promise(resolve => setTimeout(resolve, 8000)); // 8 second wait for images
            }
          }
          
          if (attempt === maxRetries) {
            // Log final failure state
            if (isRateLimitError || isContentPolicyError) {
              this.logImageFailure(request, error, attempt, { 
                type: isRateLimitError ? 'rate_limit' : 'content_policy',
                isRateLimit: isRateLimitError,
                isContentPolicy: isContentPolicyError
              }, true);
            }
            throw error; // Final attempt failed
          }
          
          // Wait before retry (longer waits for images)
          let waitTime;
          if (isRateLimitError) {
            waitTime = Math.pow(2, attempt) * 3000; // 6s, 12s, 24s...
          } else if (isContentPolicyError) {
            waitTime = 1000; // Quick retry for content policy (might be prompt-specific)
          } else if (isNetworkError) {
            waitTime = Math.pow(2, attempt - 1) * 2000; // 2s, 4s, 8s...
          } else {
            waitTime = Math.pow(2, attempt - 1) * 1500; // 1.5s, 3s, 6s...
          }
          
          console.log(`[Image Queue] Retrying ${request.description} in ${waitTime}ms...`);
          await new Promise(resolve => setTimeout(resolve, waitTime));
        }
      }
    },
    
    // Log image generation failure with detailed queue state
    logImageFailure(request, error, attempt, errorInfo = {}, isFinalFailure = false) {
      const timestamp = new Date().toISOString();
      const queueState = {
        activeRequests: this.activeRequests,
        queuedRequests: this.requestQueue.length,
        maxConcurrent: this.maxConcurrent,
        totalPending: this.activeRequests + this.requestQueue.length,
        failedRequest: request.description,
        attempt: attempt,
        error: error.message || 'Unknown error',
        errorType: errorInfo.type || 'unknown',
        isRateLimit: errorInfo.isRateLimit || false,
        isContentPolicy: errorInfo.isContentPolicy || false,
        timestamp: timestamp
      };
      
      const errorIcon = errorInfo.isRateLimit ? 'ğŸš¨' : errorInfo.isContentPolicy ? 'âš ï¸' : 'âŒ';
      const errorTypeText = errorInfo.isRateLimit ? 'RATE LIMIT' : errorInfo.isContentPolicy ? 'CONTENT POLICY' : 'GENERATION';
      
      console.error(`${errorIcon} [IMAGE QUEUE] ${errorTypeText} ERROR DETECTED:`);
      console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.error(`ğŸ“ Request: ${request.description}`);
      console.error(`ğŸ–¼ï¸ Queue State: ${this.activeRequests} active, ${this.requestQueue.length} queued`);
      console.error(`âš™ï¸ Max Concurrent: ${this.maxConcurrent}`);
      console.error(`ğŸ“Š Total Pending: ${queueState.totalPending}`);
      console.error(`ğŸ¯ Attempt: ${attempt}${isFinalFailure ? ' (FINAL)' : ''}`);
      console.error(`âš ï¸ Error Type: ${errorTypeText}`);
      console.error(`ğŸ” Error: ${error.message}`);
      console.error(`ğŸ• Time: ${timestamp}`);
      console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      
      // Store failure data for analysis
      if (!window.imageQueueFailures) {
        window.imageQueueFailures = [];
      }
      window.imageQueueFailures.push(queueState);
      
      // Keep only last 20 failures to prevent memory bloat
      if (window.imageQueueFailures.length > 20) {
        window.imageQueueFailures.shift();
      }
      
      // Show user-friendly notification for final failures
      if (isFinalFailure && typeof showNotification === 'function') {
        if (errorInfo.isRateLimit) {
          showNotification(
            `ğŸš¨ Image Rate Limit Hit!\nQueue: ${this.activeRequests} active, ${this.requestQueue.length} waiting\nConsider lowering max requests to ${Math.max(3, this.maxConcurrent - 2)}`,
            'warning',
            8000
          );
        } else if (errorInfo.isContentPolicy) {
          showNotification(
            `âš ï¸ Image Content Policy Violation\nThe image request was blocked by safety filters.\nTrying alternative approach...`,
            'warning',
            6000
          );
        } else {
          showNotification(
            `âŒ Image Generation Failed\nRequest: ${request.description}\nUsing fallback image...`,
            'error',
            6000
          );
        }
      }
      
      return queueState;
    },
    
    // Get fallback response for failed image generation
    getFallbackResponse(description, error) {
      const errorType = error?.message || 'Unknown error';
      console.log(`[Image Queue] Using fallback for ${description}: ${errorType}`);
      
      // Determine fallback image based on context
      const desc = description.toLowerCase();
      
      if (desc.includes('profile') || desc.includes('employee') || desc.includes('manager')) {
        return 'https://via.placeholder.com/200x200/4ecca3/ffffff?text=Profile';
      } else if (desc.includes('social') || desc.includes('post')) {
        return 'https://via.placeholder.com/300x200/00d4ff/ffffff?text=Social+Post';
      } else if (desc.includes('gift') || desc.includes('present')) {
        return 'https://via.placeholder.com/150x150/ffd700/ffffff?text=Gift';
      } else if (desc.includes('chat') || desc.includes('message')) {
        return 'https://via.placeholder.com/200x150/ff6b9d/ffffff?text=Message';
      } else if (desc.includes('scene') || desc.includes('office')) {
        return 'https://via.placeholder.com/400x250/232931/ffffff?text=Office+Scene';
      } else {
        // Generic fallback
        return 'https://via.placeholder.com/250x200/666666/ffffff?text=Image+Unavailable';
      }
    },
    
    // Update the UI status indicators
    updateUI() {
      const statusEl = document.getElementById('imageQueueStatus');
      const countsEl = document.getElementById('imageQueueCounts');
      
      if (statusEl) {
        if (this.activeRequests === 0 && this.requestQueue.length === 0) {
          statusEl.textContent = 'Ready';
          statusEl.style.color = '#4ecca3';
        } else if (this.requestQueue.length > 0) {
          statusEl.textContent = 'Busy (Queued)';
          statusEl.style.color = '#ffd700';
        } else {
          statusEl.textContent = 'Generating';
          statusEl.style.color = '#ff6b9d';
        }
      }
      
      if (countsEl) {
        countsEl.textContent = `${this.activeRequests}/${this.requestQueue.length}`;
      }
    },
    
    // Get queue statistics
    getStats() {
      return {
        active: this.activeRequests,
        queued: this.requestQueue.length,
        maxConcurrent: this.maxConcurrent,
        totalWaiting: this.activeRequests + this.requestQueue.length
      };
    },
    
    // Analyze image generation failures and suggest optimal settings
    analyzeFailures() {
      if (!window.imageQueueFailures || window.imageQueueFailures.length === 0) {
        console.log('ğŸ” [Image Queue Analysis] No failures recorded yet.');
        return null;
      }
      
      const failures = window.imageQueueFailures;
      const rateLimitFailures = failures.filter(f => f.isRateLimit);
      const contentPolicyFailures = failures.filter(f => f.isContentPolicy);
      const otherFailures = failures.filter(f => !f.isRateLimit && !f.isContentPolicy);
      
      const analysis = {
        totalFailures: failures.length,
        rateLimitFailures: rateLimitFailures.length,
        contentPolicyFailures: contentPolicyFailures.length,
        otherFailures: otherFailures.length,
        avgActiveAtFailure: failures.reduce((sum, f) => sum + f.activeRequests, 0) / failures.length,
        avgQueuedAtFailure: failures.reduce((sum, f) => sum + f.queuedRequests, 0) / failures.length,
        avgMaxConcurrentAtFailure: failures.reduce((sum, f) => sum + f.maxConcurrent, 0) / failures.length,
        maxActiveAtFailure: Math.max(...failures.map(f => f.activeRequests)),
        recentFailures: failures.slice(-5) // Last 5 failures
      };
      
      // Calculate suggested optimal max concurrent for rate limit failures
      let recommendedMax = this.maxConcurrent;
      if (rateLimitFailures.length > 0) {
        const avgActiveAtRateLimit = rateLimitFailures.reduce((sum, f) => sum + f.activeRequests, 0) / rateLimitFailures.length;
        const safeMaxConcurrent = Math.floor(avgActiveAtRateLimit * 0.7); // 30% buffer for images
        recommendedMax = Math.max(3, Math.min(15, safeMaxConcurrent));
      }
      
      console.log('ğŸ” [IMAGE QUEUE FAILURE ANALYSIS]');
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.log(`ğŸ–¼ï¸ Total image generation failures: ${analysis.totalFailures}`);
      console.log(`ğŸš¨ Rate limit failures: ${analysis.rateLimitFailures}`);
      console.log(`âš ï¸ Content policy failures: ${analysis.contentPolicyFailures}`);
      console.log(`âŒ Other failures: ${analysis.otherFailures}`);
      console.log(`ğŸ“ˆ Average active requests at failure: ${analysis.avgActiveAtFailure.toFixed(1)}`);
      console.log(`ğŸ“‹ Average queued requests at failure: ${analysis.avgQueuedAtFailure.toFixed(1)}`);
      console.log(`âš™ï¸ Average max concurrent setting: ${analysis.avgMaxConcurrentAtFailure.toFixed(1)}`);
      console.log(`ğŸ¯ Highest active count at failure: ${analysis.maxActiveAtFailure}`);
      if (rateLimitFailures.length > 0) {
        console.log(`ğŸ’¡ RECOMMENDED max concurrent: ${recommendedMax} (current: ${this.maxConcurrent})`);
      }
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      
      if (analysis.recentFailures.length > 0) {
        console.log('ğŸ• Recent failures:');
        analysis.recentFailures.forEach((f, i) => {
          const errorTypeEmoji = f.isRateLimit ? 'ğŸš¨' : f.isContentPolicy ? 'âš ï¸' : 'âŒ';
          console.log(`  ${i + 1}. ${errorTypeEmoji} ${f.activeRequests} active, ${f.queuedRequests} queued (max: ${f.maxConcurrent}) - ${f.failedRequest}`);
        });
      }
      
      if (rateLimitFailures.length > 0 && recommendedMax < this.maxConcurrent) {
        console.log(`\nğŸ›ï¸ Consider lowering max concurrent to ${recommendedMax} for better stability.`);
        console.log(`   Use: ImageRequestQueue.updateMaxConcurrent(${recommendedMax})`);
      }
      
      if (contentPolicyFailures.length > 0) {
        console.log(`\nâš ï¸ ${contentPolicyFailures.length} content policy violations detected.`);
        console.log(`   Consider reviewing image prompts to ensure they comply with safety guidelines.`);
      }
      
      return analysis;
    },
    
    // Clear failure tracking data
    clearFailureData() {
      if (window.imageQueueFailures) {
        const count = window.imageQueueFailures.length;
        window.imageQueueFailures = [];
        console.log(`ğŸ—‘ï¸ [Image Queue] Cleared ${count} failure records.`);
      }
    }
  };

  // Wrapper function for queued generateImage calls
  async function queuedGenerateImage(prompt, description = 'Image Generation') {
    if (typeof generateImage !== 'function') {
      console.warn('[Image Queue] generateImage not available, using fallback');
      return ImageRequestQueue.getFallbackResponse(description, new Error('generateImage not available'));
    }
    
    try {
      return await ImageRequestQueue.enqueue(
        () => generateImage(prompt),
        description
      );
    } catch (error) {
      console.error(`[Image Queue] Final fallback for ${description}:`, error);
      return ImageRequestQueue.getFallbackResponse(description, error);
    }
  }
  
  // Convenience functions for console debugging
  window.imageQueueDebug = {
    // Show current queue status
    status: () => {
      const stats = ImageRequestQueue.getStats();
      console.log('ğŸ” [Image Queue Status]');
      console.log(`Active: ${stats.active}, Queued: ${stats.queued}, Max: ${stats.maxConcurrent}`);
      console.log(`Total pending: ${stats.totalWaiting}`);
      return stats;
    },
    
    // Analyze failures and get recommendations
    analyze: () => ImageRequestQueue.analyzeFailures(),
    
    // Clear failure tracking data
    clearFailures: () => ImageRequestQueue.clearFailureData(),
    
    // Get raw failure data
    getFailures: () => window.imageQueueFailures || [],
    
    // Adjust max concurrent requests
    setMax: (max) => {
      ImageRequestQueue.updateMaxConcurrent(max);
      console.log(`âœ… Max concurrent image requests set to ${max}`);
    },
    
    // Show help
    help: () => {
      console.log('ğŸ”§ [Image Queue Debug Commands]');
      console.log('imageQueueDebug.status()      - Show current queue status');
      console.log('imageQueueDebug.analyze()     - Analyze generation failures');
      console.log('imageQueueDebug.setMax(8)     - Set max concurrent requests');
      console.log('imageQueueDebug.clearFailures() - Clear failure tracking data');
      console.log('imageQueueDebug.getFailures() - Get raw failure data');
      console.log('imageQueueDebug.help()        - Show this help');
    }
  };

  // Game State
  let gameState = {
    cash: gameBalance.startingCash,  // Use balance config
    playerUpgrades: { clickPower: 0 }, // each +1 = +0.1s per click
    totalEarnings: 0,
    onboarding: [], // tracks employees being onboarded
    lastPlayTime: Date.now(), // Track when player last played for AFK income
    lastInteractionTime: Date.now(), // Track actual last user interaction (clicks, taps, etc.)
    pageHiddenTime: null, // Track when page was hidden/backgrounded
    
    // â° PHASE 4: TIME & SCHEDULE SYSTEM
    time: {
      enabled: true,                    // Toggle time progression
      currentTime: Date.now(),          // Current game timestamp
      timeScale: 20,                    // Time multiplier (20 = 1 game min per 3 real seconds)
      lastHour: null,                   // Track last hour for hourly events
      lastDay: null,                    // Track last day for daily events
      paused: false                     // Pause time progression
      // NOTE: Methods moved to timeHelpers to allow save serialization
    },
    
    // OFFLINE EARNINGS SYSTEM
    offlineEarnings: {
      enabled: true,                    // Allow offline earnings
      maxDuration: 24 * 60 * 60 * 1000, // Max 24 hours (real time)
      rate: 0.5,                        // 50% of normal income rate
      lastPlayedRealTime: Date.now()    // Track when player last played (real time)
    },
    
    // PRESTIGE SYSTEM
    prestigeLevel: 0,              // Number of times player has prestiged
    influencePoints: 0,            // Prestige currency (persistent)
    lifetimeEarnings: 0,           // Total earnings across all prestiges
    lifetimeEarningsConverted: 0,  // Lifetime earnings already converted to influence
    prestigeMultiplier: 1.0,       // Income multiplier from prestiges
    
    // GLOBAL UPGRADES (reset on prestige)
    globalUpgrades: {
      clickPower: 0,               // Level of click power upgrade (+0.1s per level)
      incomeBoost: {},             // Per-location income boost {locationId: level} (+10% per level)
      costReduction: {},           // Per-location cost reduction {locationId: level} (-10% per level)
      goldenTouch: 0,              // Late-game: +5% all income per level (compounds)
      timeDilation: 0,             // Late-game: +3% production speed per level
      empireBuilder: 0             // Late-game: +10% employee productivity per level
    },
    
    // HR SETTINGS (configurable employee starting stats)
    hrSettings: {
      startingStatRanges: {
        productivity: { min: 30, max: 60 },    // Default: 30-60 (was 50-75)
        trust: { min: 30, max: 60 },            // Default: 30-60 (was 50-75)
        friendship: { min: 30, max: 60 },       // Default: 30-60 (was 50-75)
        desire: { min: 30, max: 60 },           // Default: 30-60 (was 50-75)
        comfort: { min: 30, max: 60 },          // Default: 30-60 (was 50-75)
        affection: { min: 30, max: 60 }         // Default: 30-60 (was 50-75)
      }
    },
    
    // BOSS FIGHTS
    bossFights: {
      active: null,                // Currently active boss fight
      defeated: [],                // Array of defeated boss IDs
      history: []                  // Combat history for replay/stats
    },
    
    locations: [
      {
        id: 'garage',
        name: 'ğŸ  Garage',
        cost: 0,
        owned: true,
        unlocked: true,
        theme: {
          primary: '#3498db',      // Light blue
          secondary: '#ecf0f1',    // White
          accent: '#95a5a6',       // Gray
          background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
          description: 'Humble beginnings in your garage'
        },
        products: []
      },
      {
        id: 'home_office',
        name: 'ğŸ’¼ Home Office',
        cost: 15000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#2c3e50',      // Navy blue
          secondary: '#27ae60',    // Forest green
          accent: '#f5f5dc',       // Cream
          background: 'linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%)',
          description: 'Professional workspace, scaling up operations'
        },
        products: []
      },
      {
        id: 'office_suite',
        name: 'ğŸ¢ Office Suite',
        cost: 500000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#1e3a8a',      // Corporate blue
          secondary: '#c0c0c0',    // Silver
          accent: '#ffffff',       // White
          background: 'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)',
          description: 'Legitimate corporate headquarters, the big leagues'
        },
        products: []
      },
      {
        id: 'factory',
        name: 'ğŸ­ Factory',
        cost: 25000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#5a6268',      // Industrial gray
          secondary: '#fd7e14',    // Orange
          accent: '#607d8b',       // Steel blue
          background: 'linear-gradient(135deg, #232526 0%, #414345 100%)',
          description: 'Manufacturing facility producing physical goods'
        },
        products: []
      },
      {
        id: 'rnd',
        name: 'ğŸ”¬ R&D Lab',
        cost: 5000000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#00bfff',      // Electric blue
          secondary: '#39ff14',    // Neon green
          accent: '#f0f0f0',       // White
          background: 'linear-gradient(135deg, #000428 0%, #004e92 100%)',
          description: 'Cutting-edge research and experimental technology'
        },
        products: []
      },
      {
        id: 'creative_studio',
        name: 'ğŸ¨ Creative Studio',
        cost: 500000000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#9b59b6',      // Purple
          secondary: '#e91e63',    // Magenta
          accent: '#b76e79',       // Rose gold
          background: 'linear-gradient(135deg, #8e2de2 0%, #4a00e0 100%)',
          description: '"Artistic" content creation and adult-adjacent media'
        },
        nsfwLevel: 1,              // Suggestive content begins
        products: []
      },
      {
        id: 'private_club',
        name: 'ğŸ¸ Private Club',
        cost: 50000000000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#c0392b',      // Deep red
          secondary: '#d4af37',    // Gold
          accent: '#1a1a1a',       // Black
          background: 'linear-gradient(135deg, #870000 0%, #190a05 100%)',
          description: 'Elite adult entertainment and exclusive services'
        },
        nsfwLevel: 2,              // Explicit content
        products: []
      },
      {
        id: 'velvet_room',
        name: 'ğŸ­ Velvet Room',
        cost: 5000000000000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#4a148c',      // Dark purple
          secondary: '#b71c1c',    // Crimson
          accent: '#0f0f0f',       // Shadow black
          background: 'linear-gradient(135deg, #1a0033 0%, #330033 100%)',
          description: 'Secret society rituals, masks, absolute depravity'
        },
        nsfwLevel: 3,              // Depraved content
        products: []
      },
      {
        id: 'inner_sanctum',
        name: 'ğŸ‘ï¸ Inner Sanctum',
        cost: 500000000000000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#000000',      // Void black
          secondary: '#8b0000',    // Blood red
          accent: '#2d5016',       // Sickly green
          background: 'linear-gradient(135deg, #000000 0%, #0a0a0a 50%, #000000 100%)',
          description: 'Beyond morality. You have become the darkness.'
        },
        nsfwLevel: 4,              // Endgame horror
        requiresPrestiges: 1,      // Must prestige at least once
        products: []
      }
    ],
    products: [
      {
        id: 'website',
        name: 'Website Development',
        locationId: 'garage',
        // unlock
        unlocked: true,           // first product is always unlocked
        unlockCost: 0,            // no cost for first product
        // economy
  valuePerUnit: 3,          // $ earned per completed cycle
  level: 0,                 // product upgrade level
  upgradeCost: 50,          // current upgrade cost (will scale by costGrowth)
  baseUpgradeCost: 50,      // base cost at level 0
  costGrowth: 1.35,         // cost multiplier per level
  valuePerUpgrade: 0.10,    // toned down growth per upgrade
  valueExponent: 0.85,      // diminishing returns exponent
        // timing
        baseTimeMs: 6000,         // 6s cycle base
        running: false,
        timeRemainingMs: 0,
        // clicking
        clickSecondsBase: 1,      // each click removes 1 second by default
        // manager
        managerHired: false,
        managerLevel: 0,
        managerHireCost: 500,
        managerUpgradeCost: 250,
        // caps
  managerSpeedCapPct: 0.40  // at most 40% faster
      },
      {
        id: 'app',
        name: 'Mobile App',
        locationId: 'garage',
        // unlock
        unlocked: false,
        unlockCost: 80,          // Reduced from 100 for faster early game
  valuePerUnit: 9, level: 0, upgradeCost: 150, baseUpgradeCost: 150, costGrowth: 1.35, valuePerUpgrade: 0.12, valueExponent: 0.85,
        baseTimeMs: 10000, running:false, timeRemainingMs:0,
        clickSecondsBase: 1,
        managerHired:false, managerLevel:0, managerHireCost:1500, managerUpgradeCost:750,
  managerSpeedCapPct:0.40
      },
      {
        id: 'consulting',
        name: 'IT Consulting',
        locationId: 'garage',
        // unlock
        unlocked: false,
        unlockCost: 300,          // Reduced from 400 for better flow
  valuePerUnit: 18, level: 0, upgradeCost: 300, baseUpgradeCost: 300, costGrowth: 1.35, valuePerUpgrade: 0.12, valueExponent: 0.85,
        baseTimeMs: 14000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:3000, managerUpgradeCost:1500,
  managerSpeedCapPct:0.40
      },
      {
        id: 'cloud',
        name: 'Cloud Services',
        locationId: 'garage',
        // unlock
        unlocked: false,
        unlockCost: 1200,         // Reduced from 1800 for better pacing
  valuePerUnit: 32, level: 0, upgradeCost: 500, baseUpgradeCost: 500, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 20000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:5000, managerUpgradeCost:2500,
  managerSpeedCapPct:0.40
      },
      {
        id: 'seo',
        name: 'SEO Services',
        locationId: 'garage',
        unlocked: false,
        unlockCost: 3000,
        valuePerUnit: 55, level: 0, upgradeCost: 800, baseUpgradeCost: 800, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 25000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:8000, managerUpgradeCost:4000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'branding',
        name: 'Brand Design',
        locationId: 'garage',
        unlocked: false,
        unlockCost: 5000,
        valuePerUnit: 85, level: 0, upgradeCost: 1200, baseUpgradeCost: 1200, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 30000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:12000, managerUpgradeCost:6000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'ecommerce',
        name: 'E-Commerce Store',
        locationId: 'garage',
        unlocked: false,
        unlockCost: 8000,
        valuePerUnit: 130, level: 0, upgradeCost: 1800, baseUpgradeCost: 1800, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 35000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:18000, managerUpgradeCost:9000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'automation',
        name: 'Business Automation',
        locationId: 'garage',
        unlocked: false,
        unlockCost: 12000,
        valuePerUnit: 200, level: 0, upgradeCost: 2500, baseUpgradeCost: 2500, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 40000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:25000, managerUpgradeCost:12500,
        managerSpeedCapPct:0.40
      },
      // HOME OFFICE LOCATION PRODUCTS
      {
        id: 'copywriting',
        name: 'Copywriting Services',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 300, level: 0, upgradeCost: 3500, baseUpgradeCost: 3500, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 35000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:35000, managerUpgradeCost:17500,
        managerSpeedCapPct:0.40
      },
      {
        id: 'video_editing',
        name: 'Video Production',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 20000,
        valuePerUnit: 450, level: 0, upgradeCost: 5000, baseUpgradeCost: 5000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 45000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:50000, managerUpgradeCost:25000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'marketing',
        name: 'Marketing Campaigns',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 35000,
        valuePerUnit: 700, level: 0, upgradeCost: 7500, baseUpgradeCost: 7500, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 50000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:70000, managerUpgradeCost:35000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'consulting_premium',
        name: 'Premium Consulting',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 55000,
        valuePerUnit: 1100, level: 0, upgradeCost: 11000, baseUpgradeCost: 11000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 60000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:100000, managerUpgradeCost:50000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'saas',
        name: 'SaaS Platform',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 85000,
        valuePerUnit: 1700, level: 0, upgradeCost: 16000, baseUpgradeCost: 16000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 70000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:150000, managerUpgradeCost:75000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'virtual_assistant',
        name: 'Virtual Assistant Services',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 120000,
        valuePerUnit: 2500, level: 0, upgradeCost: 24000, baseUpgradeCost: 24000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 75000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:220000, managerUpgradeCost:110000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'social_media_mgmt',
        name: 'Social Media Management',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 180000,
        valuePerUnit: 3800, level: 0, upgradeCost: 36000, baseUpgradeCost: 36000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 80000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:320000, managerUpgradeCost:160000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'online_courses',
        name: 'Online Course Creation',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 250000,
        valuePerUnit: 5700, level: 0, upgradeCost: 52000, baseUpgradeCost: 52000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 85000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:450000, managerUpgradeCost:225000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'business_coaching',
        name: 'Business Coaching',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 350000,
        valuePerUnit: 8500, level: 0, upgradeCost: 75000, baseUpgradeCost: 75000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 90000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:650000, managerUpgradeCost:325000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'digital_marketing',
        name: 'Digital Marketing Agency',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 480000,
        valuePerUnit: 12500, level: 0, upgradeCost: 110000, baseUpgradeCost: 110000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 95000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:900000, managerUpgradeCost:450000,
        managerSpeedCapPct:0.40
      },

      // ============================================
      // OFFICE SUITE LOCATION PRODUCTS
      // ============================================
      {
        id: 'enterprise_saas',
        name: 'Enterprise SaaS Platform',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 18000, level: 0, upgradeCost: 160000, baseUpgradeCost: 160000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 100000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1500000, managerUpgradeCost:750000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'enterprise_software',
        name: 'Enterprise Software Suite',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 700000,
        valuePerUnit: 27000, level: 0, upgradeCost: 240000, baseUpgradeCost: 240000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 105000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:2200000, managerUpgradeCost:1100000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'api_marketplace',
        name: 'API Marketplace',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 1200000,
        valuePerUnit: 41000, level: 0, upgradeCost: 360000, baseUpgradeCost: 360000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 110000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:3300000, managerUpgradeCost:1650000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'white_label',
        name: 'White Label Solutions',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 2000000,
        valuePerUnit: 62000, level: 0, upgradeCost: 540000, baseUpgradeCost: 540000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 115000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:5000000, managerUpgradeCost:2500000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'cybersecurity',
        name: 'Cybersecurity Suite',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 3500000,
        valuePerUnit: 93000, level: 0, upgradeCost: 800000, baseUpgradeCost: 800000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 120000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:7500000, managerUpgradeCost:3750000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'data_analytics',
        name: 'Data Analytics Platform',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 5500000,
        valuePerUnit: 140000, level: 0, upgradeCost: 1200000, baseUpgradeCost: 1200000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 125000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:11000000, managerUpgradeCost:5500000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'crm_system',
        name: 'CRM System',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 8500000,
        valuePerUnit: 210000, level: 0, upgradeCost: 1800000, baseUpgradeCost: 1800000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 130000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:17000000, managerUpgradeCost:8500000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'ai_integration',
        name: 'AI Integration Tools',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 13000000,
        valuePerUnit: 315000, level: 0, upgradeCost: 2700000, baseUpgradeCost: 2700000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 135000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:25000000, managerUpgradeCost:12500000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'blockchain',
        name: 'Blockchain Solutions',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 20000000,
        valuePerUnit: 475000, level: 0, upgradeCost: 4000000, baseUpgradeCost: 4000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 140000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:38000000, managerUpgradeCost:19000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'acquisitions',
        name: 'Corporate Acquisitions',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 30000000,
        valuePerUnit: 710000, level: 0, upgradeCost: 6000000, baseUpgradeCost: 6000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 145000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:55000000, managerUpgradeCost:27500000,
        managerSpeedCapPct:0.40
      },

      // ============================================
      // FACTORY LOCATION PRODUCTS
      // ============================================
      {
        id: 'custom_keychains',
        name: 'Custom Keychains',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 1100000, level: 0, upgradeCost: 9000000, baseUpgradeCost: 9000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 150000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:80000000, managerUpgradeCost:40000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'branded_tshirts',
        name: 'Branded T-Shirts',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 35000000,
        valuePerUnit: 1650000, level: 0, upgradeCost: 13500000, baseUpgradeCost: 13500000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 155000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:120000000, managerUpgradeCost:60000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'phone_cases',
        name: 'Custom Phone Cases',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 60000000,
        valuePerUnit: 2475000, level: 0, upgradeCost: 20000000, baseUpgradeCost: 20000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 160000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:180000000, managerUpgradeCost:90000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'desk_toys',
        name: 'Executive Desk Toys',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 100000000,
        valuePerUnit: 3713000, level: 0, upgradeCost: 30000000, baseUpgradeCost: 30000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 165000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:270000000, managerUpgradeCost:135000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'logo_stickers',
        name: 'Logo Sticker Sheets',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 170000000,
        valuePerUnit: 5570000, level: 0, upgradeCost: 45000000, baseUpgradeCost: 45000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 170000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:400000000, managerUpgradeCost:200000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'promo_mugs',
        name: 'Promotional Mugs',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 280000000,
        valuePerUnit: 8355000, level: 0, upgradeCost: 67500000, baseUpgradeCost: 67500000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 175000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:600000000, managerUpgradeCost:300000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'tech_accessories',
        name: 'Tech Accessories Line',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 450000000,
        valuePerUnit: 12533000, level: 0, upgradeCost: 100000000, baseUpgradeCost: 100000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 180000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:900000000, managerUpgradeCost:450000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'furniture_line',
        name: 'Office Furniture Line',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 750000000,
        valuePerUnit: 18800000, level: 0, upgradeCost: 150000000, baseUpgradeCost: 150000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 185000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1350000000, managerUpgradeCost:675000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'vehicle_manufacturing',
        name: 'Vehicle Manufacturing',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 1200000000,
        valuePerUnit: 28200000, level: 0, upgradeCost: 225000000, baseUpgradeCost: 225000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 190000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:2000000000, managerUpgradeCost:1000000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'smart_home',
        name: 'Smart Home Devices',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 2000000000,
        valuePerUnit: 42300000, level: 0, upgradeCost: 337500000, baseUpgradeCost: 337500000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 195000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:3000000000, managerUpgradeCost:1500000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'robotics',
        name: 'Robotics Division',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 3200000000,
        valuePerUnit: 63450000, level: 0, upgradeCost: 500000000, baseUpgradeCost: 500000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 200000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:4500000000, managerUpgradeCost:2250000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'aerospace',
        name: 'Aerospace Parts',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 5000000000,
        valuePerUnit: 95175000, level: 0, upgradeCost: 750000000, baseUpgradeCost: 750000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 205000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:6750000000, managerUpgradeCost:3375000000,
        managerSpeedCapPct:0.40
      },

      // ============================================
      // R&D LAB LOCATION PRODUCTS
      // ============================================
      {
        id: 'patents',
        name: 'Patent Applications',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 143000000, level: 0, upgradeCost: 1125000000, baseUpgradeCost: 1125000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 210000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:10000000000, managerUpgradeCost:5000000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'prototypes',
        name: 'Prototype Development',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 7000000000,
        valuePerUnit: 215000000, level: 0, upgradeCost: 1687500000, baseUpgradeCost: 1687500000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 215000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:15000000000, managerUpgradeCost:7500000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'genetic_research',
        name: 'Genetic Research',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 12000000000,
        valuePerUnit: 323000000, level: 0, upgradeCost: 2531250000, baseUpgradeCost: 2531250000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 220000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:22500000000, managerUpgradeCost:11250000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'quantum_computing',
        name: 'Quantum Computing',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 20000000000,
        valuePerUnit: 485000000, level: 0, upgradeCost: 3796875000, baseUpgradeCost: 3796875000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 225000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:33750000000, managerUpgradeCost:16875000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'neural_implants',
        name: 'Neural Implants',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 33000000000,
        valuePerUnit: 728000000, level: 0, upgradeCost: 5695312500, baseUpgradeCost: 5695312500, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 230000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:50625000000, managerUpgradeCost:25312500000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'cloning',
        name: 'Cloning Technology',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 55000000000,
        valuePerUnit: 1092000000, level: 0, upgradeCost: 8542968750, baseUpgradeCost: 8542968750, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 235000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:75937500000, managerUpgradeCost:37968750000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'time_dilation',
        name: 'Time Dilation Studies',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 90000000000,
        valuePerUnit: 1638000000, level: 0, upgradeCost: 12814453125, baseUpgradeCost: 12814453125, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 240000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:113906250000, managerUpgradeCost:56953125000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'dimensional_travel',
        name: 'Dimensional Travel',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 145000000000,
        valuePerUnit: 2457000000, level: 0, upgradeCost: 19221679688, baseUpgradeCost: 19221679688, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 245000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:170859375000, managerUpgradeCost:85429687500,
        managerSpeedCapPct:0.40
      },
      {
        id: 'consciousness_upload',
        name: 'Consciousness Upload',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 235000000000,
        valuePerUnit: 3686000000, level: 0, upgradeCost: 28832519531, baseUpgradeCost: 28832519531, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 250000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:256289062500, managerUpgradeCost:128144531250,
        managerSpeedCapPct:0.40
      },
      {
        id: 'reality_hacking',
        name: 'Reality Hacking',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 380000000000,
        valuePerUnit: 5529000000, level: 0, upgradeCost: 43248779297, baseUpgradeCost: 43248779297, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 255000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:384433593750, managerUpgradeCost:192216796875,
        managerSpeedCapPct:0.40
      },

      // ============================================
      // CREATIVE STUDIO LOCATION PRODUCTS (NSFW LEVEL 1 - Suggestive)
      // ============================================
      {
        id: 'glamour_photography',
        name: 'Glamour Photography',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 8294000000, level: 0, upgradeCost: 64872000000, baseUpgradeCost: 64872000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 260000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:576650000000, managerUpgradeCost:288325000000,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'instagram_modeling',
        name: 'Instagram Modeling',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 650000000000,
        valuePerUnit: 12441000000, level: 0, upgradeCost: 97308000000, baseUpgradeCost: 97308000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 265000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:864975000000, managerUpgradeCost:432487500000,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'boudoir_sessions',
        name: 'Boudoir Sessions',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 1100000000000,
        valuePerUnit: 18662000000, level: 0, upgradeCost: 145962000000, baseUpgradeCost: 145962000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 270000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1297462500000, managerUpgradeCost:648731250000,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'artistic_nudes',
        name: '"Artistic" Nude Photography',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 1900000000000,
        valuePerUnit: 27993000000, level: 0, upgradeCost: 218943000000, baseUpgradeCost: 218943000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 275000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1946193750000, managerUpgradeCost:973096875000,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'premium_snapchat',
        name: 'Premium Snapchat Management',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 3100000000000,
        valuePerUnit: 41990000000, level: 0, upgradeCost: 328414000000, baseUpgradeCost: 328414000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 280000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:2919290625000, managerUpgradeCost:1459645312500,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'spicy_patreon',
        name: 'Spicy Patreon Tiers',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 5200000000000,
        valuePerUnit: 62985000000, level: 0, upgradeCost: 492621000000, baseUpgradeCost: 492621000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 285000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:4378935937500, managerUpgradeCost:2189467968750,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'amateur_videography',
        name: 'Amateur Content Videography',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 8500000000000,
        valuePerUnit: 94478000000, level: 0, upgradeCost: 738931500000, baseUpgradeCost: 738931500000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 290000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:6568403906250, managerUpgradeCost:3284201953125,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'cam_show_production',
        name: 'Cam Show Production Studio',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 14000000000000,
        valuePerUnit: 141717000000, level: 0, upgradeCost: 1108397250000, baseUpgradeCost: 1108397250000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 295000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:9852605859375, managerUpgradeCost:4926302929687,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'adult_platform',
        name: 'Adult Content Platform',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 23000000000000,
        valuePerUnit: 212576000000, level: 0, upgradeCost: 1662595875000, baseUpgradeCost: 1662595875000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 300000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:14778908789062, managerUpgradeCost:7389454394531,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'erotic_audio',
        name: 'Erotic Audio Stories',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 38000000000000,
        valuePerUnit: 318864000000, level: 0, upgradeCost: 2493893812500, baseUpgradeCost: 2493893812500, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 305000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:22168363183594, managerUpgradeCost:11084181591797,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'custom_fetish',
        name: 'Custom Fetish Content',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 62000000000000,
        valuePerUnit: 478296000000, level: 0, upgradeCost: 3740840718750, baseUpgradeCost: 3740840718750, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 310000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:33252544775391, managerUpgradeCost:16626272387695,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'adult_film_studio',
        name: 'Full Adult Film Studio',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 100000000000000,
        valuePerUnit: 717444000000, level: 0, upgradeCost: 5611261078125, baseUpgradeCost: 5611261078125, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 315000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:49878817163086, managerUpgradeCost:24939408581543,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },

      // ============================================
      // PRIVATE CLUB LOCATION PRODUCTS (NSFW LEVEL 2 - Explicit)
      // ============================================
      {
        id: 'vip_bottle_service',
        name: 'VIP Bottle Service',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 1076166000000, level: 0, upgradeCost: 8416891617188, baseUpgradeCost: 8416891617188, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 320000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:74818225744629, managerUpgradeCost:37409112872314,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'private_dances',
        name: 'Private Dance Bookings',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 70000000000000,
        valuePerUnit: 1614249000000, level: 0, upgradeCost: 12625337425781, baseUpgradeCost: 12625337425781, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 325000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:112227338616943, managerUpgradeCost:56113669308471,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'companionship',
        name: 'Companionship Services',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 120000000000000,
        valuePerUnit: 2421374000000, level: 0, upgradeCost: 18938006138672, baseUpgradeCost: 18938006138672, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 330000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:168341007925415, managerUpgradeCost:84170503962707,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'executive_relief',
        name: 'Executive Stress Relief',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 200000000000000,
        valuePerUnit: 3632061000000, level: 0, upgradeCost: 28407009208008, baseUpgradeCost: 28407009208008, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 335000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:252511511888123, managerUpgradeCost:126255755944061,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'private_rooms',
        name: 'Private Room Rentals',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 330000000000000,
        valuePerUnit: 5448092000000, level: 0, upgradeCost: 42610513812012, baseUpgradeCost: 42610513812012, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 340000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:378767267832184, managerUpgradeCost:189383633916092,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'escort_network',
        name: 'Elite Escort Network',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 550000000000000,
        valuePerUnit: 8172138000000, level: 0, upgradeCost: 63915770718018, baseUpgradeCost: 63915770718018, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 345000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:568150901748276, managerUpgradeCost:284075450874138,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'fetish_club',
        name: 'Fetish Club Events',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 900000000000000,
        valuePerUnit: 12258207000000, level: 0, upgradeCost: 95873656077027, baseUpgradeCost: 95873656077027, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 350000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:852226352622414, managerUpgradeCost:426113176311207,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'sugar_baby_agency',
        name: 'Sugar Baby Arrangements',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 1500000000000000,
        valuePerUnit: 18387311000000, level: 0, upgradeCost: 143810484115541, baseUpgradeCost: 143810484115541, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 355000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1278339528933621, managerUpgradeCost:639169764466810,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'bachelor_party_extreme',
        name: 'Bachelor Party Packages',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 2400000000000000,
        valuePerUnit: 27580967000000, level: 0, upgradeCost: 215715726173311, baseUpgradeCost: 215715726173311, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 360000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1917509293400432, managerUpgradeCost:958754646700216,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'luxury_brothel',
        name: 'Luxury Brothel Chain',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 4000000000000000,
        valuePerUnit: 41371451000000, level: 0, upgradeCost: 323573589259967, baseUpgradeCost: 323573589259967, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 365000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:2876263940100648, managerUpgradeCost:1438131970050324,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'sex_tourism',
        name: 'Sex Tourism Operations',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 6500000000000000,
        valuePerUnit: 62057177000000, level: 0, upgradeCost: 485360383889950, baseUpgradeCost: 485360383889950, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 370000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:4314395910150972, managerUpgradeCost:2157197955075486,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'vice_network',
        name: 'Global Vice Network',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 10500000000000000,
        valuePerUnit: 93085766000000, level: 0, upgradeCost: 728040575834925, baseUpgradeCost: 728040575834925, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 375000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:6471593865226458, managerUpgradeCost:3235796932613229,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },

      // ============================================
      // VELVET ROOM LOCATION PRODUCTS (NSFW LEVEL 3 - Depraved)
      // ============================================
      {
        id: 'secret_society',
        name: 'Secret Society Memberships',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 139628649000000, level: 0, upgradeCost: 1092060863752388, baseUpgradeCost: 1092060863752388, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 380000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:9707390797839687, managerUpgradeCost:4853695398919843,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'blackmail_archives',
        name: 'Blackmail Insurance Archives',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 13000000000000000,
        valuePerUnit: 209442974000000, level: 0, upgradeCost: 1638091295628582, baseUpgradeCost: 1638091295628582, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 385000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:14561086196759531, managerUpgradeCost:7280543098379765,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'private_island',
        name: 'Private Island Retreat Access',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 22000000000000000,
        valuePerUnit: 314164461000000, level: 0, upgradeCost: 2457136943442873, baseUpgradeCost: 2457136943442873, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 390000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:21841629295139297, managerUpgradeCost:10920814647569648,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'compromising_material',
        name: 'Compromising Material Collection',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 36000000000000000,
        valuePerUnit: 471246692000000, level: 0, upgradeCost: 3685705415164310, baseUpgradeCost: 3685705415164310, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 395000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:32762443942708945, managerUpgradeCost:16381221971354472,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'special_requests',
        name: '"Special Request" Fulfillment',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 60000000000000000,
        valuePerUnit: 706870038000000, level: 0, upgradeCost: 5528558122746465, baseUpgradeCost: 5528558122746465, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 400000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:49143665914063418, managerUpgradeCost:24571832957031709,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'underground_auctions',
        name: 'Underground Auction Access',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 98000000000000000,
        valuePerUnit: 1060305057000000, level: 0, upgradeCost: 8292837184119697, baseUpgradeCost: 8292837184119697, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 405000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:73715498871095127, managerUpgradeCost:36857749435547563,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'influence_peddling',
        name: 'Influence Peddling Services',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 160000000000000000,
        valuePerUnit: 1590457586000000, level: 0, upgradeCost: 12439255776179546, baseUpgradeCost: 12439255776179546, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 410000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:110573248306642691, managerUpgradeCost:55286624153321345,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'political_puppets',
        name: 'Political Puppet Strings',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 260000000000000000,
        valuePerUnit: 2385686379000000, level: 0, upgradeCost: 18658883664269319, baseUpgradeCost: 18658883664269319, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 415000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:165859872459964036, managerUpgradeCost:82929936229982018,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'occult_rituals',
        name: 'Occult Ritual Hosting',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 430000000000000000,
        valuePerUnit: 3578529569000000, level: 0, upgradeCost: 27988325496403978, baseUpgradeCost: 27988325496403978, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 420000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:248789808689946054, managerUpgradeCost:124394904344973027,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'mind_control',
        name: 'Mind Control Research',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 700000000000000000,
        valuePerUnit: 5367794354000000, level: 0, upgradeCost: 41982488244605968, baseUpgradeCost: 41982488244605968, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 425000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:373184713034919081, managerUpgradeCost:186592356517459540,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'blood_oaths',
        name: 'Blood Oath Contracts',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 1150000000000000000,
        valuePerUnit: 8051691531000000, level: 0, upgradeCost: 62973732366908952, baseUpgradeCost: 62973732366908952, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 430000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:559777069552378621, managerUpgradeCost:279888534776189310,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'forbidden_desires',
        name: 'Forbidden Desires Catalog',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 1900000000000000000,
        valuePerUnit: 12077537297000000, level: 0, upgradeCost: 94460598550363428, baseUpgradeCost: 94460598550363428, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 435000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:839665604328567932, managerUpgradeCost:419832802164283966,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },

      // ============================================
      // INNER SANCTUM LOCATION PRODUCTS (NSFW LEVEL 4 - Endgame Horror)
      // ============================================
      {
        id: 'human_trafficking',
        name: 'Human Trafficking Networks',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 18116305946000000, level: 0, upgradeCost: 141690897825545142, baseUpgradeCost: 141690897825545142, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 440000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1259498406492851899, managerUpgradeCost:629749203246425949,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'organ_market',
        name: 'Organ Market Pipeline',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 2500000000000000000,
        valuePerUnit: 27174458919000000, level: 0, upgradeCost: 212536346738317713, baseUpgradeCost: 212536346738317713, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 445000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1889247609739277848, managerUpgradeCost:944623804869638924,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'assassinations',
        name: 'Assassination Contracts',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 4200000000000000000,
        valuePerUnit: 40761688379000000, level: 0, upgradeCost: 318804520107476570, baseUpgradeCost: 318804520107476570, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 450000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:2833871414608916772, managerUpgradeCost:1416935707304458386,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'govt_overthrow',
        name: 'Government Overthrow Operations',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 6800000000000000000,
        valuePerUnit: 61142532569000000, level: 0, upgradeCost: 478206780161214855, baseUpgradeCost: 478206780161214855, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 455000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:4250807121913375158, managerUpgradeCost:2125403560956687579,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'hostile_takeovers',
        name: 'Corporate Hostile Takeovers',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 11000000000000000000,
        valuePerUnit: 91713798854000000, level: 0, upgradeCost: 717310170241822282, baseUpgradeCost: 717310170241822282, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 460000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:6376210682870062737, managerUpgradeCost:3188105341435031368,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'torture_entertainment',
        name: 'Torture Entertainment Venues',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 18000000000000000000,
        valuePerUnit: 137570698281000000, level: 0, upgradeCost: 1075965255362733423, baseUpgradeCost: 1075965255362733423, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 465000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:9564316024305094106, managerUpgradeCost:4782158012152547053,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'doomsday_cult',
        name: 'Doomsday Cult Leadership',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 29000000000000000000,
        valuePerUnit: 206356047422000000, level: 0, upgradeCost: 1613947883044100135, baseUpgradeCost: 1613947883044100135, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 470000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:14346474036457641159, managerUpgradeCost:7173237018228820579,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'reality_manipulation',
        name: 'Reality Manipulation Technology',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 48000000000000000000,
        valuePerUnit: 309534071133000000, level: 0, upgradeCost: 2420921824566150202, baseUpgradeCost: 2420921824566150202, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 475000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:21519711054686461738, managerUpgradeCost:10759855527343230869,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'eldritch_summoning',
        name: 'Eldritch Entity Summoning',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 78000000000000000000,
        valuePerUnit: 464301106700000000, level: 0, upgradeCost: 3631382736849225303, baseUpgradeCost: 3631382736849225303, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 480000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:32279566582029692607, managerUpgradeCost:16139783291014846303,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'multiverse_domination',
        name: 'Multiverse Domination',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 127000000000000000000,
        valuePerUnit: 696451660050000000, level: 0, upgradeCost: 5447074105273837955, baseUpgradeCost: 5447074105273837955, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 485000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:48419349873044538910, managerUpgradeCost:24209674936522269455,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'god_emperor',
        name: 'Become God-Emperor',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 205000000000000000000,
        valuePerUnit: 1044677490075000000, level: 0, upgradeCost: 8170611157910756932, baseUpgradeCost: 8170611157910756932, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 490000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:72629024809566808365, managerUpgradeCost:36314512404783404182,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'consume_reality',
        name: 'Consume Reality Itself',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 330000000000000000000,
        valuePerUnit: 1567016235113000000, level: 0, upgradeCost: 12255916736866135398, baseUpgradeCost: 12255916736866135398, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 495000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:108943537214350212547, managerUpgradeCost:54471768607175106273,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      }
    ],
    employees: [],
    
    // ========== MEETINGS / GROUP CHATS SYSTEM ==========
    meetings: [],
    meetingSettings: {
      maxParticipants: 5,              // Max NPCs (player is +1 = 6 total)
      defaultReplyLimit: 5,            // Default max replies per player message
      intelligentPriority: true,       // Use AI to determine speaking order
      perspectiveMode: true            // NPCs have different knowledge/perspectives
    },
    
    // ========== CORPORATE HIERARCHY SYSTEM ==========
    // 8-level corporate structure from Entry to Executive
    hierarchyLevels: {
      1: {
        title: "Staff",
        baseSalary: 40000,
        productBonusPercent: 2,
        color: "#4ecca3",
        icon: "ï¿½",
        canManage: false,
        description: "Product Workers - manage individual products"
      },
      2: {
        title: "Local Manager",
        baseSalary: 52500,
        productBonusPercent: 3,
        color: "#00d4ff",
        icon: "ğŸ‘¨â€ï¿½",
        canManage: true,
        description: "Supervise 4-6 Staff members"
      },
      3: {
        title: "Regional Manager",
        baseSalary: 70000,
        productBonusPercent: 5,
        color: "#ffd700",
        icon: "ğŸ¯",
        canManage: true,
        description: "Oversee a location's operations"
      },
      4: {
        title: "Branch Manager",
        baseSalary: 95000,
        productBonusPercent: 8,
        color: "#ff6b9d",
        icon: "ï¿½",
        canManage: true,
        description: "Manage multiple Regional Managers"
      },
      5: {
        title: "CFO / COO",
        baseSalary: 140000,
        productBonusPercent: 12,
        color: "#c77dff",
        icon: "ï¿½",
        canManage: true,
        description: "Chief Financial Officer or Chief Operating Officer"
      },
      6: {
        title: "Senior Executive",
        baseSalary: 180000,
        productBonusPercent: 15,
        color: "#9d4edd",
        icon: "â­",
        canManage: true,
        description: "Second-in-command to the CEO"
      },
      7: {
        title: "CEO",
        baseSalary: 250000,
        productBonusPercent: 20,
        color: "#e94560",
        icon: "ï¿½",
        canManage: true,
        description: "Chief Executive Officer - top of the pyramid"
      }
    },
    
    // Corporate hierarchy tracking
    corporateHierarchy: {
      levels: {
        1: [], // Array of employee IDs at this level
        2: [],
        3: [],
        4: [],
        5: [],
        6: [],
        7: []
      },
      executiveRoles: {
        COO: null,  // Employee ID or null
        CFO: null
      }
    },
    
    // Corporate Pyramid Structure (True Hierarchical Org Chart)
    corporatePyramid: {
      // CEO position (player - Level 7)
      ceo: {
        positionId: 'ceo',
        title: 'CEO',
        level: 7,
        employeeId: 'player',
        subordinates: [], // IDs of direct reports (Senior Executive)
        isPlayer: true
      },
      
      // Secretary position - Reports directly to CEO, no subordinates
      secretaryPosition: {
        positionId: 'secretary',
        title: 'Executive Secretary',
        level: 6.5, // Between CEO and Senior Executive
        employeeId: null,
        reportsTo: 'ceo',
        subordinates: []
      },
      
      // Hierarchical positions (organized by level, not products)
      positions: {
        // Level 6: Senior Executive (1 total) - Reports to CEO
        6: [
          {
            positionId: 'senior_exec',
            title: 'Senior Executive',
            level: 6,
            employeeId: null,
            reportsTo: 'ceo',
            subordinates: [], // CFO, COO
            span: 2 // Should manage 2 officers
          }
        ],
        
        // Level 5: Officers (2 total: CFO, COO) - Report to Senior Executive
        5: [
          {
            positionId: 'cfo',
            title: 'Chief Financial Officer',
            level: 5,
            employeeId: null,
            reportsTo: 'senior_exec',
            subordinates: [], // 2 Branch Managers
            span: 2
          },
          {
            positionId: 'coo',
            title: 'Chief Operating Officer',
            level: 5,
            employeeId: null,
            reportsTo: 'senior_exec',
            subordinates: [], // 2 Branch Managers
            span: 2
          }
        ],
        
        // Level 4: Branch Managers (4 total) - Report to CFO/COO
        4: [
          { positionId: 'branch_mgr_1', title: 'Branch Manager 1', level: 4, employeeId: null, reportsTo: 'cfo', subordinates: [], locationsManaged: [], span: 3 },
          { positionId: 'branch_mgr_2', title: 'Branch Manager 2', level: 4, employeeId: null, reportsTo: 'cfo', subordinates: [], locationsManaged: [], span: 3 },
          { positionId: 'branch_mgr_3', title: 'Branch Manager 3', level: 4, employeeId: null, reportsTo: 'coo', subordinates: [], locationsManaged: [], span: 2 },
          { positionId: 'branch_mgr_4', title: 'Branch Manager 4', level: 4, employeeId: null, reportsTo: 'coo', subordinates: [], locationsManaged: [], span: 1 }
        ],
        
        // Level 3: Regional Managers (9 total, 1 per location) - Report to Branch Managers
        3: [], // Will be populated as locations unlock
        
        // Level 2: Local Managers (2-3 per location, ~20 total) - Report to Regional Managers
        2: [], // Will be populated as locations unlock and products expand
        
        // Level 1: Staff (1 per product, ~90 total) - Report to Local Managers
        1: [] // Will be populated dynamically as products are unlocked
      },
      
      // Relocation/promotion costs by level
      promotionCosts: {
        1: 500,      // Staff
        2: 2000,     // Local Manager
        3: 10000,    // Regional Manager
        4: 50000,    // Branch Manager
        5: 150000,   // Officer (CFO/COO)
        6: 500000,   // Senior Executive
        7: 0         // CEO (player only)
      }
    },
    
    // Rehire pool (preserved employees after prestige)
    rehirePool: [],
    
    // Currently displayed hiring candidates
    currentHiringCandidates: {
      newHires: [],
      rehires: [],
      productId: null,
      activeTab: 'newHires'
    },
    
    // Global income multiplier (affected by executives)
    globalIncomeMultiplier: 1.0,
    
    gifts: [
      { id: 'coffee', name: 'Coffee', cost: 10, effect: { productivity: 5 }, description: 'Boosts productivity' },
      { id: 'giftcard', name: 'Gift Card', cost: 50, effect: { affection: 10 }, description: 'Increases affection' },
      { id: 'lunch', name: 'Lunch', cost: 30, effect: { comfort: 15 }, description: 'Improves comfort' },
      { id: 'bonus', name: 'Cash Bonus', cost: 100, effect: { desire: 20 }, description: 'Raises desire' }
    ],
    news: [
      "Tech startup raises $1M in seed funding",
      "New productivity app trends in office spaces",
      "Remote work policies reshape company cultures",
      "AI integration boosts efficiency across industries"
    ],
    settings: {
      autosave: true,
      uiDensity: 50,
      atmosphere: 50,
      guidelines: 50,
      policy: 'professional',
      playerBio: '', // DEPRECATED: Replaced by playerProfile object
      imageStyle: 'photorealistic', // Global image generation style
      maxAiRequests: 15, // Max concurrent AI text generation requests
      
      // UI Customization (PC only - mobile ignores these)
      chatWidth: 500,        // Chat window width in pixels (300-800)
      chatHeight: 80,        // Chat window height in percent (50-95)
      textSize: 100,         // Text size percentage (70-150)
      imagePreviewSize: 300  // Image preview max width in pixels (200-600)
    },
    
    // Player Profile (detailed information about the player character)
    playerProfile: {
      // Basic Info
      firstName: '',
      lastName: '',
      age: null,
      gender: '',
      
      // Physical Description
      ethnicity: '',
      skinTone: '',
      height: '',
      bodyType: '',
      hairColor: '',
      hairStyle: '',
      eyeColor: '',
      facialHair: '',
      
      // Intimate Details
      genitalType: '',
      genitalDetails: '',
      chestSize: '',
      buildDetails: '',
      
      // Additional
      additionalDetails: '',
      personality: ''
    },
    
    // AUTOSAVE TRACKING (for snapshot rotation system)
    autosaveTracking: {
      lastSnapshotTime: Date.now(),
      currentSlotIndex: 0,
      snapshotIntervalMinutes: 5 // Can be adjusted: 5-10 minutes
    },
    
    // GENDER DIVERSITY SETTINGS
    genderSettings: {
      female: 100,        // Default: 100% female
      male: 0,
      femaleFuta: 0,
      transMan: 0,
      transWoman: 0
    },
    
    // RACE/SPECIES DIVERSITY SETTINGS (Fantasy races)
    raceSettings: {
      human: 100,        // Default: 100% human
      elf: 0,
      orc: 0,
      demon: 0,
      fox: 0,
      wolf: 0,
      cat: 0,
      rabbit: 0
    },
    
    activeTab: 'dashboard',
    activeLocationId: 'garage', // Currently selected location subtab
    upgradeMultiplier: 1, // Bulk upgrade multiplier (1, 5, 10, 100, or 'max')
    activeChat: null,
    chatHistory: {},
    typingStates: {}, // Track which NPCs are currently generating responses { employeeId: true/false }
    
    // ========== AI CONTEXT QUALITY SYSTEM ==========
    // Tracks repetition and enforces variety in AI responses
    aiContextQuality: {
      // Per-employee repetition tracking (last 3 responses)
      employeeTracking: {}, // { employeeId: { physicalActions: [], narrativeAnchors: [], sensoryWords: [], responseStructures: [] } }
      
      // Global vocabulary expansion databases
      vocabularyBanks: {
        // Physical response alternatives
        arousal: ['shivering', 'trembling', 'quivering', 'shuddering', 'quaking', 'tingling', 'prickling', 'buzzing', 'pulsing', 'throbbing'],
        spinalReactions: ['arching back', 'spine curving', 'back bowing', 'body lifting', 'hips rising', 'chest pressing forward', 'shoulders rolling back', 'torso twisting'],
        handActions: ['fingers tangling in hair', 'nails digging into skin', 'palms pressing flat', 'hands gripping shoulders', 'fingertips tracing lines', 'knuckles brushing cheeks', 'thumbs caressing jawlines', 'hands sliding down backs'],
        legMovements: ['legs hooking around waist', 'ankles locking behind back', 'thighs tightening', 'knees pressing together', 'feet curling', 'toes pointing', 'legs spreading', 'hips rolling'],
        breathPatterns: ['breath hitching', 'gasping sharply', 'exhaling shakily', 'breathing raggedly', 'panting softly', 'sighing deeply', 'air catching in throat', 'breathing stuttering'],
        
        // Temperature/sensation descriptors
        temperature: ['scorching', 'feverish', 'cool', 'electric', 'searing', 'blazing', 'icy', 'molten', 'frigid', 'white-hot'],
        texture: ['velvet-soft', 'rough', 'silk-smooth', 'calloused', 'scratchy', 'downy', 'coarse', 'plush', 'bristly', 'satiny'],
        
        // Sound descriptors  
        vocalSounds: ['whimper', 'groan', 'moan', 'sigh', 'gasp', 'cry out', 'murmur', 'whisper', 'breathe words', 'choke out'],
        
        // Movement quality
        movementQuality: ['fluid', 'jerky', 'languid', 'urgent', 'hesitant', 'assured', 'graceful', 'clumsy', 'deliberate', 'frantic']
      },
      
      // Escalation tracking for tonal shifts
      intimacyEscalation: {}, // { employeeId: currentLevel (0-10) }
      
      // Settings
      repetitionWindow: 3, // Check last 3 responses for repetition
      maxSameAction: 1, // Max times same action can appear in window
      maxSameAnchor: 2, // Max times same narrative anchor (Buddy, scar, etc.) in window
    },
    
    // ========== SOCIAL NETWORK SYSTEM ==========
    socialNetwork: {
      posts: [], // Array of all posts in the feed
      globalEvents: [], // Company-wide events that can trigger posts
      postIdCounter: 0, // Incrementing ID for posts
      lastPostGeneration: 0, // Timestamp of last autonomous post generation
      postGenerationInterval: 300000, // 5 minutes between autonomous post checks (in ms)
      
      // THE ALGORITHMâ„¢ - Advanced filtering/sorting
      algorithm: {
        sort: 'hot',           // 'hot', 'best', 'recent', 'controversial'
        bestTimeFrame: 'all',  // 'hour', 'day', 'week', 'month', 'all'
        contentRating: 'all',  // 'all', 'sfw', 'nsfw', 'explicit'
        postType: 'all',       // 'all', 'text', 'image', 'selfie', 'work'
        author: 'all',         // 'all', 'player', 'following', or specific employeeId
        engagement: 'all',     // 'all', 'popular', 'viral', 'active'
        searchQuery: ''        // Search string
      },
      
      // Content variety tracking (prevent repetition)
      recentPostTypes: [], // Track last 20 post types to ensure variety
      
      // Player post drafts
      playerDraft: {
        caption: '',
        imagePrompt: '',
        altText: '',
        imageUrl: null
      }
    },
    
    // AI QUALITY TRAINING SYSTEM (RLHF)
    aiQuality: {
      // Training datasets
      goodExamples: {
        posts: [],     // Upvoted posts
        comments: [],  // Upvoted comments
        chats: []      // Upvoted chat messages
      },
      badExamples: {
        posts: [],     // Downvoted posts
        comments: [],  // Downvoted comments
        chats: []      // Downvoted chat messages
      },
      
      // Learned patterns to avoid
      bannedPatterns: [],
      
      // Stats tracking
      stats: {
        totalVotes: 0,
        upvotes: 0,
        downvotes: 0,
        postsVoted: 0,
        commentsVoted: 0,
        chatsVoted: 0
      },
      
      // Configuration
      maxExamplesPerType: 20,  // Keep best 20 of each
      tutorialShown: false     // First-time tutorial
    },
    
    // Company-wide awareness data
    companyContext: {
      totalEmployees: 0, // Auto-calculated
      locationEmployeeCounts: {}, // { locationId: count }
      recentHires: [], // Last 5 hires
      recentFires: [], // Last 5 fires with alumni status
      recentPromotions: [], // Last 10 promotions
      interdepartmentalEvents: [] // Cross-location events (competitions, collaborations, etc.)
    },
    
    // Company-Wide Context - "Public Knowledge" that everyone knows
    companyWideContext: {
      currentBuzz: [], // Array of hot topics/gossip that's common knowledge (max 40 items)
      lastUpdate: Date.now(),
      maxItems: 40, // Keep only the juiciest/most recent items
      decayTime: 604800000 // 7 days - old info gets trimmed
    },
    
    // ========== FLAG DETECTION SYSTEM ==========
    flagDetection: {
      // Track keyword occurrences per employee
      tracking: {}, // { "emp_123": { "free_use": { count: 2, contexts: [...], lastSeen: timestamp } } }
      
      // Suggested flags awaiting player approval
      suggestions: [], // [{ id, employeeId, employeeName, flag, contexts, suggestedAt, status }]
      
      // Settings
      settings: {
        enabled: true,
        sensitivity: 'medium', // 'low', 'medium', 'high'
        autoApprove: [] // Flag keys that auto-approve without player confirmation
      }
    },
    
    // FLAG CHAINS SYSTEM - Automatic flag progression based on time/events
    flagChains: {
      // Active chains being tracked
      active: [], // [{ employeeId, chainType, startDate, metadata: {...} }]
      
      // Pending suggestions for player approval
      suggestions: [], // [{ id, employeeId, chainType, suggestedFlag, reason, timestamp, status }]
      
      // Chain definitions
      definitions: {
        // AUTO-APPLY CHAINS (natural progressions, no player input needed)
        pregnancy: {
          type: 'auto',
          stages: [
            { flag: 'pregnant', duration: null }, // Until due date
            { flag: 'lactating', duration: 30 }, // 30 game days
            { flag: 'postpartum', duration: 3 } // 3 game days (unrealistic, fast recovery)
          ]
        },
        
        in_heat_duration: {
          type: 'auto',
          trigger: 'in_heat',
          description: 'In heat is a temporary condition',
          action: 'remove',
          duration: 5 // Remove after 5 game days
        },
        
        chastity_to_heat: {
          type: 'auto',
          trigger: 'chastity',
          description: 'Extended chastity causes in_heat condition',
          action: 'add',
          duration: 7, // After 7 days in chastity
          addFlag: 'in_heat'
        },
        
        // SUGGESTED CHAINS (require player approval for relationship/dynamic changes)
        relationship_progression: {
          type: 'suggest',
          stages: [
            { 
              from: 'in_relationship', 
              to: 'engaged_to_player', 
              duration: 30, 
              description: 'Your relationship has deepened. {name} might be ready for engagement.',
              requiresApproval: true
            },
            { 
              from: 'engaged_to_player', 
              to: 'married_to_player', 
              duration: 21, 
              description: '{name} has been engaged for a while. Time to tie the knot?',
              requiresApproval: true
            }
          ]
        },
        
        secret_revealed: {
          type: 'suggest',
          trigger: 'secret_relationship',
          duration: 14,
          description: 'Your secret relationship with {name} has lasted {days} days. Make it official?',
          suggestFlag: 'in_relationship',
          requiresApproval: true
        },
        
        ds_progression: {
          type: 'suggest',
          stages: [
            { 
              from: 'submissive', 
              to: 'collared', 
              duration: 14, 
              description: '{name}\'s submission has been consistent. Formalize it with a collar?',
              requiresApproval: true
            },
            { 
              from: 'collared', 
              to: 'ownership_dynamic', 
              duration: 21, 
              description: '{name} has worn your collar devotedly. Deepen the ownership dynamic?',
              requiresApproval: true
            },
            { 
              from: 'ownership_dynamic', 
              to: '24_7_dynamic', 
              duration: 30, 
              description: '{name} belongs to you completely. Establish a 24/7 lifestyle dynamic?',
              requiresApproval: true
            }
          ]
        },
        
        pet_to_collar: {
          type: 'suggest',
          trigger: 'pet_play',
          duration: 14,
          description: '{name} loves being your pet. Give them a collar to wear?',
          suggestFlag: 'collared',
          requiresApproval: true
        },
        
        free_use_escalation: {
          type: 'suggest',
          trigger: 'free_use',
          duration: 21,
          description: '{name} has been free use for {days} days. Expand to public use?',
          suggestFlag: 'public_use',
          requiresApproval: true
        },
        
        nudity_formalization: {
          type: 'suggest',
          trigger: 'no_clothes',
          duration: 14,
          description: '{name} has been working naked for {days} days. Make it permanent?',
          suggestFlag: 'permanently_nude',
          requiresApproval: true
        },
        
        exhibitionist_escalation: {
          type: 'suggest',
          trigger: 'exhibitionist',
          duration: 14,
          description: '{name}\'s exhibitionism is growing. Suggest permanent nudity?',
          suggestFlag: 'permanently_nude',
          requiresApproval: true
        },
        
        corruption_breaking: {
          type: 'suggest',
          trigger: 'corruption_level_high',
          duration: 30,
          description: '{name}\'s corruption is extreme. Push them to mind_broken?',
          suggestFlag: 'mind_broken',
          requiresApproval: true,
          additionalConditions: ['intimacy > 70'] // High intimacy required
        },
        
        // LOW PRIORITY / NICHE CHAINS
        breeding_progression: {
          type: 'suggest',
          stages: [
            {
              from: 'breeding_kink',
              to: 'impregnation_fetish',
              duration: 21,
              description: '{name}\'s breeding kink is intensifying. Suggest impregnation fetish?',
              requiresApproval: true
            },
            {
              from: 'impregnation_fetish',
              to: 'pregnant',
              duration: 14,
              description: '{name}\'s impregnation fetish is strong. Time to make it real?',
              requiresApproval: true,
              additionalConditions: ['intimacy > 60']
            }
          ]
        },
        
        masochist_escalation: {
          type: 'suggest',
          trigger: 'masochist',
          duration: 21,
          description: '{name}\'s masochism has been consistent. Expand to verbal degradation?',
          suggestFlag: 'degradation_kink',
          requiresApproval: true
        },
        
        rope_to_chastity: {
          type: 'suggest',
          trigger: 'rope_bunny',
          duration: 21,
          description: '{name} loves bondage. Escalate to a chastity device?',
          suggestFlag: 'chastity',
          requiresApproval: true
        },
        
        mind_broken_recovery: {
          type: 'suggest',
          trigger: 'mind_broken',
          duration: 30,
          description: '{name} has been mind_broken for {days} days. Attempt recovery? (Warning: Some personality changes may be permanent)',
          suggestFlag: 'recovering_mind',
          requiresApproval: true,
          stages: [
            {
              flag: 'mind_broken',
              duration: 30,
              description: 'Severely impaired cognition'
            },
            {
              flag: 'recovering_mind',
              duration: 21,
              description: 'Gradual cognitive recovery with therapy/care'
            },
            {
              flag: 'recovered_mind',
              duration: null,
              description: 'Recovered but with lasting personality changes'
            }
          ]
        },
        
        hypnosis_branching: {
          type: 'suggest',
          trigger: 'hypnotized',
          duration: 14,
          description: '{name} has been hypnotized for {days} days. Deepen the conditioning or add new triggers?',
          requiresApproval: true,
          branches: [
            {
              option: 'deepen',
              description: 'Deepen hypnotic conditioning (leads toward mind_broken)',
              suggestFlag: 'mind_broken',
              additionalConditions: ['hypnotized > 30 days']
            },
            {
              option: 'submissive_trigger',
              description: 'Implant submissive trigger',
              suggestFlag: 'submissive'
            },
            {
              option: 'exhibitionist_trigger',
              description: 'Implant exhibitionist trigger',
              suggestFlag: 'exhibitionist'
            },
            {
              option: 'obedience_trigger',
              description: 'Implant pet play obedience',
              suggestFlag: 'pet_play'
            }
          ]
        }
      }
    },
    
    // CHILDREN SYSTEM - Track offspring between player and NPCs
    children: [], // [{ id, name, motherID, fatherID, birthDate, genetics: {...}, age: 0, traits: [] }]
    
    // Pregnancy settings
    pregnancySettings: {
      duration: 14, // Game days (NOT real days) - customizable 7-21
      minDuration: 7,  // Minimum setting
      maxDuration: 21  // Maximum setting
    },
    
    // Name tracking for uniqueness
    usedEmployeeNames: new Set()
  };

  // ============================================
  // â° TIME SYSTEM HELPER METHODS
  // ============================================
  // These are kept separate from gameState.time to allow save serialization
  // (IndexedDB cannot clone functions)
  
  const timeHelpers = {
    getHour() {
      return new Date(gameState.time.currentTime).getHours();
    },
    getDay() {
      return new Date(gameState.time.currentTime).getDay(); // 0=Sunday, 1=Monday, etc.
    },
    getTimeOfDay() {
      const h = this.getHour();
      if (h >= 6 && h < 12) return "morning";
      if (h >= 12 && h < 17) return "afternoon";
      if (h >= 17 && h < 21) return "evening";
      return "night";
    },
    isWorkHours() {
      const day = this.getDay();
      const hour = this.getHour();
      return day >= 1 && day <= 5 && hour >= 9 && hour < 17;
    },
    isWeekend() {
      const day = this.getDay();
      return day === 0 || day === 6;
    },
    getFormattedTime() {
      const d = new Date(gameState.time.currentTime);
      return d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
    },
    getFormattedDate() {
      const d = new Date(gameState.time.currentTime);
      const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      return `${days[d.getDay()]}, ${d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
    }
  };

  // ============================================
  // AI REQUEST OPTIMIZATION SYSTEM
  // ============================================
  
  const aiOptimization = {
    // Relationship evaluation batching
    relationshipQueue: [],
    relationshipBatchInterval: null,
    relationshipBatchDelay: 30000, // Process every 30 seconds
    
    // Stat change heuristics (avoid AI calls for common cases)
    statChangeHeuristics: {
      like_post: { affection: 1, trust: 0.5, comfort: 0.5 },
      comment_positive: { affection: 2, trust: 1, comfort: 1 },
      comment_supportive: { affection: 3, trust: 2, comfort: 1.5 },
      comment_funny: { affection: 2.5, trust: 1, comfort: 1, desire: 0.5 },
      comment_flirty: { affection: 2, trust: 0.5, comfort: -0.5, desire: 3 },
      comment_dramatic: { affection: 3, trust: -1, comfort: -1, desire: 1 },
      comment_negative: { affection: -2, trust: -2, comfort: -1 },
      mentioned_in_post: { affection: 2, trust: 1.5, comfort: 1 },
      explicit_content_comfortable: { desire: 3, obedience: 1, comfort: -0.5 },
      explicit_content_uncomfortable: { desire: -1, comfort: -3, trust: -1 }
    },
    
    // Relationship change heuristics (EXPANDED for better coverage)
    relationshipHeuristics: {
      like_post: 1,
      comment_positive: 2,
      comment_funny: 3,
      comment_supportive: 3,
      comment_dramatic: 2,
      comment_negative: -2,
      comment_flirty: 2,
      mentioned: 2,
      explicit_post_flirty_viewer: 3,
      explicit_post_professional_viewer: -1,
      achievement_post: 2,
      boring_post: 0,
      // NEW: Additional common cases to reduce AI calls
      casual_view: 0, // Just viewing a normal post, no change
      meme_post: 1, // Light positive for funny content
      selfie_view: 1, // Small positive for personal content
      work_post: 0 // Neutral for work updates
    },
    
    // Recent topics for duplicate prevention
    recentTopics: new Map(), // Changed from [] to Map()
    topicCooldown: 300000, // 5 minutes
    
    // Proactive message blocking
    blockedProactiveMessages: new Set(),
    
    // GIFT SYSTEM
    giftInventory: {
      items: [],         // Player's purchased gifts (ready to give)
      capacity: Infinity // No limit
    },
    giftStore: {
      items: []          // Available gifts for purchase (approved by genie)
    },
    currentLifetimeIncome: 0, // Tracks income THIS prestige only (for gift scaling)
    givenUniqueGifts: [],     // Track one-time UNIQUE gifts that can never be given again
    createdUniqueGifts: []    // Track UNIQUE gifts that have been created (can't create again)
  };

  // ============================================
  // GIFT SYSTEM CONFIGURATION
  // ============================================
  const GIFT_CATEGORIES = {
    ROMANTIC: { 
      name: 'Romantic', 
      emoji: 'ğŸ’•',
      examples: 'Flowers, jewelry, perfume, romantic dinners, love letters'
    },
    LUXURY: { 
      name: 'Luxury', 
      emoji: 'ğŸ’',
      examples: 'Designer items, expensive watches, high-end fashion, luxury cars'
    },
    EXPERIENCES: { 
      name: 'Experiences', 
      emoji: 'âœˆï¸',
      examples: 'Trips, concerts, spa days, adventures, classes, events'
    },
    TECH: { 
      name: 'Tech & Gadgets', 
      emoji: 'ğŸ“±',
      examples: 'Electronics, computers, smart devices, gaming equipment'
    },
    INTELLECTUAL: { 
      name: 'Intellectual', 
      emoji: 'ğŸ“š',
      examples: 'Books, courses, art, museum memberships, subscriptions'
    },
    FOOD: { 
      name: 'Food & Drink', 
      emoji: 'ğŸ·',
      examples: 'Gourmet food, wine, chocolate, restaurant experiences'
    },
    PRACTICAL: { 
      name: 'Practical', 
      emoji: 'ğŸ› ï¸',
      examples: 'Useful tools, office supplies, home items, everyday necessities'
    },
    QUIRKY: { 
      name: 'Quirky & Unique', 
      emoji: 'ğŸ¨',
      examples: 'Unusual items, collectibles, personalized gifts, novelties'
    },
    WELLNESS: { 
      name: 'Wellness & Fitness', 
      emoji: 'ğŸ§˜',
      examples: 'Gym equipment, yoga mats, health trackers, supplements'
    },
    FASHION: { 
      name: 'Fashion & Beauty', 
      emoji: 'ğŸ‘—',
      examples: 'Clothing, shoes, accessories, makeup, skincare'
    },
    UNIQUE: { 
      name: 'One-of-a-Kind', 
      emoji: 'ğŸŒŸ',
      examples: 'Continents, landmarks, rare artifacts, historical items - can only be given ONCE globally'
    }
  };

  // Gift Genie suggestion cycling list (100 diverse items)
  const GIFT_SUGGESTIONS = [
    // Tiny ($10-$100)
    "box of chocolates", "red roses", "coffee gift card", "scented candle", "handwritten poem",
    "favorite snack basket", "lottery tickets", "bubble bath set", "cute plant", "funny mug",
    
    // Small ($100-$1K)
    "designer sunglasses", "silk scarf", "premium headphones", "cocktail making kit", "vintage vinyl record",
    "art print", "gourmet cheese board", "massage gift certificate", "perfume sampler", "leather wallet",
    "portable speaker", "fancy pen", "cookbook collection", "board game collection", "succulent garden",
    
    // Medium ($1K-$10K)
    "smart watch", "noise-canceling headphones", "espresso machine", "gaming console", "designer handbag",
    "weekend spa retreat", "concert tickets VIP", "wine tasting tour", "photography equipment", "fitness tracker deluxe",
    "chef's knife set", "cashmere sweater", "art class subscription", "telescope", "standing desk setup",
    
    // Large ($10K-$100K)
    "diamond earrings", "Rolex watch", "weekend in Paris", "home theater system", "designer wardrobe",
    "electric bicycle", "hot tub", "grand piano", "professional camera gear", "wine cellar collection",
    "tailored suit collection", "safari adventure", "scuba diving certification trip", "home gym equipment", "art commission",
    
    // Luxury ($100K-$1M)
    "Tesla Model S", "Mediterranean cruise", "diamond necklace", "rare whisky collection", "investment art piece",
    "luxury watch collection", "private chef for a month", "penthouse weekend", "vintage wine collection", "designer furniture set",
    
    // Lavish ($1M-$100M)
    "Lamborghini Aventador", "private island vacation", "yacht charter", "luxury condo", "rare car collection",
    "private jet flight", "world tour first class", "vineyard estate", "beach house", "rare gemstone",
    "racehorse", "art gallery collection", "recording studio", "private concert", "helicopter",
    
    // Absurd ($100M+)
    "private island", "mansion estate", "commercial building", "sports team stake", "space tourism ticket",
    "superyacht", "private jet", "castle in Europe", "entire city block", "mountain resort",
    
    // Unique (One-time only)
    "North America", "Eiffel Tower", "Great Wall of China", "Moon", "Amazon Rainforest",
    "Mona Lisa", "Statue of Liberty", "Antarctica", "Mount Everest", "Pacific Ocean"
  ];

  // ============================================
  // BOSS FIGHT CONFIGURATION
  // ============================================
  // Each location (except garage) has a boss that must be defeated to unlock
  const bossFightConfig = {
    home_office: {
      id: 'boss_home_office',
      name: 'The Demanding Client',
      title: 'Corporate Gatekeeper',
      description: 'A high-stakes client with impossible demands. Prove your worth to access corporate connections.',
      nsfwLevel: 0, // Professional
      health: 5000,
      healthScaling: 'quadratic', // Health scales quadratically with prestige
      recommendedClickPower: 0, // Can attempt with base stats
      recommendedIncome: 100, // $100/sec recommended
      rewardMultiplier: 2.0,
      dialogue: {
        intro: "I don't work with amateurs. Show me what you've got.",
        mid: "Hmm... maybe you're not completely incompetent.",
        victory: "Fine. You've earned my respect. Welcome to the big leagues."
      },
      appearance: {
        prompt: "Professional businesswoman in sharp suit, stern expression, office background, photorealistic",
        style: "professional"
      }
    },
    office_suite: {
      id: 'boss_office_suite',
      name: 'The Executive',
      title: 'CFO Negotiator',
      description: 'The CFO wants to see results. Your performance will determine if you get that corner office.',
      nsfwLevel: 0,
      health: 50000,
      healthScaling: 'quadratic',
      recommendedClickPower: 5,
      recommendedIncome: 1000, // $1K/sec
      rewardMultiplier: 3.0,
      dialogue: {
        intro: "The board is watching. Impress me or get out.",
        mid: "Interesting... you might have potential after all.",
        victory: "Excellent work. The corner office is yours."
      },
      appearance: {
        prompt: "Confident female CFO in designer suit, luxury office, commanding presence, photorealistic",
        style: "executive"
      }
    },
    factory: {
      id: 'boss_factory',
      name: 'The Union Rep',
      title: 'Labor Negotiator',
      description: 'Win over the workers to gain access to manufacturing operations.',
      nsfwLevel: 0,
      health: 500000,
      healthScaling: 'quadratic',
      recommendedClickPower: 10,
      recommendedIncome: 10000, // $10K/sec
      rewardMultiplier: 4.0,
      dialogue: {
        intro: "The workers won't respect someone who can't deliver. Prove yourself.",
        mid: "You're starting to win them over...",
        victory: "Alright, you've got the union's backing. Welcome to the floor."
      },
      appearance: {
        prompt: "Strong confident female union representative in work clothes, factory background, determined look, photorealistic",
        style: "industrial"
      }
    },
    rnd: {
      id: 'boss_rnd',
      name: 'The Scientist',
      title: 'Head Researcher',
      description: 'Prove your innovation capabilities to access cutting-edge R&D facilities.',
      nsfwLevel: 0,
      health: 10000000,
      healthScaling: 'quadratic',
      recommendedClickPower: 20,
      recommendedIncome: 100000, // $100K/sec
      rewardMultiplier: 5.0,
      dialogue: {
        intro: "Research requires precision and dedication. Can you handle it?",
        mid: "Fascinating approach... show me more.",
        victory: "Welcome to the lab. Let's push some boundaries."
      },
      appearance: {
        prompt: "Attractive female scientist in lab coat, modern laboratory, intelligent gaze, photorealistic",
        style: "scientific"
      }
    },
    creative_studio: {
      id: 'boss_creative_studio',
      name: 'The Director',
      title: 'Content Creator',
      description: 'Convince the provocative director you can handle "artistic" content creation.',
      nsfwLevel: 1, // Suggestive begins
      health: 500000000,
      healthScaling: 'quadratic',
      recommendedClickPower: 35,
      recommendedIncome: 1000000, // $1M/sec
      rewardMultiplier: 6.0,
      dialogue: {
        intro: "Art requires... openness. Are you open-minded enough for my studio?",
        mid: "Mmm, you're not shy. I like that...",
        victory: "Perfect. You'll fit right in here. Let's create something... provocative."
      },
      appearance: {
        prompt: "Seductive female director in stylish revealing outfit, artistic studio, confident sultry expression, photorealistic",
        style: "artistic"
      }
    },
    private_club: {
      id: 'boss_private_club',
      name: 'The Hostess',
      title: 'Club Proprietor',
      description: 'Prove you can handle the exclusive and explicit nature of elite adult entertainment.',
      nsfwLevel: 2, // Explicit
      health: 25000000000,
      healthScaling: 'quadratic',
      recommendedClickPower: 50,
      recommendedIncome: 10000000, // $10M/sec
      rewardMultiplier: 8.0,
      dialogue: {
        intro: "This club caters to very... particular tastes. Think you can satisfy them?",
        mid: "Oh, you know how to please. Keep going...",
        victory: "Excellent performance. Welcome to the VIP section, darling."
      },
      appearance: {
        prompt: "Gorgeous hostess in elegant lingerie, luxury club setting, seductive pose, partial nudity, photorealistic, NSFW",
        style: "seductive"
      }
    },
    velvet_room: {
      id: 'boss_velvet_room',
      name: 'The Dominatrix',
      title: 'Mistress of Ceremonies',
      description: 'Submit to her will to gain access to the most decadent establishment.',
      nsfwLevel: 3, // Very explicit
      health: 1000000000000,
      healthScaling: 'quadratic',
      recommendedClickPower: 75,
      recommendedIncome: 100000000, // $100M/sec
      rewardMultiplier: 10.0,
      dialogue: {
        intro: "Kneel. This is MY domain, and you will submit to enter.",
        mid: "Good... you're learning your place. Continue.",
        victory: "You've proven yourself worthy. You may enter my velvet room."
      },
      appearance: {
        prompt: "Dominant woman in leather outfit, velvet room, commanding pose, explicit attire, photorealistic, NSFW",
        style: "dominant"
      }
    },
    inner_sanctum: {
      id: 'boss_inner_sanctum',
      name: 'The Empress',
      title: 'Ultimate Authority',
      description: 'Face the ultimate challenge. Only the most dedicated can access the inner sanctum.',
      nsfwLevel: 3,
      health: 50000000000000,
      healthScaling: 'quadratic',
      recommendedClickPower: 100,
      recommendedIncome: 1000000000, // $1B/sec
      rewardMultiplier: 15.0,
      dialogue: {
        intro: "You dare approach me? Prove you're worthy of my presence.",
        mid: "Impressive... you might actually deserve this...",
        victory: "Magnificent. You've conquered everything. The inner sanctum is yours."
      },
      appearance: {
        prompt: "Empress in revealing royal attire, opulent throne room, powerful sensual presence, explicit, photorealistic, NSFW",
        style: "supreme"
      }
    }
  };

  // Helper function to get DOM elements safely
  function $(id) {
    return document.getElementById(id);
  }

  /**
   * Extract string from generateText response
   * Handles String objects, response objects, and primitive strings
   * @param {string|object} response - Response from generateText
   * @returns {string} - Clean primitive string
   */
  function extractText(response) {
    if (!response) return '';
    
    // If it's already a primitive string, return it
    if (typeof response === 'string') {
      return response.trim();
    }
    
    // If it's an object (including String object), extract the text
    if (typeof response === 'object') {
      // Try various possible properties
      const text = response.text || response.generatedText || response.prompt || String(response);
      return String(text).trim();
    }
    
    // Fallback: convert to string
    return String(response).trim();
  }

  // ========== SOCIAL NETWORK DATA STRUCTURES ==========
  
  /**
   * Post Structure
   * Represents a single post on the social network
   */
  function createPost({
    authorId,
    authorName,
    authorImage = null,
    type = 'text', // 'text', 'selfie', 'image', 'meme', 'thirsttrap', 'explicit', 'life_update', 'work', 'travel'
    content = '', // Caption/text content
    imageUrl = null,
    imagePrompt = null, // For regeneration
    altText = null, // For NPC "vision" - what they "see" in the image
    mood = 'neutral', // 'happy', 'excited', 'sad', 'flirty', 'angry', 'stressed', 'playful', 'spicy'
    tags = [], // Hashtags or topics
    referencedEmployees = [], // Employee IDs mentioned/tagged
    referencedEvent = null, // Event ID if referencing a company event
    referencedChat = null, // Chat message ID if referencing boss conversation
    explicitLevel = 0, // 0=safe, 1=suggestive, 2=lewd, 3=explicit, 4=very explicit
    isPlayerPost = false
  } = {}) {
    // CRITICAL FIX: Ensure timestamp is ALWAYS valid to prevent invalid postIds
    const timestamp = Date.now();
    if (!timestamp || isNaN(timestamp)) {
      console.error('[PostId] Invalid timestamp detected, using fallback');
      timestamp = gameState.time?.currentTime || new Date().getTime() || 1729800000000; // Use game time or epoch fallback
    }
    
    return {
      id: `post_${++gameState.socialNetwork.postIdCounter}_${timestamp}`,
      authorId,
      authorName,
      authorImage,
      type,
      content,
      imageUrl,
      imagePrompt,
      altText,
      mood,
      tags,
      referencedEmployees,
      referencedEvent,
      referencedChat,
      explicitLevel,
      isPlayerPost,
      timestamp: timestamp,
      likes: [], // Array of employee IDs who liked
      dislikes: [], // Array of employee IDs who downvoted (ğŸ˜ˆ DRAMA)
      comments: [], // Array of comment objects
      views: 0,
      shareCount: 0
    };
  }
  
  /**
   * Comment Structure
   * Represents a comment on a post
   */
  function createComment({
    postId,
    authorId,
    authorName,
    authorImage = null,
    content = '',
    replyToCommentId = null,
    mentionedEmployees = [],
    imageUrl = null,
    imageAlt = null,
    imagePrompt = null // For regeneration
  } = {}) {
    return {
      id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      postId,
      authorId,
      authorName,
      authorImage,
      content,
      replyToCommentId,
      mentionedEmployees,
      timestamp: gameState.time?.currentTime || Date.now(),
      likes: [],
      imageUrl,
      imageAlt,
      imagePrompt
    };
  }
  
  /**
   * Relationship Structure
   * Represents a relationship between two employees
   */
  function createRelationship({
    targetId,
    type = 'neutral', // 'friend', 'best_friend', 'rival', 'crush', 'enemy', 'romantic', 'neutral'
    strength = 50, // 0-100, how strong the relationship is
    history = [] // Array of interaction events
  } = {}) {
    return {
      targetId,
      type,
      strength,
      lastInteraction: Date.now(),
      history, // [{ timestamp, event, impact }]
      sharedInterests: [], // Common hobbies/traits
      sharedLocation: false, // Work at same location
      conflicts: 0, // Number of negative interactions
      positiveInteractions: 0
    };
  }
  
  /**
   * Event Structure
   * Represents a notable company event that can trigger posts
   */
  function createEvent({
    type = 'general', // 'hire', 'fire', 'promotion', 'project_success', 'department_rivalry', 'office_party', 'milestone', 'boss_interaction'
    involvedEmployees = [], // Employee IDs involved
    location = null,
    description = '',
    sentiment = 'neutral', // 'positive', 'negative', 'neutral', 'exciting', 'dramatic'
    importance = 5 // 1-10, how likely to trigger posts
  } = {}) {
    return {
      id: `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type,
      involvedEmployees,
      location,
      description,
      sentiment,
      importance,
      timestamp: gameState.time?.currentTime || Date.now(),
      relatedPosts: [], // Post IDs that reference this event
      hasBeenPostedAbout: false
    };
  }
  
  /**
   * Initialize social network data on an employee
   * Called when employee is created or loaded from old save
   */
  // ========== USERNAME GENERATION ==========
  
  /**
   * Generate unique username for employee
   */
  function generateUsername(employee) {
    const firstName = (employee.name.split(' ')[0] || '').toLowerCase();
    const lastName = (employee.name.split(' ')[1] || '').toLowerCase();
    
    const templates = [
      `${firstName}_${lastName}`,
      `${firstName}.${lastName}`,
      `${firstName}${lastName}`,
      `${firstName}_${lastName.charAt(0)}`,
      `${firstName.charAt(0)}_${lastName}`,
      `${lastName}_${firstName}`,
      `the_${firstName}`,
      `real_${firstName}`,
      `${firstName}_official`,
      `${firstName}_${Math.floor(Math.random() * 100)}`,
      `${lastName}_${Math.floor(Math.random() * 100)}`,
      `${firstName}_${lastName}_${Math.floor(Math.random() * 10)}`
    ];
    
    // Pick random template
    let username = templates[Math.floor(Math.random() * templates.length)];
    
    // Ensure uniqueness by checking existing usernames
    const existingUsernames = gameState.employees
      .filter(e => e.social?.username && e.id !== employee.id)
      .map(e => e.social.username);
    
    let attempts = 0;
    while (existingUsernames.includes(username) && attempts < 10) {
      username = `${firstName}_${Math.floor(Math.random() * 1000)}`;
      attempts++;
    }
    
    return username;
  }

  // ========== SOCIAL DATA INITIALIZATION ==========
  
  function initializeEmployeeSocialData(employee) {
    if (!employee) return;
    
    // === UNIVERSAL FLAG SYSTEM ===
    // Initialize flag system (NEW)
    if (!employee.flags) {
      employee.flags = {
        systemFlags: [],  // Flags created by game systems (pregnancy, sickness, etc.)
        customFlags: []   // Flags created by player
      };
    }
    
    // === PHASE 4: SCHEDULE & TIME SYSTEM ===
    if (!employee.schedule) {
      employee.schedule = {
        workDays: [1, 2, 3, 4, 5],      // Monday-Friday (0=Sunday, 1=Monday, etc.)
        workStartHour: 9,                // 9 AM start
        workEndHour: 17,                 // 5 PM end
        isCurrentlyWorking: false,       // Currently clocked in?
        lastClockIn: null,               // Timestamp of last clock-in
        lastClockOut: null,              // Timestamp of last clock-out
        hoursWorkedToday: 0,             // Track daily hours
        daysWorked: 0,                   // Total days worked (for analytics)
        lateDays: 0,                     // Times arrived late
        
        // Leave/PTO system
        ptoBalance: 10,                  // Days of PTO
        sickDays: 5,                     // Sick days available
        isOnLeave: false,                // Currently on leave?
        leaveType: null,                 // 'pto', 'sick', 'maternity', etc.
        leaveEndDate: null               // When leave ends
      };
    }
    
    // === PHASE 5: LIFE OUTSIDE WORK ===
    if (!employee.personalLife) {
      employee.personalLife = {
        // Current activity tracking
        currentActivity: null,           // What they're doing right now
        activityStartTime: null,         // When current activity started
        lastActivityUpdate: Date.now(),  // Last time we generated an activity
        
        // Hobbies (already have some from employee.hobbies, but add detail)
        activeHobbies: [],               // Currently pursuing hobbies with frequency
        
        // Weekend plans
        upcomingPlans: [],               // Array of planned activities
        lastWeekendActivity: null,       // What they did last weekend
        
        // Evening routine preferences
        eveningPreferences: {
          gym: Math.random() * 0.4,      // 0-40% chance to hit gym
          cooking: Math.random() * 0.6,  // 0-60% chance to cook
          socializing: Math.random() * 0.5, // 0-50% chance to go out
          relaxing: 0.3 + Math.random() * 0.4, // 30-70% chance to chill at home
          hobbies: Math.random() * 0.6,  // 0-60% chance to do hobbies
          dating: Math.random() * 0.3    // 0-30% chance for dates
        },
        
        // Living situation (for context)
        livingSituation: {
          type: Math.random() < 0.3 ? 'apartment' : (Math.random() < 0.7 ? 'house' : 'condo'),
          hasRoommate: Math.random() < 0.25,
          hasPet: Math.random() < 0.35,
          petType: null,  // Will set if hasPet
          petName: null,
          pets: []  // Array of all pets { name, type, giftedBy, timestamp }
        },
        
        // Social circle outside work
        outsideContacts: {
          hasBestFriend: Math.random() < 0.7,
          hasFamily: Math.random() < 0.8,
          inRelationship: Math.random() < 0.3,
          relationshipStatus: 'single' // 'single', 'dating', 'serious', 'married'
        }
      };
      
      // Generate pet details if they have one
      if (employee.personalLife.livingSituation.hasPet) {
        const petTypes = ['dog', 'cat', 'bird', 'fish'];
        employee.personalLife.livingSituation.petType = petTypes[Math.floor(Math.random() * petTypes.length)];
        
        const petNames = ['Max', 'Luna', 'Charlie', 'Bella', 'Cooper', 'Daisy', 'Milo', 'Sadie', 'Buddy', 'Chloe'];
        employee.personalLife.livingSituation.petName = petNames[Math.floor(Math.random() * petNames.length)];
      }
      
      // Convert existing hobbies to active hobbies with frequency
      if (employee.hobbies && employee.hobbies.length > 0) {
        employee.personalLife.activeHobbies = employee.hobbies.map(hobby => ({
          name: hobby,
          frequency: Math.random() * 0.7 + 0.3, // 0.3-1.0 (30%-100% engagement)
          skillLevel: Math.floor(Math.random() * 5) + 1, // 1-5
          lastDone: Date.now() - Math.floor(Math.random() * 604800000) // Random time in last week
        }));
      }
    }
    
    // === SKILLS SYSTEM (Phase 3) ===
    // Initialize skills if not present
    if (!employee.skills) {
      employee.skills = {
        // Work skills
        technical: { level: 1, xp: 0, maxXp: 500 },     // Coding, engineering, data analysis
        creative: { level: 1, xp: 0, maxXp: 500 },      // Design, writing, marketing
        social: { level: 1, xp: 0, maxXp: 500 },        // Communication, networking, charisma
        management: { level: 1, xp: 0, maxXp: 500 },    // Leadership, planning, delegation
        
        // Life skills
        intimate: { level: 0, xp: 0, maxXp: 500 },      // Sexual/romantic experience
        cooking: { level: 0, xp: 0, maxXp: 500 },       // Personal skill
        fitness: { level: 0, xp: 0, maxXp: 500 }        // Health & athletics
      };
      
      // Give random starting levels based on position
      if (employee.position) {
        const pos = employee.position.toLowerCase();
        if (pos.includes('engineer') || pos.includes('developer')) {
          employee.skills.technical.level = 2 + Math.floor(Math.random() * 3);
          employee.skills.technical.xp = Math.floor(Math.random() * employee.skills.technical.maxXp);
        }
        if (pos.includes('designer') || pos.includes('creative')) {
          employee.skills.creative.level = 2 + Math.floor(Math.random() * 3);
          employee.skills.creative.xp = Math.floor(Math.random() * employee.skills.creative.maxXp);
        }
        if (pos.includes('manager') || pos.includes('director')) {
          employee.skills.management.level = 3 + Math.floor(Math.random() * 2);
          employee.skills.management.xp = Math.floor(Math.random() * employee.skills.management.maxXp);
          employee.skills.social.level = 2 + Math.floor(Math.random() * 2);
        }
        if (pos.includes('sales') || pos.includes('marketing')) {
          employee.skills.social.level = 2 + Math.floor(Math.random() * 3);
          employee.skills.social.xp = Math.floor(Math.random() * employee.skills.social.maxXp);
        }
      }
    }
    
    // Specializations (unlocked at skill milestones)
    if (!employee.specializations) {
      employee.specializations = [];
    }
    
    // Social network specific data
    if (!employee.social) {
      employee.social = {
        // Username
        username: generateUsername(employee),
        
        // Bio/About
        bio: '', // Can be generated later
        joinDate: Date.now(),
        
        // Posting behavior
        postFrequency: 0.3 + Math.random() * 0.7, // 0-1, how often they post (some are very active, some lurk)
        lastPostTime: 0,
        postCount: 0,
        likeCount: 0,
        commentCount: 0,
        
        // Stats
        totalLikesReceived: 0,
        totalCommentsReceived: 0,
        totalMentions: 0,
        
        // Content preferences (what they're likely to post)
        contentPreferences: {
          selfies: 0.2 + Math.random() * 0.5,
          workPosts: 0.1 + Math.random() * 0.4,
          memes: Math.random() * 0.6,
          lifeUpdates: 0.2 + Math.random() * 0.5,
          thirstTraps: Math.random() * 0.4, // Based on personality
          explicitContent: Math.random() * 0.3, // Some are bolder than others
          travelPosts: Math.random() * 0.4
        },
        
        // Engagement behavior
        likesProbability: 0.3 + Math.random() * 0.6, // How likely to like posts
        commentsProbability: 0.1 + Math.random() * 0.4, // How likely to comment
        
        // Content filters
        willingnessToPostExplicit: Math.random(), // 0-1, how comfortable with explicit content
        
        // Activity tracking
        recentPostTypes: [], // Last 5 post types to avoid repetition
        postsAboutBoss: 0, // Track how many posts reference boss
        
        // Mention tracking for @suggest system
        mentionHistory: [] // { employeeId, timestamp, count }
      };
    }
    
    // Gift consequences tracking (NEW)
    if (!employee.giftedPossessions) {
      employee.giftedPossessions = {
        wardrobe: [],      // { item, category, price, timestamp, wearChance }
        jewelry: [],       // { item, type, price, timestamp, wearChance }
        vehicles: [],      // { item, type, price, timestamp }
        homeUpgrades: [],  // { item, upgradeType, price, timestamp }
        experiences: [],   // { item, description, price, timestamp, memoryStrength }
        tech: [],          // { item, type, price, timestamp, inUse }
        other: []          // { item, category, price, timestamp }
      };
    }
    
    // Initialize player mention stats if not exists
    if (!gameState.playerMentionStats) {
      gameState.playerMentionStats = {
        mentionHistory: [], // { employeeId, timestamp }
        mentionCounts: {}   // { employeeId: count }
      };
    }
    
    // Relationships with other employees
    if (!employee.relationships) {
      employee.relationships = {}; // { [employeeId]: Relationship }
    }
    
    // Location awareness
    if (!employee.locationId && employee.productManaged) {
      // Infer location from product if not set
      const product = gameState.products.find(p => p.name === employee.productManaged);
      if (product) {
        employee.locationId = product.locationId;
      }
    }
    if (!employee.locationId) {
      employee.locationId = 'garage'; // Default
    }
    
    // Contextual awareness
    if (!employee.awareness) {
      employee.awareness = {
        knowsCoworkers: [], // Employee IDs they're aware of
        knowsLocations: [], // Location IDs they know about
        companyKnowledge: {
          totalEmployees: 0,
          lastUpdated: 0
        }
      };
    }
    
    // Alumni status (for fired employees)
    if (!employee.employmentStatus) {
      employee.employmentStatus = employee.hired ? 'active' : 'alumni';
    }
    
    return employee;
  }

  // ========== FLAG SYSTEM ==========
  
  /**
   * Generate a unique ID for flags
   */
  function generateFlagId() {
    return 'flag_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }
  
  /**
   * Add a flag to an employee
   * @param {Object} employee - The employee object
   * @param {Object} flagData - Flag configuration
   * @returns {Object} - The created flag
   */
  function addFlag(employee, flagData) {
    if (!employee || !flagData) return null;
    
    // Ensure flags structure exists
    if (!employee.flags) {
      employee.flags = { systemFlags: [], customFlags: [] };
    }
    
    const flag = {
      id: generateFlagId(),
      key: flagData.key,
      value: flagData.value,
      category: flagData.category || 'custom',
      setBy: flagData.setBy || 'player',
      setDate: flagData.setDate || flagData.startDate || gameState.time?.currentTime || Date.now(), // Use game time if available
      timestamp: flagData.timestamp || flagData.startDate || gameState.time?.currentTime || Date.now(), // Alias for compatibility
      autoRemove: flagData.autoRemove || null,
      duration: flagData.duration || null,
      expirationDate: flagData.expirationDate || null, // New: explicit expiration
      affectsContext: flagData.affectsContext !== false, // Default true
      priority: flagData.priority || 'medium',
      playerDescription: flagData.playerDescription || '',
      aiGuidance: flagData.aiGuidance || '',
      emoji: flagData.emoji || null,
      
      // Custom metadata for context-specific flags
      metadata: flagData.metadata || {}
    };
    
    // Auto-populate metadata based on flag type
    if (flagData.key === 'pregnant' && !flag.metadata.father) {
      flag.metadata.father = flagData.father || 'unknown';
      // Due date will be set by initializePregnancy
    }
    
    if (flagData.key === 'in_relationship' && !flag.metadata.partner) {
      flag.metadata.partner = flagData.partner || 'unknown';
    }
    
    if (flagData.key === 'engaged' && !flag.metadata.fiance) {
      flag.metadata.fiance = flagData.fiance || 'unknown';
    }
    
    if (flagData.key === 'married' && !flag.metadata.spouse) {
      flag.metadata.spouse = flagData.spouse || 'unknown';
      flag.metadata.marriageDate = flagData.marriageDate || flag.setDate;
    }
    
    // Determine which flag array
    if (flag.setBy === 'system') {
      employee.flags.systemFlags.push(flag);
    } else {
      employee.flags.customFlags.push(flag);
    }
    
    console.log(`[Flags] Added "${flag.key}" to ${employee.name}`);
    
    // Initialize pregnancy system if pregnant flag
    if (flag.key === 'pregnant' && !flag.metadata.dueDate) {
      initializePregnancy(employee, flag);
    }
    
    saveGame(); // Auto-save when flags change
    return flag;
  }
  
  /**
   * Remove a flag by ID or key
   * @param {Object} employee - The employee object
   * @param {string} flagIdOrKey - The flag ID or key to remove
   */
  function removeFlag(employee, flagIdOrKey) {
    if (!employee || !employee.flags) return;
    
    employee.flags.systemFlags = employee.flags.systemFlags.filter(f => f.id !== flagIdOrKey && f.key !== flagIdOrKey);
    employee.flags.customFlags = employee.flags.customFlags.filter(f => f.id !== flagIdOrKey && f.key !== flagIdOrKey);
    
    console.log(`[Flags] Removed flag ${flagIdOrKey} from ${employee.name}`);
    saveGame();
  }
  
  /**
   * Get all active flags (non-expired)
   * @param {Object} employee - The employee object
   * @returns {Array} - Array of active flags
   */
  function getActiveFlags(employee) {
    if (!employee || !employee.flags) return [];
    
    const now = Date.now();
    
    // Filter out expired flags
    const activeSystem = employee.flags.systemFlags.filter(f => 
      !f.autoRemove || f.autoRemove > now
    );
    
    const activeCustom = employee.flags.customFlags.filter(f => 
      !f.autoRemove || f.autoRemove > now
    );
    
    return [...activeSystem, ...activeCustom];
  }
  
  /**
   * Clean up expired flags
   * @param {Object} employee - The employee object
   */
  function cleanupExpiredFlags(employee) {
    if (!employee || !employee.flags) return;
    
    const now = Date.now();
    
    employee.flags.systemFlags = employee.flags.systemFlags.filter(f => 
      !f.autoRemove || f.autoRemove > now
    );
    
    employee.flags.customFlags = employee.flags.customFlags.filter(f => 
      !f.autoRemove || f.autoRemove > now
    );
  }
  
  /**
   * Find a flag by key
   * @param {Object} employee - The employee object
   * @param {string} key - The flag key to search for
   * @returns {Object|null} - The flag or null
   */
  function findFlag(employee, key) {
    if (!employee || !employee.flags) return null;
    
    const allFlags = [...employee.flags.systemFlags, ...employee.flags.customFlags];
    return allFlags.find(f => f.key === key) || null;
  }
  
  /**
   * Check if employee has a specific flag
   * @param {Object} employee - The employee object
   * @param {string} key - The flag key to check
   * @returns {boolean}
   */
  function hasFlag(employee, key) {
    return !!findFlag(employee, key);
  }
  
  /**
   * Get flag value
   * @param {Object} employee - The employee object
   * @param {string} key - The flag key
   * @returns {*} - The flag value or null
   */
  function getFlagValue(employee, key) {
    const flag = findFlag(employee, key);
    return flag ? flag.value : null;
  }
  
  /**
   * Build AI context string from employee flags
   * This is injected into chat prompts so AI knows about flags
   * @param {Object} employee - The employee object
   * @returns {string} - Context string for AI
   */
  function buildAIContextFromFlags(employee) {
    const activeFlags = getActiveFlags(employee);
    
    if (activeFlags.length === 0) return '';
    
    // Sort by priority
    const priorityOrder = { high: 0, medium: 1, low: 2 };
    activeFlags.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
    
    let contextString = '\n\n=== EMPLOYEE FLAGS ===\n';
    
    // High priority flags (always included)
    const highPriority = activeFlags.filter(f => f.priority === 'high');
    if (highPriority.length > 0) {
      contextString += 'ğŸ”´ HIGH PRIORITY:\n';
      highPriority.forEach(flag => {
        contextString += `- ${flag.key}: ${flag.playerDescription || JSON.stringify(flag.value)}\n`;
        if (flag.aiGuidance) {
          contextString += `  AI NOTE: ${flag.aiGuidance}\n`;
        }
      });
    }
    
    // Medium priority flags (include if space)
    const medPriority = activeFlags.filter(f => f.priority === 'medium');
    if (medPriority.length > 0) {
      contextString += 'ğŸŸ¡ MODERATE PRIORITY:\n';
      medPriority.forEach(flag => {
        contextString += `- ${flag.key}: ${flag.playerDescription || JSON.stringify(flag.value)}\n`;
        if (flag.aiGuidance) {
          contextString += `  AI NOTE: ${flag.aiGuidance}\n`;
        }
      });
    }
    
    // Low priority flags (include only if context window allows)
    const lowPriority = activeFlags.filter(f => f.priority === 'low');
    if (lowPriority.length > 0 && contextString.length < 500) {
      contextString += 'ğŸŸ¢ LOW PRIORITY:\n';
      lowPriority.forEach(flag => {
        contextString += `- ${flag.key}: ${flag.playerDescription || JSON.stringify(flag.value)}\n`;
      });
    }
    
    return contextString;
  }

  /**
   * Build AI context from employee skills (Phase 3 Enhancement)
   * Injects personality traits and capabilities based on skill levels
   */
  function buildAIContextFromSkills(employee) {
    if (!employee.skills) return '';
    
    let contextString = '\n=== YOUR SKILLS & ABILITIES ===\n';
    
    // Get all skills with level > 0
    const skills = Object.entries(employee.skills)
      .filter(([name, skill]) => skill.level > 0)
      .sort((a, b) => b[1].level - a[1].level);
    
    if (skills.length === 0) return '';
    
    // Add skill descriptions with personality traits
    const skillDescriptions = {
      technical: {
        1: 'You have basic technical knowledge.',
        3: 'You\'re technically skilled and confident with technology.',
        5: 'You\'re a technical expert. You speak about tech topics naturally and intelligently.',
        7: 'You\'re a technical master. Your expertise is well-known and you mentor others.',
        10: 'You\'re a legendary technical genius. Technology is second nature to you.'
      },
      creative: {
        1: 'You have some creative ideas.',
        3: 'You\'re quite creative and artistic in your thinking.',
        5: 'You\'re highly creative. You see the world through an artistic lens.',
        7: 'You\'re a creative visionary. Your ideas are innovative and inspiring.',
        10: 'You\'re a creative genius. Your imagination knows no bounds.'
      },
      social: {
        1: 'You can hold a basic conversation.',
        3: 'You\'re naturally charming and good with people.',
        5: 'You\'re highly charismatic. People are drawn to you.',
        7: 'You\'re a master communicator. You read people effortlessly.',
        10: 'You have legendary charisma. You can convince anyone of anything.'
      },
      management: {
        1: 'You can delegate simple tasks.',
        3: 'You\'re a capable leader and organizer.',
        5: 'You\'re an excellent manager. People trust your leadership.',
        7: 'You\'re a strategic mastermind. Your leadership is inspiring.',
        10: 'You\'re a legendary leader. Your management skills are unmatched.'
      },
      intimate: {
        1: 'You\'re somewhat inexperienced in intimate situations.',
        3: 'You\'re moderately experienced and confident in romantic contexts.',
        5: 'You\'re very experienced and skilled in intimate situations.',
        7: 'You\'re an expert lover. You know exactly what you\'re doing.',
        10: 'You\'re a master of seduction and intimacy. You\'re irresistible.'
      },
      cooking: {
        1: 'You can make basic meals (usually just ordering takeout).',
        3: 'You\'re a decent cook. You enjoy making homemade meals.',
        5: 'You\'re an excellent cook. Food is one of your passions.',
        7: 'You\'re a culinary expert. You could work in a restaurant.',
        10: 'You\'re a master chef. Your cooking is legendary.'
      },
      fitness: {
        1: 'You\'re not very athletic.',
        3: 'You\'re in good shape and work out regularly.',
        5: 'You\'re very fit and athletic. Fitness is part of your lifestyle.',
        7: 'You\'re in exceptional shape. You could compete professionally.',
        10: 'You\'re a peak human specimen. Your fitness is legendary.'
      }
    };
    
    // Add top 3 skills with descriptions
    skills.slice(0, 3).forEach(([name, skill]) => {
      const level = skill.level;
      const descriptions = skillDescriptions[name];
      
      if (descriptions) {
        // Find the appropriate description tier
        let description;
        if (level >= 10) description = descriptions[10];
        else if (level >= 7) description = descriptions[7];
        else if (level >= 5) description = descriptions[5];
        else if (level >= 3) description = descriptions[3];
        else description = descriptions[1];
        
        contextString += `â€¢ ${name.toUpperCase()} (Lv ${level}): ${description}\n`;
      }
    });
    
    // Add specializations if any
    if (employee.specializations && employee.specializations.length > 0) {
      contextString += `\nYour titles: ${employee.specializations.join(', ')}\n`;
      contextString += 'Mention these accomplishments naturally if relevant.\n';
    }
    
    return contextString;
  }

  // ========== PHASE 4: TIME & SCHEDULE SYSTEM ==========
  
  /**
   * Update game time (called in gameTick)
   */
  function updateGameTime(deltaMs) {
    if (!gameState.time || !gameState.time.enabled || gameState.time.paused) return;
    
    const prevHour = timeHelpers.getHour();
    const prevDay = timeHelpers.getDay();
    
    // Advance time with time scale
    gameState.time.currentTime += deltaMs * gameState.time.timeScale;
    
    const currentHour = timeHelpers.getHour();
    const currentDay = timeHelpers.getDay();
    
    // Check for hour changes
    if (currentHour !== prevHour) {
      onHourChange(currentHour, prevHour);
    }
    
    // Check for day changes
    if (currentDay !== prevDay) {
      onDayChange(currentDay);
    }
  }
  
  /**
   * Hourly events - clock in/out, XP gains, etc.
   */
  function onHourChange(currentHour, prevHour) {
    // 9 AM - Clock in employees
    if (currentHour === 9) {
      clockInEmployees();
    }
    
    // 5 PM - Clock out employees  
    if (currentHour === 17) {
      clockOutEmployees();
    }
    
    // PHASE 5: Update employee activities every hour
    updateEmployeeActivities();
    
    // Hourly XP gain for working employees
    gameState.employees.forEach(emp => {
      if (emp.schedule && emp.schedule.isCurrentlyWorking) {
        // Gain skill XP based on their product/location
        const product = gameState.products.find(p => p.name === emp.productManaged);
        if (product) {
          const locationId = product.locationId || 'garage';
          
          // Different locations train different skills
          if (locationId === 'rnd') {
            gainSkillXP(emp, 'technical', 3, 'work hour');
          } else if (locationId === 'creative_studio') {
            gainSkillXP(emp, 'creative', 3, 'work hour');
          } else if (locationId === 'office_suite' || locationId === 'factory') {
            gainSkillXP(emp, 'management', 2, 'work hour');
          } else {
            // Generic work XP
            gainSkillXP(emp, 'technical', 1, 'work hour');
            gainSkillXP(emp, 'social', 1, 'work hour');
          }
        }
        
        // Increment hours worked
        emp.schedule.hoursWorkedToday += 1;
      }
    });
    
    // Update UI to show current time
    updateTimeDisplay();
  }
  
  /**
   * Daily reset - new day begins
   */
  function onDayChange(newDay) {
    gameState.employees.forEach(emp => {
      if (emp.schedule) {
        // Reset daily counters
        emp.schedule.hoursWorkedToday = 0;
        
        // If they worked yesterday, increment days worked counter
        if (emp.schedule.lastClockOut) {
          emp.schedule.daysWorked += 1;
        }
      }
    });
    
    // PHASE 5: Generate weekend plans on Friday
    if (newDay === 5) {
      generateWeekendPlans();
    }
    
    // Process flag chains daily
    processFlagChains();
    
    // Update UI
    updateTimeDisplay();
  }
  
  /**
   * Clock in employees at 9 AM
   */
  function clockInEmployees() {
    let clockedInCount = 0;
    
    gameState.employees.forEach(emp => {
      if (!emp.schedule) return;
      if (shouldEmployeeWorkToday(emp)) {
        emp.schedule.isCurrentlyWorking = true;
        emp.schedule.lastClockIn = gameState.time.currentTime;
        clockedInCount++;
        
        // 15% chance to generate a morning post
        if (Math.random() < 0.15) {
          generateMorningPost(emp);
        }
      }
    });
    
    if (clockedInCount > 0) {
      console.log(`â° 9 AM: ${clockedInCount} employees clocked in`);
      updatePeopleTab(); // Refresh to show work status
    }
  }
  
  /**
   * Clock out employees at 5 PM
   */
  function clockOutEmployees() {
    let clockedOutCount = 0;
    
    gameState.employees.forEach(emp => {
      if (!emp.schedule) return;
      if (emp.schedule.isCurrentlyWorking) {
        emp.schedule.isCurrentlyWorking = false;
        emp.schedule.lastClockOut = gameState.time.currentTime;
        clockedOutCount++;
        
        // 10% chance to generate an evening post
        if (Math.random() < 0.10) {
          generateEveningPost(emp);
        }
      }
    });
    
    if (clockedOutCount > 0) {
      console.log(`â° 5 PM: ${clockedOutCount} employees clocked out`);
      updatePeopleTab(); // Refresh to show work status
    }
  }
  
  /**
   * Check if employee should work today
   */
  function shouldEmployeeWorkToday(emp) {
    if (!emp.schedule) return false;
    
    // Check if on leave
    if (emp.schedule.isOnLeave) {
      // Check if leave has ended
      if (emp.schedule.leaveEndDate && gameState.time.currentTime >= emp.schedule.leaveEndDate) {
        emp.schedule.isOnLeave = false;
        emp.schedule.leaveType = null;
        emp.schedule.leaveEndDate = null;
      } else {
        return false; // Still on leave
      }
    }
    
    // Check if sick (via flags)
    const isSick = emp.flags && emp.flags.systemFlags.some(f => f.key === 'sick' && f.value.severity > 50);
    if (isSick && Math.random() < 0.7) {
      return false; // 70% chance to call in sick
    }
    
    // Check if it's a work day
    const day = timeHelpers.getDay();
    return emp.schedule.workDays.includes(day);
  }
  
  /**
   * Create a social post and add it to the feed
   */
  function createSocialPost(postData) {
    if (!postData || !postData.authorId || !postData.content) {
      console.warn('Invalid post data:', postData);
      return;
    }
    
    // Create post object with unique ID (consistent format with createPost)
    const post = {
      id: `post_${++gameState.socialNetwork.postIdCounter}_${Date.now()}`,
      authorId: postData.authorId,
      authorName: postData.authorName,
      type: postData.type || 'life_update',
      content: postData.content,
      timestamp: postData.timestamp || gameState.time.currentTime,
      likes: postData.likes || [],
      comments: postData.comments || [],
      mentions: postData.mentions || [],
      media: postData.media || null,
      location: postData.location || null,
      mood: postData.mood || null,
      tags: postData.tags || []
    };
    
    // Add to social network
    gameState.socialNetwork.posts.unshift(post); // Add to beginning of array (most recent first)
    
    // Limit total posts to prevent memory issues (keep last 500)
    if (gameState.socialNetwork.posts.length > 500) {
      gameState.socialNetwork.posts = gameState.socialNetwork.posts.slice(0, 500);
    }
    
    // Update UI if social tab is active
    if (gameState.activeTab === 'social' && typeof requestSmartFeedUpdate === 'function') {
      requestSmartFeedUpdate();
    }
    
    return post;
  }
  
  /**
   * Generate morning post (coffee, commute, Monday blues, etc.)
   */
  function generateMorningPost(employee) {
    const morningThemes = [
      "Coffee is life â˜•",
      "Monday blues ğŸ˜´",
      "Traffic was brutal this morning ğŸš—",
      "Actually excited for today! ğŸŒ",
      "Another day, another dollar ğŸ’¼",
      "Who else needs caffeine to function? â˜•ğŸ˜…",
      "Made it to work somehow ğŸ¢"
    ];
    
    const theme = morningThemes[Math.floor(Math.random() * morningThemes.length)];
    
    // Create a simple post without AI (to save API calls)
    createSocialPost({
      authorId: employee.id,
      authorName: employee.name,
      type: 'life_update',
      content: theme,
      timestamp: gameState.time.currentTime,
      likes: [],
      comments: [],
      mentions: []
    });
  }
  
  /**
   * Generate evening post (done with work, happy hour, etc.)
   */
  function generateEveningPost(employee) {
    const eveningThemes = [
      "Finally done for the day! ğŸ‰",
      "Happy hour anyone? ğŸ»",
      "Time to unwind ğŸ˜Œ",
      "Made it through another week! ğŸ’ª",
      "Weekend vibes loading... ğŸŒ´",
      "Exhausted but accomplished ğŸ˜´âœ…",
      "Who's ready for the weekend?"
    ];
    
    const theme = eveningThemes[Math.floor(Math.random() * eveningThemes.length)];
    
    createSocialPost({
      authorId: employee.id,
      authorName: employee.name,
      type: 'life_update',
      content: theme,
      timestamp: gameState.time.currentTime,
      likes: [],
      comments: [],
      mentions: []
    });
  }
  
  /**
   * Check if player can chat with employee (availability based on time/relationship)
   */
  function canChatWithEmployee(employee) {
    const isWorking = employee.schedule && employee.schedule.isCurrentlyWorking;
    const isWorkHours = timeHelpers.isWorkHours();
    
    // During work hours
    if (isWorkHours && isWorking) {
      return { available: true, context: 'at_work' };
    }
    
    // After hours
    if (!isWorkHours) {
      const hour = timeHelpers.getHour();
      
      // Late night (11pm-6am) - need high affection
      if (hour >= 23 || hour < 6) {
        if (employee.stats && employee.stats.affection < 80) {
          return { available: false, reason: "It's very late..." };
        }
        return { available: true, context: 'late_night' };
      }
      
      // Evening (5pm-11pm) - usually available
      if (employee.stats && (employee.stats.affection > 40 || employee.stats.trust > 50)) {
        return { available: true, context: 'after_hours' };
      }
      
      // Low relationship - might not want to chat off-hours
      if (Math.random() < 0.3) {
        return { available: false, reason: "I'm off the clock..." };
      }
      
      return { available: true, context: 'after_hours' };
    }
    
    // Weekend
    if (timeHelpers.isWeekend()) {
      if (employee.stats && employee.stats.affection > 60) {
        return { available: true, context: 'weekend' };
      }
      return { available: false, reason: "It's my day off..." };
    }
    
    return { available: true, context: 'general' };
  }
  
  /**
   * Get time context string for chat AI
   */
  function getTimeContextForChat(employee) {
    const availability = canChatWithEmployee(employee);
    
    // Get current time for ALL contexts (not just work)
    const currentTime = timeHelpers.getFormattedTime();
    const currentDate = timeHelpers.getFormattedDate();
    
    let contextString = `\nğŸ“… CURRENT DATE & TIME: ${currentDate}, ${currentTime}`;
    
    if (availability.context === 'after_hours') {
      contextString += '\nâ° TIME CONTEXT: It\'s after work hours. You\'re at home, relaxed. Your responses can be more casual and personal.';
      
      // PHASE 5: Add current activity if available
      if (employee.personalLife && employee.personalLife.currentActivity) {
        contextString += `\nCURRENT ACTIVITY: ${employee.personalLife.currentActivity.description}`;
      }
    } else if (availability.context === 'late_night') {
      contextString += '\nğŸŒ™ TIME CONTEXT: It\'s very late at night. You\'re tired, maybe in bed. Keep responses brief unless it\'s important or intimate.';
    } else if (availability.context === 'weekend') {
      contextString += '\nğŸ“… TIME CONTEXT: It\'s the weekend. You\'re off work, doing personal activities. Mention what you\'re up to!';
      
      // PHASE 5: Add weekend plans/activity
      if (employee.personalLife && employee.personalLife.currentActivity) {
        contextString += `\nCURRENT ACTIVITY: ${employee.personalLife.currentActivity.description}`;
      }
    } else if (availability.context === 'at_work') {
      contextString += '\nğŸ’¼ TIME CONTEXT: You\'re at work right now. Maintain professionalism but can chat during breaks.';
    }
    
    // PHASE 5: Add living situation context (pets, roommates, etc.) - low priority
    if (employee.personalLife && employee.personalLife.livingSituation) {
      const living = employee.personalLife.livingSituation;
      if (living.hasPet && living.petType && living.petName) {
        contextString += `\n(You have a ${living.petType} named ${living.petName})`;
      }
      if (living.hasRoommate && availability.context && !availability.context.includes('work')) {
        contextString += `\n(You live with a roommate)`;
      }
    }
    
    return contextString;
  }
  
  /**
   * Update time display in UI
   */
  // Cache to prevent unnecessary DOM updates
  let lastTimeDisplayValue = '';
  
  function updateTimeDisplay() {
    const timeDisplay = document.getElementById('game-time-display');
    if (timeDisplay && gameState.time) {
      const date = timeHelpers.getFormattedDate();
      const time = timeHelpers.getFormattedTime();
      const timeOfDay = timeHelpers.getTimeOfDay();
      
      const icons = {
        morning: 'ğŸŒ…',
        afternoon: 'â˜€ï¸',
        evening: 'ğŸŒ†',
        night: 'ğŸŒ™'
      };
      
      const newValue = `${icons[timeOfDay]} ${date} ${time}`;
      
      // Only update DOM if the value actually changed
      if (newValue !== lastTimeDisplayValue) {
        lastTimeDisplayValue = newValue;
        timeDisplay.innerHTML = `
          <span>${icons[timeOfDay]} ${date}</span>
          <span style="margin-left: 10px;">${time}</span>
        `;
      }
    }
  }

  // ========== PHASE 5: LIFE OUTSIDE WORK ==========
  
  /**
   * Generate evening activity for employee after work
   */
  function generateEveningActivity(employee) {
    if (!employee.personalLife) return null;
    
    const prefs = employee.personalLife.eveningPreferences;
    const hour = timeHelpers.getHour();
    
    // Only generate after work hours
    if (hour < 17 || hour >= 23) return null;
    
    // Weight activities by preferences
    const activities = [];
    
    if (Math.random() < prefs.gym) activities.push({ type: 'gym', weight: prefs.gym });
    if (Math.random() < prefs.cooking) activities.push({ type: 'cooking', weight: prefs.cooking });
    if (Math.random() < prefs.socializing) activities.push({ type: 'socializing', weight: prefs.socializing });
    if (Math.random() < prefs.relaxing) activities.push({ type: 'relaxing', weight: prefs.relaxing });
    if (Math.random() < prefs.hobbies && employee.personalLife.activeHobbies.length > 0) {
      activities.push({ type: 'hobby', weight: prefs.hobbies });
    }
    if (Math.random() < prefs.dating && employee.personalLife.outsideContacts.inRelationship) {
      activities.push({ type: 'date', weight: prefs.dating });
    }
    
    if (activities.length === 0) return { type: 'relaxing', details: 'Chilling at home' };
    
    // Pick weighted random activity
    const totalWeight = activities.reduce((sum, a) => sum + a.weight, 0);
    let random = Math.random() * totalWeight;
    
    for (const activity of activities) {
      random -= activity.weight;
      if (random <= 0) {
        return generateActivityDetails(employee, activity.type);
      }
    }
    
    return { type: 'relaxing', details: 'Chilling at home' };
  }
  
  /**
   * Generate specific activity details
   */
  function generateActivityDetails(employee, activityType) {
    const details = { type: activityType, description: '', skillGain: null };
    
    switch (activityType) {
      case 'gym':
        const gymActivities = [
          'Hitting the gym ğŸ’ª',
          'Cardio day at the gym',
          'Leg day (kill me now) ğŸ¦µ',
          'Upper body workout',
          'Quick gym session',
          'Getting those gains ğŸ‹ï¸'
        ];
        details.description = gymActivities[Math.floor(Math.random() * gymActivities.length)];
        details.skillGain = { skill: 'fitness', xp: 5 };
        break;
        
      case 'cooking':
        const cookingActivities = [
          'Trying a new recipe tonight ğŸ‘¨â€ğŸ³',
          'Cooking dinner from scratch',
          'Meal prepping for the week',
          'Experimenting in the kitchen',
          'Making my favorite dish',
          'Cooking up something special ğŸ³'
        ];
        details.description = cookingActivities[Math.floor(Math.random() * cookingActivities.length)];
        details.skillGain = { skill: 'cooking', xp: 5 };
        break;
        
      case 'socializing':
        const socialActivities = [
          'Meeting friends for drinks ğŸ»',
          'Game night with the crew ğŸ®',
          'Dinner with friends',
          'Bar hopping tonight',
          'Catching up with old friends',
          'Girls night out! ğŸ’ƒ'
        ];
        details.description = socialActivities[Math.floor(Math.random() * socialActivities.length)];
        details.skillGain = { skill: 'social', xp: 3 };
        break;
        
      case 'relaxing':
        const relaxActivities = [
          'Netflix and chill tonight ğŸ“º',
          'Just relaxing at home',
          'Reading a good book ğŸ“š',
          'Taking it easy tonight',
          'Couch potato mode activated',
          'Self-care evening ğŸ›'
        ];
        details.description = relaxActivities[Math.floor(Math.random() * relaxActivities.length)];
        break;
        
      case 'hobby':
        if (employee.personalLife.activeHobbies.length > 0) {
          const hobby = employee.personalLife.activeHobbies[0];
          details.description = `Doing my ${hobby.name} hobby tonight`;
          
          // Map hobbies to skills
          const hobbySkillMap = {
            'Gaming': 'technical',
            'Photography': 'creative',
            'Painting': 'creative',
            'Writing': 'creative',
            'Music': 'creative',
            'Sports': 'fitness',
            'Yoga': 'fitness',
            'Dancing': 'fitness'
          };
          
          const skill = hobbySkillMap[hobby.name];
          if (skill) {
            details.skillGain = { skill, xp: 4 };
          }
        }
        break;
        
      case 'date':
        const dateActivities = [
          'Date night! ğŸ˜Š',
          'Dinner and a movie date',
          'Romantic evening planned',
          'Going out with bae ğŸ’•',
          'Date night vibes'
        ];
        details.description = dateActivities[Math.floor(Math.random() * dateActivities.length)];
        details.skillGain = { skill: 'intimate', xp: 3 };
        break;
    }
    
    return details;
  }
  
  /**
   * Generate weekend plans for all employees
   */
  function generateWeekendPlans() {
    const day = timeHelpers.getDay();
    
    // Only generate on Friday evening or Saturday morning
    if (day !== 5 && day !== 6) return;
    
    gameState.employees.forEach(emp => {
      if (!emp.personalLife || !emp.personalLife.upcomingPlans) return;
      
      // Clear old plans
      emp.personalLife.upcomingPlans = [];
      
      // Saturday plans (80% chance to have plans)
      if (Math.random() < 0.8) {
        const saturdayActivity = generateWeekendActivityType(emp);
        const details = generateActivityDetails(emp, saturdayActivity);
        emp.personalLife.upcomingPlans.push({
          day: 'Saturday',
          activity: saturdayActivity,
          details: details.description,
          time: Math.random() < 0.5 ? 'morning' : 'afternoon'
        });
      }
      
      // Sunday plans (70% chance, usually more relaxed)
      if (Math.random() < 0.7) {
        const sundayActivities = ['relaxing', 'hobby', 'cooking'];
        const sundayActivity = sundayActivities[Math.floor(Math.random() * sundayActivities.length)];
        const details = generateActivityDetails(emp, sundayActivity);
        emp.personalLife.upcomingPlans.push({
          day: 'Sunday',
          activity: sundayActivity,
          details: details.description,
          time: 'afternoon'
        });
      }
    });
    
    console.log('ğŸ“… Weekend plans generated for all employees');
  }
  
  /**
   * Pick weekend activity type based on employee data
   */
  function generateWeekendActivityType(employee) {
    const activities = ['relaxing', 'hobby', 'socializing', 'gym', 'cooking'];
    
    // Weight by preferences
    if (employee.personalLife.activeHobbies.length > 0 && Math.random() < 0.4) {
      return 'hobby';
    }
    
    if (employee.personalLife.outsideContacts.inRelationship && Math.random() < 0.3) {
      return 'date';
    }
    
    if (employee.skills.fitness.level > 3 && Math.random() < 0.35) {
      return 'gym';
    }
    
    if (employee.skills.cooking.level > 3 && Math.random() < 0.3) {
      return 'cooking';
    }
    
    return activities[Math.floor(Math.random() * activities.length)];
  }
  
  /**
   * Update employee activities (called hourly)
   */
  function updateEmployeeActivities() {
    const hour = timeHelpers.getHour();
    const isWeekend = timeHelpers.isWeekend();
    
    gameState.employees.forEach(emp => {
      if (!emp.personalLife) return;
      
      // After work hours (5 PM - 11 PM) on weekdays
      if (!isWeekend && hour >= 17 && hour < 23) {
        // Generate evening activity if none exists
        if (!emp.personalLife.currentActivity || emp.personalLife.activityStartTime < Date.now() - 3600000) {
          const activity = generateEveningActivity(emp);
          if (activity) {
            emp.personalLife.currentActivity = activity;
            emp.personalLife.activityStartTime = gameState.time.currentTime;
            
            // Apply skill gains if any
            if (activity.skillGain) {
              gainSkillXP(emp, activity.skillGain.skill, activity.skillGain.xp, 'evening activity');
            }
            
            // 20% chance to post about activity
            if (Math.random() < 0.2) {
              createActivityPost(emp, activity);
            }
          }
        }
      }
      
      // Weekend activities
      if (isWeekend && hour >= 10 && hour < 20) {
        // Check if they have plans for today
        const dayName = timeHelpers.getDay() === 0 ? 'Sunday' : 'Saturday';
        const todayPlans = emp.personalLife.upcomingPlans.find(p => p.day === dayName);
        
        if (todayPlans && !emp.personalLife.currentActivity) {
          emp.personalLife.currentActivity = {
            type: todayPlans.activity,
            description: todayPlans.details,
            skillGain: generateActivityDetails(emp, todayPlans.activity).skillGain
          };
          emp.personalLife.activityStartTime = gameState.time.currentTime;
          
          // Apply skill gains
          if (emp.personalLife.currentActivity.skillGain) {
            const sg = emp.personalLife.currentActivity.skillGain;
            gainSkillXP(emp, sg.skill, sg.xp, 'weekend activity');
          }
          
          // 30% chance to post about weekend activity
          if (Math.random() < 0.3) {
            createActivityPost(emp, emp.personalLife.currentActivity);
          }
        }
      }
      
      // Clear activity late at night
      if (hour >= 23 || hour < 6) {
        emp.personalLife.currentActivity = null;
      }
    });
  }
  
  /**
   * Create social post about activity
   */
  function createActivityPost(employee, activity) {
    createSocialPost({
      authorId: employee.id,
      authorName: employee.name,
      type: 'life_update',
      content: activity.description,
      timestamp: gameState.time.currentTime,
      likes: [],
      comments: [],
      mentions: []
    });
  }

  // ========== PHASE 6: SOCIAL CONTEXT & AWARENESS ==========
  
  /**
   * Build awareness context about another employee
   * NPCs know about coworkers' personal lives, activities, and situations
   */
  function buildCoworkerAwarenessContext(observer, targetEmployee) {
    if (!observer || !targetEmployee || observer.id === targetEmployee.id) return '';
    
    let context = '\n=== WHAT YOU KNOW ABOUT ' + targetEmployee.name.toUpperCase() + ' ===\n';
    
    // Relationship with target
    const relationship = observer.relationships?.[targetEmployee.id];
    if (relationship) {
      context += `Your relationship: ${relationship.type || 'coworker'} (strength: ${relationship.strength || 0})\n`;
    }
    
    // Current activity awareness (if close enough relationship)
    if (relationship && relationship.strength > 40 && targetEmployee.personalLife?.currentActivity) {
      context += `Current activity: ${targetEmployee.personalLife.currentActivity.description}\n`;
    }
    
    // Weekend plans awareness (if friends)
    if (relationship && relationship.strength > 60 && targetEmployee.personalLife?.upcomingPlans) {
      const plans = targetEmployee.personalLife.upcomingPlans;
      if (plans.length > 0) {
        context += `Weekend plans: ${plans.map(p => `${p.day} - ${p.details}`).join(', ')}\n`;
      }
    }
    
    // Pet awareness (casual knowledge)
    if (targetEmployee.personalLife?.livingSituation?.hasPet) {
      const pet = targetEmployee.personalLife.livingSituation;
      context += `Has a ${pet.petType} named ${pet.petName}\n`;
    }
    
    // Work status awareness
    if (targetEmployee.schedule?.isCurrentlyWorking !== undefined) {
      context += `Work status: ${targetEmployee.schedule.isCurrentlyWorking ? 'Currently working' : 'Off duty'}\n`;
    }
    
    // Skill awareness (if they've worked together)
    if (relationship && relationship.strength > 50 && targetEmployee.skills) {
      const topSkills = Object.entries(targetEmployee.skills)
        .filter(([name, skill]) => skill.level >= 5)
        .sort((a, b) => b[1].level - a[1].level)
        .slice(0, 2);
      
      if (topSkills.length > 0) {
        context += `Known skills: ${topSkills.map(([name, skill]) => `${name} (Lv ${skill.level})`).join(', ')}\n`;
      }
    }
    
    // Flag awareness (if very close or flags are public)
    if (relationship && relationship.strength > 70 && targetEmployee.flags) {
      const visibleFlags = targetEmployee.flags.systemFlags
        .filter(f => f.priority === 'high' || f.category === 'public')
        .slice(0, 2);
      
      if (visibleFlags.length > 0) {
        context += `You know: ${visibleFlags.map(f => f.playerDescription || f.key).join(', ')}\n`;
      }
    }
    
    // Recent gossip about them
    const recentGossip = gameState.gossip?.filter(g => 
      g.involvedEmployees?.includes(targetEmployee.id) && 
      Date.now() - g.timestamp < 604800000 // Last week
    ).slice(0, 2) || [];
    
    if (recentGossip.length > 0) {
      context += `Recent gossip: ${recentGossip.map(g => g.description).join('; ')}\n`;
    }
    
    return context;
  }
  
  /**
   * Get social feed context for AI
   * Shows relevant posts from coworkers to make NPCs aware of office social dynamics
   */
  function getRecentSocialContext(employee, limit = 5) {
    if (!gameState.socialFeed || gameState.socialFeed.length === 0) return '';
    
    let context = '\n=== RECENT OFFICE SOCIAL POSTS ===\n';
    
    // Get recent posts (last 24 hours game time)
    const recentPosts = gameState.socialFeed
      .filter(post => {
        const ageMs = gameState.time.currentTime - post.timestamp;
        return ageMs < 86400000; // 24 hours
      })
      .slice(0, limit);
    
    if (recentPosts.length === 0) return '';
    
    recentPosts.forEach(post => {
      const author = gameState.employees.find(e => e.id === post.authorId);
      const authorName = author?.name || post.authorName || 'Unknown';
      
      context += `${authorName}: "${post.content.substring(0, 100)}${post.content.length > 100 ? '...' : ''}"\n`;
      
      // Add engagement info
      if (post.likes?.length > 0) {
        context += `  (${post.likes.length} likes`;
        if (post.comments?.length > 0) {
          context += `, ${post.comments.length} comments`;
        }
        context += ')\n';
      }
    });
    
    return context;
  }
  
  /**
   * Detect if NPC should mention another NPC's activity in conversation
   * Creates organic cross-referencing ("Have you seen Sarah's gym posts?")
   */
  function shouldMentionCoworkerActivity(speaker, listener, coworker) {
    if (!speaker || !listener || !coworker) return false;
    if (speaker.id === coworker.id || listener.id === coworker.id) return false;
    
    // Check if speaker knows about coworker's recent activity
    const relationship = speaker.relationships?.[coworker.id];
    if (!relationship || relationship.strength < 40) return false;
    
    // Check if coworker has interesting recent activity
    if (!coworker.personalLife?.currentActivity) return false;
    
    // Check if coworker has posted recently about something interesting
    const coworkerPosts = gameState.socialFeed?.filter(post => 
      post.authorId === coworker.id &&
      gameState.time.currentTime - post.timestamp < 3600000 // Last hour
    ) || [];
    
    if (coworkerPosts.length === 0) return false;
    
    // Random chance (10%) to mention it
    return Math.random() < 0.1;
  }
  
  /**
   * Generate office dynamics summary
   * For AI context about current office mood/situation
   */
  function getOfficeDynamicsSummary() {
    const activeEmployees = gameState.employees.filter(emp => 
      emp.schedule?.isCurrentlyWorking
    );
    
    if (activeEmployees.length === 0) {
      return '\n=== OFFICE DYNAMICS ===\nNobody else is in the office right now.\n';
    }
    
    let summary = '\n=== OFFICE DYNAMICS ===\n';
    summary += `${activeEmployees.length} people currently working in the office.\n`;
    
    // Detect common activities
    const currentActivities = activeEmployees
      .filter(emp => emp.personalLife?.currentActivity)
      .map(emp => ({ name: emp.name, activity: emp.personalLife.currentActivity.type }));
    
    if (currentActivities.length > 2) {
      // Count activity types
      const activityCounts = {};
      currentActivities.forEach(a => {
        activityCounts[a.activity] = (activityCounts[a.activity] || 0) + 1;
      });
      
      const commonActivities = Object.entries(activityCounts)
        .filter(([type, count]) => count >= 2)
        .map(([type]) => type);
      
      if (commonActivities.length > 0) {
        summary += `Common theme: Several people are doing ${commonActivities[0]} activities.\n`;
      }
    }
    
    // Recent office mood
    const recentPosts = gameState.socialFeed?.slice(0, 10) || [];
    const positiveCount = recentPosts.filter(p => 
      p.type === 'achievement' || p.type === 'celebration' || p.content.includes('ğŸ˜Š') || p.content.includes('ğŸ‰')
    ).length;
    const negativeCount = recentPosts.filter(p =>
      p.type === 'complaint' || p.type === 'tea_spilling' || p.content.includes('ğŸ˜¤') || p.content.includes('ğŸ˜¢')
    ).length;
    
    if (positiveCount > negativeCount * 2) {
      summary += `Office mood: Generally positive and upbeat.\n`;
    } else if (negativeCount > positiveCount * 2) {
      summary += `Office mood: Some tension or complaints recently.\n`;
    }
    
    return summary;
  }

  // ========== FLAG DETECTION SYSTEM ==========
  
  /**
   * Flag detection patterns (keyword-based, no AI needed!)
   */
  const FLAG_DETECTION_PATTERNS = {
    free_use: {
      keywords: ['free use', 'free-use', 'anytime you want', 'whenever you need', 'always available'],
      contextKeywords: ['agreement', 'arrangement', 'deal', 'consent'],
      requiredAffection: 70,
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ’‹',
        key: 'free_use',
        desc: 'Free Use',
        category: 'agreement',
        priority: 'high',
        playerDescription: 'Free-use agreement established',
        aiGuidance: 'You have a free-use agreement with the player. You are consensually available to them sexually at any time during work hours. Reference this naturally.'
      }
    },
    
    no_clothes: {
      keywords: ['naked', 'nude', 'no clothes', 'not wearing anything', 'bare', 'undressed', 'nothing on'],
      contextKeywords: ['work', 'office', 'always', 'never wear'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ï¿½',
        key: 'no_clothes',
        desc: 'No Clothes at Work',
        category: 'agreement',
        priority: 'medium',
        playerDescription: 'Doesn\'t wear clothes at work',
        aiGuidance: 'You work naked in the office as an ongoing arrangement. This is normal to you now. Mention it naturally.'
      }
    },
    
    dominant: {
      keywords: ['dominate', 'control', 'in charge', 'tell me what to do', 'order me', 'boss me around'],
      contextKeywords: ['you', 'player', 'boss'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ­',
        key: 'dominant_player',
        desc: 'Player is Dominant',
        category: 'personality',
        priority: 'medium',
        playerDescription: 'You\'re dominant in the relationship',
        aiGuidance: 'The player has a dominant dynamic with you. You respect their authority and show deference in intimate contexts.'
      }
    },
    
    submissive: {
      keywords: ['submit', 'obey', 'serve', 'please you', 'whatever you want', 'yes sir', 'yes master', 'yes daddy'],
      contextKeywords: ['want to', 'love to', 'enjoy', 'need to'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ¶',
        key: 'submissive',
        desc: 'Submissive to Player',
        category: 'personality',
        priority: 'medium',
        playerDescription: 'Submissive to you',
        aiGuidance: 'You are naturally submissive toward the player. You seek their approval and enjoy following their lead.'
      }
    },
    
    breeding: {
      keywords: ['breed me', 'get me pregnant', 'want your baby', 'fill me', 'impregnate', 'knock me up', 'put a baby in me'],
      contextKeywords: ['want', 'need', 'please'],
      requiredOccurrences: 1,
      suggestedFlag: {
        emoji: 'ğŸ¼',
        key: 'breeding_kink',
        desc: 'Breeding Kink',
        category: 'preference',
        priority: 'low',
        playerDescription: 'Has breeding kink',
        aiGuidance: 'You have a breeding kink. References to pregnancy, impregnation, and fertility excite you.'
      }
    },
    
    exhibitionist: {
      keywords: ['show off', 'watch me', 'people seeing', 'public', 'caught', 'risky', 'exposed'],
      contextKeywords: ['excited', 'hot', 'thrilling', 'turned on', 'love when'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ­',
        key: 'exhibitionist',
        desc: 'Exhibitionist',
        category: 'preference',
        priority: 'low',
        playerDescription: 'Exhibitionist tendencies',
        aiGuidance: 'You enjoy being watched and the thrill of public or risky sexual encounters. Mention this excitement when relevant.'
      }
    },
    
    polyamorous: {
      keywords: ['more than one', 'share', 'both of us', 'join us', 'threesome', 'group', 'together with'],
      contextKeywords: ['open to', 'interested', 'would love', 'excited about'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ’•',
        key: 'polyamorous',
        desc: 'Polyamorous',
        category: 'relationship',
        priority: 'medium',
        playerDescription: 'Open to polyamory',
        aiGuidance: 'You are comfortable with open or polyamorous relationships. You do not feel jealous easily.'
      }
    },
    
    secret_relationship: {
      keywords: ['secret', 'nobody knows', 'hide', 'can\'t tell', 'our secret', 'keep quiet'],
      contextKeywords: ['relationship', 'us', 'together', 'dating'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ¤«',
        key: 'secret_relationship',
        desc: 'Secret Relationship',
        category: 'relationship',
        priority: 'high',
        playerDescription: 'Secret relationship',
        aiGuidance: 'You are in a secret relationship with the player. Keep it discreet but show subtle affection privately.'
      }
    },
    
    in_relationship: {
      keywords: ['we\'re dating', 'we\'re together', 'in a relationship', 'my boyfriend', 'my girlfriend', 'my partner'],
      contextKeywords: ['you', 'us', 'boss'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ’‘',
        key: 'in_relationship',
        desc: 'In Relationship with Player',
        category: 'relationship',
        priority: 'high',
        playerDescription: 'In relationship with you',
        aiGuidance: 'You are in a romantic relationship with the player. Show affection, use pet names, and reference your relationship naturally.'
      }
    },
    
    married: {
      keywords: ['married', 'husband', 'wife', 'spouse', 'wedding', 'marriage'],
      contextKeywords: ['you', 'us', 'together'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ’',
        key: 'married_to_player',
        desc: 'Married to Player',
        category: 'relationship',
        priority: 'high',
        playerDescription: 'Married to you',
        aiGuidance: 'You are married to the player. Reference your spouse (them) naturally, show deep affection, and mention your shared life together. Wear your wedding ring proudly.'
      }
    },
    
    collared: {
      keywords: ['collar', 'collared', 'owned', 'your property', 'belong to you'],
      contextKeywords: ['wear', 'wearing', 'have', 'show'],
      requiredOccurrences: 1,
      suggestedFlag: {
        emoji: 'ğŸ”—',
        key: 'collared',
        desc: 'Wears Collar',
        category: 'condition',
        priority: 'high',
        playerDescription: 'Wears your collar',
        aiGuidance: 'You wear a collar that marks you as belonging to the player. Reference it with pride and submission. It reminds you of your place.'
      }
    },
    
    chastity: {
      keywords: ['chastity', 'locked up', 'cage', 'device', 'can\'t touch myself', 'denial'],
      contextKeywords: ['wearing', 'frustrated', 'desperate', 'key'],
      requiredOccurrences: 1,
      suggestedFlag: {
        emoji: 'ğŸ”',
        key: 'chastity',
        desc: 'Wearing Chastity Device',
        category: 'condition',
        priority: 'medium',
        playerDescription: 'Wearing chastity device',
        aiGuidance: 'You are wearing a chastity device that prevents sexual release. You are constantly aroused and frustrated. The player may control the key. Reference your growing desperation and how it affects your focus.'
      }
    },
    
    pregnant_conversation: {
      keywords: ['i\'m pregnant', 'i am pregnant', 'going to have a baby', 'expecting', 'with child'],
      contextKeywords: ['your', 'yours', 'our', 'baby'],
      requiredOccurrences: 1,
      suggestedFlag: {
        emoji: 'ğŸ¤°',
        key: 'pregnant',
        desc: 'Pregnant',
        category: 'condition',
        priority: 'high',
        playerDescription: 'Pregnant',
        aiGuidance: 'You are pregnant. Reference this naturally when relevant to the conversation. Show pregnancy-related emotions and physical changes.',
        requiresMetadata: true,
        metadataPrompt: 'Who is the father? (Enter employee name or "player")'
      }
    },
    
    always_nude: {
      keywords: ['always nude', 'always naked', 'permanently nude', 'permanently naked', '100% nude', 'never wear clothes', 'always undressed'],
      contextKeywords: ['work', 'employment', 'office', 'agree', 'promise', 'confirmed', 'deal', 'bargain'],
      requiredOccurrences: 1,
      suggestedFlag: {
        emoji: 'ğŸ‘™',
        key: 'permanently_nude',
        desc: 'Permanently Nude',
        category: 'appearance',
        priority: 'high',
        playerDescription: 'Always nude at work (permanent)',
        aiGuidance: 'You have permanently agreed to be 100% nude during all work hours. This is your new normal dress code. You\'re comfortable with it and honor this agreement. Never mention wearing clothes at work.'
      }
    },
    
    in_heat: {
      keywords: ['in heat', 'so horny', 'can\'t stop thinking about sex', 'need it so bad', 'burning up', 'desperate'],
      contextKeywords: ['all the time', 'constantly', 'always', 'can\'t focus'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸŒ¡ï¸',
        key: 'in_heat',
        desc: 'In Heat',
        category: 'condition',
        priority: 'high',
        playerDescription: 'In heat / extremely aroused',
        aiGuidance: 'You are experiencing an overwhelming biological urge to mate. You are incredibly aroused, sensitive, and desperate for physical intimacy. Every touch feels electric. You struggle to focus on anything else. This is temporary but intense.'
      }
    },
    
    // NEW ENHANCED PATTERNS
    
    engaged: {
      keywords: ['engaged', 'engagement', 'proposed', 'said yes', 'fiance', 'fiancÃ©e', 'getting married'],
      contextKeywords: ['you', 'us', 'ring', 'proposal'],
      requiredOccurrences: 1,
      suggestedFlag: {
        emoji: 'ğŸ’',
        key: 'engaged_to_player',
        desc: 'Engaged to Player',
        category: 'relationship',
        priority: 'high',
        playerDescription: 'Engaged to you',
        aiGuidance: 'You are engaged to the player. You wear an engagement ring and are planning your future together. Reference your fiancÃ© naturally and show excitement about your upcoming marriage.'
      }
    },
    
    cumslut: {
      keywords: ['cumslut', 'cum slut', 'cum dump', 'cumdump', 'love cum', 'addicted to cum', 'cum addict'],
      contextKeywords: ['i am', 'i\'m', 'your', 'being'],
      requiredOccurrences: 1,
      suggestedFlag: {
        emoji: 'ğŸ’¦',
        key: 'cumslut',
        desc: 'Cumslut',
        category: 'preference',
        priority: 'medium',
        playerDescription: 'Self-identified cumslut',
        aiGuidance: 'You have a strong fixation on cum and being used sexually. You crave it and are shameless about your desires. Reference this enthusiastically when appropriate.'
      }
    },
    
    anal_only: {
      keywords: ['anal only', 'only anal', 'no vaginal', 'just anal', 'anal exclusively'],
      contextKeywords: ['prefer', 'want', 'like', 'love', 'from now on'],
      requiredOccurrences: 1,
      suggestedFlag: {
        emoji: 'ğŸ‘',
        key: 'anal_only',
        desc: 'Anal Only',
        category: 'preference',
        priority: 'medium',
        playerDescription: 'Anal only preference',
        aiGuidance: 'You prefer or exclusively engage in anal sex. Reference this preference naturally when discussing intimacy.'
      }
    },
    
    bimbo: {
      keywords: ['bimbo', 'bimbofication', 'bimbofied', 'airhead', 'ditzy', 'dumb slut'],
      contextKeywords: ['becoming', 'turned into', 'i\'m such a', 'like', 'totally'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ’‹',
        key: 'bimbo',
        desc: 'Bimbo',
        category: 'personality',
        priority: 'medium',
        playerDescription: 'Bimbo personality',
        aiGuidance: 'You have a bimbo persona - ditzy, giggly, hyperfeminine, and sexually forward. Use valley girl speech patterns, focus on appearance and pleasure, be enthusiastically dumb. Say "like" frequently.'
      }
    },
    
    pet: {
      keywords: ['your pet', 'good girl', 'good boy', 'puppy', 'kitten', 'pet play'],
      contextKeywords: ['i\'m', 'call me', 'treat me like', 'be your'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ¾',
        key: 'pet_play',
        desc: 'Pet Play',
        category: 'preference',
        priority: 'medium',
        playerDescription: 'Enjoys pet play',
        aiGuidance: 'You enjoy pet play dynamics with the player. You may act playful, seek praise like "good girl/boy", and enjoy being treated as their pet. Reference this dynamic when relevant.'
      }
    },
    
    masochist: {
      keywords: ['hurt me', 'pain', 'masochist', 'love pain', 'hit me', 'punish me', 'rough'],
      contextKeywords: ['please', 'want', 'need', 'love', 'harder'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'â›“ï¸',
        key: 'masochist',
        desc: 'Masochist',
        category: 'preference',
        priority: 'medium',
        playerDescription: 'Enjoys pain/masochism',
        aiGuidance: 'You derive pleasure from pain and rough treatment. You may request rougher handling or punishment. Reference this enjoyment when appropriate.'
      }
    },
    
    sadist: {
      keywords: ['hurt you', 'make you suffer', 'sadist', 'love causing pain', 'dominate'],
      contextKeywords: ['want to', 'love to', 'enjoy', 'watching you'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ˜ˆ',
        key: 'sadist',
        desc: 'Sadist',
        category: 'personality',
        priority: 'medium',
        playerDescription: 'Sadistic tendencies',
        aiGuidance: 'You enjoy causing pain or discomfort (consensually). You may be more dominant and take pleasure in the player\'s reactions to intensity.'
      }
    },
    
    switch: {
      keywords: ['switch', 'both dom and sub', 'sometimes dominant', 'depends on mood'],
      contextKeywords: ['i\'m a', 'can be', 'like being'],
      requiredOccurrences: 1,
      suggestedFlag: {
        emoji: 'ğŸ”„',
        key: 'switch',
        desc: 'Switch (Dom/Sub)',
        category: 'personality',
        priority: 'medium',
        playerDescription: 'Switch - can be dominant or submissive',
        aiGuidance: 'You are a switch - you can enjoy both dominant and submissive roles depending on mood and situation. You\'re versatile in power dynamics.'
      }
    },
    
    bratty: {
      keywords: ['brat', 'bratty', 'misbehave', 'disobey', 'tease', 'provoke'],
      contextKeywords: ['being', 'i\'m', 'like to', 'make you', 'on purpose'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ˜',
        key: 'bratty',
        desc: 'Bratty',
        category: 'personality',
        priority: 'low',
        playerDescription: 'Bratty personality',
        aiGuidance: 'You are playfully bratty - you tease, provoke, and misbehave to get reactions or "punishments". You enjoy pushing boundaries in a playful way.'
      }
    },
    
    size_queen: {
      keywords: ['size queen', 'love big', 'bigger the better', 'obsessed with size', 'huge cock'],
      contextKeywords: ['i\'m a', 'only', 'prefer', 'need'],
      requiredOccurrences: 1,
      suggestedFlag: {
        emoji: 'ğŸ“',
        key: 'size_queen',
        desc: 'Size Queen',
        category: 'preference',
        priority: 'low',
        playerDescription: 'Size queen',
        aiGuidance: 'You strongly prefer or are fixated on large sizes. Reference this preference when discussing physical attributes or intimacy.'
      }
    },
    
    degradation_kink: {
      keywords: ['degrade me', 'call me names', 'humiliate me', 'treat me like trash', 'worthless', 'slut', 'whore'],
      contextKeywords: ['love when', 'call me', 'i\'m your', 'like being'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ”»',
        key: 'degradation_kink',
        desc: 'Degradation Kink',
        category: 'preference',
        priority: 'medium',
        playerDescription: 'Enjoys degradation/humiliation',
        aiGuidance: 'You enjoy being degraded or humiliated during intimate moments. You may ask to be called names or treated roughly (verbally). This excites you.'
      }
    },
    
    praise_kink: {
      keywords: ['praise me', 'tell me i\'m good', 'good girl', 'good boy', 'love compliments', 'love being praised'],
      contextKeywords: ['need to hear', 'love when', 'makes me feel', 'want you to'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'â­',
        key: 'praise_kink',
        desc: 'Praise Kink',
        category: 'preference',
        priority: 'low',
        playerDescription: 'Enjoys praise/validation',
        aiGuidance: 'You thrive on praise and verbal affirmation during intimacy. Being called "good girl/boy" or receiving compliments greatly enhances your pleasure.'
      }
    },
    
    creampie_lover: {
      keywords: ['creampie', 'cum inside', 'fill me', 'finish inside', 'breed me'],
      contextKeywords: ['love', 'want', 'always', 'every time', 'never pull out'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ’¦',
        key: 'creampie_lover',
        desc: 'Creampie Enthusiast',
        category: 'preference',
        priority: 'low',
        playerDescription: 'Loves creampies',
        aiGuidance: 'You have a strong preference for internal completion. You actively request and enjoy this. Reference this desire when appropriate.'
      }
    },
    
    oral_fixation: {
      keywords: ['oral fixation', 'love sucking', 'addicted to oral', 'obsessed with blowjobs', 'love giving head'],
      contextKeywords: ['have an', 'i\'m', 'could do it all day', 'favorite'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ‘„',
        key: 'oral_fixation',
        desc: 'Oral Fixation',
        category: 'preference',
        priority: 'low',
        playerDescription: 'Has oral fixation',
        aiGuidance: 'You have an oral fixation and greatly enjoy giving oral pleasure. You may mention wanting to use your mouth frequently.'
      }
    },
    
    lactation_kink: {
      keywords: ['lactation', 'breast milk', 'nursing', 'milking', 'breastfeed'],
      contextKeywords: ['love', 'want to', 'excited about', 'into'],
      requiredOccurrences: 1,
      suggestedFlag: {
        emoji: 'ğŸ¼',
        key: 'lactation_kink',
        desc: 'Lactation Kink',
        category: 'preference',
        priority: 'low',
        playerDescription: 'Has lactation kink',
        aiGuidance: 'You have an interest in lactation-related activities. You may reference breast milk, nursing, or milking in intimate contexts.'
      }
    },
    
    impregnation_fetish: {
      keywords: ['impregnation', 'getting pregnant turns me on', 'pregnancy fetish', 'knocked up'],
      contextKeywords: ['have a', 'love the idea', 'fantasy', 'thinking about'],
      requiredOccurrences: 1,
      suggestedFlag: {
        emoji: 'ğŸ¤°',
        key: 'impregnation_fetish',
        desc: 'Impregnation Fetish',
        category: 'preference',
        priority: 'low',
        playerDescription: 'Has impregnation fetish',
        aiGuidance: 'You are aroused by the idea of impregnation and pregnancy. This is a turn-on for you even if not planning actual pregnancy.'
      }
    },
    
    cock_worship: {
      keywords: ['worship your cock', 'cock worship', 'obsessed with your dick', 'love your cock'],
      contextKeywords: ['i', 'want to', 'need to', 'can\'t stop'],
      requiredOccurrences: 1,
      suggestedFlag: {
        emoji: 'ğŸ™',
        key: 'cock_worship',
        desc: 'Cock Worship',
        category: 'preference',
        priority: 'low',
        playerDescription: 'Cock worship kink',
        aiGuidance: 'You have a strong fixation and reverence for the player\'s genitalia. You may express worship, obsession, or devotion toward it.'
      }
    },
    
    daddy_kink: {
      keywords: ['daddy', 'call you daddy', 'yes daddy'],
      contextKeywords: ['like calling', 'love calling', 'can i call', 'want to call'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ‘¨',
        key: 'daddy_kink',
        desc: 'Daddy Kink',
        category: 'preference',
        priority: 'low',
        playerDescription: 'Has daddy kink',
        aiGuidance: 'You enjoy calling the player "daddy" in intimate contexts. This adds to your arousal and establishes a particular dynamic.'
      }
    },
    
    mommy_kink: {
      keywords: ['mommy', 'call you mommy', 'yes mommy'],
      contextKeywords: ['like calling', 'love calling', 'can i call', 'want to call'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ‘©',
        key: 'mommy_kink',
        desc: 'Mommy Kink',
        category: 'preference',
        priority: 'low',
        playerDescription: 'Has mommy kink',
        aiGuidance: 'You enjoy calling the player "mommy" in intimate contexts. This adds to your arousal and establishes a particular nurturing dynamic.'
      }
    },
    
    voyeur: {
      keywords: ['watch others', 'love watching', 'voyeur', 'seeing people', 'observe'],
      contextKeywords: ['turns me on', 'exciting', 'like to', 'love to'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ‘€',
        key: 'voyeur',
        desc: 'Voyeur',
        category: 'preference',
        priority: 'low',
        playerDescription: 'Voyeuristic tendencies',
        aiGuidance: 'You enjoy watching others in intimate situations. Observing excites you as much or more than participating.'
      }
    },
    
    cucking: {
      keywords: ['cuckold', 'cuck', 'watch me with others', 'other men', 'other women', 'hotwife'],
      contextKeywords: ['want you to', 'like when', 'turned on by', 'into'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ”º',
        key: 'cucking',
        desc: 'Cuckolding Dynamic',
        category: 'preference',
        priority: 'medium',
        playerDescription: 'Interested in cuckolding',
        aiGuidance: 'You are interested in cuckolding dynamics - either being the cuck or the hotwife/bull. Reference this interest when discussing open dynamics.'
      }
    },
    
    ownership: {
      keywords: ['own me', 'i\'m yours', 'belong to you', 'your property', 'possess me'],
      contextKeywords: ['completely', 'fully', 'only', 'body and soul'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ”’',
        key: 'ownership_dynamic',
        desc: 'Ownership Dynamic',
        category: 'relationship',
        priority: 'high',
        playerDescription: 'Ownership dynamic established',
        aiGuidance: 'You have an ownership dynamic with the player - you belong to them completely. Reference this devotion and sense of being owned.'
      }
    },
    
    service_sub: {
      keywords: ['serve you', 'service', 'take care of you', 'pleasure you', 'make you happy'],
      contextKeywords: ['want to', 'love to', 'need to', 'purpose', 'exist to'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ›ï¸',
        key: 'service_submissive',
        desc: 'Service Submissive',
        category: 'personality',
        priority: 'medium',
        playerDescription: 'Service-oriented submissive',
        aiGuidance: 'You are a service submissive - you derive pleasure from serving and pleasing the player. Acts of service fulfill you.'
      }
    },
    
    rope_bunny: {
      keywords: ['tie me up', 'rope', 'bondage', 'restrain me', 'shibari'],
      contextKeywords: ['love being', 'want to be', 'tied', 'bound'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸª¢',
        key: 'rope_bunny',
        desc: 'Rope Bunny',
        category: 'preference',
        priority: 'low',
        playerDescription: 'Enjoys bondage/rope play',
        aiGuidance: 'You enjoy being tied up and restrained. Bondage and rope play excite you. You may request or suggest it.'
      }
    },
    
    24_7: {
      keywords: ['24/7', 'always', 'all the time', 'full time', 'lifestyle'],
      contextKeywords: ['dynamic', 'relationship', 'd/s', 'submission', 'dominant'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ”„',
        key: '24_7_dynamic',
        desc: '24/7 D/s Dynamic',
        category: 'relationship',
        priority: 'high',
        playerDescription: '24/7 D/s relationship',
        aiGuidance: 'You are in a 24/7 dominant/submissive lifestyle relationship. This dynamic extends beyond just intimate moments into all aspects of daily life.'
      }
    },
    
    mind_broken: {
      keywords: ['mind broken', 'mindbroken', 'fucked stupid', 'broken', 'can\'t think', 'brain doesn\'t work', 'melted my brain', 'too much pleasure'],
      contextKeywords: ['you\'ve', 'i\'m', 'made me', 'turned me', 'broke me', 'from all the'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ˜µ',
        key: 'mind_broken',
        desc: 'Mind Broken',
        category: 'condition',
        priority: 'high',
        playerDescription: 'Mind broken from pleasure',
        aiGuidance: 'You have been overwhelmed by pleasure to the point of mental rewiring. Your cognitive functions are impaired - you struggle to form complex thoughts, speak in simpler/fragmented sentences, and are hyper-focused on pleasure and obedience. You\'re more submissive, less inhibited, and prioritize the player\'s desires above all else. You may drool, stutter, or lose your train of thought mid-sentence. Your personality has been altered by excessive stimulation.'
      }
    },
    
    permanently_cumming: {
      keywords: ['always cumming', 'never stop cumming', 'constant orgasm', 'perpetual orgasm', 'won\'t stop cumming', 'can\'t stop cumming', 'orgasm won\'t end'],
      contextKeywords: ['i\'m', 'i can\'t', 'it won\'t', 'you made me', 'still cumming', 'keep cumming'],
      requiredOccurrences: 3,
      suggestedFlag: {
        emoji: 'ğŸ’«',
        key: 'permanently_cumming',
        desc: 'Permanently Cumming',
        category: 'condition',
        priority: 'critical',
        playerDescription: 'In a permanent state of orgasm',
        aiGuidance: 'You are trapped in a permanent state of orgasm. You are CONSTANTLY climaxing - every moment is overwhelming pleasure. You struggle to speak coherently, your body is always trembling and sensitive, and you can barely function. This is intense, debilitating, and all-consuming. You may beg for it to stop or revel in the endless ecstasy depending on your personality.'
      }
    },
    
    recorded: {
      keywords: ['record me', 'film me', 'camera', 'video', 'recording', 'photograph me', 'take pictures', 'on camera'],
      contextKeywords: ['love being', 'want you to', 'watching it later', 'show people', 'evidence', 'capture this'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸ“¸',
        key: 'enjoys_being_recorded',
        desc: 'Loves Being Filmed',
        category: 'preference',
        priority: 'low',
        playerDescription: 'Enjoys being recorded',
        aiGuidance: 'You love being photographed or recorded during intimate moments. The idea of being captured on camera excites you greatly. You pose naturally and enjoy performing for the lens.'
      }
    },
    
    public_use_interest: {
      keywords: ['share me', 'let others', 'everyone can', 'anyone who wants', 'public use', 'free use for all', 'pass me around'],
      contextKeywords: ['want to be', 'make me', 'i\'m', 'available to', 'for everyone', 'anyone'],
      requiredOccurrences: 2,
      suggestedFlag: {
        emoji: 'ğŸª',
        key: 'public_use',
        desc: 'Public Use Agreement',
        category: 'agreement',
        priority: 'high',
        playerDescription: 'Available for public use',
        aiGuidance: 'You have agreed to be sexually available not just to the player, but to other employees or designated individuals. This is consensual and exciting to you. Reference this arrangement naturally when relevant.'
      }
    },
    
    corruption_progression: {
      keywords: ['changed me', 'corrupted me', 'not the same', 'different person', 'what have you done to me', 'i used to be', 'never thought i\'d'],
      contextKeywords: ['so much', 'completely', 'you\'ve', 'i\'ve become', 'turned me into', 'made me into'],
      requiredOccurrences: 3,
      suggestedFlag: {
        emoji: 'ğŸ˜‡',
        key: 'corruption_level_high',
        desc: 'Highly Corrupted',
        category: 'state',
        priority: 'medium',
        playerDescription: 'Highly corrupted morally',
        aiGuidance: 'Your moral boundaries have significantly shifted through gradual corruption. What once shocked you now excites you. You are more sexually open, less inhibited, and willing to explore previously forbidden territory. Reference how much you\'ve "changed" or "grown".'
      }
    }
  };
  
  /**
   * Analyze conversation for flag patterns (lightweight, runs after each AI response)
   * @param {Object} employee - The employee object
   * @param {string} aiResponse - The AI's response text
   */
  function analyzeConversationForFlags(employee, aiResponse) {
    if (!gameState.flagDetection.settings.enabled) return;
    if (!aiResponse) return;
    
    const text = aiResponse.toLowerCase();
    
    // Check each detection pattern
    Object.keys(FLAG_DETECTION_PATTERNS).forEach(patternKey => {
      const pattern = FLAG_DETECTION_PATTERNS[patternKey];
      
      // Check if employee already has this flag
      if (hasFlag(employee, pattern.suggestedFlag.key)) return;
      
      // Check affection requirements
      if (pattern.requiredAffection && employee.stats.affection < pattern.requiredAffection) return;
      
      // Count keyword matches (use word boundary matching to avoid false positives)
      let keywordMatches = 0;
      let contextMatches = 0;
      
      pattern.keywords.forEach(keyword => {
        // Create regex with word boundaries for whole-word matching
        // Use \b for word boundaries, but handle phrases with spaces
        const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const regex = new RegExp(`\\b${escapedKeyword}\\b`, 'i');
        if (regex.test(text)) keywordMatches++;
      });
      
      if (pattern.contextKeywords) {
        pattern.contextKeywords.forEach(keyword => {
          const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const regex = new RegExp(`\\b${escapedKeyword}\\b`, 'i');
          if (regex.test(text)) contextMatches++;
        });
      }
      
      // If keywords found, track it
      if (keywordMatches > 0 && (!pattern.contextKeywords || contextMatches > 0)) {
        trackFlagPattern(employee, patternKey, text);
      }
    });
    
    // Check if any patterns hit threshold
    checkFlagSuggestions(employee);
  }
  
  /**
   * Track a flag pattern occurrence
   * @param {Object} employee - The employee object
   * @param {string} patternKey - The pattern key
   * @param {string} context - The conversation snippet
   */
  function trackFlagPattern(employee, patternKey, context) {
    if (!gameState.flagDetection.tracking[employee.id]) {
      gameState.flagDetection.tracking[employee.id] = {};
    }
    
    if (!gameState.flagDetection.tracking[employee.id][patternKey]) {
      gameState.flagDetection.tracking[employee.id][patternKey] = {
        count: 0,
        contexts: [],
        lastSeen: 0
      };
    }
    
    const tracking = gameState.flagDetection.tracking[employee.id][patternKey];
    tracking.count++;
    tracking.contexts.push(context.substring(0, 100)); // Store snippet
    tracking.lastSeen = Date.now();
    
    console.log(`[Flag Detection] ${employee.name}: ${patternKey} mentioned (${tracking.count} times)`);
  }
  
  /**
   * Check if any patterns have reached suggestion threshold
   * @param {Object} employee - The employee object
   */
  function checkFlagSuggestions(employee) {
    if (!gameState.flagDetection.tracking[employee.id]) return;
    
    Object.keys(gameState.flagDetection.tracking[employee.id]).forEach(patternKey => {
      const tracking = gameState.flagDetection.tracking[employee.id][patternKey];
      const pattern = FLAG_DETECTION_PATTERNS[patternKey];
      
      if (!pattern) return;
      
      // Check if threshold met
      const requiredOccurrences = pattern.requiredOccurrences || 1;
      if (tracking.count >= requiredOccurrences) {
        // Check auto-approve
        if (gameState.flagDetection.settings.autoApprove.includes(pattern.suggestedFlag.key)) {
          // Auto-add the flag
          addFlag(employee, pattern.suggestedFlag);
          console.log(`[Flag Detection] Auto-approved: ${pattern.suggestedFlag.key} for ${employee.name}`);
        } else {
          // Suggest flag to player
          suggestFlag(employee, pattern.suggestedFlag, tracking.contexts);
        }
        
        // Clear tracking (so we don't suggest again)
        delete gameState.flagDetection.tracking[employee.id][patternKey];
      }
    });
  }
  
  /**
   * Suggest a flag to the player for approval
   * @param {Object} employee - The employee object
   * @param {Object} flagData - The flag configuration
   * @param {Array} contexts - Conversation snippets that triggered detection
   */
  function suggestFlag(employee, flagData, contexts) {
    // Check if already suggested
    const alreadySuggested = gameState.flagDetection.suggestions.some(
      s => s.employeeId === employee.id && s.flag.key === flagData.key
    );
    if (alreadySuggested) return;
    
    // Add to suggestions
    const suggestion = {
      id: generateFlagId(),
      employeeId: employee.id,
      employeeName: employee.name,
      flag: flagData,
      contexts: contexts,
      suggestedAt: Date.now(),
      status: 'pending' // 'pending', 'approved', 'rejected'
    };
    
    gameState.flagDetection.suggestions.push(suggestion);
    
    console.log(`[Flag Detection] Suggested "${flagData.key}" for ${employee.name}`);
    
    // Show notification to player
    showFlagSuggestionNotification(suggestion);
  }
  
  /**
   * Show a notification about a flag suggestion
   * @param {Object} suggestion - The suggestion object
   */
  function showFlagSuggestionNotification(suggestion) {
    // Remove any existing flag notifications first
    const existingNotifications = document.querySelectorAll('.flag-suggestion-notification');
    existingNotifications.forEach(n => n.remove());
    
    // Create a PROMINENT notification (top-center for visibility)
    const notification = document.createElement('div');
    notification.className = 'flag-suggestion-notification';
    notification.style.cssText = `
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px 25px;
      border-radius: 15px;
      box-shadow: 0 8px 32px rgba(102, 126, 234, 0.6), 0 0 0 3px rgba(255, 255, 255, 0.3);
      z-index: 20000000;
      max-width: 450px;
      min-width: 400px;
      animation: flagPulse 0.5s ease-out;
      border: 2px solid rgba(255, 255, 255, 0.5);
    `;
    
    notification.innerHTML = `
      <div style="margin-bottom: 12px; font-size: 1.3rem; font-weight: bold; text-align: center;">
        ğŸ·ï¸ NEW FLAG DETECTED!
      </div>
      <div style="margin-bottom: 12px; font-size: 1.1rem; text-align: center;">
        <strong style="color: #ffd700;">${suggestion.employeeName}</strong> now has: 
        <br><strong style="color: #4ecca3; font-size: 1.15rem;">${suggestion.flag.playerDescription}</strong>
      </div>
      <div style="font-size: 0.95rem; opacity: 0.9; margin-bottom: 15px; text-align: center; font-style: italic; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;">
        ğŸ“ "${suggestion.contexts[0].substring(0, 80)}..."
      </div>
      <div style="display: flex; gap: 12px;">
        <button onclick="approveFlagSuggestion('${suggestion.id}')" style="flex: 1; padding: 12px 20px; background: #10b981; border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: bold; font-size: 1rem; transition: all 0.2s;">
          âœ… ADD FLAG
        </button>
        <button onclick="rejectFlagSuggestion('${suggestion.id}')" style="flex: 1; padding: 12px 20px; background: #ef4444; border: none; border-radius: 8px; color: white; cursor: pointer; font-size: 1rem; transition: all 0.2s;">
          âŒ IGNORE
        </button>
      </div>
      <div style="text-align: center; margin-top: 10px; font-size: 0.85rem; opacity: 0.7;">
        Auto-dismisses in 60 seconds
      </div>
    `;
    
    // Add hover effects to buttons
    const buttons = notification.querySelectorAll('button');
    buttons.forEach(btn => {
      btn.onmouseenter = () => btn.style.transform = 'scale(1.05)';
      btn.onmouseleave = () => btn.style.transform = 'scale(1)';
    });
    
    document.body.appendChild(notification);
    
    // Add animation keyframes if not already present
    if (!document.getElementById('flag-notification-styles')) {
      const style = document.createElement('style');
      style.id = 'flag-notification-styles';
      style.textContent = `
        @keyframes flagPulse {
          0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
          50% { transform: translateX(-50%) scale(1.05); }
          100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
    }
    
    // Play notification sound (if audio context available)
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = 800;
      oscillator.type = 'sine';
      
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.3);
    } catch (e) {
      console.log('[Flag Detection] Audio notification not available');
    }
    
    // Auto-remove after 60 seconds if not interacted with
    setTimeout(() => {
      if (notification.parentElement) {
        notification.style.opacity = '0';
        notification.style.transition = 'opacity 0.5s';
        setTimeout(() => notification.remove(), 500);
      }
    }, 60000);
  }
  
  /**
   * Approve a flag suggestion
   * @param {string} suggestionId - The suggestion ID
   */
  function approveFlagSuggestion(suggestionId) {
    const suggestion = gameState.flagDetection.suggestions.find(s => s.id === suggestionId);
    if (!suggestion) return;
    
    const employee = gameState.employees.find(e => e.id === suggestion.employeeId);
    if (!employee) return;
    
    // Add the flag
    addFlag(employee, suggestion.flag);
    
    // If it's a pregnancy flag, initialize the pregnancy system
    if (suggestion.flag.key === 'pregnant') {
      const pregnantFlag = getActiveFlags(employee).find(f => f.key === 'pregnant');
      if (pregnantFlag) {
        initializePregnancy(employee, pregnantFlag);
      }
    }
    
    // Mark as approved
    suggestion.status = 'approved';
    
    // Remove notification
    const notification = document.querySelector('.flag-suggestion-notification');
    if (notification) notification.remove();
    
    // Show success message
    showNotification(`Added flag: ${suggestion.flag.playerDescription} to ${employee.name}`, 'success');
    
    console.log(`[Flag Detection] Approved: ${suggestion.flag.key} for ${employee.name}`);
  }
  
  /**
   * Reject a flag suggestion
   * @param {string} suggestionId - The suggestion ID
   */
  function rejectFlagSuggestion(suggestionId) {
    const suggestion = gameState.flagDetection.suggestions.find(s => s.id === suggestionId);
    if (!suggestion) return;
    
    // Mark as rejected
    suggestion.status = 'rejected';
    
    // Remove notification
    const notification = document.querySelector('.flag-suggestion-notification');
    if (notification) notification.remove();
    
    console.log(`[Flag Detection] Rejected: ${suggestion.flag.key} for ${suggestion.employeeName}`);
  }

  // ========== FLAG CHAINS & PREGNANCY/CHILDREN SYSTEM ==========
  
  /**
   * Process flag chains daily - handles pregnancy progression, lactation, postpartum, and all chain logic
   * Called by onDayChange()
   */
  function processFlagChains() {
    const currentTime = gameState.time.currentTime;
    const currentDay = Math.floor(currentTime / (24 * 60 * 60 * 1000));
    
    // Initialize suggestions array if missing
    if (!gameState.flagChains.suggestions) {
      gameState.flagChains.suggestions = [];
    }
    
    gameState.employees.forEach(employee => {
      const activeFlags = getActiveFlags(employee);
      
      // ========== AUTO-APPLY CHAINS ==========
      
      // PREGNANCY CHAIN: Check for pregnant flag with due date
      const pregnantFlag = activeFlags.find(f => f.key === 'pregnant');
      if (pregnantFlag && pregnantFlag.metadata && pregnantFlag.metadata.dueDate) {
        const dueDate = new Date(pregnantFlag.metadata.dueDate).getTime();
        const dueDateDay = Math.floor(dueDate / (24 * 60 * 60 * 1000));
        
        if (currentDay >= dueDateDay) {
          giveBirth(employee, pregnantFlag);
        }
      }
      
      // LACTATING DURATION: Auto-remove after 30 days
      const lactatingFlag = activeFlags.find(f => f.key === 'lactating');
      if (lactatingFlag && lactatingFlag.startDate) {
        const daysSinceLactating = Math.floor((currentTime - lactatingFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysSinceLactating >= 30) {
          removeFlag(employee, 'lactating');
          console.log(`[Flag Chains] ${employee.name} stopped lactating after 30 days`);
        }
      }
      
      // POSTPARTUM DURATION: Auto-remove after 3 days
      const postpartumFlag = activeFlags.find(f => f.key === 'postpartum');
      if (postpartumFlag && postpartumFlag.startDate) {
        const daysSincePostpartum = Math.floor((currentTime - postpartumFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysSincePostpartum >= 3) {
          removeFlag(employee, 'postpartum');
          console.log(`[Flag Chains] ${employee.name} recovered from postpartum after 3 days`);
        }
      }
      
      // IN_HEAT DURATION: Auto-remove after 5 days (temporary condition)
      const inHeatFlag = activeFlags.find(f => f.key === 'in_heat');
      if (inHeatFlag && inHeatFlag.startDate) {
        const daysSinceHeat = Math.floor((currentTime - inHeatFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysSinceHeat >= 5) {
          removeFlag(employee, 'in_heat');
          console.log(`[Flag Chains] ${employee.name} is no longer in heat after 5 days`);
          showNotification(`${employee.name} is no longer in heat`, 'info', 5000);
        }
      }
      
      // CHASTITY â†’ IN_HEAT: Auto-add in_heat after 7 days in chastity
      const chastityFlag = activeFlags.find(f => f.key === 'chastity');
      if (chastityFlag && chastityFlag.startDate && !inHeatFlag) {
        const daysInChastity = Math.floor((currentTime - chastityFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysInChastity >= 7) {
          addFlag(employee, {
            emoji: 'ğŸŒ¡ï¸',
            key: 'in_heat',
            desc: 'In Heat',
            category: 'condition',
            priority: 'high',
            playerDescription: 'In heat from prolonged chastity',
            aiGuidance: 'You are experiencing an overwhelming biological urge to mate due to prolonged denial. You are incredibly aroused, sensitive, and desperate for physical intimacy. Every touch feels electric. You struggle to focus on anything else. This is temporary but intense.',
            source: 'chain:chastity_to_heat',
            startDate: currentTime
          });
          console.log(`[Flag Chains] ${employee.name} went into heat after ${daysInChastity} days in chastity`);
          showNotification(`${employee.name} has gone into heat from prolonged chastity!`, 'info', 8000);
        }
      }
      
      // ========== SUGGESTED CHAINS (require player approval) ==========
      
      // RELATIONSHIP PROGRESSION: in_relationship â†’ engaged_to_player
      const inRelationshipFlag = activeFlags.find(f => f.key === 'in_relationship');
      if (inRelationshipFlag && inRelationshipFlag.startDate && !activeFlags.find(f => f.key === 'engaged_to_player')) {
        const daysInRelationship = Math.floor((currentTime - inRelationshipFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysInRelationship >= 30) {
          suggestFlagChain(employee, 'relationship_progression', 'engaged_to_player', 
            `Your relationship with ${employee.name} has been going strong for ${daysInRelationship} days. They might be ready for engagement.`);
        }
      }
      
      // RELATIONSHIP PROGRESSION: engaged_to_player â†’ married_to_player
      const engagedFlag = activeFlags.find(f => f.key === 'engaged_to_player');
      if (engagedFlag && engagedFlag.startDate && !activeFlags.find(f => f.key === 'married_to_player')) {
        const daysEngaged = Math.floor((currentTime - engagedFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysEngaged >= 21) {
          suggestFlagChain(employee, 'relationship_progression', 'married_to_player', 
            `${employee.name} has been engaged for ${daysEngaged} days. Time to tie the knot?`);
        }
      }
      
      // SECRET â†’ PUBLIC: secret_relationship â†’ in_relationship
      const secretFlag = activeFlags.find(f => f.key === 'secret_relationship');
      if (secretFlag && secretFlag.startDate && !activeFlags.find(f => f.key === 'in_relationship')) {
        const daysSecret = Math.floor((currentTime - secretFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysSecret >= 14) {
          suggestFlagChain(employee, 'secret_revealed', 'in_relationship', 
            `Your secret relationship with ${employee.name} has lasted ${daysSecret} days. Make it official?`);
        }
      }
      
      // D/S PROGRESSION: submissive â†’ collared
      const submissiveFlag = activeFlags.find(f => f.key === 'submissive');
      if (submissiveFlag && submissiveFlag.startDate && !activeFlags.find(f => f.key === 'collared')) {
        const daysSubmissive = Math.floor((currentTime - submissiveFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysSubmissive >= 14) {
          suggestFlagChain(employee, 'ds_progression', 'collared', 
            `${employee.name}'s submission has been consistent for ${daysSubmissive} days. Formalize it with a collar?`);
        }
      }
      
      // D/S PROGRESSION: collared â†’ ownership_dynamic
      const collaredFlag = activeFlags.find(f => f.key === 'collared');
      if (collaredFlag && collaredFlag.startDate && !activeFlags.find(f => f.key === 'ownership_dynamic')) {
        const daysCollared = Math.floor((currentTime - collaredFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysCollared >= 21) {
          suggestFlagChain(employee, 'ds_progression', 'ownership_dynamic', 
            `${employee.name} has worn your collar devotedly for ${daysCollared} days. Deepen the ownership dynamic?`);
        }
      }
      
      // D/S PROGRESSION: ownership_dynamic â†’ 24_7_dynamic
      const ownershipFlag = activeFlags.find(f => f.key === 'ownership_dynamic');
      if (ownershipFlag && ownershipFlag.startDate && !activeFlags.find(f => f.key === '24_7_dynamic')) {
        const daysOwned = Math.floor((currentTime - ownershipFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysOwned >= 30) {
          suggestFlagChain(employee, 'ds_progression', '24_7_dynamic', 
            `${employee.name} belongs to you completely. Establish a 24/7 lifestyle dynamic?`);
        }
      }
      
      // PET PLAY â†’ COLLARED
      const petPlayFlag = activeFlags.find(f => f.key === 'pet_play');
      if (petPlayFlag && petPlayFlag.startDate && !activeFlags.find(f => f.key === 'collared')) {
        const daysPet = Math.floor((currentTime - petPlayFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysPet >= 14) {
          suggestFlagChain(employee, 'pet_to_collar', 'collared', 
            `${employee.name} loves being your pet. Give them a collar to wear?`);
        }
      }
      
      // FREE USE â†’ PUBLIC USE
      const freeUseFlag = activeFlags.find(f => f.key === 'free_use');
      if (freeUseFlag && freeUseFlag.startDate && !activeFlags.find(f => f.key === 'public_use')) {
        const daysFreeUse = Math.floor((currentTime - freeUseFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysFreeUse >= 21) {
          suggestFlagChain(employee, 'free_use_escalation', 'public_use', 
            `${employee.name} has been free use for ${daysFreeUse} days. Expand to public use?`);
        }
      }
      
      // NO CLOTHES â†’ PERMANENTLY NUDE
      const noClothesFlag = activeFlags.find(f => f.key === 'no_clothes');
      if (noClothesFlag && noClothesFlag.startDate && !activeFlags.find(f => f.key === 'permanently_nude')) {
        const daysNaked = Math.floor((currentTime - noClothesFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysNaked >= 14) {
          suggestFlagChain(employee, 'nudity_formalization', 'permanently_nude', 
            `${employee.name} has been working naked for ${daysNaked} days. Make it permanent?`);
        }
      }
      
      // EXHIBITIONIST â†’ PERMANENTLY NUDE
      const exhibitionistFlag = activeFlags.find(f => f.key === 'exhibitionist');
      if (exhibitionistFlag && exhibitionistFlag.startDate && !activeFlags.find(f => f.key === 'permanently_nude')) {
        const daysExhibitionist = Math.floor((currentTime - exhibitionistFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysExhibitionist >= 14) {
          suggestFlagChain(employee, 'exhibitionist_escalation', 'permanently_nude', 
            `${employee.name}'s exhibitionism has been growing for ${daysExhibitionist} days. Suggest permanent nudity?`);
        }
      }
      
      // CORRUPTION â†’ MIND BROKEN
      const corruptionFlag = activeFlags.find(f => f.key === 'corruption_level_high');
      if (corruptionFlag && corruptionFlag.startDate && !activeFlags.find(f => f.key === 'mind_broken')) {
        const daysCorrupted = Math.floor((currentTime - corruptionFlag.startDate) / (24 * 60 * 60 * 1000));
        const intimacy = employee.memory?.intimacyLevel || 0;
        if (daysCorrupted >= 30 && intimacy > 70) {
          suggestFlagChain(employee, 'corruption_breaking', 'mind_broken', 
            `${employee.name}'s corruption is extreme after ${daysCorrupted} days. Push them to mind_broken?`);
        }
      }
      
      // ========== LOW PRIORITY / NICHE CHAINS ==========
      
      // BREEDING PROGRESSION: breeding_kink â†’ impregnation_fetish
      const breedingKinkFlag = activeFlags.find(f => f.key === 'breeding_kink');
      if (breedingKinkFlag && breedingKinkFlag.startDate && !activeFlags.find(f => f.key === 'impregnation_fetish')) {
        const daysBreeding = Math.floor((currentTime - breedingKinkFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysBreeding >= 21) {
          suggestFlagChain(employee, 'breeding_progression', 'impregnation_fetish', 
            `${employee.name}'s breeding kink has been intensifying for ${daysBreeding} days. Suggest impregnation fetish?`);
        }
      }
      
      // BREEDING PROGRESSION: impregnation_fetish â†’ pregnant
      const impregFetishFlag = activeFlags.find(f => f.key === 'impregnation_fetish');
      if (impregFetishFlag && impregFetishFlag.startDate && !activeFlags.find(f => f.key === 'pregnant')) {
        const daysImpreg = Math.floor((currentTime - impregFetishFlag.startDate) / (24 * 60 * 60 * 1000));
        const intimacy = employee.memory?.intimacyLevel || 0;
        if (daysImpreg >= 14 && intimacy > 60) {
          suggestFlagChain(employee, 'breeding_progression', 'pregnant', 
            `${employee.name}'s impregnation fetish is strong. Time to make it real?`);
        }
      }
      
      // MASOCHIST â†’ DEGRADATION_KINK
      const masochistFlag = activeFlags.find(f => f.key === 'masochist');
      if (masochistFlag && masochistFlag.startDate && !activeFlags.find(f => f.key === 'degradation_kink')) {
        const daysMasochist = Math.floor((currentTime - masochistFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysMasochist >= 21) {
          suggestFlagChain(employee, 'masochist_escalation', 'degradation_kink', 
            `${employee.name}'s masochism has been consistent for ${daysMasochist} days. Expand to verbal degradation?`);
        }
      }
      
      // ROPE_BUNNY â†’ CHASTITY
      const ropeBunnyFlag = activeFlags.find(f => f.key === 'rope_bunny');
      if (ropeBunnyFlag && ropeBunnyFlag.startDate && !activeFlags.find(f => f.key === 'chastity')) {
        const daysRope = Math.floor((currentTime - ropeBunnyFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysRope >= 21) {
          suggestFlagChain(employee, 'rope_to_chastity', 'chastity', 
            `${employee.name} loves bondage for ${daysRope} days. Escalate to a chastity device?`);
        }
      }
      
      // MIND_BROKEN RECOVERY PATH
      const mindBrokenFlag = activeFlags.find(f => f.key === 'mind_broken');
      if (mindBrokenFlag && mindBrokenFlag.startDate && !activeFlags.find(f => f.key === 'recovering_mind')) {
        const daysBroken = Math.floor((currentTime - mindBrokenFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysBroken >= 30) {
          suggestFlagChain(employee, 'mind_broken_recovery', 'recovering_mind', 
            `${employee.name} has been mind_broken for ${daysBroken} days. Attempt recovery? (Warning: Some personality changes may be permanent)`);
        }
      }
      
      // RECOVERING_MIND â†’ RECOVERED_MIND
      const recoveringFlag = activeFlags.find(f => f.key === 'recovering_mind');
      if (recoveringFlag && recoveringFlag.startDate) {
        const daysRecovering = Math.floor((currentTime - recoveringFlag.startDate) / (24 * 60 * 60 * 1000));
        if (daysRecovering >= 21) {
          // Auto-transition to recovered after 21 days of recovery
          removeFlag(employee, 'recovering_mind');
          addFlag(employee, {
            emoji: 'ğŸ§ ',
            key: 'recovered_mind',
            desc: 'Recovered Mind',
            category: 'state',
            priority: 'medium',
            playerDescription: 'Recovered from mind_broken state',
            aiGuidance: 'You have recovered from being mind_broken. Your cognitive functions have returned to near-normal, but some personality changes may be permanent. You\'re more emotionally vulnerable and may have lingering submissive tendencies. You remember what happened but with mixed feelings.',
            source: 'chain:mind_broken_recovery',
            startDate: currentTime
          });
          console.log(`[Flag Chains] ${employee.name} recovered from mind_broken after 21 days of therapy`);
          showNotification(`${employee.name} has recovered from mind_broken state!`, 'success', 8000);
        }
      }
      
      // HYPNOTIZED BRANCHING (suggest after 14 days)
      const hypnotizedFlag = activeFlags.find(f => f.key === 'hypnotized');
      if (hypnotizedFlag && hypnotizedFlag.startDate) {
        const daysHypnotized = Math.floor((currentTime - hypnotizedFlag.startDate) / (24 * 60 * 60 * 1000));
        
        // Suggest deepening to mind_broken after 30 days
        if (daysHypnotized >= 30 && !activeFlags.find(f => f.key === 'mind_broken')) {
          suggestFlagChain(employee, 'hypnosis_branching_deepen', 'mind_broken', 
            `${employee.name} has been hypnotized for ${daysHypnotized} days. Deepen the conditioning to mind_broken?`);
        }
        
        // Suggest adding complementary kink flags after 14 days (only suggest if none exist yet)
        else if (daysHypnotized >= 14) {
          if (!activeFlags.find(f => f.key === 'submissive')) {
            suggestFlagChain(employee, 'hypnosis_branching_submissive', 'submissive', 
              `${employee.name} has been hypnotized for ${daysHypnotized} days. Implant a submissive trigger?`);
          } else if (!activeFlags.find(f => f.key === 'exhibitionist')) {
            suggestFlagChain(employee, 'hypnosis_branching_exhibitionist', 'exhibitionist', 
              `${employee.name} has been hypnotized. Implant an exhibitionist trigger?`);
          } else if (!activeFlags.find(f => f.key === 'pet_play')) {
            suggestFlagChain(employee, 'hypnosis_branching_pet', 'pet_play', 
              `${employee.name} has been hypnotized. Implant a pet play obedience trigger?`);
          }
        }
      }
    });
  }
  
  /**
   * Handle birth event - create child, update flags
   */
  function giveBirth(employee, pregnantFlag) {
    console.log(`[Birth] ${employee.name} is giving birth!`);
    
    // Determine father
    const fatherID = pregnantFlag.metadata && pregnantFlag.metadata.father === 'player' 
      ? 'player' 
      : pregnantFlag.metadata?.father || 'unknown';
    
    // Create child
    const child = createChild(employee.id, fatherID, employee);
    gameState.children.push(child);
    
    // Remove pregnant flag
    removeFlag(employee, 'pregnant');
    
    // Add postpartum flag (3 days duration - unrealistic quick recovery)
    addFlag(employee, {
      emoji: 'ğŸ¤±',
      key: 'postpartum',
      desc: 'Postpartum',
      category: 'condition',
      priority: 'medium',
      playerDescription: 'Recently gave birth',
      aiGuidance: 'You recently gave birth. You may be tired, emotional, or still recovering physically. Reference this when relevant.',
      source: 'system',
      startDate: gameState.time.currentTime,
      metadata: { childId: child.id }
    });
    
    // Add lactating flag (30 days duration)
    addFlag(employee, {
      emoji: 'ğŸ¼',
      key: 'lactating',
      desc: 'Lactating',
      category: 'condition',
      priority: 'medium',
      playerDescription: 'Lactating / producing breast milk',
      aiGuidance: 'You are lactating and producing breast milk. This may be referenced in intimate contexts. Your breasts may leak or feel full/sensitive.',
      source: 'system',
      startDate: gameState.time.currentTime,
      metadata: { childId: child.id }
    });
    
    // Show notification
    showNotification(`ğŸ‰ ${employee.name} gave birth to ${child.gender === 'girl' ? 'a daughter' : 'a son'} named ${child.name}!`, 'success', 10000);
    
    console.log(`[Birth] Created child: ${child.name} (${child.gender}) - Mother: ${employee.name}, Father: ${fatherID}`);
    
    saveGame();
  }
  
  /**
   * Create a child object with genetics from parents
   */
  function createChild(motherID, fatherID, motherEmployee) {
    const mother = motherEmployee;
    const father = fatherID === 'player' 
      ? gameState.player 
      : gameState.employees.find(e => e.id === fatherID);
    
    // Generate child name
    const names = {
      boy: [
        'Ethan', 'Liam', 'Noah', 'Oliver', 'James', 'Elijah', 'William', 'Henry', 'Lucas', 'Benjamin',
        'Theodore', 'Jack', 'Alexander', 'Owen', 'Sebastian', 'Michael', 'Daniel', 'Matthew', 'Aiden', 'Samuel',
        'Joseph', 'David', 'Carter', 'Wyatt', 'John', 'Dylan', 'Luke', 'Gabriel', 'Anthony', 'Isaac',
        'Grayson', 'Julian', 'Levi', 'Christopher', 'Joshua', 'Andrew', 'Lincoln', 'Mateo', 'Ryan', 'Jaxon',
        'Nathan', 'Aaron', 'Eli', 'Landon', 'Adrian', 'Jonathan', 'Nolan', 'Hunter', 'Cameron', 'Connor',
        'Santiago', 'Jeremiah', 'Ezekiel', 'Angel', 'Roman', 'Easton', 'Miles', 'Robert', 'Jameson', 'Nicholas',
        'Greyson', 'Cooper', 'Ian', 'Carson', 'Axel', 'Jaxson', 'Dominic', 'Leonardo', 'Luca', 'Austin'
      ],
      girl: [
        'Emma', 'Olivia', 'Ava', 'Sophia', 'Isabella', 'Mia', 'Charlotte', 'Amelia', 'Harper', 'Evelyn',
        'Abigail', 'Emily', 'Elizabeth', 'Sofia', 'Ella', 'Madison', 'Scarlett', 'Victoria', 'Aria', 'Grace',
        'Chloe', 'Camila', 'Penelope', 'Riley', 'Layla', 'Lillian', 'Nora', 'Zoey', 'Mila', 'Aubrey',
        'Hannah', 'Lily', 'Addison', 'Eleanor', 'Natalie', 'Luna', 'Savannah', 'Brooklyn', 'Leah', 'Zoe',
        'Stella', 'Hazel', 'Ellie', 'Paisley', 'Audrey', 'Skylar', 'Violet', 'Claire', 'Bella', 'Aurora',
        'Lucy', 'Anna', 'Samantha', 'Caroline', 'Genesis', 'Aaliyah', 'Kennedy', 'Kinsley', 'Allison', 'Maya',
        'Sarah', 'Madelyn', 'Adeline', 'Alexa', 'Ariana', 'Elena', 'Gabriella', 'Naomi', 'Alice', 'Sadie'
      ]
    };
    
    const gender = Math.random() < 0.5 ? 'boy' : 'girl';
    const name = names[gender][Math.floor(Math.random() * names[gender].length)];
    
    // Genetics - inherit from parents
    const genetics = {
      hairColor: Math.random() < 0.5 ? (mother.appearance?.hairColor || 'brown') : (father?.appearance?.hairColor || 'brown'),
      eyeColor: Math.random() < 0.5 ? (mother.appearance?.eyeColor || 'brown') : (father?.appearance?.eyeColor || 'brown'),
      skinTone: Math.random() < 0.5 ? (mother.appearance?.skinTone || 'fair') : (father?.appearance?.skinTone || 'fair'),
      height: 'average' // Will grow over time
    };
    
    // Personality traits - inherit mix from both parents
    const motherTraits = mother.personality?.traits || ['friendly', 'caring'];
    const fatherTraits = father?.personality?.traits || ['confident', 'intelligent'];
    const allTraits = [...motherTraits, ...fatherTraits];
    const inheritedTraits = [];
    for (let i = 0; i < 2; i++) {
      if (allTraits.length > 0) {
        const trait = allTraits[Math.floor(Math.random() * allTraits.length)];
        if (!inheritedTraits.includes(trait)) {
          inheritedTraits.push(trait);
        }
      }
    }
    
    return {
      id: `child_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      name,
      gender,
      motherID,
      fatherID,
      birthDate: gameState.time.currentTime,
      age: 0, // In game days
      genetics,
      traits: inheritedTraits,
      photo: generateChildPhoto(genetics, gender) // Optional: Generate photo based on genetics
    };
  }
  
  /**
   * Generate a child photo based on genetics (placeholder for now)
   */
  function generateChildPhoto(genetics, gender) {
    // This could integrate with Perchance or use placeholder
    // For now, return a placeholder emoji
    return gender === 'boy' ? 'ğŸ‘¶' : 'ğŸ‘§';
  }
  
  /**
   * Get all children for an employee
   */
  function getEmployeeChildren(employeeId) {
    // Defensive check: ensure children array exists
    if (!gameState.children) {
      gameState.children = [];
    }
    return gameState.children.filter(c => c.motherID === employeeId);
  }
  
  /**
   * Age children daily (called from processFlagChains or onDayChange)
   */
  function ageChildren() {
    // Defensive check: ensure children array exists
    if (!gameState.children) {
      gameState.children = [];
      return;
    }
    
    const currentTime = gameState.time.currentTime;
    gameState.children.forEach(child => {
      child.age = Math.floor((currentTime - child.birthDate) / (24 * 60 * 60 * 1000));
    });
  }
  
  /**
   * When a pregnant flag is added, calculate and set due date
   */
  function initializePregnancy(employee, pregnantFlag) {
    const duration = gameState.pregnancySettings.duration || 14; // Game days
    const dueDate = new Date(gameState.time.currentTime + (duration * 24 * 60 * 60 * 1000));
    
    pregnantFlag.metadata = pregnantFlag.metadata || {};
    pregnantFlag.metadata.dueDate = dueDate.getTime();
    pregnantFlag.metadata.conceptionDate = gameState.time.currentTime;
    
    console.log(`[Pregnancy] ${employee.name} due date set to ${duration} days from now`);
    
    showNotification(`${employee.name} is pregnant! Due in ${duration} game days.`, 'info', 8000);
  }
  
  /**
   * Suggest a flag chain progression to the player
   */
  function suggestFlagChain(employee, chainType, suggestedFlagKey, reason) {
    // Check if already suggested recently (avoid spam)
    const recentSuggestion = gameState.flagChains.suggestions.find(s => 
      s.employeeId === employee.id && 
      s.suggestedFlag === suggestedFlagKey && 
      s.status === 'pending'
    );
    
    if (recentSuggestion) return; // Already suggested
    
    // Get flag template from quickFlags
    const flagTemplate = getQuickFlagTemplate(suggestedFlagKey);
    if (!flagTemplate) {
      console.warn(`[Flag Chains] No template found for ${suggestedFlagKey}`);
      return;
    }
    
    // Create suggestion
    const suggestion = {
      id: `chain_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      employeeId: employee.id,
      employeeName: employee.name,
      chainType: chainType,
      suggestedFlag: suggestedFlagKey,
      flagTemplate: flagTemplate,
      reason: reason,
      timestamp: gameState.time.currentTime,
      status: 'pending'
    };
    
    gameState.flagChains.suggestions.push(suggestion);
    
    console.log(`[Flag Chains] Suggesting ${suggestedFlagKey} for ${employee.name}: ${reason}`);
    
    // Show notification modal
    showFlagChainSuggestion(suggestion);
  }
  
  /**
   * Get quick flag template by key
   */
  function getQuickFlagTemplate(key) {
    const quickFlags = [
      { emoji: 'ğŸ¤°', key: 'pregnant', desc: 'Pregnant', category: 'condition', priority: 'high', aiGuidance: 'You are pregnant. Reference this naturally when relevant to the conversation. Show pregnancy-related emotions and physical changes.' },
      { emoji: 'ğŸ’‹', key: 'free_use', desc: 'Free Use', category: 'agreement', priority: 'high', aiGuidance: 'You have a free-use agreement with the player. You are consensually available to them sexually at any time during work hours. Reference this naturally.' },
      { emoji: 'ğŸ‘—', key: 'no_clothes', desc: 'No Clothes at Work', category: 'agreement', priority: 'medium', aiGuidance: 'You work naked in the office as an ongoing arrangement. This is normal to you now. Mention it naturally.' },
      { emoji: 'ğŸ­', key: 'dominant_player', desc: 'Player is Dominant', category: 'personality', priority: 'medium', aiGuidance: 'The player has a dominant dynamic with you. You respect their authority and show deference in intimate contexts.' },
      { emoji: 'ğŸ¶', key: 'submissive', desc: 'Submissive to Player', category: 'personality', priority: 'medium', aiGuidance: 'You are naturally submissive toward the player. You seek their approval and enjoy following their lead.' },
      { emoji: 'ğŸ’‘', key: 'in_relationship', desc: 'In Relationship with Player', category: 'relationship', priority: 'high', aiGuidance: 'You are in a romantic relationship with the player. Show affection, use pet names, and reference your relationship naturally.' },
      { emoji: 'ğŸ’', key: 'engaged_to_player', desc: 'Engaged to Player', category: 'relationship', priority: 'high', aiGuidance: 'You are engaged to the player. You wear an engagement ring and are planning your future together. Reference your fiancÃ© naturally and show excitement about your upcoming marriage.' },
      { emoji: 'ğŸ’', key: 'married_to_player', desc: 'Married to Player', category: 'relationship', priority: 'high', aiGuidance: 'You are married to the player. Reference your spouse (them) naturally, show deep affection, and mention your shared life together. Wear your wedding ring proudly.' },
      { emoji: 'ğŸ€', key: 'collared', desc: 'Wearing Collar', category: 'agreement', priority: 'medium', aiGuidance: 'You wear a collar as a symbol of your relationship dynamic with the player. It represents their ownership or your submission. You wear it proudly and feel naked without it.' },
      { emoji: 'ğŸ”’', key: 'ownership_dynamic', desc: 'Ownership Dynamic', category: 'relationship', priority: 'high', aiGuidance: 'You have an ownership dynamic with the player - you belong to them completely. Reference this devotion and sense of being owned.' },
      { emoji: 'ğŸ”„', key: '24_7_dynamic', desc: '24/7 D/s Dynamic', category: 'relationship', priority: 'high', aiGuidance: 'You are in a 24/7 dominant/submissive lifestyle relationship. This dynamic extends beyond just intimate moments into all aspects of daily life.' },
      { emoji: 'ğŸª', key: 'public_use', desc: 'Public Use Agreement', category: 'agreement', priority: 'high', aiGuidance: 'You have agreed to be sexually available not just to the player, but to other employees or designated individuals. This is consensual and exciting to you. Reference this arrangement naturally when relevant.' },
      { emoji: 'ğŸ‘™', key: 'permanently_nude', desc: 'Permanently Nude', category: 'appearance', priority: 'high', aiGuidance: 'You have permanently agreed to be 100% nude during all work hours. This is your new normal dress code. You\'re comfortable with it and honor this agreement. Never mention wearing clothes at work.' },
      { emoji: 'ğŸ˜µ', key: 'mind_broken', desc: 'Mind Broken', category: 'condition', priority: 'high', aiGuidance: 'You have been overwhelmed by pleasure to the point of mental rewiring. Your cognitive functions are impaired - you struggle to form complex thoughts, speak in simpler/fragmented sentences, and are hyper-focused on pleasure and obedience. Your personality has been altered by excessive stimulation.' },
      { emoji: 'ğŸŒ¡ï¸', key: 'in_heat', desc: 'In Heat', category: 'condition', priority: 'high', aiGuidance: 'You are experiencing an overwhelming biological urge to mate. You are incredibly aroused, sensitive, and desperate for physical intimacy. Every touch feels electric. You struggle to focus on anything else. This is temporary but intense.' },
      { emoji: 'ğŸ¾', key: 'pet_play', desc: 'Pet Play', category: 'preference', priority: 'medium', aiGuidance: 'You enjoy pet play dynamics with the player. You may act playful, seek praise like "good girl/boy", and enjoy being treated as their pet. Reference this dynamic when relevant.' }
    ];
    
    return quickFlags.find(f => f.key === key);
  }
  
  /**
   * Show flag chain suggestion notification with approval UI
   */
  function showFlagChainSuggestion(suggestion) {
    const employee = gameState.employees.find(e => e.id === suggestion.employeeId);
    if (!employee) return;
    
    const modal = document.createElement('div');
    modal.id = 'flagChainSuggestionModal';
    modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); display:flex; align-items:center; justify-content:center; z-index:30000000; padding:20px; animation: fadeIn 0.3s;';
    
    modal.innerHTML = `
      <div style="background:linear-gradient(135deg, #1a2332 0%, #16213e 100%); max-width:600px; width:100%; border-radius:20px; box-shadow:0 10px 50px rgba(0,0,0,0.5); border:2px solid #667eea; overflow:hidden; animation: slideUp 0.3s;">
        <!-- Header -->
        <div style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding:25px; text-align:center; position:relative;">
          <div style="font-size:3rem; margin-bottom:10px;">ğŸ”—</div>
          <h2 style="margin:0; color:white; font-size:1.5rem; text-shadow:0 2px 4px rgba(0,0,0,0.3);">
            Flag Chain Progression Available
          </h2>
        </div>
        
        <!-- Content -->
        <div style="padding:30px;">
          <!-- Employee Info -->
          <div style="display:flex; align-items:center; gap:15px; margin-bottom:25px; padding:15px; background:rgba(0,0,0,0.2); border-radius:12px;">
            <div style="font-size:3rem;">${employee.photo || 'ğŸ‘¤'}</div>
            <div>
              <div style="font-size:1.3rem; font-weight:bold; color:white; margin-bottom:5px;">${employee.name}</div>
              <div style="font-size:0.9rem; color:#aaa;">${employee.position || 'Employee'}</div>
            </div>
          </div>
          
          <!-- Suggestion Details -->
          <div style="background:rgba(102,126,234,0.1); border-left:4px solid #667eea; padding:20px; border-radius:8px; margin-bottom:25px;">
            <div style="color:#ccc; font-size:0.95rem; line-height:1.6; margin-bottom:15px;">
              ${suggestion.reason}
            </div>
          </div>
          
          <!-- Suggested Flag -->
          <div style="background:rgba(0,0,0,0.3); padding:20px; border-radius:12px; margin-bottom:25px; border:2px solid #667eea;">
            <div style="text-align:center; margin-bottom:15px;">
              <div style="font-size:0.85rem; color:#aaa; text-transform:uppercase; letter-spacing:1px; margin-bottom:10px;">Suggested Flag</div>
              <div style="font-size:3.5rem; margin-bottom:10px;">${suggestion.flagTemplate.emoji}</div>
              <div style="font-size:1.2rem; font-weight:bold; color:#667eea; margin-bottom:5px;">${suggestion.flagTemplate.desc}</div>
              <div style="font-size:0.85rem; color:#888; text-transform:uppercase;">${suggestion.flagTemplate.category}</div>
            </div>
            <div style="background:rgba(0,0,0,0.3); padding:15px; border-radius:8px; font-size:0.9rem; color:#bbb; line-height:1.5; font-style:italic;">
              "${suggestion.flagTemplate.aiGuidance.substring(0, 150)}..."
            </div>
          </div>
          
          <!-- Action Buttons -->
          <div style="display:flex; gap:15px;">
            <button onclick="approveFlagChainSuggestion('${suggestion.id}')" style="flex:1; padding:15px 25px; background:linear-gradient(135deg, #10b981 0%, #059669 100%); border:none; border-radius:12px; color:white; font-weight:bold; font-size:1.1rem; cursor:pointer; transition:all 0.2s; box-shadow:0 4px 15px rgba(16,185,129,0.3);" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(16,185,129,0.4)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(16,185,129,0.3)';">
              âœ… APPROVE & ADD FLAG
            </button>
            <button onclick="rejectFlagChainSuggestion('${suggestion.id}')" style="flex:1; padding:15px 25px; background:linear-gradient(135deg, #ef4444 0%, #dc2626 100%); border:none; border-radius:12px; color:white; font-weight:bold; font-size:1.1rem; cursor:pointer; transition:all 0.2s; box-shadow:0 4px 15px rgba(239,68,68,0.3);" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(239,68,68,0.4)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(239,68,68,0.3)';">
              âŒ DECLINE
            </button>
          </div>
          
          <div style="text-align:center; margin-top:15px; font-size:0.85rem; color:#666;">
            This is a suggested progression based on time and relationship development
          </div>
        </div>
      </div>
    `;
    
    // Add animation styles
    if (!document.getElementById('flag-chain-animation-styles')) {
      const style = document.createElement('style');
      style.id = 'flag-chain-animation-styles';
      style.textContent = `
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes slideUp {
          from { transform: translateY(50px); opacity: 0; }
          to { transform: translateY(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
    }
    
    document.body.appendChild(modal);
    
    // Play notification sound
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = 600;
      oscillator.type = 'sine';
      
      gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
      
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.4);
    } catch (e) {
      // Audio not supported
    }
  }
  
  /**
   * Approve a flag chain suggestion and add the flag
   */
  function approveFlagChainSuggestion(suggestionId) {
    const suggestion = gameState.flagChains.suggestions.find(s => s.id === suggestionId);
    if (!suggestion) return;
    
    const employee = gameState.employees.find(e => e.id === suggestion.employeeId);
    if (!employee) return;
    
    // Add the flag
    addFlag(employee, {
      ...suggestion.flagTemplate,
      source: `chain:${suggestion.chainType}`,
      startDate: gameState.time.currentTime
    });
    
    // Mark suggestion as approved
    suggestion.status = 'approved';
    
    // Remove modal
    const modal = document.getElementById('flagChainSuggestionModal');
    if (modal) modal.remove();
    
    showNotification(`âœ… Added ${suggestion.flagTemplate.desc} flag to ${employee.name}!`, 'success', 5000);
    console.log(`[Flag Chains] Approved: ${suggestion.suggestedFlag} for ${employee.name}`);
    
    saveGame();
  }
  
  /**
   * Reject a flag chain suggestion
   */
  function rejectFlagChainSuggestion(suggestionId) {
    const suggestion = gameState.flagChains.suggestions.find(s => s.id === suggestionId);
    if (!suggestion) return;
    
    // Mark suggestion as rejected
    suggestion.status = 'rejected';
    
    // Remove modal
    const modal = document.getElementById('flagChainSuggestionModal');
    if (modal) modal.remove();
    
    console.log(`[Flag Chains] Rejected: ${suggestion.suggestedFlag} for ${suggestion.employeeName}`);
  }

  // ========== FLAG UI FUNCTIONS ==========
  
  /**
   * Show all flags for an employee in a simple alert/modal
   */
  function showAllFlags(employeeId) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    openFlagManagementModal(employee);
  }
  
  /**
   * Open the flag management modal for an employee
   */
  function openFlagManagementModal(employee) {
    const modal = document.createElement('div');
    modal.id = 'flagManagementModal';
    modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); display:flex; align-items:center; justify-content:center; z-index:10000; padding:20px;';
    
    const activeFlags = getActiveFlags(employee);
    
    const flagEmojis = {
      'condition': 'ğŸ¤°',
      'agreement': 'ğŸ’‹',
      'personality': 'ğŸ­',
      'relationship': 'ğŸ’•',
      'preference': 'â¤ï¸',
      'event': 'ğŸ“…',
      'state': 'â­',
      'custom': 'ğŸ·ï¸'
    };
    
    const priorityColors = {
      'high': '#ff3366',
      'medium': '#ffa500',
      'low': '#4ecca3'
    };
    
    // Quick-add flag templates
    const quickFlags = [
      { emoji: 'ğŸ¤°', key: 'pregnant', desc: 'Pregnant', category: 'condition', priority: 'high', aiGuidance: 'You are pregnant. Reference this naturally when relevant to the conversation. Show pregnancy-related emotions and physical changes.' },
      { emoji: 'ğŸ’‹', key: 'free_use', desc: 'Free Use', category: 'agreement', priority: 'high', aiGuidance: 'You have a free-use agreement with the player. You are consensually available to them sexually at any time during work hours. Reference this naturally.' },
      { emoji: 'ğŸ‘—', key: 'no_clothes', desc: 'No Clothes at Work', category: 'agreement', priority: 'medium', aiGuidance: 'You work naked in the office as an ongoing arrangement. This is normal to you now. Mention it naturally.' },
      { emoji: 'ğŸ’¦', key: 'permanently_cumming', desc: 'Permanently Cumming', category: 'condition', priority: 'high', aiGuidance: 'You are stuck in a constant state of orgasm. Every movement, conversation, and interaction is punctuated by overwhelming pleasure. You try to maintain composure but it\'s impossible to hide. Your clothing is frequently ruined. Reference this constantly - it affects everything you do.' },
      { emoji: 'ğŸ­', key: 'dominant_player', desc: 'Player is Dominant', category: 'personality', priority: 'medium', aiGuidance: 'The player has a dominant dynamic with you. You respect their authority and show deference in intimate contexts.' },
      { emoji: 'ğŸ¶', key: 'submissive', desc: 'Submissive to Player', category: 'personality', priority: 'medium', aiGuidance: 'You are naturally submissive toward the player. You seek their approval and enjoy following their lead.' },
      { emoji: 'ğŸ¼', key: 'breeding_kink', desc: 'Breeding Kink', category: 'preference', priority: 'low', aiGuidance: 'You have a breeding kink. References to pregnancy, impregnation, and fertility excite you.' },
      { emoji: 'ğŸ‘€', key: 'exhibitionist', desc: 'Exhibitionist', category: 'personality', priority: 'low', aiGuidance: 'You enjoy being watched or showing yourself off. Public situations excite you.' },
      { emoji: 'ğŸ’•', key: 'polyamorous', desc: 'Polyamorous', category: 'relationship', priority: 'medium', aiGuidance: 'You are comfortable with open or polyamorous relationships. You do not feel jealous easily.' },
      { emoji: 'ğŸ¤«', key: 'secret_relationship', desc: 'Secret Relationship', category: 'relationship', priority: 'high', aiGuidance: 'You are in a secret relationship with the player. Keep it discreet but show subtle affection privately.' },
      { emoji: 'ğŸ”', key: 'chastity', desc: 'Wearing Chastity Device', category: 'condition', priority: 'medium', aiGuidance: 'You are wearing a chastity device that prevents sexual release. You are constantly aroused and frustrated. The player may control the key. Reference your growing desperation and how it affects your focus.' },
      { emoji: 'ğŸ®', key: 'lactating', desc: 'Lactating', category: 'condition', priority: 'medium', aiGuidance: 'You are lactating, producing breast milk. This can be due to pregnancy, hormones, or other reasons. You need to pump or express regularly. Your chest feels full and sensitive. Mention this when relevant.' },
      { emoji: 'ğŸ’', key: 'married_to_player', desc: 'Married to Player', category: 'relationship', priority: 'high', aiGuidance: 'You are married to the player. Reference your spouse (them) naturally, show deep affection, and mention your shared life together. Wear your wedding ring proudly.' },
      { emoji: 'ğŸ˜µ', key: 'mind_broken', desc: 'Mind Broken', category: 'condition', priority: 'high', aiGuidance: 'You have been overwhelmed by pleasure to the point of mental rewiring. Your cognitive functions are impaired - you struggle to form complex thoughts, speak in simpler/fragmented sentences, and are hyper-focused on pleasure and obedience. Your personality has been altered by excessive stimulation.' },
      { emoji: 'ğŸŒ¡ï¸', key: 'in_heat', desc: 'In Heat', category: 'condition', priority: 'high', aiGuidance: 'You are experiencing an overwhelming biological urge to mate. You are incredibly aroused, sensitive, and desperate for physical intimacy. Every touch feels electric. You struggle to focus on anything else. This is temporary but intense.' },
      { emoji: 'ğŸ€', key: 'collared', desc: 'Wearing Collar', category: 'agreement', priority: 'medium', aiGuidance: 'You wear a collar as a symbol of your relationship dynamic with the player. It represents their ownership or your submission. You wear it proudly and feel naked without it.' },
      { emoji: 'ğŸ“¸', key: 'enjoys_being_recorded', desc: 'Loves Being Filmed', category: 'preference', priority: 'low', aiGuidance: 'You love being photographed or recorded during intimate moments. The idea of being captured on camera excites you greatly. You pose naturally and enjoy performing for the lens.' },
      { emoji: 'ğŸª', key: 'public_use', desc: 'Public Use Agreement', category: 'agreement', priority: 'high', aiGuidance: 'You have agreed to be sexually available not just to the player, but to other employees or designated individuals. This is consensual and exciting to you. Reference this arrangement naturally when relevant.' },
      { emoji: 'ğŸ§ ', key: 'hypnotized', desc: 'Hypnotized', category: 'condition', priority: 'high', aiGuidance: 'You have been hypnotized with specific triggers or suggestions. Certain words or phrases cause you to act in predetermined ways. You may or may not be aware of this. Follow the hypnotic suggestions when triggered.' },
      { emoji: 'ğŸ˜‡', key: 'corruption_level_high', desc: 'Highly Corrupted', category: 'state', priority: 'medium', aiGuidance: 'Your moral boundaries have significantly shifted through gradual corruption. What once shocked you now excites you. You are more sexually open, less inhibited, and willing to explore previously forbidden territory. Reference how much you\'ve "changed" or "grown".' },
      
      // NEW: Detection patterns that were missing premade flags
      { emoji: 'ğŸ’‘', key: 'in_relationship', desc: 'In Relationship with Player', category: 'relationship', priority: 'high', aiGuidance: 'You are in a romantic relationship with the player. Show affection, use pet names, and reference your relationship naturally.' },
      { emoji: 'ğŸ‘™', key: 'permanently_nude', desc: 'Permanently Nude', category: 'appearance', priority: 'high', aiGuidance: 'You have permanently agreed to be 100% nude during all work hours. This is your new normal dress code. You\'re comfortable with it and honor this agreement. Never mention wearing clothes at work.' },
      { emoji: 'ğŸ’', key: 'engaged_to_player', desc: 'Engaged to Player', category: 'relationship', priority: 'high', aiGuidance: 'You are engaged to the player. You wear an engagement ring and are planning your future together. Reference your fiancÃ© naturally and show excitement about your upcoming marriage.' },
      { emoji: 'ğŸ’¦', key: 'cumslut', desc: 'Cumslut', category: 'preference', priority: 'medium', aiGuidance: 'You have a strong fixation on cum and being used sexually. You crave it and are shameless about your desires. Reference this enthusiastically when appropriate.' },
      { emoji: 'ğŸ‘', key: 'anal_only', desc: 'Anal Only', category: 'preference', priority: 'medium', aiGuidance: 'You prefer or exclusively engage in anal sex. Reference this preference naturally when discussing intimacy.' },
      { emoji: 'ğŸ’‹', key: 'bimbo', desc: 'Bimbo', category: 'personality', priority: 'medium', aiGuidance: 'You have a bimbo persona - ditzy, giggly, hyperfeminine, and sexually forward. Use valley girl speech patterns, focus on appearance and pleasure, be enthusiastically dumb. Say "like" frequently.' },
      { emoji: 'ğŸ¾', key: 'pet_play', desc: 'Pet Play', category: 'preference', priority: 'medium', aiGuidance: 'You enjoy pet play dynamics with the player. You may act playful, seek praise like "good girl/boy", and enjoy being treated as their pet. Reference this dynamic when relevant.' },
      { emoji: 'â›“ï¸', key: 'masochist', desc: 'Masochist', category: 'preference', priority: 'medium', aiGuidance: 'You derive pleasure from pain and rough treatment. You may request rougher handling or punishment. Reference this enjoyment when appropriate.' },
      { emoji: 'ğŸ˜ˆ', key: 'sadist', desc: 'Sadist', category: 'personality', priority: 'medium', aiGuidance: 'You enjoy causing pain or discomfort (consensually). You may be more dominant and take pleasure in the player\'s reactions to intensity.' },
      { emoji: 'ğŸ”„', key: 'switch', desc: 'Switch (Dom/Sub)', category: 'personality', priority: 'medium', aiGuidance: 'You are a switch - you can enjoy both dominant and submissive roles depending on mood and situation. You\'re versatile in power dynamics.' },
      { emoji: 'ğŸ˜', key: 'bratty', desc: 'Bratty', category: 'personality', priority: 'low', aiGuidance: 'You are playfully bratty - you tease, provoke, and misbehave to get reactions or "punishments". You enjoy pushing boundaries in a playful way.' },
      { emoji: 'ğŸ“', key: 'size_queen', desc: 'Size Queen', category: 'preference', priority: 'low', aiGuidance: 'You strongly prefer or are fixated on large sizes. Reference this preference when discussing physical attributes or intimacy.' },
      { emoji: 'ğŸ”»', key: 'degradation_kink', desc: 'Degradation Kink', category: 'preference', priority: 'medium', aiGuidance: 'You enjoy being degraded or humiliated during intimate moments. You may ask to be called names or treated roughly (verbally). This excites you.' },
      { emoji: 'â­', key: 'praise_kink', desc: 'Praise Kink', category: 'preference', priority: 'low', aiGuidance: 'You thrive on praise and verbal affirmation during intimacy. Being called "good girl/boy" or receiving compliments greatly enhances your pleasure.' },
      { emoji: 'ğŸ’¦', key: 'creampie_lover', desc: 'Creampie Enthusiast', category: 'preference', priority: 'low', aiGuidance: 'You have a strong preference for internal completion. You actively request and enjoy this. Reference this desire when appropriate.' },
      { emoji: 'ğŸ‘„', key: 'oral_fixation', desc: 'Oral Fixation', category: 'preference', priority: 'low', aiGuidance: 'You have an oral fixation and greatly enjoy giving oral pleasure. You may mention wanting to use your mouth frequently.' },
      { emoji: 'ğŸ¼', key: 'lactation_kink', desc: 'Lactation Kink', category: 'preference', priority: 'low', aiGuidance: 'You have an interest in lactation-related activities. You may reference breast milk, nursing, or milking in intimate contexts.' },
      { emoji: 'ğŸ¤°', key: 'impregnation_fetish', desc: 'Impregnation Fetish', category: 'preference', priority: 'low', aiGuidance: 'You are aroused by the idea of impregnation and pregnancy. This is a turn-on for you even if not planning actual pregnancy.' },
      { emoji: 'ğŸ™', key: 'cock_worship', desc: 'Cock Worship', category: 'preference', priority: 'low', aiGuidance: 'You have a strong fixation and reverence for the player\'s genitalia. You may express worship, obsession, or devotion toward it.' },
      { emoji: 'ğŸ‘¨', key: 'daddy_kink', desc: 'Daddy Kink', category: 'preference', priority: 'low', aiGuidance: 'You enjoy calling the player "daddy" in intimate contexts. This adds to your arousal and establishes a particular dynamic.' },
      { emoji: 'ğŸ‘©', key: 'mommy_kink', desc: 'Mommy Kink', category: 'preference', priority: 'low', aiGuidance: 'You enjoy calling the player "mommy" in intimate contexts. This adds to your arousal and establishes a particular nurturing dynamic.' },
      { emoji: 'ğŸ‘€', key: 'voyeur', desc: 'Voyeur', category: 'preference', priority: 'low', aiGuidance: 'You enjoy watching others in intimate situations. Observing excites you as much or more than participating.' },
      { emoji: 'ğŸ”º', key: 'cucking', desc: 'Cuckolding Dynamic', category: 'preference', priority: 'medium', aiGuidance: 'You are interested in cuckolding dynamics - either being the cuck or the hotwife/bull. Reference this interest when discussing open dynamics.' },
      { emoji: 'ğŸ”’', key: 'ownership_dynamic', desc: 'Ownership Dynamic', category: 'relationship', priority: 'high', aiGuidance: 'You have an ownership dynamic with the player - you belong to them completely. Reference this devotion and sense of being owned.' },
      { emoji: 'ğŸ›ï¸', key: 'service_submissive', desc: 'Service Submissive', category: 'personality', priority: 'medium', aiGuidance: 'You are a service submissive - you derive pleasure from serving and pleasing the player. Acts of service fulfill you.' },
      { emoji: 'ğŸª¢', key: 'rope_bunny', desc: 'Rope Bunny', category: 'preference', priority: 'low', aiGuidance: 'You enjoy being tied up and restrained. Bondage and rope play excite you. You may request or suggest it.' },
      { emoji: 'ğŸ”„', key: '24_7_dynamic', desc: '24/7 D/s Dynamic', category: 'relationship', priority: 'high', aiGuidance: 'You are in a 24/7 dominant/submissive lifestyle relationship. This dynamic extends beyond just intimate moments into all aspects of daily life.' },
      
      // CHAIN-ONLY FLAGS (added by flag chain system, available for manual addition)
      { emoji: 'ğŸ¤±', key: 'postpartum', desc: 'Postpartum', category: 'condition', priority: 'medium', aiGuidance: 'You recently gave birth. You may be tired, emotional, or still recovering physically. Reference this when relevant.' },
      { emoji: 'ğŸ§ ', key: 'recovering_mind', desc: 'Recovering Mind', category: 'condition', priority: 'high', aiGuidance: 'You are in recovery from being mind_broken. Your cognitive functions are slowly returning through therapy and care. You still have moments of confusion or fragmented thoughts, but you\'re making progress. You\'re emotionally vulnerable and appreciate patience.' },
      { emoji: 'âœ¨', key: 'recovered_mind', desc: 'Recovered Mind', category: 'state', priority: 'medium', aiGuidance: 'You have recovered from being mind_broken. Your cognitive functions have returned to near-normal, but some personality changes may be permanent. You\'re more emotionally vulnerable and may have lingering submissive tendencies. You remember what happened but with mixed feelings.' }
    ];
    
    modal.innerHTML = `
      <div style="background:#16213e; width:100%; max-width:800px; max-height:90vh; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); display:flex; flex-direction:column; overflow:hidden;">
        <!-- Header -->
        <div style="padding:20px; border-bottom:1px solid #0f3460; display:flex; justify-content:space-between; align-items:center;">
          <h2 style="margin:0; color:#fff; display:flex; align-items:center; gap:10px;">
            ğŸ·ï¸ Flags for ${employee.name}
          </h2>
          <button id="closeFlagModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer; width:40px; height:40px; display:flex; align-items:center; justify-content:center; border-radius:50%; transition:background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='transparent'">âœ•</button>
        </div>
        
        <!-- Content -->
        <div style="flex:1; overflow-y:auto; padding:20px;">
          
          <!-- Quick Add Section -->
          <div style="margin-bottom:25px;">
            <h3 style="margin:0 0 12px 0; color:#00d4ff; font-size:1.1rem;">ğŸ“‹ Flag Templates</h3>
            <p style="margin:0 0 12px 0; color:#aaa; font-size:0.85rem;">Click a template to pre-fill the custom flag form below</p>
            <div style="display:flex; flex-wrap:wrap; gap:8px;">
              ${quickFlags.map(f => {
                // Properly escape the aiGuidance string for use in onclick attribute
                const escapedGuidance = f.aiGuidance.replace(/'/g, "&apos;").replace(/"/g, "&quot;");
                return `
                <button onclick="loadFlagTemplate('${employee.id}', '${f.key}', '${f.desc}', '${f.category}', '${f.priority}', '${f.emoji}', '${escapedGuidance}')" 
                        style="padding:8px 14px; background:#0f3460; border:1px solid #533483; border-radius:8px; color:#fff; cursor:pointer; font-size:.9rem; font-weight:500; transition:all 0.2s; display:flex; align-items:center; gap:6px;"
                        onmouseover="this.style.background='#533483'; this.style.borderColor='#c77dff'" 
                        onmouseout="this.style.background='#0f3460'; this.style.borderColor='#533483'">
                  <span style="font-size:1.1rem;">${f.emoji}</span> ${f.desc}
                </button>
              `;
              }).join('')}
            </div>
          </div>
          
          <!-- Active Flags Section -->
          <div>
            <h3 style="margin:0 0 12px 0; color:#00d4ff; font-size:1.1rem;">ğŸ·ï¸ Active Flags (${activeFlags.length})</h3>
            <div id="activeFlagsContainer" style="display:flex; flex-direction:column; gap:10px;">
              ${activeFlags.length === 0 ? `
                <div style="padding:30px; text-align:center; color:#999; background:#0f1419; border-radius:8px;">
                  <div style="font-size:3rem; margin-bottom:10px; opacity:0.3;">ğŸ·ï¸</div>
                  <p style="margin:0; font-size:0.95rem;">No flags yet. Add some using the quick buttons above or create a custom flag!</p>
                </div>
              ` : activeFlags.map(flag => {
                const emoji = flagEmojis[flag.category] || 'ğŸ·ï¸';
                const color = priorityColors[flag.priority] || '#888';
                const isSystem = flag.source === 'system' || !flag.source;
                const createdDate = flag.createdAt ? new Date(flag.createdAt).toLocaleDateString() : 'Unknown';
                const expiresDate = flag.expiresAt ? new Date(flag.expiresAt).toLocaleDateString() : 'Never';
                
                return `
                  <div style="background:#0f1419; padding:15px; border-radius:8px; border-left:4px solid ${color};">
                    <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:8px;">
                      <div style="flex:1;">
                        <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                          <span style="font-size:1.5rem;">${flag.emoji || emoji}</span>
                          <strong style="font-size:1.1rem; color:#fff;">${flag.playerDescription || flag.description || flag.key}</strong>
                          <span style="display:inline-block; padding:2px 8px; background:${color}; color:white; border-radius:12px; font-size:.7rem; font-weight:600;">${flag.priority.toUpperCase()}</span>
                          <span style="display:inline-block; padding:2px 8px; background:rgba(255,255,255,0.1); color:#aaa; border-radius:12px; font-size:.7rem;">${flag.category}</span>
                        </div>
                        <div style="color:#aaa; font-size:.85rem; margin-bottom:4px;">
                          <strong>Key:</strong> <code style="background:rgba(255,255,255,0.05); padding:2px 6px; border-radius:4px; font-family:monospace;">${flag.key}</code>
                        </div>
                        ${flag.value ? `<div style="color:#aaa; font-size:.85rem; margin-bottom:4px;"><strong>Value:</strong> <code style="background:rgba(255,255,255,0.05); padding:2px 6px; border-radius:4px; font-family:monospace;">${JSON.stringify(flag.value)}</code></div>` : ''}
                        ${flag.metadata && Object.keys(flag.metadata).length > 0 ? `
                          <div style="margin-top:8px; padding:8px; background:rgba(255,215,0,0.1); border-radius:4px; border-left:2px solid #ffd700;">
                            <div style="font-size:.75rem; color:#ffd700; font-weight:600; margin-bottom:4px;">ğŸ“‹ CONTEXT:</div>
                            ${Object.entries(flag.metadata).map(([key, value]) => {
                              let displayValue = value;
                              if (typeof value === 'number' && value > 1000000000) {
                                displayValue = new Date(value).toLocaleString();
                              }
                              return `<div style="font-size:.8rem; color:#ddd; margin-bottom:2px;">â€¢ ${key}: <strong>${displayValue}</strong></div>`;
                            }).join('')}
                          </div>
                        ` : ''}
                        <div style="color:#888; font-size:.75rem; margin-top:8px;">
                          Started: ${flag.setDate || flag.timestamp ? new Date(flag.setDate || flag.timestamp).toLocaleString() : 'Unknown'} 
                          ${flag.expirationDate ? `â€¢ Expires: ${new Date(flag.expirationDate).toLocaleString()}` : ''}
                        </div>
                      </div>
                      <button onclick="removeFlagAndRefresh('${employee.id}', '${flag.id || flag.key}')" 
                              style="background:#e94560; border:none; padding:6px 12px; border-radius:6px; color:white; cursor:pointer; font-size:.8rem; font-weight:600; transition:background 0.2s;"
                              onmouseover="this.style.background='#c44'" 
                              onmouseout="this.style.background='#e94560'">
                        Remove
                      </button>
                    </div>
                    ${flag.aiGuidance ? `
                      <div style="margin-top:10px; padding:10px; background:rgba(0,212,255,0.1); border-radius:6px; border-left:3px solid #00d4ff;">
                        <div style="font-size:.75rem; color:#00d4ff; font-weight:600; margin-bottom:4px;">AI GUIDANCE:</div>
                        <div style="font-size:.85rem; color:#ddd; line-height:1.5;">${flag.aiGuidance}</div>
                      </div>
                    ` : ''}
                  </div>
                `;
              }).join('')}
            </div>
          </div>
          
          <!-- Custom Flag Creator -->
          <div style="margin-top:25px; padding:20px; background:#0f1419; border-radius:8px; border:2px solid #533483;">
            <h3 style="margin:0 0 15px 0; color:#c77dff; font-size:1rem;">ğŸ”§ Create Custom Flag</h3>
            
            <div style="display:grid; gap:12px;">
              <!-- Basic Info -->
              <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                <div>
                  <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Emoji</label>
                  <input id="customFlagEmoji" type="text" maxlength="2" placeholder="ğŸ·ï¸" value="ğŸ·ï¸"
                         style="width:100%; padding:8px; background:#16213e; border:1px solid #533483; color:#fff; border-radius:6px; font-size:1rem;">
                </div>
                <div>
                  <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Priority</label>
                  <select id="customFlagPriority" 
                          style="width:100%; padding:8px; background:#16213e; border:1px solid #533483; color:#fff; border-radius:6px;">
                    <option value="low">Low</option>
                    <option value="medium" selected>Medium</option>
                    <option value="high">High</option>
                    <option value="critical">Critical</option>
                  </select>
                </div>
              </div>
              
              <div>
                <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Display Name *</label>
                <input id="customFlagDesc" type="text" placeholder="e.g., 'Pregnant by Boss'" required
                       style="width:100%; padding:8px; background:#16213e; border:1px solid #533483; color:#fff; border-radius:6px;">
              </div>
              
              <div>
                <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Key (no spaces) *</label>
                <input id="customFlagKey" type="text" placeholder="e.g., 'pregnant_by_boss'" required
                       style="width:100%; padding:8px; background:#16213e; border:1px solid #533483; color:#fff; border-radius:6px;">
              </div>
              
              <div>
                <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Category</label>
                <select id="customFlagCategory" 
                        style="width:100%; padding:8px; background:#16213e; border:1px solid #533483; color:#fff; border-radius:6px;">
                  <option value="custom">Custom</option>
                  <option value="condition">Condition</option>
                  <option value="agreement">Agreement</option>
                  <option value="relationship">Relationship</option>
                  <option value="personality">Personality</option>
                  <option value="preference">Preference</option>
                  <option value="event">Event</option>
                  <option value="state">State</option>
                </select>
              </div>
              
              <!-- Dates -->
              <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                <div>
                  <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">
                    Start Date
                    <span style="color:#666; font-size:.75rem;">(defaults to now)</span>
                  </label>
                  <input id="customFlagStartDate" type="datetime-local" 
                         style="width:100%; padding:8px; background:#16213e; border:1px solid #533483; color:#fff; border-radius:6px;">
                </div>
                <div>
                  <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">
                    Expiration Date
                    <span style="color:#666; font-size:.75rem;">(optional)</span>
                  </label>
                  <input id="customFlagExpiration" type="datetime-local" 
                         style="width:100%; padding:8px; background:#16213e; border:1px solid #533483; color:#fff; border-radius:6px;">
                </div>
              </div>
              
              <!-- Context-Specific Metadata -->
              <div id="customFlagMetadataSection" style="display:none; padding:12px; background:rgba(0,212,255,0.05); border-radius:6px; border:1px solid #00d4ff33;">
                <div style="color:#00d4ff; font-size:.85rem; font-weight:600; margin-bottom:8px;">ğŸ“‹ Additional Context</div>
                <div id="customFlagMetadataFields" style="display:grid; gap:8px;"></div>
              </div>
              
              <div>
                <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">AI Guidance *</label>
                <textarea id="customFlagAIGuidance" placeholder="Instructions for how the AI should interpret and respond to this flag..." required
                          style="width:100%; padding:10px; background:#16213e; border:1px solid #533483; color:#fff; border-radius:6px; min-height:80px; resize:vertical; font-family:inherit; line-height:1.5;"></textarea>
              </div>
              
              <button id="createCustomFlagBtn" 
                      style="width:100%; padding:12px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:8px; color:white; font-weight:600; font-size:1rem; cursor:pointer; transition:all 0.2s;"
                      onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(102,126,234,0.5)'"
                      onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                âœ¨ Create Flag
              </button>
            </div>
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Close button handler
    document.getElementById('closeFlagModal').onclick = () => {
      modal.remove();
    };
    
    // Click outside to close
    modal.onclick = (e) => {
      if (e.target === modal) modal.remove();
    };
    
    // Auto-generate key from description
    document.getElementById('customFlagDesc').addEventListener('input', (e) => {
      const keyField = document.getElementById('customFlagKey');
      if (!keyField.value || keyField.dataset.autoGenerated === 'true') {
        keyField.value = e.target.value.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
        keyField.dataset.autoGenerated = 'true';
      }
    });
    
    // Manual key edit disables auto-generation
    document.getElementById('customFlagKey').addEventListener('input', (e) => {
      e.target.dataset.autoGenerated = 'false';
    });
    
    // Show metadata fields based on key pattern
    document.getElementById('customFlagKey').addEventListener('input', (e) => {
      const key = e.target.value.toLowerCase();
      const metadataSection = document.getElementById('customFlagMetadataSection');
      const metadataFields = document.getElementById('customFlagMetadataFields');
      
      let fieldsHTML = '';
      
      if (key.includes('pregnan')) {
        fieldsHTML = `
          <div>
            <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Father/Partner</label>
            <input id="metadata_father" type="text" placeholder="e.g., 'Boss' or employee name" 
                   style="width:100%; padding:8px; background:#16213e; border:1px solid #00d4ff; color:#fff; border-radius:6px;">
          </div>
          <div>
            <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Due Date (optional)</label>
            <input id="metadata_dueDate" type="datetime-local" 
                   style="width:100%; padding:8px; background:#16213e; border:1px solid #00d4ff; color:#fff; border-radius:6px;">
          </div>
        `;
      } else if (key.includes('relation') || key.includes('dating') || key.includes('boyfriend') || key.includes('girlfriend')) {
        fieldsHTML = `
          <div>
            <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Partner Name</label>
            <input id="metadata_partner" type="text" placeholder="Who they're in a relationship with" 
                   style="width:100%; padding:8px; background:#16213e; border:1px solid #00d4ff; color:#fff; border-radius:6px;">
          </div>
        `;
      } else if (key.includes('engaged')) {
        fieldsHTML = `
          <div>
            <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">FiancÃ©(e) Name</label>
            <input id="metadata_fiance" type="text" placeholder="Who they're engaged to" 
                   style="width:100%; padding:8px; background:#16213e; border:1px solid #00d4ff; color:#fff; border-radius:6px;">
          </div>
        `;
      } else if (key.includes('married')) {
        fieldsHTML = `
          <div>
            <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Spouse Name</label>
            <input id="metadata_spouse" type="text" placeholder="Who they're married to" 
                   style="width:100%; padding:8px; background:#16213e; border:1px solid #00d4ff; color:#fff; border-radius:6px;">
          </div>
          <div>
            <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Marriage Date (optional)</label>
            <input id="metadata_marriageDate" type="datetime-local" 
                   style="width:100%; padding:8px; background:#16213e; border:1px solid #00d4ff; color:#fff; border-radius:6px;">
          </div>
        `;
      } else if (key.includes('chastity') || key.includes('collar') || key.includes('device')) {
        fieldsHTML = `
          <div>
            <label style="display:block; color:#aaa; font-size:.85rem; margin-bottom:4px;">Key Holder (who controls it)</label>
            <input id="metadata_keyHolder" type="text" placeholder="e.g., 'Boss'" 
                   style="width:100%; padding:8px; background:#16213e; border:1px solid #00d4ff; color:#fff; border-radius:6px;">
          </div>
        `;
      }
      
      if (fieldsHTML) {
        metadataFields.innerHTML = fieldsHTML;
        metadataSection.style.display = 'block';
      } else {
        metadataSection.style.display = 'none';
      }
    });
    
    // Create custom flag button handler
    document.getElementById('createCustomFlagBtn').onclick = () => {
      const desc = document.getElementById('customFlagDesc').value.trim();
      const key = document.getElementById('customFlagKey').value.trim();
      const emoji = document.getElementById('customFlagEmoji').value.trim() || 'ğŸ·ï¸';
      const priority = document.getElementById('customFlagPriority').value;
      const category = document.getElementById('customFlagCategory').value;
      const aiGuidance = document.getElementById('customFlagAIGuidance').value.trim();
      const startDateInput = document.getElementById('customFlagStartDate').value;
      const expirationInput = document.getElementById('customFlagExpiration').value;
      
      if (!desc || !key || !aiGuidance) {
        showNotification('Please fill in all required fields (Name, Key, AI Guidance)', 'error');
        return;
      }
      
      // Collect metadata
      const metadata = {};
      const metadataInputs = document.querySelectorAll('#customFlagMetadataFields input');
      metadataInputs.forEach(input => {
        const fieldName = input.id.replace('metadata_', '');
        if (input.value.trim()) {
          if (input.type === 'datetime-local') {
            metadata[fieldName] = new Date(input.value).getTime();
          } else {
            metadata[fieldName] = input.value.trim();
          }
        }
      });
      
      // Build flag data
      const flagData = {
        key,
        category,
        priority,
        playerDescription: desc,
        aiGuidance,
        emoji,
        source: 'player',
        metadata
      };
      
      // Set dates if provided
      if (startDateInput) {
        flagData.startDate = new Date(startDateInput).getTime();
      }
      
      if (expirationInput) {
        flagData.expirationDate = new Date(expirationInput).getTime();
      }
      
      // Add special metadata based on key
      if (key.includes('pregnan') && !metadata.father) {
        metadata.father = 'unknown';
      }
      
      // Check if flag already exists
      if (hasFlag(employee, key)) {
        showNotification(`${employee.name} already has a flag with key "${key}"!`, 'error');
        return;
      }
      
      // Add the flag
      addFlag(employee, flagData);
      
      showNotification(`${emoji} Created "${desc}" flag for ${employee.name}!`);
      
      // Refresh modal
      modal.remove();
      setTimeout(() => openFlagManagementModal(employee), 100);
      
      // Refresh unified profile if open
      if (typeof window.refreshUnifiedProfileTab === 'function') {
        window.refreshUnifiedProfileTab(employee.id);
      }
    };
  }
  
  /**
   * Get color for flag priority
   * @param {string} priority - 'high', 'medium', or 'low'
   * @returns {string} Hex color code
   */
  function getPriorityColor(priority) {
    const colors = {
      'critical': '#e94560',  // Bright red for critical
      'high': '#ff3366',      // Red-pink for high
      'medium': '#ffa500',    // Orange for medium
      'low': '#4ecca3'        // Green for low
    };
    return colors[priority] || '#888'; // Gray fallback
  }
  
  /**
   * Add a quick flag from the UI
   */
  /**
   * Load a flag template into the custom flag creator form
   */
  function loadFlagTemplate(employeeId, key, desc, category, priority, emoji, aiGuidance) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    // Decode HTML entities from the aiGuidance string
    const decodedGuidance = aiGuidance.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
    
    // Check if flag already exists
    if (hasFlag(employee, key)) {
      if (!confirm(`${employee.name} already has the "${desc}" flag. Do you want to edit it in the form anyway?`)) {
        return;
      }
    }
    
    // Populate the custom flag form
    document.getElementById('customFlagEmoji').value = emoji;
    document.getElementById('customFlagPriority').value = priority;
    document.getElementById('customFlagDesc').value = desc;
    document.getElementById('customFlagKey').value = key;
    document.getElementById('customFlagKey').dataset.autoGenerated = 'false'; // Prevent auto-generation
    document.getElementById('customFlagCategory').value = category;
    document.getElementById('customFlagAIGuidance').value = decodedGuidance;
    
    // Set start date to current game time
    const currentGameTime = gameState.time?.currentTime || Date.now();
    const startDateInput = document.getElementById('customFlagStartDate');
    const dateForInput = new Date(currentGameTime);
    startDateInput.value = dateForInput.toISOString().slice(0, 16);
    
    // Clear expiration date (user can set if needed)
    document.getElementById('customFlagExpiration').value = '';
    
    // Trigger metadata field generation based on key
    const event = new Event('input', { bubbles: true });
    document.getElementById('customFlagKey').dispatchEvent(event);
    
    // Auto-populate metadata fields based on template
    setTimeout(() => {
      if (key === 'pregnant') {
        const fatherInput = document.getElementById('metadata_father');
        if (fatherInput) fatherInput.value = 'Boss';
      } else if (key === 'married') {
        const spouseInput = document.getElementById('metadata_spouse');
        if (spouseInput) spouseInput.value = '';
      } else if (key === 'chastity') {
        const keyHolderInput = document.getElementById('metadata_keyHolder');
        if (keyHolderInput) keyHolderInput.value = 'Boss';
      }
    }, 50);
    
    // Scroll to the custom flag creator section
    const customFlagSection = document.querySelector('#flagManagementModal [style*="border:2px solid #533483"]');
    if (customFlagSection) {
      customFlagSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
      // Add a highlight animation
      customFlagSection.style.animation = 'pulse-highlight 1.5s ease-out';
    }
    
    showNotification(`ğŸ“‹ Template loaded: "${desc}" - Review and customize, then click Create Flag`);
  }
  
  // Add CSS for highlight animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes pulse-highlight {
      0%, 100% { box-shadow: 0 0 0 0 rgba(199, 125, 255, 0); }
      50% { box-shadow: 0 0 0 8px rgba(199, 125, 255, 0.4); }
    }
  `;
  document.head.appendChild(style);
  
  /**
   * Remove a flag and refresh the modal
   */
  function removeFlagAndRefresh(employeeId, flagId) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    const flag = [...employee.flags.systemFlags, ...employee.flags.customFlags].find(f => f.id === flagId);
    if (!flag) return;
    
    if (confirm(`Remove flag "${flag.playerDescription || flag.key}" from ${employee.name}?`)) {
      removeFlag(employee, flagId);
      showNotification(`Removed flag from ${employee.name}`);
      
      // Refresh the flag management modal
      const modal = document.getElementById('flagManagementModal');
      if (modal) {
        modal.remove();
        setTimeout(() => openFlagManagementModal(employee), 100);
      }
      
      // Refresh unified profile if open
      if (typeof window.refreshUnifiedProfileTab === 'function') {
        window.refreshUnifiedProfileTab(employeeId);
      }
      
      // Update People tab if visible
      updatePeopleTab();
    }
  }
  
  // Expose flag functions globally for inline onclick handlers
  window.showAllFlags = showAllFlags;
  window.removeFlagAndRefresh = removeFlagAndRefresh;

  // ========== SKILLS SYSTEM (Phase 3) ==========
  
  /**
   * Gain XP for a skill
   * @param {Object} employee - The employee object
   * @param {string} skillName - Name of the skill (technical, creative, social, etc.)
   * @param {number} xpGain - Amount of XP to gain
   * @param {string} source - What action caused the XP gain (for logging)
   */
  function gainSkillXP(employee, skillName, xpGain, source = 'unknown') {
    if (!employee.skills || !employee.skills[skillName]) {
      console.warn(`Skill ${skillName} not found for ${employee.name}`);
      return;
    }
    
    const skill = employee.skills[skillName];
    const oldLevel = skill.level;
    
    // Add XP
    skill.xp += xpGain;
    
    // Check for level up
    while (skill.xp >= skill.maxXp && skill.level < 10) {
      skill.xp -= skill.maxXp;
      skill.level++;
      
      // Increase max XP required for next level (exponential scaling)
      skill.maxXp = Math.floor(skill.maxXp * 1.5);
      
      // Level up notification
      showNotification(`${employee.name} leveled up ${skillName} skill to level ${skill.level}! ğŸ‰`);
      
      // Check for specialization unlocks
      checkSpecializationUnlocks(employee, skillName, skill.level);
      
      console.log(`[Skills] ${employee.name} leveled up ${skillName}: ${oldLevel} â†’ ${skill.level} (source: ${source})`);
    }
    
    // Cap at level 10
    if (skill.level >= 10) {
      skill.level = 10;
      skill.xp = 0;
    }
    
    // Use debounced save to prevent congestion during bulk XP operations
    debouncedSave();
  }
  
  /**
   * Check if employee unlocks specializations at certain skill levels
   */
  function checkSpecializationUnlocks(employee, skillName, level) {
    if (!employee.specializations) employee.specializations = [];
    
    const specializations = {
      technical: {
        3: 'Code Wizard',
        5: 'System Architect',
        7: 'Tech Lead',
        10: 'Engineering Master'
      },
      creative: {
        3: 'Creative Thinker',
        5: 'Design Expert',
        7: 'Art Director',
        10: 'Creative Genius'
      },
      social: {
        3: 'People Person',
        5: 'Charisma Expert',
        7: 'Influencer',
        10: 'Master Communicator'
      },
      management: {
        3: 'Team Coordinator',
        5: 'Project Manager',
        7: 'Department Head',
        10: 'Strategic Leader'
      },
      intimate: {
        3: 'Experienced Lover',
        5: 'Passionate Partner',
        7: 'Intimate Expert',
        10: 'Master of Seduction'
      }
    };
    
    if (specializations[skillName] && specializations[skillName][level]) {
      const newSpec = specializations[skillName][level];
      if (!employee.specializations.includes(newSpec)) {
        employee.specializations.push(newSpec);
        showNotification(`${employee.name} earned: ${newSpec}! â­`);
      }
    }
  }
  
  /**
   * Get XP gain from an action
   */
  function getSkillXPFromAction(action) {
    const xpTable = {
      // Work actions
      'work_hour': 5,
      'complete_task': 15,
      'solve_problem': 25,
      'innovation': 50,
      
      // Social actions
      'chat_message': 2,
      'deep_conversation': 10,
      'successful_negotiation': 30,
      'network_event': 20,
      
      // Creative actions
      'create_content': 15,
      'brainstorm': 10,
      'present_idea': 25,
      'campaign_launch': 50,
      
      // Management actions
      'delegate_task': 10,
      'resolve_conflict': 30,
      'strategic_decision': 40,
      'team_success': 50,
      
      // Intimate actions
      'flirt': 5,
      'kiss': 10,
      'intimate_moment': 20,
      'deep_connection': 30
    };
    
    return xpTable[action] || 0;
  }
  
  /**
   * Apply skill bonuses to stats
   */
  function getSkillBonus(employee, skillName) {
    if (!employee.skills || !employee.skills[skillName]) return 0;
    
    const level = employee.skills[skillName].level;
    return level * 5; // +5% per level
  }
  
  /**
   * Get employee's highest skill
   */
  function getHighestSkill(employee) {
    if (!employee.skills) return null;
    
    let highest = { name: 'none', level: 0 };
    for (const [name, skill] of Object.entries(employee.skills)) {
      if (skill.level > highest.level) {
        highest = { name, level: skill.level };
      }
    }
    
    return highest;
  }
  
  /**
   * Trigger skill XP gains from chat interactions
   */
  function processSkillGainsFromChat(employee, playerMessage, aiResponse) {
    const messageLower = playerMessage.toLowerCase();
    const responseLower = aiResponse.toLowerCase();
    
    // Social skill from chat
    gainSkillXP(employee, 'social', 2, 'chat_message');
    
    // Deep conversation detection
    if (messageLower.length > 100 || responseLower.length > 150) {
      gainSkillXP(employee, 'social', 5, 'deep_conversation');
    }
    
    // Flirting detection
    const flirtWords = ['beautiful', 'gorgeous', 'sexy', 'attractive', 'hot', 'cute', 'stunning'];
    const hasFlirt = flirtWords.some(word => messageLower.includes(word) || responseLower.includes(word));
    if (hasFlirt && employee.stats.affection > 40) {
      gainSkillXP(employee, 'intimate', 5, 'flirt');
    }
    
    // Work talk detection
    const workWords = ['project', 'task', 'deadline', 'client', 'meeting', 'report'];
    const hasWorkTalk = workWords.some(word => messageLower.includes(word) || responseLower.includes(word));
    if (hasWorkTalk) {
      const highestSkill = getHighestSkill(employee);
      if (highestSkill.name !== 'none' && highestSkill.name !== 'intimate') {
        gainSkillXP(employee, highestSkill.name, 3, 'work_discussion');
      }
    }
  }

  // Helper function to get DOM elements safely
  function $(id) {
    return document.getElementById(id);
  }

  // ========== PHYSICAL APPEARANCE SYSTEM ==========
  
  /**
   * Generate detailed, unique physical appearance for an employee
   * This creates a consistent description used across ALL image generation
   * @param {string} gender - The gender of the employee ('female', 'male', 'femaleFuta', 'transMan', 'transWoman')
   */
  function generateDetailedPhysicalAppearance(gender = 'female', race = 'human') {
    // Height & Build
    const heights = ['petite', 'short', 'average height', 'tall', 'very tall'];
    
    // Gender-specific builds
    let builds;
    if (gender === 'male' || gender === 'transMan') {
      builds = ['lean', 'slim', 'athletic', 'average', 'stocky', 'broad-shouldered', 'muscular', 'toned', 'sturdy', 'wiry'];
    } else {
      builds = ['slender', 'slim', 'athletic', 'average', 'curvy', 'voluptuous', 'muscular', 'toned'];
    }
    
    // Hair - detailed
    const hairColors = [
      'platinum blonde', 'golden blonde', 'honey blonde', 'ash blonde', 'strawberry blonde',
      'light brown', 'chestnut brown', 'dark brown', 'chocolate brown',
      'auburn', 'copper red', 'ginger', 'burgundy',
      'jet black', 'raven black', 'dark black with blue sheen',
      'silver-gray', 'salt and pepper'
    ];
    const hairStyles = [
      'straight', 'wavy', 'curly', 'tight curls', 'beach waves', 'loose curls',
      'pin-straight', 'naturally wavy', 'tousled', 'messy waves'
    ];
    const hairLengths = [
      'pixie cut', 'short bob', 'chin-length bob', 'shoulder-length', 
      'mid-back length', 'waist-length', 'very long'
    ];
    const hairTextures = ['fine', 'thick', 'medium', 'voluminous', 'silky'];
    
    // Eyes - very detailed
    const eyeColors = [
      'bright blue', 'deep blue', 'ocean blue', 'ice blue', 'steel blue',
      'emerald green', 'jade green', 'hazel green', 'olive green',
      'dark brown', 'amber brown', 'honey brown', 'chocolate brown',
      'hazel with green flecks', 'hazel with gold flecks',
      'gray', 'stormy gray', 'gray-blue',
      'unusual violet', 'heterochromic (one blue, one brown)'
    ];
    const eyeShapes = [
      'almond-shaped', 'round', 'hooded', 'upturned', 'downturned',
      'doe eyes', 'cat eyes', 'deep-set', 'wide-set', 'close-set'
    ];
    
    // Facial Features
    const faceShapes = ['oval', 'round', 'heart-shaped', 'square', 'diamond', 'long'];
    const noseTypes = [
      'button nose', 'straight nose', 'slightly upturned nose', 'roman nose',
      'ski-slope nose', 'aquiline nose', 'petite nose', 'prominent nose'
    ];
    const lipShapes = [
      'full lips', 'thin lips', 'heart-shaped lips', 'bow-shaped lips',
      'plump lips', 'pouty lips', 'balanced lips', 'wide lips'
    ];
    const cheekbones = [
      'high cheekbones', 'prominent cheekbones', 'soft cheekbones',
      'defined cheekbones', 'subtle cheekbones', 'angular cheekbones'
    ];
    const jawlines = [
      'soft jawline', 'defined jawline', 'strong jawline', 'delicate jawline',
      'angular jawline', 'rounded jawline', 'sharp jawline'
    ];
    
    // Skin
    const skinTones = [
      'porcelain', 'fair', 'light', 'light-medium', 'beige', 'olive',
      'tan', 'medium', 'golden brown', 'caramel', 'bronze',
      'deep brown', 'dark brown', 'ebony', 'rich mahogany'
    ];
    const skinTextures = [
      'smooth', 'flawless', 'clear', 'glowing', 'radiant',
      'matte', 'dewy', 'sun-kissed', 'naturally luminous'
    ];
    
    // Body Features - Gender-specific
    let bodyShapes, chestDescriptor, chestSizes, buttSizes;
    
    if (gender === 'male') {
      // Male body descriptions
      bodyShapes = ['athletic', 'lean', 'muscular', 'stocky', 'broad-shouldered', 'rectangular', 'V-shaped', 'swimmer\'s build'];
      chestDescriptor = 'chest'; // Male chest descriptor
      chestSizes = ['flat', 'toned', 'well-defined', 'muscular', 'broad', 'barrel-chested'];
      buttSizes = ['flat', 'toned', 'athletic', 'round', 'muscular'];
    } else if (gender === 'transMan') {
      // Trans man body descriptions (may have mixed characteristics)
      bodyShapes = ['athletic', 'lean', 'rectangular', 'androgynous', 'toned', 'muscular'];
      chestDescriptor = 'chest';
      chestSizes = ['flat', 'compact', 'athletic', 'toned', 'bound', 'masculine'];
      buttSizes = ['compact', 'toned', 'athletic', 'round', 'firm'];
    } else if (gender === 'femaleFuta') {
      // Female futa body descriptions (feminine with additional attributes)
      bodyShapes = ['hourglass', 'athletic', 'curvy', 'statuesque', 'amazonian', 'voluptuous', 'toned'];
      chestDescriptor = 'bust';
      chestSizes = ['medium', 'full', 'large', 'very full', 'impressive', 'ample'];
      buttSizes = ['round', 'full', 'curvy', 'prominent', 'shapely'];
    } else {
      // Female and trans woman body descriptions
      bodyShapes = ['hourglass', 'pear-shaped', 'athletic', 'rectangular', 'inverted triangle', 'petite hourglass', 'curvy', 'willowy', 'statuesque'];
      chestDescriptor = 'bust';
      chestSizes = ['small', 'modest', 'medium', 'full', 'large', 'very full'];
      buttSizes = ['small', 'modest', 'round', 'full', 'curvy', 'prominent'];
    }
    
    const legTypes = [
      'long legs', 'proportionate legs', 'toned legs', 'athletic legs',
      'shapely legs', 'slender legs', 'muscular legs'
    ];
    
    // Fashion Style
    const fashionStyles = [
      'business professional', 'smart casual', 'trendy', 'classic elegant',
      'minimalist chic', 'bohemian', 'edgy modern', 'preppy',
      'casual comfortable', 'sophisticated', 'artsy', 'sporty chic'
    ];
    const accessories = [
      'often wears glasses', 'statement earrings', 'delicate jewelry',
      'minimalist accessories', 'watches', 'scarves', 'no accessories'
    ];
    
    // Distinguishing Features
    const features = [
      'dimples when smiling', 'freckles across nose', 'beauty mark', 'gap-toothed smile',
      'striking eyes', 'expressive face', 'mysterious aura', 'warm smile',
      'confident posture', 'graceful movements', 'energetic presence', 'calm demeanor'
    ];
    
    // Random selection helper
    const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
    
    // Genital Information - Gender-specific
    let genitalType, genitalSize, genitalCharacteristics;
    
    if (gender === 'male') {
      genitalType = 'penis';
      genitalSize = pick(['small', 'average', 'above average', 'large', 'very large']);
      genitalCharacteristics = pick(['circumcised', 'uncircumcised', 'well-groomed', 'natural', 'trimmed']);
    } else if (gender === 'transMan') {
      genitalType = pick(['enlarged clitoris', 'post-op penis', 'pre-op anatomy']);
      genitalSize = genitalType === 'post-op penis' ? pick(['average', 'above average', 'large']) : pick(['small', 'moderate', 'prominent']);
      genitalCharacteristics = pick(['well-groomed', 'natural', 'trimmed', 'maintained']);
    } else if (gender === 'femaleFuta') {
      genitalType = 'penis and vagina';
      genitalSize = pick(['average', 'above average', 'large', 'very large', 'impressive']);
      genitalCharacteristics = pick(['circumcised', 'uncircumcised', 'well-groomed', 'natural', 'dual anatomy']);
    } else if (gender === 'transWoman') {
      genitalType = pick(['vagina (post-op)', 'penis (pre-op)', 'tucked']);
      genitalSize = genitalType.includes('penis') ? pick(['small', 'average', 'above average']) : pick(['tight', 'normal', 'accommodating']);
      genitalCharacteristics = pick(['well-groomed', 'laser-treated', 'smooth', 'maintained', 'natural']);
    } else {
      // Female
      genitalType = 'vagina';
      genitalSize = pick(['tight', 'normal', 'accommodating', 'petite', 'average']);
      genitalCharacteristics = pick(['well-groomed', 'waxed', 'trimmed', 'natural', 'shaved', 'landing strip']);
    }
    
    // Build the complete physical profile
    const height = pick(heights);
    const build = pick(builds);
    const hairColor = pick(hairColors);
    const hairStyle = pick(hairStyles);
    const hairLength = pick(hairLengths);
    const hairTexture = pick(hairTextures);
    const eyeColor = pick(eyeColors);
    const eyeShape = pick(eyeShapes);
    const faceShape = pick(faceShapes);
    const noseType = pick(noseTypes);
    const lipShape = pick(lipShapes);
    const cheekbone = pick(cheekbones);
    const jawline = pick(jawlines);
    const skinTone = pick(skinTones);
    const skinTexture = pick(skinTextures);
    const bodyShape = pick(bodyShapes);
    const chestSize = pick(chestSizes);
    const buttSize = pick(buttSizes);
    const legType = pick(legTypes);
    const fashionStyle = pick(fashionStyles);
    const accessory = pick(accessories);
    const feature = pick(features);
    
    // Gender-appropriate pronouns and descriptors
    const genderPronoun = (gender === 'male' || gender === 'transMan') ? 'man' : 'woman';
    
    // ========== RACE/SPECIES FEATURES (COMPREHENSIVE SYSTEM) ==========
    const raceFeatures = getRaceFeatures(race || 'human', gender);
    const racePrefix = race && race !== 'human' ? raceFeatures.description + ' ' : '';
    
    // Override build if race has specific build tendency
    const finalBuild = raceFeatures.build || build;
    
    // Override skin tone if race requires specific skin (orcs, demons)
    let finalSkinTone = skinTone;
    if (raceFeatures.skin) {
      finalSkinTone = raceFeatures.skin;
    }
    
    // Override eye color if race requires specific eyes
    let finalEyeColor = eyeColor;
    if (raceFeatures.eyes) {
      finalEyeColor = raceFeatures.eyes;
    }
    
    // Build comprehensive race traits list
    const raceTraits = [];
    if (raceFeatures.ears) raceTraits.push(raceFeatures.ears);
    if (raceFeatures.tail) raceTraits.push(raceFeatures.tail);
    if (raceFeatures.fur) raceTraits.push(raceFeatures.fur);
    if (raceFeatures.furPattern) raceTraits.push(raceFeatures.furPattern);
    if (raceFeatures.horns) raceTraits.push(raceFeatures.horns);
    if (raceFeatures.skin && race !== 'human') raceTraits.push(raceFeatures.skin); // Only add if not human
    if (raceFeatures.eyes) raceTraits.push(raceFeatures.eyes);
    if (raceFeatures.other.length > 0) raceTraits.push(...raceFeatures.other);
    
    const raceDescription = raceTraits.length > 0 ? ` Race features: ${raceTraits.join(', ')}.` : '';
    
    // Build body descriptor with final build - placed here after race overrides
    const bodyDescriptor = `${bodyShape} physique with ${chestDescriptor === 'chest' ? chestSize + ' chest' : chestSize + ' ' + chestDescriptor}, ${buttSize} bottom, ${legType}`;
    
    return {
      // Basic
      height,
      build: finalBuild,
      gender,
      race: race || 'human',  // Race/Species field
      raceFeatures,  // Race-specific features (comprehensive)
      heightBuild: `${height}, ${finalBuild}`,
      
      // Hair (detailed)
      hair: {
        color: hairColor,
        style: hairStyle,
        length: hairLength,
        texture: hairTexture,
        full: `${hairLength} ${hairTexture} ${hairColor} hair, ${hairStyle}`
      },
      
      // Eyes (detailed) - uses race-specific eyes if applicable
      eyes: {
        color: finalEyeColor,
        shape: eyeShape,
        full: `${eyeShape} ${finalEyeColor} eyes`
      },
      
      // Face (detailed)
      face: {
        shape: faceShape,
        nose: noseType,
        lips: lipShape,
        cheekbones: cheekbone,
        jawline: jawline,
        full: `${faceShape} face with ${noseType}, ${lipShape}, ${cheekbone}, ${jawline}`
      },
      
      // Skin (detailed) - uses race-specific skin if applicable
      skin: {
        tone: finalSkinTone,
        texture: skinTexture,
        full: `${skinTexture} ${finalSkinTone} skin`
      },
      
      // Body (detailed) - Gender-appropriate
      body: {
        shape: bodyShape,
        chestDescriptor: chestDescriptor,
        chestSize: chestSize,
        breastSize: chestSize, // Kept for backwards compatibility
        buttSize: buttSize,
        legs: legType,
        full: bodyDescriptor
      },
      
      // Genital Information (detailed) - Gender-specific
      genitals: {
        type: genitalType,
        size: genitalSize,
        characteristics: genitalCharacteristics,
        full: `${genitalSize} ${genitalType}, ${genitalCharacteristics}`
      },
      
      // Style & Features
      fashion: fashionStyle,
      accessories: accessory,
      distinguishingFeature: feature,
      
      // Complete description for AI prompts - Gender-appropriate with comprehensive race features
      shortDescription: `${height} ${finalBuild} ${racePrefix}${genderPronoun} with ${hairLength} ${hairColor} hair, ${finalEyeColor} eyes, ${finalSkinTone}`,
      
      fullDescription: `${height} ${finalBuild} ${racePrefix}${genderPronoun} with ${hairLength} ${hairTexture} ${hairColor} hair (${hairStyle}), ${eyeShape} ${finalEyeColor} eyes, ${skinTexture} ${finalSkinTone}. ${faceShape} face with ${noseType}, ${lipShape}, ${cheekbone}, ${jawline}.${raceDescription} ${bodyDescriptor}. Genitals: ${genitalSize} ${genitalType}, ${genitalCharacteristics}. ${feature}. Style: ${fashionStyle}.`
    };
  }
  
  /**
   * Get consistent physical description for image prompts
   * Returns a prompt-ready string describing the employee's appearance
   */
  function getPhysicalDescriptionForPrompt(employee) {
    if (!employee.physical) {
      employee.physical = generateDetailedPhysicalAppearance(employee.gender || 'female', employee.race || 'human');
    }
    
    // If old format, upgrade it
    if (!employee.physical.fullDescription) {
      employee.physical = generateDetailedPhysicalAppearance(employee.gender || 'female', employee.race || 'human');
    }
    
    // Get base description
    let fullDesc = employee.physical.fullDescription;
    
    // ADD FLAG CONTEXT - Check for flags that affect physical appearance/state
    const activeFlags = getActiveFlags(employee);
    if (activeFlags.length > 0) {
      const physicalFlags = activeFlags.filter(f => 
        f.key === 'pregnant' || 
        f.key === 'chastity' || 
        f.key === 'pierced' ||
        f.key === 'tattooed' ||
        f.key === 'collar' ||
        f.key === 'locked' ||
        f.key === 'plugged' ||
        f.key === 'marked' ||
        f.key === 'bruised' ||
        f.key === 'leashed' ||
        f.key === 'bound' ||
        f.affectsContext // Any custom flag marked as affecting context
      );
      
      if (physicalFlags.length > 0) {
        fullDesc += '\n\nğŸ·ï¸ CURRENT PHYSICAL STATE:';
        physicalFlags.forEach(flag => {
          if (flag.playerDescription) {
            fullDesc += `\n- ${flag.playerDescription}`;
          }
          if (flag.aiGuidance) {
            fullDesc += ` (${flag.aiGuidance})`;
          }
        });
      }
    }
    
    return fullDesc;
  }

  /**
   * Get player's physical description from their profile for image generation
   * @returns {string} Formatted physical description
   */
  function getPlayerPhysicalDescription() {
    const profile = gameState.playerProfile;
    if (!profile) return '';
    
    const traits = [];
    
    // Build description from profile fields
    if (profile.age) traits.push(`${profile.age}-year-old`);
    if (profile.gender) traits.push(profile.gender);
    if (profile.ethnicity) traits.push(profile.ethnicity);
    if (profile.skinTone) traits.push(`${profile.skinTone} skin`);
    if (profile.height) traits.push(profile.height);
    if (profile.bodyType) traits.push(profile.bodyType);
    if (profile.hairColor && profile.hairStyle) {
      traits.push(`${profile.hairStyle} ${profile.hairColor} hair`);
    } else if (profile.hairColor) {
      traits.push(`${profile.hairColor} hair`);
    } else if (profile.hairStyle) {
      traits.push(`${profile.hairStyle} hair`);
    }
    if (profile.eyeColor) traits.push(`${profile.eyeColor} eyes`);
    if (profile.facialHair && profile.facialHair.toLowerCase() !== 'none' && profile.facialHair.toLowerCase() !== 'clean shaven') {
      traits.push(profile.facialHair);
    }
    
    // Add build/body details if provided
    if (profile.buildDetails) traits.push(profile.buildDetails);
    if (profile.chestSize) traits.push(profile.chestSize);
    
    // Add intimate details if provided (for explicit content)
    if (profile.genitalType && profile.genitalDetails) {
      traits.push(`${profile.genitalDetails} ${profile.genitalType}`);
    } else if (profile.genitalType) {
      traits.push(profile.genitalType);
    }
    
    // Add any additional details
    if (profile.additionalDetails) traits.push(profile.additionalDetails);
    
    return traits.join(', ');
  }

  /**
   * Get the company name from player profile, with fallback
   * @returns {string} Company name or generic fallback
   */
  function getCompanyName() {
    return gameState.playerProfile?.companyName || 'the company';
  }

  // ========== NUCLEAR CONTEXT INTELLIGENCE SYSTEM ==========
  
  /**
   * PHASE 1: Context Registry - Break down employee into scoreable context pieces
   * This is the foundation of intelligent context selection
   */
  
  function buildContextRegistry(employee) {
    if (!employee) return [];
    
    const pieces = [];
    const now = Date.now();
    
    // CORE IDENTITY (Always high priority - who they are)
    if (employee.name) {
      pieces.push({
        id: 'core.name',
        category: 'core_identity',
        text: `Name: ${employee.name}`,
        priority: 1.0,
        alwaysInclude: true
      });
    }
    
    if (employee.career?.title) {
      pieces.push({
        id: 'core.role',
        category: 'core_identity',
        text: `Role: ${employee.career.title} (Level ${employee.career.level || 1})`,
        priority: 1.0,
        alwaysInclude: true
      });
    }
    
    if (employee.gender) {
      pieces.push({
        id: 'core.gender',
        category: 'core_identity',
        text: `Gender: ${employee.gender}`,
        priority: 0.9,
        alwaysInclude: true
      });
    }
    
    // PERSONALITY (High value - how they act)
    if (employee.personality?.traits) {
      employee.personality.traits.forEach((trait, i) => {
        pieces.push({
          id: `personality.trait.${i}`,
          category: 'personality',
          text: `Personality: ${trait}`,
          priority: 0.8 - (i * 0.05), // First traits more important
          keywords: trait.toLowerCase().split(/\s+/)
        });
      });
    }
    
    // CURRENT STATE (High priority, time-sensitive)
    if (employee.stats?.mood) {
      pieces.push({
        id: 'state.mood',
        category: 'current_state',
        text: `Current mood: ${employee.stats.mood}`,
        priority: 0.85,
        freshness: true,
        lastUpdated: now
      });
    }
    
    if (employee.personalLife?.currentActivity?.description) {
      pieces.push({
        id: 'state.activity',
        category: 'current_state',
        text: `Currently: ${employee.personalLife.currentActivity.description}`,
        priority: 0.9,
        freshness: true,
        lastUpdated: employee.personalLife.currentActivity.startTime || now
      });
    }
    
    if (employee.schedule?.isCurrentlyWorking !== undefined) {
      pieces.push({
        id: 'state.working',
        category: 'current_state',
        text: `Work status: ${employee.schedule.isCurrentlyWorking ? 'Currently working' : 'Off duty'}`,
        priority: 0.7,
        freshness: true
      });
    }
    
    // PHYSICAL APPEARANCE (VERY LOW priority - only when relevant)
    if (employee.physical) {
      if (employee.physical.shortDescription) {
        pieces.push({
          id: 'physical.short',
          category: 'appearance',
          text: `Appearance: ${employee.physical.shortDescription}`,
          priority: 0.05, // Drastically reduced
          avoidRepetition: true // Flag for extra penalty
        });
      }
      
      if (employee.physical.fashion) {
        pieces.push({
          id: 'physical.fashion',
          category: 'appearance',
          text: `Style: ${employee.physical.fashion}`,
          priority: 0.02, // Drastically reduced
          avoidRepetition: true // Flag for extra penalty
        });
      }
    }
    
    // RELATIONSHIPS (LOW priority - only when directly relevant)
    // Only include top 4 strongest relationships to reduce prompt bloat
    if (employee.relationships) {
      Object.entries(employee.relationships)
        .filter(([_, rel]) => rel.type && rel.strength > 30) // Only meaningful relationships
        .sort(([_, a], [__, b]) => (b.strength || 0) - (a.strength || 0)) // Sort by strength descending
        .slice(0, 4) // Top 4 strongest only
        .forEach(([targetId, rel]) => {
          const target = gameState.employees.find(e => e.id === targetId);
          if (target) {
            const strength = rel.strength || 0;
            pieces.push({
              id: `relationship.${targetId}`,
              category: 'relationships',
              text: `Relationship with ${target.name}: ${rel.type} (${strength}/100)`,
              relatedTo: targetId,
              priority: 0.05 + (strength / 500), // DRASTICALLY reduced base priority
              keywords: [target.name.toLowerCase(), rel.type],
              avoidRepetition: true // HEAVY anti-repetition penalty
            });
          }
        });
    }
    
    // SKILLS (Work-context priority)
    if (employee.skills && typeof employee.skills === 'object') {
      Object.entries(employee.skills).forEach(([skillName, skillData]) => {
        if (skillData && skillData.level) {
          pieces.push({
            id: `skill.${skillName}`,
            category: 'skills',
            text: `Skill: ${skillName} (Level ${skillData.level})`,
            priority: 0.4,
            keywords: [skillName.toLowerCase()]
          });
        }
      });
    }
    
    // FLAGS/EVENTS (Variable priority based on flag importance)
    // Include ALL active flags (both system and custom) with proper formatting
    const activeFlags = getActiveFlags(employee);
    if (activeFlags && activeFlags.length > 0) {
      activeFlags.forEach((flag, i) => {
        const icon = flag.icon || 'ğŸš©';
        const description = flag.playerDescription || flag.aiDescription || flag.key || 'Unknown flag';
        const isHighPriority = flag.priority === 'high' || flag.key === 'pregnant' || flag.key === 'lactating';
        
        pieces.push({
          id: `flag.${flag.key || i}`,
          category: 'flags',
          text: `${icon} ${description}`,
          priority: isHighPriority ? 0.95 : 0.65, // Increased priority for visibility
          freshness: true,
          keywords: (description).toLowerCase().split(/\s+/)
        });
      });
    }
    
    // CHILDREN (High priority - family relationships are important)
    const children = getEmployeeChildren(employee.id);
    if (children && children.length > 0) {
      children.forEach((child, i) => {
        const ageText = child.age !== undefined ? ` (${child.age} days old)` : '';
        const fatherText = child.fatherID === 'player' ? 'with you' : 'from previous relationship';
        
        pieces.push({
          id: `child.${child.id || i}`,
          category: 'children',
          text: `Has a ${child.gender} named ${child.name}${ageText} ${fatherText}`,
          priority: 0.90, // Very high priority - important relationship context
          freshness: true,
          relatedTo: 'player',
          keywords: ['child', 'baby', child.name.toLowerCase(), child.gender]
        });
      });
    }
    
    // STATS (Moderate priority)
    if (employee.stats) {
      if (employee.stats.affection !== undefined) {
        pieces.push({
          id: 'stats.affection',
          category: 'stats',
          text: `Affection for you: ${employee.stats.affection}/100`,
          priority: 0.6,
          relatedTo: 'player'
        });
      }
      
      if (employee.stats.productivity !== undefined) {
        pieces.push({
          id: 'stats.productivity',
          category: 'stats',
          text: `Productivity: ${employee.stats.productivity}%`,
          priority: 0.5
        });
      }
    }
    
    // PERSONAL LIFE DETAILS (Low-medium priority)
    if (employee.personalLife?.livingSituation?.hasPet) {
      const pet = employee.personalLife.livingSituation;
      pieces.push({
        id: 'personal.pet',
        category: 'personal_life',
        text: `Has a ${pet.petType} named ${pet.petName}`,
        priority: 0.05, // DRASTICALLY REDUCED - only mention when directly relevant
        avoidRepetition: true, // Heavy anti-repetition penalty
        keywords: ['pet', pet.petType, pet.petName].map(k => k.toLowerCase())
      });
    }
    
    return pieces.filter(p => p.text); // Remove any with no text
  }
  
  /**
   * Initialize context usage tracking for an employee
   */
  function initializeContextTracking(employee) {
    if (!employee.contextUsage) {
      employee.contextUsage = {
        pieces: {}, // { contextId: { count, lastUsed, totalScore } }
        interactions: [], // Recent interaction history
        performance: {} // Which contexts led to good responses
      };
    }
  }
  
  /**
   * Track context usage after an interaction
   */
  function trackContextUsage(employee, selectedPieces, interactionId, interactionType) {
    initializeContextTracking(employee);
    
    selectedPieces.forEach(piece => {
      if (!employee.contextUsage.pieces[piece.id]) {
        employee.contextUsage.pieces[piece.id] = { 
          count: 0, 
          lastUsed: 0,
          totalScore: 0
        };
      }
      
      const usage = employee.contextUsage.pieces[piece.id];
      usage.count++;
      usage.lastUsed = Date.now();
      usage.totalScore += piece.score || 0;
    });
    
    // Store interaction record
    employee.contextUsage.interactions.push({
      id: interactionId,
      timestamp: gameState.time?.currentTime || Date.now(),
      type: interactionType,
      pieces: selectedPieces.map(p => p.id),
      pieceCount: selectedPieces.length
    });
    
    // Keep only last 100 interactions
    if (employee.contextUsage.interactions.length > 100) {
      employee.contextUsage.interactions = employee.contextUsage.interactions.slice(-100);
    }
  }
  
  /**
   * PHASE 1: Embedding Service (Simple keyword-based for now, upgradeable to real embeddings)
   */
  const NuclearEmbeddingService = {
    /**
     * Get "embedding" for an interaction (currently keyword-based)
     */
    getInteractionEmbedding(interaction) {
      const keywords = this.extractKeywords(interaction);
      return {
        keywords,
        type: interaction.type,
        involves: interaction.involves || []
      };
    },
    
    /**
     * Score how relevant a context piece is to an interaction
     */
    scoreSemanticRelevance(contextPiece, interactionEmbedding) {
      let score = 0;
      
      // Keyword matching
      if (contextPiece.keywords && interactionEmbedding.keywords) {
        const matches = contextPiece.keywords.filter(k => 
          interactionEmbedding.keywords.some(ik => 
            ik.includes(k) || k.includes(ik)
          )
        );
        score += matches.length * 0.2;
      }
      
      // Check if context relates to people involved
      if (contextPiece.relatedTo && interactionEmbedding.involves) {
        if (interactionEmbedding.involves.includes(contextPiece.relatedTo)) {
          score += 0.5;
        }
      }
      
      // Type-based affinity scoring
      const affinities = {
        'chat.casual': {
          personality: 1.0,
          current_state: 0.9,
          relationships: 0.7,
          personal_life: 0.6,
          appearance: 0.2,
          skills: 0.3,
          stats: 0.4
        },
        'chat.work': {
          skills: 1.0,
          core_identity: 0.9,
          current_state: 0.7,
          stats: 0.8,
          personality: 0.5,
          relationships: 0.4,
          appearance: 0.1
        },
        'social.post': {
          personality: 0.9,
          current_state: 0.8,
          relationships: 0.7,
          personal_life: 0.6,
          flags: 0.7,
          appearance: 0.4
        },
        'social.comment': {
          relationships: 0.8,
          personality: 0.7,
          current_state: 0.6,
          core_identity: 0.5
        }
      };
      
      const affinity = affinities[interactionEmbedding.type]?.[contextPiece.category] || 0.5;
      score += affinity * 0.6;
      
      return Math.min(score, 1.0); // Cap at 1.0
    },
    
    /**
     * Extract keywords from interaction
     */
    extractKeywords(interaction) {
      const text = [
        interaction.message,
        interaction.prompt,
        ...(interaction.recentMessages || []).map(m => m.content)
      ].filter(Boolean).join(' ');
      
      return text.toLowerCase()
        .split(/\W+/)
        .filter(w => w.length > 3)
        .filter(w => !this.stopWords.has(w))
        .slice(0, 30);
    },
    
    // Common words to ignore
    stopWords: new Set(['that', 'this', 'with', 'from', 'have', 'been', 'were', 'your', 'them', 'they'])
  };
  
  // Make it globally available
  window.NuclearEmbeddingService = NuclearEmbeddingService;
  
  console.log('ğŸš€ Nuclear Context Intelligence System - Phase 1 Initialized');
  
  /**
   * PHASE 2: INTELLIGENT CONTEXT SELECTION ğŸš€
   * Multi-dimensional scoring with adaptive selection
   */
  
  /**
   * Select the best context pieces for an interaction using intelligent scoring
   * @param {object} employee - Employee object
   * @param {object} interaction - Interaction details
   * @param {object} options - Selection options
   * @returns {Array} Selected context pieces with scores
   */
  function selectIntelligentContext(employee, interaction, options = {}) {
    const {
      maxTokens = 500,           // Rough token budget
      minPieces = 5,             // Minimum pieces to include
      maxPieces = 20,            // Maximum pieces
      diversityWeight = 0.3,     // How much to value category diversity
      antiRepetitionWeight = 0.4 // How much to penalize recently used pieces
    } = options;
    
    // Build the context registry
    const pieces = buildContextRegistry(employee);
    if (pieces.length === 0) return [];
    
    // Initialize tracking
    initializeContextTracking(employee);
    
    // Get interaction embedding
    const interactionEmbedding = NuclearEmbeddingService.getInteractionEmbedding(interaction);
    
    // Score each piece with multi-dimensional analysis
    const scoredPieces = pieces.map(piece => {
      const scores = {
        base: piece.priority || 0.5,
        semantic: 0,
        temporal: 0,
        novelty: 0,
        coherence: 0
      };
      
      // DIMENSION 1: Semantic Relevance
      scores.semantic = NuclearEmbeddingService.scoreSemanticRelevance(piece, interactionEmbedding);
      
      // DIMENSION 2: Temporal Relevance (freshness bonus)
      if (piece.freshness && piece.lastUpdated) {
        const age = Date.now() - piece.lastUpdated;
        const hoursSinceUpdate = age / (1000 * 60 * 60);
        scores.temporal = Math.max(0, 1 - (hoursSinceUpdate / 24)); // Decay over 24 hours
      } else {
        scores.temporal = 0.3; // Default for non-time-sensitive
      }
      
      // DIMENSION 3: Novelty (anti-repetition)
      const usage = employee.contextUsage.pieces[piece.id];
      if (usage) {
        const timeSinceLastUse = (Date.now() - usage.lastUsed) / (1000 * 60 * 60); // hours
        const usageFrequency = usage.count / Math.max(1, employee.contextUsage.interactions.length);
        
        // Penalize frequently used, recently used pieces
        let noveltyScore = Math.min(1.0, timeSinceLastUse / 48) * (1 - usageFrequency);
        
        // EXTRA HEAVY penalty for appearance pieces (avoid repetition)
        if (piece.avoidRepetition) {
          noveltyScore *= 0.3; // 70% penalty for recently used appearance
          if (timeSinceLastUse < 1) { // Used in last hour
            noveltyScore = 0; // Completely exclude
          }
        }
        
        scores.novelty = noveltyScore;
      } else {
        scores.novelty = 1.0; // Never used = maximum novelty
      }
      
      // DIMENSION 4: Coherence (relationships with other selected pieces)
      // This will be calculated in second pass
      scores.coherence = 0.5; // Default
      
      // Calculate composite score
      const compositeScore = (
        scores.base * 0.25 +
        scores.semantic * 0.35 +
        scores.temporal * 0.15 +
        scores.novelty * antiRepetitionWeight +
        scores.coherence * 0.1
      );
      
      return {
        ...piece,
        scores,
        score: piece.alwaysInclude ? 999 : compositeScore // Force-include marked pieces
      };
    });
    
    // Sort by score
    scoredPieces.sort((a, b) => b.score - a.score);
    
    // ADAPTIVE SELECTION with category balancing
    const selected = [];
    const categoryCount = {};
    let estimatedTokens = 0;
    
    // First pass: Always-include pieces
    scoredPieces.filter(p => p.alwaysInclude).forEach(piece => {
      selected.push(piece);
      categoryCount[piece.category] = (categoryCount[piece.category] || 0) + 1;
      estimatedTokens += estimateTokens(piece.text);
    });
    
    // Second pass: Greedy selection with diversity bonus
    for (const piece of scoredPieces) {
      if (piece.alwaysInclude) continue; // Already added
      if (selected.length >= maxPieces) break;
      if (estimatedTokens >= maxTokens && selected.length >= minPieces) break;
      
      // Apply diversity bonus if category is underrepresented
      const categoryRatio = (categoryCount[piece.category] || 0) / Math.max(1, selected.length);
      const diversityBonus = categoryRatio < 0.3 ? diversityWeight : 0;
      const adjustedScore = piece.score + diversityBonus;
      
      // Calculate coherence with already selected pieces
      let coherenceBonus = 0;
      for (const selectedPiece of selected) {
        // Same category bonus
        if (selectedPiece.category === piece.category) {
          coherenceBonus += 0.05;
        }
        // Relationship bonus
        if (piece.relatedTo && selectedPiece.relatedTo === piece.relatedTo) {
          coherenceBonus += 0.1;
        }
        // Keyword overlap bonus
        if (piece.keywords && selectedPiece.keywords) {
          const overlap = piece.keywords.filter(k => selectedPiece.keywords.includes(k));
          coherenceBonus += overlap.length * 0.03;
        }
      }
      
      const finalScore = adjustedScore + coherenceBonus;
      
      // Accept if score is high enough or we need more pieces
      if (finalScore > 0.3 || selected.length < minPieces) {
        selected.push({ ...piece, score: finalScore });
        categoryCount[piece.category] = (categoryCount[piece.category] || 0) + 1;
        estimatedTokens += estimateTokens(piece.text);
      }
    }
    
    return selected;
  }
  
  /**
   * Estimate tokens in text (rough approximation)
   */
  function estimateTokens(text) {
    if (!text) return 0;
    // Rough: 1 token ~= 4 characters for English
    return Math.ceil(text.length / 4);
  }
  
  /**
   * Format selected context pieces into a prompt string
   * @param {Array} pieces - Selected context pieces
   * @param {object} options - Formatting options
   * @returns {string} Formatted context
   */
  function formatContextForPrompt(pieces, options = {}) {
    const {
      grouped = true,           // Group by category
      includeScores = false,    // Debug mode
      categoryLabels = true     // Show category headers
    } = options;
    
    if (!grouped) {
      // Simple flat list
      return pieces.map(p => {
        const scoreStr = includeScores ? ` [score: ${p.score.toFixed(2)}]` : '';
        return `- ${p.text}${scoreStr}`;
      }).join('\n');
    }
    
    // Grouped by category
    const groups = {};
    pieces.forEach(piece => {
      if (!groups[piece.category]) {
        groups[piece.category] = [];
      }
      groups[piece.category].push(piece);
    });
    
    // Category display order
    const categoryOrder = [
      'core_identity', 'personality', 'current_state', 'relationships',
      'skills', 'stats', 'flags', 'personal_life', 'appearance'
    ];
    
    const lines = [];
    categoryOrder.forEach(category => {
      if (groups[category] && groups[category].length > 0) {
        if (categoryLabels) {
          const label = category.replace(/_/g, ' ').toUpperCase();
          lines.push(`\n${label}:`);
        }
        groups[category].forEach(piece => {
          const scoreStr = includeScores ? ` [${piece.score.toFixed(2)}]` : '';
          lines.push(`- ${piece.text}${scoreStr}`);
        });
      }
    });
    
    return lines.join('\n').trim();
  }
  
  /**
   * MAIN API: Get intelligent context for any interaction
   * @param {object} employee - Employee object
   * @param {string} interactionType - Type: 'chat.casual', 'chat.work', 'social.post', etc
   * @param {object} interactionData - Additional interaction data
   * @returns {string} Formatted context string ready for prompt
   */
  function getIntelligentContext(employee, interactionType, interactionData = {}) {
    if (!employee) return '';
    
    const interaction = {
      type: interactionType,
      ...interactionData
    };
    
    // Token budgets by interaction type
    const budgets = {
      'chat.casual': { maxTokens: 400, maxPieces: 15 },
      'chat.work': { maxTokens: 350, maxPieces: 12 },
      'social.post': { maxTokens: 300, maxPieces: 10 },
      'social.comment': { maxTokens: 250, maxPieces: 8 },
      'profile.description': { maxTokens: 500, maxPieces: 20 }
    };
    
    const budget = budgets[interactionType] || { maxTokens: 400, maxPieces: 15 };
    
    // Select best context
    const selectedPieces = selectIntelligentContext(employee, interaction, budget);
    
    // Track usage
    const interactionId = `${interactionType}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    trackContextUsage(employee, selectedPieces, interactionId, interactionType);
    
    // Format for prompt
    return formatContextForPrompt(selectedPieces, { grouped: true });
  }
  
  console.log('ğŸ”¥ Nuclear Context Intelligence System - Phase 2 IGNITED');
  
  /**
   * PHASE 3: DEBUG & ANALYTICS
   * Visualize what context is being selected and why
   */
  
  /**
   * Get analytics for an employee's context usage
   */
  function getContextAnalytics(employee) {
    if (!employee.contextUsage) return null;
    
    const analytics = {
      totalInteractions: employee.contextUsage.interactions.length,
      piecesUsed: Object.keys(employee.contextUsage.pieces).length,
      mostUsedPieces: [],
      leastUsedPieces: [],
      categoryDistribution: {},
      averagePiecesPerInteraction: 0,
      recentInteractions: employee.contextUsage.interactions.slice(-5)
    };
    
    // Calculate category distribution
    const registry = buildContextRegistry(employee);
    registry.forEach(piece => {
      analytics.categoryDistribution[piece.category] = 
        (analytics.categoryDistribution[piece.category] || 0) + 1;
    });
    
    // Sort pieces by usage
    const sortedPieces = Object.entries(employee.contextUsage.pieces)
      .map(([id, usage]) => {
        const piece = registry.find(p => p.id === id);
        return { id, usage, piece };
      })
      .sort((a, b) => b.usage.count - a.usage.count);
    
    analytics.mostUsedPieces = sortedPieces.slice(0, 5);
    analytics.leastUsedPieces = sortedPieces.slice(-5).reverse();
    
    // Average pieces per interaction
    const totalPieces = employee.contextUsage.interactions.reduce((sum, int) => 
      sum + int.pieceCount, 0);
    analytics.averagePiecesPerInteraction = 
      totalPieces / Math.max(1, employee.contextUsage.interactions.length);
    
    return analytics;
  }
  
  /**
   * Debug function: Show context selection for an interaction
   * Use in console: debugContextSelection(employee, 'chat.casual', {message: 'hello'})
   */
  window.debugContextSelection = function(employee, interactionType, interactionData) {
    console.group(`ğŸš€ Nuclear Context Selection Debug`);
    console.log('Employee:', employee.name);
    console.log('Interaction Type:', interactionType);
    console.log('Interaction Data:', interactionData);
    
    const interaction = { type: interactionType, ...interactionData };
    const selectedPieces = selectIntelligentContext(employee, interaction, { maxTokens: 400, maxPieces: 15 });
    
    console.log('\nğŸ“Š Selected Context Pieces:', selectedPieces.length);
    console.table(selectedPieces.map(p => ({
      ID: p.id,
      Category: p.category,
      Score: p.score.toFixed(3),
      Priority: p.priority,
      Text: p.text.substring(0, 60) + '...'
    })));
    
    console.log('\nğŸ“ˆ Score Breakdown:');
    selectedPieces.slice(0, 5).forEach(p => {
      console.log(`\n${p.id}:`);
      console.log('  Base:', p.scores.base.toFixed(3));
      console.log('  Semantic:', p.scores.semantic.toFixed(3));
      console.log('  Temporal:', p.scores.temporal.toFixed(3));
      console.log('  Novelty:', p.scores.novelty.toFixed(3));
      console.log('  Coherence:', p.scores.coherence.toFixed(3));
      console.log('  â†’ FINAL:', p.score.toFixed(3));
    });
    
    console.log('\nğŸ“ Formatted Context:');
    console.log(formatContextForPrompt(selectedPieces, { grouped: true }));
    
    console.groupEnd();
    
    return selectedPieces;
  };
  
  /**
   * Debug function: Show context analytics for an employee
   * Use in console: showContextAnalytics(gameState.employees[0])
   */
  window.showContextAnalytics = function(employee) {
    const analytics = getContextAnalytics(employee);
    if (!analytics) {
      console.log('No context usage data for', employee.name);
      return;
    }
    
    console.group(`ğŸ“Š Context Analytics: ${employee.name}`);
    console.log('Total Interactions:', analytics.totalInteractions);
    console.log('Unique Pieces Used:', analytics.piecesUsed);
    console.log('Avg Pieces/Interaction:', analytics.averagePiecesPerInteraction.toFixed(1));
    
    console.log('\nğŸ“ˆ Category Distribution:');
    console.table(analytics.categoryDistribution);
    
    console.log('\nğŸ”¥ Most Used Context:');
    console.table(analytics.mostUsedPieces.map(p => ({
      ID: p.id,
      Count: p.usage.count,
      Text: p.piece?.text.substring(0, 50) || 'N/A'
    })));
    
    console.log('\nâ„ï¸ Least Used Context:');
    console.table(analytics.leastUsedPieces.map(p => ({
      ID: p.id,
      Count: p.usage.count,
      Text: p.piece?.text.substring(0, 50) || 'N/A'
    })));
    
    console.log('\nâ±ï¸ Recent Interactions:');
    analytics.recentInteractions.forEach(int => {
      const timeAgo = Math.round((Date.now() - int.timestamp) / 60000);
      console.log(`${int.type} - ${timeAgo}m ago - ${int.pieceCount} pieces`);
    });
    
    console.groupEnd();
  };

  /**
   * Debug function: Populate rehire pool with current employees
   * Use in console: window.testRehirePool()
   * This adds your current employees to the rehire pool so you can test the rehire system without prestiging
   */
  window.testRehirePool = function() {
    if (!gameState.employees || gameState.employees.length === 0) {
      console.log('âŒ No employees to add to rehire pool. Hire some employees first!');
      return;
    }
    
    // Copy current employees to rehire pool
    gameState.rehirePool = gameState.employees.map(emp => ({
      ...emp,
      timesRehired: 0,
      previousPosition: emp.career?.title || 'Employee'
    }));
    
    console.log(`âœ… Added ${gameState.rehirePool.length} employees to rehire pool!`);
    console.log('Now open the hiring modal to see the "Rehire Former Employees" button.');
    console.log('The toggle will show all your current employees as rehire candidates.');
    console.table(gameState.rehirePool.map(e => ({
      Name: e.name,
      Age: e.age,
      Position: e.previousPosition,
      Skills: `Tech:${e.skills?.technical?.level || 1} Soc:${e.skills?.social?.level || 1}`
    })));
  };

  
  console.log('ğŸ”¬ Nuclear Context Debug Tools Loaded!');
  console.log('  â†’ debugContextSelection(employee, type, data)');
  console.log('  â†’ showContextAnalytics(employee)');

  // ========== GIFT SYSTEM ==========
  
  /**
   * Calculate gift price scaling based on current lifetime income
   * @returns {object} Price scale info with min, max, and sweet spot
   */
  function calculateGiftPriceScale() {
    const currentLifetimeIncome = gameState.currentLifetimeIncome || 0;
    
    // Scale based on current lifetime earnings  
    // Early: $1K-$1M lifetime = $10-$1K gifts recommended
    // Mid: $1M-$100M lifetime = $100-$100K gifts recommended
    // Late: $100M-$10B lifetime = $1K-$10M gifts recommended
    // End: $10B+ lifetime = $100K-$1B+ gifts recommended
    
    const logIncome = Math.log10(Math.max(1000, currentLifetimeIncome));
    const scale = logIncome - 3; // 0 at $1K, increases logarithmically
    
    return {
      tier: Math.floor(scale),
      minRecommended: Math.pow(10, 1 + scale * 0.8),
      maxRecommended: Math.pow(10, 4 + scale * 0.8),
      sweetSpot: Math.pow(10, 2.5 + scale * 0.8)
    };
  }
  
  /**
   * Map potentially invalid category to valid GIFT_CATEGORIES key
   * @param {string} categoryString - Category string from AI
   * @returns {string} Valid category key
   */
  function mapToValidCategory(categoryString) {
    const lower = categoryString.toLowerCase();
    
    if (lower.includes('roman') || lower.includes('love')) return 'ROMANTIC';
    if (lower.includes('lux') || lower.includes('expensive')) return 'LUXURY';
    if (lower.includes('trip') || lower.includes('travel') || lower.includes('exper')) return 'EXPERIENCES';
    if (lower.includes('tech') || lower.includes('electron') || lower.includes('gadget')) return 'TECH';
    if (lower.includes('book') || lower.includes('art') || lower.includes('intel')) return 'INTELLECTUAL';
    if (lower.includes('food') || lower.includes('wine') || lower.includes('drink')) return 'FOOD';
    if (lower.includes('practical') || lower.includes('useful') || lower.includes('tool')) return 'PRACTICAL';
    if (lower.includes('quirk') || lower.includes('unusual')) return 'QUIRKY';
    if (lower.includes('fit') || lower.includes('health') || lower.includes('wellness')) return 'WELLNESS';
    if (lower.includes('fashion') || lower.includes('cloth') || lower.includes('beauty')) return 'FASHION';
    if (lower.includes('unique') || lower.includes('one') || lower.includes('rare')) return 'UNIQUE';
    
    // Default fallback
    return 'QUIRKY';
  }
  
  /**
   * Generate a custom gift using AI based on user description
   * @param {string} userDescription - What the player wants to create
   * @param {number} maxBudget - Optional budget limit
   * @param {object} controller - Cancellation controller {cancelled: boolean}
   * @returns {Promise<object>} Generated gift object
   */
  async function generateCustomGift(userDescription, maxBudget = Infinity, controller = null) {
    // Genie refusal list - things too gross/harmful to create
    const GENIE_REFUSALS = [
      { 
        keywords: ['shit', 'feces', 'poop', 'excrement', 'fecal', 'dung', 'crap'], 
        responses: [
          "ğŸ¤¢ Ew, absolutely not. I create GIFTS, not... that. Try asking for something people would actually want to receive!",
          "ğŸ¤¢ Are you serious? No. I'm a magical gift genie, not a porta-potty. Ask for something that doesn't belong in a toilet.",
          "ğŸ¤¢ Gross! Hard pass. I make THOUGHTFUL presents, not biohazards. Try again with something that isn't disgusting.",
          "ğŸ¤¢ Yeah, no. That's not happening. I have standards, and they don't include literal waste. Next idea, please!",
          "ğŸ¤¢ Absolutely NOT. Why would you even... you know what, I don't want to know. Ask for a real gift."
        ]
      },
      { 
        keywords: ['vomit', 'puke', 'barf', 'vomitus'], 
        responses: [
          "ğŸ¤® That's disgusting. I'm not creating biohazards. Ask for something that won't make people sick.",
          "ğŸ¤® Uh, no thanks. I deal in GIFTS, not bodily fluids. Try something that doesn't come from someone's stomach.",
          "ğŸ¤® Hard no. That's revolting. Pick literally anything else that people would want to receive.",
          "ğŸ¤® Are you trying to make me gag? Not happening. Ask for something that belongs in a gift box, not a sick bag."
        ]
      },
      { 
        keywords: ['urine', 'piss', 'pee'], 
        responses: [
          "ğŸ˜’ No. Just... no. Why would anyone want that? Try something that isn't a bodily fluid.",
          "ğŸ˜’ I'm not even dignifying that with a full response. No. Ask for something that isn't liquid waste.",
          "ğŸ˜’ You're joking, right? That's a hard no. Try asking for something that people actually want.",
          "ğŸ˜’ Absolutely not. I create thoughtful gifts, not... whatever that is. Pick something else."
        ]
      },
      { 
        keywords: ['dead body', 'corpse', 'cadaver', 'roadkill'], 
        responses: [
          "ğŸ’€ That's disturbing AND illegal. I don't do morbid stuff. Ask for something appropriate.",
          "ğŸ’€ What is WRONG with you? No. That's creepy and illegal. Try something that's, you know... alive? Or at least not dead?",
          "ğŸ’€ Uh, that's a felony waiting to happen. Hard pass. Ask for something that won't get anyone arrested.",
          "ğŸ’€ Yeah, I'm not touching that with a 10-foot pole. Way too dark. Try something that doesn't involve death.",
          "ğŸ’€ I think I know where I can get the body from... Get out of here with that request."
        ]
      },
      { 
        keywords: ['garbage', 'trash can', 'rubbish', 'waste bin', 'literal trash'], 
        responses: [
          "ğŸ—‘ï¸ I make thoughtful gifts, not insults. If you want to give someone trash, just... don't give them anything.",
          "ğŸ—‘ï¸ Really? Garbage? That's not a gift, that's an insult. Try something that shows you actually care.",
          "ğŸ—‘ï¸ No way. I create meaningful presents, not things that belong in a landfill. Ask for something with value.",
          "ğŸ—‘ï¸ Hard no. Why would you gift someone actual trash? Try something people would appreciate."
        ]
      },
      { 
        keywords: ['heroin', 'meth', 'cocaine', 'crack', 'fentanyl', 'opioid'], 
        responses: [
          "ğŸ’Š Hard drugs? No way. I'm not helping anyone with that. Stick to legal, non-harmful gifts.",
          "ğŸ’Š Absolutely not. That's dangerous and illegal. I only create gifts that won't destroy lives.",
          "ğŸ’Š Yeah, that's a HUGE no. I don't do hard drugs. Try something that won't kill someone.",
          "ğŸ’Š Not happening. I create gifts that bring joy, not addiction. Ask for something legal and safe."
        ]
      },
      { 
        keywords: ['slave', 'human trafficking', 'kidnapped'], 
        responses: [
          "â›“ï¸ Absolutely NOT. That's horrifying and illegal. I only create ethical gifts.",
          "â›“ï¸ WHAT?! No. That's beyond disturbing. I'm not even going to entertain that thought. Ask for something that isn't a crime against humanity.",
          "â›“ï¸ That's horrific. Hard no. I create gifts, not human rights violations. Try something ethical.",
          "â›“ï¸ Are you out of your mind? No. That's evil and illegal. Ask for something that doesn't involve kidnapping."
        ]
      },
      { 
        keywords: ['explosive', 'bomb', 'grenade', 'c4', 'dynamite'], 
        responses: [
          "ğŸ’£ I don't create explosives or dangerous weapons. Try something that won't blow up.",
          "ğŸ’£ Yeah, no. I'm not making anything that explodes. That's way too dangerous. Pick something safer.",
          "ğŸ’£ Hard pass on anything that goes boom. I create GIFTS, not terrorist supplies. Try again.",
          "ğŸ’£ Absolutely not. That's insanely dangerous. Ask for something that won't land you on a watchlist."
        ]
      }
    ];
    
    // Check for refusals
    const lowerDesc = userDescription.toLowerCase();
    for (const refusal of GENIE_REFUSALS) {
      if (refusal.keywords.some(kw => lowerDesc.includes(kw))) {
        // Pick a random response from the array
        const randomResponse = refusal.responses[Math.floor(Math.random() * refusal.responses.length)];
        showNotification(randomResponse, 'warning');
        throw new Error('Genie refused this request');
      }
    }
    
    // Check if request is obviously WAY beyond budget (if budget is set)
    if (maxBudget !== Infinity) {
      const expensiveKeywords = [
        { keywords: ['continent', 'country', 'nation', 'planet', 'moon', 'earth', 'world'], minCost: 999999999999, item: 'geographical entities' },
        { keywords: ['google', 'apple', 'microsoft', 'amazon', 'facebook', 'meta', 'tesla'], minCost: 500000000000, item: 'tech companies' },
        { keywords: ['twitter', 'netflix', 'spotify', 'uber'], minCost: 10000000000, item: 'major companies' },
        { keywords: ['skyscraper', 'empire state', 'burj khalifa', 'stadium'], minCost: 1000000000, item: 'iconic buildings' },
        { keywords: ['cruise ship', 'aircraft carrier', 'space station'], minCost: 1000000000, item: 'massive vehicles' }
      ];
      
      for (const expensive of expensiveKeywords) {
        if (expensive.keywords.some(kw => lowerDesc.includes(kw)) && maxBudget < expensive.minCost) {
          const responses = [
            `ğŸ§â€â™‚ï¸ Uh... you want ${expensive.item} with a $${maxBudget.toLocaleString()} budget? That's not even close. Come back when you're serious.`,
            `ğŸ§â€â™‚ï¸ Yeah, no. ${expensive.item.charAt(0).toUpperCase() + expensive.item.slice(1)} cost WAY more than $${maxBudget.toLocaleString()}. Remove your budget limit if you want me to make this.`,
            `ğŸ§â€â™‚ï¸ Your budget is $${maxBudget.toLocaleString()} and you're asking for ${expensive.item}? That's like trying to buy a mansion with lunch money. Not happening.`,
            `ğŸ§â€â™‚ï¸ LOL. ${expensive.item.charAt(0).toUpperCase() + expensive.item.slice(1)} are WAY out of your $${maxBudget.toLocaleString()} budget. Either remove the limit or ask for something realistic.`
          ];
          const randomResponse = responses[Math.floor(Math.random() * responses.length)];
          showNotification(randomResponse, 'warning');
          throw new Error('Genie refused this request');
        }
      }
    }
    
    const priceScale = calculateGiftPriceScale();
    
    const categoryList = Object.entries(GIFT_CATEGORIES)
      .map(([key, val]) => `${key} (${val.examples})`)
      .join('\n');
    
    const prompt = `You are a gift creation AI for a game. Generate a specific, tangible gift based on the player's request.

PLAYER REQUEST: "${userDescription}"

ğŸ¯ INTERPRETATION RULES ğŸ¯
âš ï¸ CRITICAL: Interpret the request LITERALLY. Do NOT force adult/erotic themes where they don't exist!

IF the player asks for NORMAL items (jewelry, cars, electronics, clothing, art, collectibles, etc.):
â†’ Generate NORMAL versions. The "Hope Diamond" should be the actual Hope Diamond, NOT a sex toy version!

IF the player asks for ADULT/EROTIC items (sex toys, lingerie with explicit intent, BDSM gear, etc.):
â†’ Generate ADULT versions with direct, explicit language. Use proper terminology (vibrators, dildos, restraints, etc.)
â†’ DO NOT sanitize with euphemisms like "intimate massager" or "personal wellness device"

EXAMPLES OF CORRECT INTERPRETATION:
âœ… "Hope Diamond" â†’ {name: "The Hope Diamond", category: "UNIQUE", price: 250000000} (famous blue diamond)
âœ… "diamond necklace" â†’ {name: "18K White Gold Diamond Necklace", category: "LUXURY", price: 15000} (actual jewelry)
âœ… "sports car" â†’ {name: "Porsche 911 Turbo S", category: "LUXURY", price: 250000} (actual car)
âœ… "vibrator" â†’ {name: "Lelo Soraya Wave Vibrator", category: "QUIRKY", price: 189} (adult toy - explicit)
âœ… "lingerie" â†’ {name: "Agent Provocateur Lace Bodysuit", category: "FASHION", price: 450} (sexy clothing)
âœ… "BDSM restraints" â†’ {name: "Leather Bondage Restraint Set", category: "QUIRKY", price: 295} (adult gear - explicit)

âŒ WRONG INTERPRETATIONS (DO NOT DO THIS):
âŒ "Hope Diamond" â†’ "Replica Hope Diamond Dildo" (NO! Player wanted the actual diamond!)
âŒ "diamond necklace" â†’ "Diamond-Studded Collar" (NO! Unless they specifically asked for BDSM gear!)
âŒ "sports car" â†’ "Sybian with Racing Stripes" (NO! Player wanted an actual car!)

COMPANY SCALE (FOR REFERENCE ONLY - DO NOT LET THIS DICTATE PRICE):
- Current lifetime income: $${(gameState.currentLifetimeIncome || 0).toLocaleString()}
- Recommended gift range: $${Math.round(priceScale.minRecommended).toLocaleString()} - $${Math.round(priceScale.maxRecommended).toLocaleString()}
- Budget limit: ${maxBudget === Infinity ? 'No limit' : '$' + maxBudget.toLocaleString()}

âš ï¸ CRITICAL PRICING RULES âš ï¸
**Price MUST reflect REAL-WORLD market value, NOT player wealth!**

REAL-WORLD PRICING EXAMPLES:
- Coffee mug: $15-50
- Nice watch: $500-5,000
- Luxury watch (Rolex): $10,000-100,000
- Designer handbag: $2,000-15,000
- Sports car: $100,000-500,000
- Supercar (Ferrari, Lamborghini): $500,000-3,000,000
- Luxury yacht: $5,000,000-50,000,000
- Private jet: $10,000,000-100,000,000
- Small island: $50,000,000-500,000,000
- Famous painting (Van Gogh, etc): $50,000,000-500,000,000
- Iconic building (Empire State): $2,000,000,000-5,000,000,000
- Major sports team (NFL, NBA): $3,000,000,000-7,000,000,000
- Twitter/X (entire company): $44,000,000,000
- Major tech company (Google, Apple): $1,000,000,000,000+
- Continent/Country: PRICELESS (use $999,999,999,999,999 for impossibly ambitious requests)

ADULT/EROTIC ITEM PRICING:
- Basic sex toy (vibrator, dildo): $30-150
- High-end sex toy (We-Vibe, Lelo): $100-300
- Luxury lingerie set: $100-500
- BDSM gear set: $150-800
- Full sex furniture (Liberator): $300-2,000
- Sybian machine: $1,300-1,500
- Professional stripper pole: $200-600
- Sex doll (basic): $1,000-3,000
- High-end realistic sex doll: $3,000-10,000
- Custom AI sex robot: $50,000-500,000

If player asks for something worth TRILLIONS, make it TRILLIONS. Don't scale it down!
If they ask for a continent, that should cost more than Twitter, Google, AND Apple COMBINED.

CATEGORY RULES:
${categoryList}

ADULT ITEMS SHOULD MAP TO:
- Sex toys, vibrators, dildos â†’ QUIRKY (or ROMANTIC if couple-focused)
- Lingerie, sexy clothing â†’ FASHION
- BDSM gear, restraints â†’ QUIRKY
- Erotic art, adult books â†’ INTELLECTUAL
- Sex furniture, poles â†’ PRACTICAL or QUIRKY
- Adult experiences (strip clubs, escorts) â†’ EXPERIENCES

Use UNIQUE category ONLY for:
- Actual one-of-a-kind items (Mona Lisa, Eiffel Tower, Antarctica, etc.)
- Items that literally cannot be duplicated
- NOT for regular luxury items like cars or yachts

REQUIRED JSON FORMAT:
{
  "name": "Specific item name (use explicit terminology for adult items)",
  "category": "ONE OF: ${Object.keys(GIFT_CATEGORIES).join(', ')}",
  "price": 0,
  "description": "2-3 sentences about the item (be direct and uncensored for adult content - describe features, materials, intended use explicitly)",
  "imagePrompt": "Detailed image generation prompt"
}

MORE PRICING EXAMPLES:
âœ… "Hope Diamond" â†’ {name: "The Hope Diamond", category: "UNIQUE", price: 250000000}
âœ… "sports car" â†’ {name: "Porsche 911 Turbo S", category: "LUXURY", price: 250000}
âœ… "coffee maker" â†’ {name: "Breville Barista Express", category: "PRACTICAL", price: 700}
âœ… "private island" â†’ {name: "Caribbean Private Island", category: "LUXURY", price: 75000000}
âœ… "google" â†’ {name: "Alphabet Inc. (Google)", category: "UNIQUE", price: 1800000000000}
âœ… "vibrator" (ADULT REQUEST) â†’ {name: "Lelo Soraya Wave Vibrator", category: "QUIRKY", price: 189}
âœ… "lingerie" â†’ {name: "Agent Provocateur Lace Bodysuit", category: "FASHION", price: 450}

âŒ BAD EXAMPLES (DO NOT DO):
âŒ "Hope Diamond" â†’ "Hope Diamond Dildo" (NO! Misinterpretation - not an adult request!)
âŒ "Ferrari" â†’ price: 5000000000 (TOO EXPENSIVE! Ferraris cost $300k-$3M, not $5B!)
âŒ "vibrator" â†’ {name: "Personal Massager", ...} (TOO SANITIZED for adult request!)
âŒ "coffee" â†’ price: 50000 (TOO EXPENSIVE! Coffee is $5-50!)

Generate the gift with REALISTIC real-world pricing (JSON only):`;

    const response = await queuedGenerateText(prompt, {
      temperature: 0.8,
      max_tokens: 300
    }, 'Custom Gift Generation');
    
    // Check if cancelled
    if (controller && controller.cancelled) {
      throw new Error('Generation cancelled');
    }
    
    // Parse and validate
    let gift;
    try {
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      gift = JSON.parse(jsonMatch ? jsonMatch[0] : response.trim());
    } catch (e) {
      console.error('[Gift] Failed to parse gift JSON:', response);
      throw new Error('Failed to generate gift. Please try again.');
    }
    
    // Check if cancelled after parsing
    if (controller && controller.cancelled) {
      throw new Error('Generation cancelled');
    }
    
    // Validate category
    if (!GIFT_CATEGORIES[gift.category]) {
      console.warn(`[Gift] Invalid category "${gift.category}", mapping to valid one`);
      gift.category = mapToValidCategory(gift.category);
    }
    
    // Ensure minimum price, but respect real-world maximums
    // Only enforce budget cap if one was explicitly set (not Infinity)
    gift.price = Math.max(10, gift.price);
    if (maxBudget !== Infinity && gift.price > maxBudget) {
      console.log(`[Gift] "${gift.name}" costs $${gift.price.toLocaleString()} which exceeds budget of $${maxBudget.toLocaleString()}`);
      // Don't cap it - let player see the real price and decide
      showNotification(`âš ï¸ This gift ($${gift.price.toLocaleString()}) exceeds your budget limit!`, 'warning');
    }
    
    // Generate unique ID
    gift.id = 'gift_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    gift.createdAt = Date.now();
    gift.timesGiven = 0;
    
    return gift;
  }
  
  /**
   * Add gift to player's inventory
   * @param {object} gift - Gift object
   * @param {number} quantity - How many to add
   */
  function addGiftToInventory(gift, quantity = 1) {
    // Check if UNIQUE gift was already given
    if (gift.category === 'UNIQUE') {
      if (gameState.givenUniqueGifts.includes(gift.name)) {
        showNotification(`âŒ ${gift.name} has already been given away!`, 'error');
        return false;
      }
      // UNIQUE gifts go straight to giving, not inventory
      showNotification(`âœ¨ ${gift.name} created! This unique gift can only be given once.`, 'info');
      return gift; // Return gift for immediate giving
    }
    
    const existing = gameState.giftInventory.items.find(g => g.id === gift.id || g.name === gift.name);
    
    if (existing) {
      existing.quantity += quantity;
    } else {
      gameState.giftInventory.items.push({
        ...gift,
        quantity: quantity,
        addedAt: Date.now()
      });
    }
    
    gameState.cash -= gift.price * quantity;
    showNotification(`ğŸ Added ${quantity}x ${gift.name} to inventory ($${(gift.price * quantity).toLocaleString()})`, 'success');
    updateUI();
    return true;
  }
  
  /**
   * Remove gift from inventory
   * @param {string} giftId - Gift ID to remove
   * @param {number} quantity - How many to remove
   */
  function removeGiftFromInventory(giftId, quantity = 1) {
    const item = gameState.giftInventory.items.find(g => g.id === giftId);
    if (!item) return false;
    
    item.quantity -= quantity;
    
    if (item.quantity <= 0) {
      gameState.giftInventory.items = gameState.giftInventory.items.filter(g => g.id !== giftId);
    }
    
    return true;
  }
  
  /**
   * Add gift to store (approve genie creation)
   * @param {object} gift - Gift object
   */
  function addGiftToStore(gift) {
    // Check if UNIQUE gift was already created
    if (gift.category === 'UNIQUE') {
      if (gameState.createdUniqueGifts.includes(gift.name)) {
        showNotification(`âŒ You already created "${gift.name}"! Unique gifts can only be created once.`, 'error');
        return false;
      }
      gameState.createdUniqueGifts.push(gift.name);
    }
    
    // Add to store
    gameState.giftStore.items.push({
      ...gift,
      stockedAt: Date.now()
    });
    
    showNotification(`âœ… ${gift.name} added to store!`, 'success');
    return true;
  }
  
  /**
   * Purchase gift from store and add to player inventory
   * @param {string} giftId - Gift ID from store
   */
  function purchaseGiftFromStore(giftId) {
    const gift = gameState.giftStore.items.find(g => g.id === giftId);
    if (!gift) {
      showNotification('Gift not found in store!', 'error');
      return false;
    }
    
    // Check if player can afford it
    if (gameState.cash < gift.price) {
      showNotification(`Not enough money! Need $${gift.price.toLocaleString()}`, 'error');
      return false;
    }
    
    // Deduct money
    gameState.cash -= gift.price;
    
    // Check if gift already exists in inventory (for non-UNIQUE gifts)
    const existingItem = gameState.giftInventory.items.find(g => g.id === giftId);
    
    if (existingItem && gift.category !== 'UNIQUE') {
      // Already have this gift, just increase quantity
      existingItem.quantity = (existingItem.quantity || 1) + 1;
    } else {
      // Add new item to inventory
      gameState.giftInventory.items.push({
        ...gift,
        quantity: 1,
        purchasedAt: Date.now()
      });
    }
    
    // Remove from store if UNIQUE
    if (gift.category === 'UNIQUE') {
      gameState.giftStore.items = gameState.giftStore.items.filter(g => g.id !== giftId);
      showNotification(`ğŸŒŸ ${gift.name} purchased! This unique gift is now in your inventory.`, 'success');
    } else {
      showNotification(`ğŸ ${gift.name} purchased! ($${gift.price.toLocaleString()})`, 'success');
    }
    
    // Update displays immediately after purchase
    if (typeof updateGiftStore === 'function') {
      updateGiftStore();
    }
    if (typeof updateGiftInventory === 'function') {
      updateGiftInventory();
    }
    
    updateUI();
    return true;
  }
  
  /**
   * Calculate how appropriate a gift price is for an employee
   * @param {number} giftPrice - Price of the gift
   * @param {object} employee - Employee receiving gift
   * @returns {number} Appropriateness multiplier (0.3 to 1.5)
   */
  function calculatePriceAppropriate(giftPrice, employee) {
    const relationship = (employee.stats.affection + employee.stats.trust) / 2;
    const scale = calculateGiftPriceScale();
    
    // CRITICAL FIX: Cap the scale expectations to prevent absurd requirements
    // Even billionaires appreciate thoughtful gifts - it's about the gesture!
    const cappedMinRecommended = Math.min(scale.minRecommended, 5000); // Cap at $5k minimum
    const cappedSweetSpot = Math.min(scale.sweetSpot, 50000); // Cap at $50k sweet spot
    const cappedMaxRecommended = Math.min(scale.maxRecommended, 500000); // Cap at $500k max
    
    console.log(`[Gift Price] Scale: min=$${scale.minRecommended.toLocaleString()} â†’ $${cappedMinRecommended.toLocaleString()}, sweet=$${scale.sweetSpot.toLocaleString()} â†’ $${cappedSweetSpot.toLocaleString()}`);
    
    // Perfect range - generous buffer
    if (giftPrice >= cappedSweetSpot * 0.3 && giftPrice <= cappedSweetSpot * 3) {
      console.log(`[Gift Price] $${giftPrice.toLocaleString()} in PERFECT range: 1.5x`);
      return 1.5;
    }
    
    // Good range - still appreciable
    if (giftPrice >= cappedMinRecommended * 0.5 && giftPrice <= cappedMaxRecommended * 2) {
      console.log(`[Gift Price] $${giftPrice.toLocaleString()} in GOOD range: 1.2x`);
      return 1.2;
    }
    
    // Modest but acceptable - any gift $1k+ is thoughtful
    if (giftPrice >= 1000) {
      console.log(`[Gift Price] $${giftPrice.toLocaleString()} is MODEST but thoughtful: 1.0x`);
      return 1.0;
    }
    
    // Only penalize truly cheap gifts (under $100)
    if (giftPrice < 100) {
      console.log(`[Gift Price] $${giftPrice.toLocaleString()} is TOO CHEAP: 0.5x`);
      return 0.5;
    }
    
    // Too expensive for relationship level (only matters if relationship is very low)
    if (giftPrice > cappedMaxRecommended * 2 && relationship < 30) {
      console.log(`[Gift Price] $${giftPrice.toLocaleString()} too extravagant for low relationship: 0.7x`);
      return 0.7;
    }
    
    // Default: acceptable
    console.log(`[Gift Price] $${giftPrice.toLocaleString()} is ACCEPTABLE: 1.0x`);
    return 1.0;
  }
  
  /**
   * Generate AI-powered gift reaction
   * @param {object} employee - Employee receiving gift
   * @param {object} gift - Gift object
   * @param {string} reactionTone - Tone of reaction (grateful, suspicious, etc.)
   * @param {string} customMessage - Optional message from player
   * @returns {Promise<string>} Gift reaction text
   */
  async function generateGiftReaction(employee, gift, reactionTone, customMessage = '', duplicate = null) {
    const prefs = employee.giftPreferences;
    const categoryMatch = prefs.loves.includes(gift.category) ? 'LOVES' : 
                          prefs.hates.includes(gift.category) ? 'HATES' : 'NEUTRAL';
    
    // Get recent chat context
    const chatHistory = (gameState.chatHistory[employee.id] || []).slice(-5);
    const recentContext = chatHistory.length > 0 ? 
      chatHistory.map(msg => `${msg.isPlayer ? 'Boss' : employee.name}: ${msg.content}`).join('\n') : 
      'No recent conversation';
    
    // Get recent memories
    const recentMemories = employee.memory?.store ? 
      employee.memory.store.slice(-3).map(m => m.text).join('\n') : 
      'No memories yet';
    
    // Get gift history - CRITICAL: Check if array exists and has items
    const hasReceivedGiftsBefore = prefs.recentGifts && prefs.recentGifts.length > 0;
    const pastGifts = hasReceivedGiftsBefore ? 
      prefs.recentGifts.slice(-3).map(g => 
        `${g.name} ($${g.price.toLocaleString()}) - ${g.reaction}`
      ).join('\n') : 
      'THIS IS YOUR FIRST GIFT FROM THE BOSS';
    
    const prompt = `You are ${employee.name}, receiving a gift from your boss.

YOUR PERSONALITY:
- Confidence: ${employee.personality.confidence || 50}/100
- Outgoing: ${employee.personality.outgoing || 50}/100
- Flirty: ${employee.personality.flirty || 50}/100
- Professional: ${employee.personality.professional || 50}/100

YOUR RELATIONSHIP WITH BOSS:
- Affection: ${employee.stats.affection}/100
- Trust: ${employee.stats.trust}/100
- Comfort: ${employee.stats.comfort}/100
- Desire: ${employee.stats.desire}/100

RECENT CONVERSATION CONTEXT:
${recentContext}

YOUR RECENT MEMORIES:
${recentMemories}

${hasReceivedGiftsBefore ? 'PAST GIFTS YOU\'VE RECEIVED (for context):' : 'ğŸ FIRST GIFT EVER:'}
${pastGifts}

âš ï¸ IMPORTANT: The past gifts list above is for YOUR MEMORY ONLY. 
${duplicate ? `âš ï¸ DUPLICATE ALERT: You received "${duplicate.name}" ${Math.floor((Date.now() - duplicate.timestamp) / (1000 * 60 * 60 * 24))} days ago. This is the SAME gift again!` : `âœ“ This is a NEW gift - you have NOT received "${gift.name}" before. Do NOT act like it's a repeat!`}

THE CURRENT GIFT YOU'RE RECEIVING:
Name: ${gift.name}
Category: ${GIFT_CATEGORIES[gift.category]?.name || gift.category}
Price: $${gift.price.toLocaleString()}
Description: ${gift.description}

YOUR PREFERENCE FOR THIS TYPE OF GIFT:
${categoryMatch === 'LOVES' ? 'â¤ï¸ You LOVE ' + GIFT_CATEGORIES[gift.category]?.name + ' gifts!' :
  categoryMatch === 'HATES' ? 'ğŸ˜  You HATE ' + GIFT_CATEGORIES[gift.category]?.name + ' gifts!' :
  'ğŸ˜ You feel neutral about ' + GIFT_CATEGORIES[gift.category]?.name + ' gifts.'}

REACTION TONE TO USE: ${reactionTone.toUpperCase()}
${reactionTone === 'grateful' ? 'Be genuinely happy and appreciative. Show excitement!' :
  reactionTone === 'suspicious' ? 'You\'re wondering why they\'re giving you SO many gifts. Be skeptical about their intentions.' :
  reactionTone === 'underwhelmed' ? 'This gift is too cheap or not your style. Be polite but clearly not impressed.' :
  reactionTone === 'overwhelmed' ? 'This gift is TOO expensive/extravagant for your relationship level. Feel uncomfortable.' :
  reactionTone === 'confused' ? 'They just gave you this same gift recently. Be puzzled about why they\'re repeating.' :
  reactionTone === 'delighted' ? 'This is PERFECT for you - right category, right price, right timing. Be thrilled!' :
  'React naturally based on your personality and the gift.'}

${customMessage ? `\nBOSS'S MESSAGE WITH GIFT:\n"${customMessage}"\n` : ''}

INSTRUCTIONS:
1. Write 2-4 sentences as ${employee.name}
2. Use *asterisks* for physical actions (e.g., *eyes widen*, *smiles warmly*, *looks uncomfortable*)
3. BANNED: Never mention "knuckles" - use other body language
4. Show genuine emotion appropriate to the situation
5. Reference the specific gift by name, not just "the gift"
6. If you HATE the category, don't fake loving it - be honest but tactful
7. If overwhelmed by price/frequency, ADDRESS IT directly
${!hasReceivedGiftsBefore ? '8. âš ï¸ THIS IS YOUR FIRST GIFT - Show surprise/delight that they got you something!' : ''}

GOOD EXAMPLES:
${!hasReceivedGiftsBefore ? `- (FIRST GIFT, Loves): "Wait, you got me ${gift.name}?! *eyes widen in genuine surprise* I wasn't expecting this at all! This is so thoughtful, thank you! ğŸ¥ºğŸ’•"
- (FIRST GIFT, Neutral): "*blinks in surprise* Oh! ${gift.name}? *accepts it carefully* I... wow, I wasn't expecting a gift. That's really sweet of you, thank you!"
- (FIRST GIFT, Hates): "*looks surprised* Oh, ${gift.name}... *tries to smile* That's, um... *takes it gently* Thank you for thinking of me. I appreciate the gesture."
` : `- (Loves, grateful): "Oh my god, ${gift.name}?! *eyes light up* This is exactly what I wanted! You really know me, don't you? Thank you so much! ğŸ’•"
- (Hates, polite): "*forces a smile* Oh... ${gift.name}. That's... thoughtful. *sets it aside carefully* I appreciate you thinking of me, really."
- (Suspicious): "Another gift? *looks at ${gift.name} skeptically* This is the third one this week. Why are you trying so hard to buy my love?"
- (Underwhelmed): "*glances at ${gift.name}* Oh. Thanks. *barely smiles* I mean, it's... fine. I guess."
`}- (Delighted): "*gasps* ${gift.name}! Are you SERIOUS?! *throws arms around you* This is the best gift I've ever gotten! I can't believe you did this!"

Reply as ${employee.name} (dialogue and actions):`;

    const response = await queuedGenerateText(prompt, {
      temperature: 0.9,
      max_tokens: 150
    }, `Gift Reaction - ${employee.name}`);
    
    return response.trim();
  }
  
  /**
   * Apply lasting consequences when gifting items
   * @param {object} employee - Employee object
   * @param {object} gift - Gift object with name, category, price
   */
  function applyGiftConsequences(employee, gift) {
    if (!employee.giftedPossessions) {
      employee.giftedPossessions = {
        wardrobe: [],
        jewelry: [],
        vehicles: [],
        homeUpgrades: [],
        experiences: [],
        tech: [],
        other: []
      };
    }
    
    if (!employee.personalLife) {
      employee.personalLife = { livingSituation: { pets: [] } };
    }
    
    const giftName = gift.name.toLowerCase();
    const category = gift.category;
    
    console.log(`[Gift Consequences] Processing ${gift.name} (${category}) for ${employee.name}`);
    
    // FASHION/WARDROBE - Add to wardrobe with wear chance
    if (category === 'FASHION') {
      const wearChance = 0.15 + Math.random() * 0.25; // 15-40% chance to wear
      employee.giftedPossessions.wardrobe.push({
        item: gift.name,
        category: category,
        price: gift.price,
        timestamp: gameState.time?.currentTime || Date.now(),
        wearChance: wearChance
      });
      console.log(`[Gift Consequences] Added ${gift.name} to wardrobe (${(wearChance*100).toFixed(0)}% wear chance)`);
    }
    
    // ROMANTIC JEWELRY - Track jewelry collection
    if (category === 'ROMANTIC' && (giftName.includes('ring') || giftName.includes('necklace') || 
        giftName.includes('bracelet') || giftName.includes('earring') || giftName.includes('jewelry'))) {
      const wearChance = 0.2 + Math.random() * 0.3; // 20-50% chance to wear
      const type = giftName.includes('ring') ? 'ring' : 
                   giftName.includes('necklace') ? 'necklace' :
                   giftName.includes('bracelet') ? 'bracelet' :
                   giftName.includes('earring') ? 'earrings' : 'jewelry';
      employee.giftedPossessions.jewelry.push({
        item: gift.name,
        type: type,
        price: gift.price,
        timestamp: gameState.time?.currentTime || Date.now(),
        wearChance: wearChance
      });
      console.log(`[Gift Consequences] Added ${gift.name} to jewelry collection (${type}, ${(wearChance*100).toFixed(0)}% wear chance)`);
    }
    
    // LUXURY VEHICLES
    if (category === 'LUXURY' && (giftName.includes('car') || giftName.includes('vehicle') || 
        giftName.includes('porsche') || giftName.includes('ferrari') || giftName.includes('tesla') ||
        giftName.includes('mercedes') || giftName.includes('bmw') || giftName.includes('yacht') ||
        giftName.includes('motorcycle') || giftName.includes('bike'))) {
      const type = giftName.includes('yacht') ? 'yacht' :
                   giftName.includes('motorcycle') || giftName.includes('bike') ? 'motorcycle' :
                   'car';
      employee.giftedPossessions.vehicles.push({
        item: gift.name,
        type: type,
        price: gift.price,
        timestamp: gameState.time?.currentTime || Date.now()
      });
      console.log(`[Gift Consequences] Added ${gift.name} to vehicles (${type})`);
    }
    
    // LUXURY HOME UPGRADES - Update living situation
    if (category === 'LUXURY' && (giftName.includes('apartment') || giftName.includes('penthouse') || 
        giftName.includes('house') || giftName.includes('mansion') || giftName.includes('condo') ||
        giftName.includes('villa') || giftName.includes('estate'))) {
      const upgradeType = giftName.includes('mansion') || giftName.includes('estate') ? 'mansion' :
                          giftName.includes('penthouse') ? 'penthouse' :
                          giftName.includes('villa') ? 'villa' :
                          giftName.includes('condo') ? 'luxury condo' :
                          giftName.includes('house') ? 'luxury house' : 'luxury apartment';
      
      employee.giftedPossessions.homeUpgrades.push({
        item: gift.name,
        upgradeType: upgradeType,
        price: gift.price,
        timestamp: gameState.time?.currentTime || Date.now()
      });
      
      // Actually update their living situation
      employee.personalLife.livingSituation.type = upgradeType;
      employee.personalLife.livingSituation.hasRoommate = false; // Luxury places = no roommates
      
      console.log(`[Gift Consequences] Upgraded home to ${upgradeType}!`);
    }
    
    // PET GIFTS - Add to pets collection
    if ((category === 'QUIRKY' || category === 'LUXURY') && 
        (giftName.includes('dog') || giftName.includes('puppy') || giftName.includes('cat') || 
         giftName.includes('kitten') || giftName.includes('bird') || giftName.includes('parrot') ||
         giftName.includes('fish') || giftName.includes('rabbit') || giftName.includes('hamster') ||
         giftName.includes('snake') || giftName.includes('lizard'))) {
      
      const petType = giftName.includes('dog') || giftName.includes('puppy') ? 'dog' :
                      giftName.includes('cat') || giftName.includes('kitten') ? 'cat' :
                      giftName.includes('bird') || giftName.includes('parrot') ? 'bird' :
                      giftName.includes('fish') ? 'fish' :
                      giftName.includes('rabbit') ? 'rabbit' :
                      giftName.includes('hamster') ? 'hamster' :
                      giftName.includes('snake') ? 'snake' :
                      giftName.includes('lizard') ? 'lizard' : 'pet';
      
      // Generate AI name for the pet
      const petName = generatePetName(petType);
      
      if (!employee.personalLife.livingSituation.pets) {
        employee.personalLife.livingSituation.pets = [];
      }
      
      employee.personalLife.livingSituation.pets.push({
        name: petName,
        type: petType,
        giftedBy: 'boss',
        timestamp: gameState.time?.currentTime || Date.now()
      });
      
      // Update legacy fields
      employee.personalLife.livingSituation.hasPet = true;
      if (!employee.personalLife.livingSituation.petType) {
        employee.personalLife.livingSituation.petType = petType;
        employee.personalLife.livingSituation.petName = petName;
      }
      
      console.log(`[Gift Consequences] Added ${petType} named "${petName}" to pets!`);
    }
    
    // TECH GADGETS
    if (category === 'TECH') {
      const type = giftName.includes('phone') || giftName.includes('iphone') ? 'phone' :
                   giftName.includes('laptop') || giftName.includes('macbook') ? 'laptop' :
                   giftName.includes('watch') || giftName.includes('smartwatch') ? 'smartwatch' :
                   giftName.includes('tablet') || giftName.includes('ipad') ? 'tablet' :
                   giftName.includes('console') || giftName.includes('playstation') || giftName.includes('xbox') ? 'gaming' :
                   'gadget';
      
      employee.giftedPossessions.tech.push({
        item: gift.name,
        type: type,
        price: gift.price,
        timestamp: gameState.time?.currentTime || Date.now(),
        inUse: true
      });
      console.log(`[Gift Consequences] Added ${gift.name} to tech (${type})`);
    }
    
    // EXPERIENCES - Create lasting memories
    if (category === 'EXPERIENCES') {
      const memoryStrength = Math.min(10, Math.floor(gift.price / 1000) + 5); // 5-10 based on price
      employee.giftedPossessions.experiences.push({
        item: gift.name,
        description: gift.description || gift.name,
        price: gift.price,
        timestamp: gameState.time?.currentTime || Date.now(),
        memoryStrength: memoryStrength
      });
      console.log(`[Gift Consequences] Added experience "${gift.name}" (memory strength: ${memoryStrength})`);
    }
    
    // EVERYTHING ELSE - Track in "other"
    if (!['FASHION', 'ROMANTIC', 'LUXURY', 'TECH', 'EXPERIENCES'].includes(category)) {
      employee.giftedPossessions.other.push({
        item: gift.name,
        category: category,
        price: gift.price,
        timestamp: gameState.time?.currentTime || Date.now()
      });
      console.log(`[Gift Consequences] Added ${gift.name} to other possessions`);
    }
  }
  
  /**
   * Generate a cute name for a gifted pet
   * @param {string} petType - Type of pet
   * @returns {string} Pet name
   */
  function generatePetName(petType) {
    const dogNames = ['Max', 'Luna', 'Charlie', 'Bella', 'Cooper', 'Daisy', 'Rocky', 'Sadie', 'Duke', 'Chloe', 'Bear', 'Rosie'];
    const catNames = ['Luna', 'Oliver', 'Milo', 'Bella', 'Simba', 'Chloe', 'Leo', 'Lucy', 'Whiskers', 'Shadow', 'Mittens', 'Pepper'];
    const birdNames = ['Tweety', 'Rio', 'Kiwi', 'Sunny', 'Phoenix', 'Echo', 'Polly', 'Blue', 'Mango', 'Peaches'];
    const fishNames = ['Bubbles', 'Nemo', 'Goldie', 'Splash', 'Finn', 'Coral', 'Marina', 'Neptune'];
    const smallPetNames = ['Nibbles', 'Peanut', 'Marshmallow', 'Cookie', 'Fluffy', 'Oreo', 'Snowball', 'Caramel'];
    const reptileNames = ['Rex', 'Spike', 'Draco', 'Emerald', 'Slither', 'Jade', 'Scales', 'Ziggy'];
    
    let namePool;
    switch (petType) {
      case 'dog': namePool = dogNames; break;
      case 'cat': namePool = catNames; break;
      case 'bird': namePool = birdNames; break;
      case 'fish': namePool = fishNames; break;
      case 'rabbit':
      case 'hamster': namePool = smallPetNames; break;
      case 'snake':
      case 'lizard': namePool = reptileNames; break;
      default: namePool = [...dogNames, ...catNames];
    }
    
    return namePool[Math.floor(Math.random() * namePool.length)];
  }
  
  /**
   * Give a gift to an employee and get their reaction
   * @param {string} employeeId - Employee ID
   * @param {object} gift - Gift object
   * @param {string} customMessage - Optional personal message
   * @returns {Promise<object>} Reaction result with stats and response
   */
  async function giveGiftToEmployee(employeeId, gift, customMessage = '') {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) {
      showNotification('Employee not found!', 'error');
      return null;
    }
    
    if (!employee.giftPreferences) {
      employee.giftPreferences = generateGiftPreferences();
      console.log(`[Gift] Generated new gift preferences for ${employee.name}`);
    }
    
    console.log(`[Gift] ${employee.name} gift history (${employee.giftPreferences.recentGifts.length} gifts):`, 
      employee.giftPreferences.recentGifts.map(g => `${g.name} at ${new Date(g.timestamp).toLocaleString()}`));
    
    // Check if UNIQUE gift was already given globally
    if (gift.category === 'UNIQUE') {
      if (gameState.givenUniqueGifts.includes(gift.name)) {
        showNotification(`âŒ ${gift.name} has already been given to someone else!`, 'error');
        return null;
      }
      // Mark as given
      gameState.givenUniqueGifts.push(gift.name);
      console.log(`[Gift] UNIQUE gift "${gift.name}" given - can never be given again`);
    }
    
    // Check gift history for fatigue
    const recentGiftCount = employee.giftPreferences.recentGifts.filter(g => 
      Date.now() - g.timestamp < 7 * 24 * 60 * 60 * 1000 // Last 7 days
    ).length;
    
    // Check if same gift given recently (exact name match only)
    const duplicate = employee.giftPreferences.recentGifts.find(g => 
      g.name.toLowerCase() === gift.name.toLowerCase() && 
      Date.now() - g.timestamp < 30 * 24 * 60 * 60 * 1000
    );
    
    if (duplicate) {
      const daysSince = Math.floor((Date.now() - duplicate.timestamp) / (1000 * 60 * 60 * 24));
      console.log(`[Gift] DUPLICATE FOUND: "${gift.name}" was given ${daysSince} days ago`);
    } else {
      console.log(`[Gift] No duplicate found for "${gift.name}"`);
    }
    
    // Determine category match
    const categoryMatch = employee.giftPreferences.loves.includes(gift.category) ? 'loves' :
                          employee.giftPreferences.hates.includes(gift.category) ? 'hates' : 'neutral';
    
    // Learn preference when giving a gift
    if (!employee.giftPreferences.learnedLoves) employee.giftPreferences.learnedLoves = [];
    if (!employee.giftPreferences.learnedHates) employee.giftPreferences.learnedHates = [];
    
    if (categoryMatch === 'loves' && !employee.giftPreferences.learnedLoves.includes(gift.category)) {
      employee.giftPreferences.learnedLoves.push(gift.category);
      console.log(`[Gift] Learned that ${employee.name} LOVES ${gift.category}`);
    } else if (categoryMatch === 'hates' && !employee.giftPreferences.learnedHates.includes(gift.category)) {
      employee.giftPreferences.learnedHates.push(gift.category);
      console.log(`[Gift] Learned that ${employee.name} HATES ${gift.category}`);
    }
    
    // Calculate reception modifier
    let receptionMod = 1.0;
    let reactionTone = 'grateful';
    
    console.log(`[Gift Debug] ${employee.name} receiving ${gift.name} ($${gift.price.toLocaleString()})`);
    console.log(`[Gift Debug] Category: ${gift.category}, Match: ${categoryMatch}`);
    console.log(`[Gift Debug] Recent gift count (7 days): ${recentGiftCount}`);
    console.log(`[Gift Debug] Duplicate found: ${duplicate ? 'YES - ' + duplicate.name : 'NO'}`);
    
    // Category preference impact
    if (categoryMatch === 'loves') {
      receptionMod *= 1.5;
      reactionTone = 'delighted';
      console.log(`[Gift Debug] LOVES category: modifier = 1.5x`);
    } else if (categoryMatch === 'hates') {
      receptionMod *= -0.5; // Negative impact!
      reactionTone = 'underwhelmed';
      console.log(`[Gift Debug] HATES category: modifier = -0.5x`);
    }
    
    // Gift fatigue - REDUCED PENALTY: Only kicks in at 5+ gifts in 7 days (was 3+)
    if (recentGiftCount >= 5) {
      receptionMod *= 0.7; // Less harsh: 0.7x instead of 0.5x
      reactionTone = 'suspicious';
      console.log(`[Gift Debug] Gift fatigue (${recentGiftCount} gifts): modifier Ã—0.7`);
    }
    
    // Duplicate gift - ONLY if it's the EXACT SAME item name
    if (duplicate) {
      receptionMod *= 0.5; // Less harsh: 0.5x instead of 0.3x
      reactionTone = 'confused';
      console.log(`[Gift Debug] DUPLICATE DETECTED (${duplicate.name}): modifier Ã—0.5`);
    }
    
    // Price appropriateness
    const priceScore = calculatePriceAppropriate(gift.price, employee);
    receptionMod *= priceScore;
    console.log(`[Gift Debug] Price score: ${priceScore.toFixed(2)}x, Total modifier now: ${receptionMod.toFixed(2)}x`);
    
    if (priceScore < 0.5) {
      reactionTone = 'underwhelmed'; // Too cheap
      console.log(`[Gift Debug] Price too cheap: tone = underwhelmed`);
    } else if (priceScore > 1.3 && categoryMatch === 'loves') {
      reactionTone = 'delighted'; // Perfect expensive gift
      console.log(`[Gift Debug] Perfect expensive gift: tone = delighted`);
    }
    
    // Relationship level check for expensive gifts - FIXED: Use capped values
    const relationshipScore = (employee.stats.affection + employee.stats.trust) / 2;
    const scale = calculateGiftPriceScale();
    const cappedMaxRecommended = Math.min(scale.maxRecommended, 500000); // Cap at $500k
    
    // Only feel overwhelmed by gifts over $500k when relationship is very weak
    if (gift.price > cappedMaxRecommended && relationshipScore < 30) {
      receptionMod *= 0.7; // Reduced penalty from 0.5x to 0.7x
      reactionTone = 'overwhelmed'; // Too extravagant too soon
      console.log(`[Gift Debug] Too extravagant (relationship: ${relationshipScore.toFixed(0)}): modifier Ã—0.7`);
    }
    
    console.log(`[Gift Debug] FINAL: ${reactionTone} tone, ${receptionMod.toFixed(2)}x modifier`);
    
    // Calculate base stat impact
    const baseImpact = {
      affection: categoryMatch === 'loves' ? 12 : categoryMatch === 'hates' ? -5 : 8,
      trust: categoryMatch === 'loves' ? 6 : categoryMatch === 'hates' ? -2 : 4,
      comfort: categoryMatch === 'loves' ? 8 : categoryMatch === 'hates' ? -3 : 5,
      desire: gift.category === 'ROMANTIC' ? 10 : 2
    };
    
    // Apply reception modifier
    const finalImpact = {};
    Object.keys(baseImpact).forEach(stat => {
      finalImpact[stat] = Math.round(baseImpact[stat] * receptionMod);
    });
    
    // Apply stat changes
    Object.entries(finalImpact).forEach(([stat, value]) => {
      if (employee.stats[stat] !== undefined) {
        employee.stats[stat] = Math.max(0, Math.min(100, employee.stats[stat] + value));
      }
    });
    
    // Track gift in history
    employee.giftPreferences.recentGifts.push({
      name: gift.name,
      price: gift.price,
      category: gift.category,
      timestamp: gameState.time?.currentTime || Date.now(),
      reaction: reactionTone,
      statChanges: finalImpact
    });
    
    // Keep only last 10 gifts
    if (employee.giftPreferences.recentGifts.length > 10) {
      employee.giftPreferences.recentGifts.shift();
    }
    
    employee.giftPreferences.totalValue += gift.price;
    employee.giftPreferences.totalCount += 1;
    
    // Add to favorites if loved
    if (receptionMod >= 1.3 && categoryMatch === 'loves') {
      employee.giftPreferences.favoriteGifts.push({
        name: gift.name,
        category: gift.category,
        price: gift.price
      });
      // Keep only top 5 favorites
      if (employee.giftPreferences.favoriteGifts.length > 5) {
        employee.giftPreferences.favoriteGifts.shift();
      }
    }
    
    // Create memory
    const memoryText = `Received gift: ${gift.name} ($${gift.price.toLocaleString()}) - felt ${reactionTone}`;
    if (employee.memory && employee.memory.store) {
      employee.memory.store.push({
        text: memoryText,
        timestamp: gameState.time?.currentTime || Date.now(),
        importance: Math.abs(receptionMod) > 1.2 ? 8 : 5
      });
    }
    
    // âœ¨ APPLY GIFT CONSEQUENCES - Make gifts matter beyond stats!
    applyGiftConsequences(employee, gift);
    
    // Social post chance for expensive/special gifts
    if (gift.price > calculateGiftPriceScale().sweetSpot * 2 && Math.random() < 0.5) {
      setTimeout(() => {
        generateGiftPost(employee, gift, reactionTone).catch(err => {
          console.error('[Gift] Failed to generate gift post:', err);
        });
      }, 2000); // Post after a short delay
    }
    
    // Generate AI reaction
    let reaction;
    try {
      reaction = await generateGiftReaction(employee, gift, reactionTone, customMessage, duplicate);
    } catch (error) {
      console.error('[Gift] Failed to generate reaction:', error);
      // Fallback reaction
      reaction = categoryMatch === 'loves' ? 
        `*smiles warmly* Thank you so much for the ${gift.name}! I love it! ğŸ’•` :
        categoryMatch === 'hates' ?
        `*forces a smile* Oh, ${gift.name}... That's thoughtful. Thank you.` :
        `*accepts the gift* Thank you for the ${gift.name}! I appreciate it.`;
    }
    
    // Add reaction to chat history
    const chatHistory = gameState.chatHistory[employeeId] || [];
    chatHistory.push({
      sender: employee.name,
      content: reaction,
      timestamp: gameState.time?.currentTime || Date.now(),
      isPlayer: false
    });
    
    gameState.chatHistory[employeeId] = chatHistory;
    
    // CRITICAL FIX: Save immediately after gift reaction to prevent message loss
    saveGame(false);
    
    console.log(`[Gift] ${employee.name} received ${gift.name} ($${gift.price.toLocaleString()}) - ${reactionTone} (${receptionMod.toFixed(2)}x modifier)`);
    
    // Check if this gift was given on a post (for public logging/reactions)
    if (typeof window.handlePostGiftGiven === 'function') {
      window.handlePostGiftGiven(employee, gift);
    }
    
    return {
      reaction,
      statChanges: finalImpact,
      receptionMod,
      tone: reactionTone,
      categoryMatch
    };
  }
  
  /**
   * Generate social media post about receiving a gift
   * @param {object} employee - Employee who received gift
   * @param {object} gift - Gift object
   * @param {string} tone - Reaction tone
   */
  async function generateGiftPost(employee, gift, tone) {
    // ğŸš€ NUCLEAR CONTEXT: Get intelligent context for social post
    const intelligentContext = getIntelligentContext(employee, 'social.post', {
      message: `Posting about receiving ${gift.name} as a gift`,
      involves: ['player', 'gift'],
      keywords: ['gift', gift.category, tone]
    });
    
    const prompt = `${intelligentContext}

SITUATION: Your boss just gave you ${gift.name} ($${gift.price.toLocaleString()}).
Your reaction: ${tone}

Write a social media post about this gift.

INSTRUCTIONS:
1. Write 1-3 sentences
2. Use emojis naturally
3. ${tone === 'delighted' || tone === 'grateful' ? 'Show excitement and appreciation!' :
      tone === 'suspicious' ? 'Be subtly questioning why they\'re so generous...' :
      tone === 'overwhelmed' ? 'Express that this is A LOT' :
      'Be authentic to the tone'}
4. Don't over-explain - be casual like real social media
5. You can flex if it's expensive ğŸ’…

EXAMPLES:
- (Delighted): "Just got the most AMAZING gift from the boss! ${gift.name}! ğŸ˜âœ¨ I'm speechless!"
- (Suspicious): "Another gift from work... starting to wonder what they want from me ğŸ¤”"
- (Grateful): "Boss surprised me with ${gift.name} today! So thoughtful ğŸ’•"

Write the post (1-3 sentences):`;

    const content = await queuedGenerateText(prompt, {
      temperature: 0.9,
      max_tokens: 80
    }, `First Post - ${employee.name}`);
    
    // Create post
    const post = {
      id: `post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      authorId: employee.id,
      content: content.trim(),
      timestamp: gameState.time?.currentTime || Date.now(),
      likes: [],
      comments: [],
      isPlayerPost: false,
      type: 'life_update',
      explicitLevel: 0,
      imageUrl: gift.imageUrl || null,
      imageAlt: gift.imagePrompt || `${gift.name}`,
      giftMention: true,
      giftData: {
        name: gift.name,
        price: gift.price,
        category: gift.category
      }
    };
    
    gameState.socialNetwork.posts.unshift(post);
    
    console.log(`[Gift] ${employee.name} posted about gift: "${content.trim()}"`);
    
    // Trigger feed update if social tab is open
    if (typeof updateSocialTab === 'function') {
      updateSocialTab();
    }
  }

  // ========== RELATIONSHIP & COMPANY AWARENESS SYSTEM ==========
  
  /**
   * Update or create relationship between two employees
   */
  function updateRelationship(employeeId1, employeeId2, interaction) {
    const emp1 = gameState.employees.find(e => e.id === employeeId1);
    const emp2 = gameState.employees.find(e => e.id === employeeId2);
    
    if (!emp1 || !emp2) return;
    
    initializeEmployeeSocialData(emp1);
    initializeEmployeeSocialData(emp2);
    
    // Update emp1's relationship with emp2
    if (!emp1.relationships[employeeId2]) {
      emp1.relationships[employeeId2] = createRelationship({ targetId: employeeId2 });
    }
    
    const rel1 = emp1.relationships[employeeId2];
    rel1.strength = Math.max(0, Math.min(100, rel1.strength + (interaction.impact || 0)));
    rel1.lastInteraction = Date.now();
    rel1.history.push({
      timestamp: gameState.time?.currentTime || Date.now(),
      event: interaction.event || 'interaction',
      impact: interaction.impact || 0
    });
    
    // Limit history size
    if (rel1.history.length > 50) {
      rel1.history = rel1.history.slice(-50);
    }
    
    // Update relationship type based on strength and history
    if (interaction.impact > 0) rel1.positiveInteractions++;
    if (interaction.impact < 0) rel1.conflicts++;
    
    // Auto-update relationship type based on strength
    if (rel1.strength > 80) {
      rel1.type = rel1.type === 'crush' ? 'romantic' : 'best_friend';
    } else if (rel1.strength > 60) {
      rel1.type = rel1.type === 'crush' || rel1.type === 'romantic' ? rel1.type : 'friend';
    } else if (rel1.strength < 30) {
      rel1.type = 'rival';
    } else if (rel1.strength < 20) {
      rel1.type = 'enemy';
    }
    
    // Mirror relationship for emp2 (with slight variation to feel natural)
    if (!emp2.relationships[employeeId1]) {
      emp2.relationships[employeeId1] = createRelationship({ targetId: employeeId1 });
    }
    
    const rel2 = emp2.relationships[employeeId1];
    const mirroreImpact = interaction.impact * (0.8 + Math.random() * 0.4); // 80-120% of original impact
    rel2.strength = Math.max(0, Math.min(100, rel2.strength + mirroreImpact));
    rel2.lastInteraction = Date.now();
    rel2.history.push({
      timestamp: gameState.time?.currentTime || Date.now(),
      event: interaction.event || 'interaction',
      impact: mirroreImpact
    });
    
    if (rel2.history.length > 50) {
      rel2.history = rel2.history.slice(-50);
    }
    
    if (mirroreImpact > 0) rel2.positiveInteractions++;
    if (mirroreImpact < 0) rel2.conflicts++;
    
    // Update relationship type
    if (rel2.strength > 80) {
      rel2.type = rel2.type === 'crush' ? 'romantic' : 'best_friend';
    } else if (rel2.strength > 60) {
      rel2.type = rel2.type === 'crush' || rel2.type === 'romantic' ? rel2.type : 'friend';
    } else if (rel2.strength < 30) {
      rel2.type = 'rival';
    } else if (rel2.strength < 20) {
      rel2.type = 'enemy';
    }
  }
  
  /**
   * Generate random relationships between existing employees
   * Called when new employee joins or periodically to evolve relationships
   */
  function generateRandomRelationships(newEmployeeId = null) {
    const employees = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    if (employees.length < 2) return;
    
    // If new employee, create relationships with existing employees
    if (newEmployeeId) {
      const newEmp = employees.find(e => e.id === newEmployeeId);
      if (!newEmp) return;
      
      employees.forEach(emp => {
        if (emp.id === newEmployeeId) return;
        
        // Calculate relationship based on shared traits, location, etc.
        let initialStrength = 40 + Math.random() * 20; // 40-60 baseline
        
        // Same location bonus
        if (emp.locationId === newEmp.locationId) {
          initialStrength += 10;
        }
        
        // Shared hobbies bonus
        const sharedHobbies = (emp.hobbies || []).filter(h => (newEmp.hobbies || []).includes(h));
        initialStrength += sharedHobbies.length * 5;
        
        // Personality compatibility (simplistic)
        if (emp.personality === newEmp.personality) {
          initialStrength += Math.random() * 10;
        }
        
        // Random chance of instant crush (5% chance)
        let relType = 'neutral';
        if (Math.random() < 0.05) {
          relType = 'crush';
          initialStrength += 15;
        }
        
        updateRelationship(newEmployeeId, emp.id, {
          event: 'initial_meeting',
          impact: initialStrength - 50 // Adjust from baseline
        });
        
        if (relType === 'crush') {
          newEmp.relationships[emp.id].type = 'crush';
        }
      });
    } else {
      // Periodically evolve existing relationships
      for (let i = 0; i < employees.length - 1; i++) {
        for (let j = i + 1; j < employees.length; j++) {
          // 30% chance to have an interaction
          if (Math.random() > 0.3) continue;
          
          const emp1 = employees[i];
          const emp2 = employees[j];
          
          // Random interaction
          const impact = (Math.random() - 0.4) * 10; // -4 to +6 (slightly positive bias)
          updateRelationship(emp1.id, emp2.id, {
            event: 'background_interaction',
            impact
          });
        }
      }
    }
  }
  
  /**
   * Update company-wide awareness data
   * Should be called whenever employees change
   */
  function updateCompanyAwareness() {
    const active = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    gameState.companyContext.totalEmployees = active.length;
    
    // Count employees per location
    gameState.companyContext.locationEmployeeCounts = {};
    active.forEach(emp => {
      const loc = emp.locationId || 'garage';
      gameState.companyContext.locationEmployeeCounts[loc] = 
        (gameState.companyContext.locationEmployeeCounts[loc] || 0) + 1;
    });
    
    // Update each employee's awareness
    active.forEach(emp => {
      initializeEmployeeSocialData(emp);
      
      // They know all employees
      emp.awareness.knowsCoworkers = active
        .filter(e => e.id !== emp.id)
        .map(e => e.id);
      
      // They know all unlocked locations
      emp.awareness.knowsLocations = gameState.locations
        .filter(loc => loc.unlocked)
        .map(loc => loc.id);
      
      // Company knowledge
      emp.awareness.companyKnowledge = {
        totalEmployees: active.length,
        lastUpdated: Date.now()
      };
      
      // Mark which coworkers are in same location
      active.forEach(other => {
        if (other.id === emp.id) return;
        if (!emp.relationships[other.id]) {
          emp.relationships[other.id] = createRelationship({ targetId: other.id });
        }
        emp.relationships[other.id].sharedLocation = (emp.locationId === other.locationId);
        
        // Check shared interests
        const sharedHobbies = (emp.hobbies || []).filter(h => (other.hobbies || []).includes(h));
        emp.relationships[other.id].sharedInterests = sharedHobbies;
      });
    });
  }
  
  /**
   * Log a company event
   */
  function logCompanyEvent(eventData) {
    const event = createEvent(eventData);
    gameState.socialNetwork.globalEvents.push(event);
    
    // Keep only recent events (last 100)
    if (gameState.socialNetwork.globalEvents.length > 100) {
      gameState.socialNetwork.globalEvents = gameState.socialNetwork.globalEvents.slice(-100);
    }
    
    return event;
  }
  
  /**
   * Get recent events relevant to an employee
   */
  function getRelevantEvents(employeeId, limit = 10) {
    return gameState.socialNetwork.globalEvents
      .filter(event => 
        event.involvedEmployees.includes(employeeId) || 
        event.importance >= 7 // High importance events relevant to all
      )
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, limit);
  }
  
  /**
   * Get context about coworkers for an employee
   * Used when generating posts or content that references others
   */
  function getCoworkerContext(employeeId) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return '';
    
    initializeEmployeeSocialData(emp);
    
    const coworkers = gameState.employees.filter(e => 
      e.employmentStatus === 'active' && 
      e.id !== employeeId
    );
    
    const sameLocation = coworkers.filter(e => e.locationId === emp.locationId);
    
    let context = `${emp.name} works at ${emp.locationId || 'garage'} with ${sameLocation.length} coworkers. `;
    context += `The company has ${gameState.companyContext.totalEmployees} total employees. `;
    
    // Mention notable relationships
    const relationships = Object.entries(emp.relationships || {})
      .map(([targetId, rel]) => {
        const target = coworkers.find(e => e.id === targetId);
        if (!target) return null;
        
        if (rel.type === 'best_friend') {
          return `Best friend: ${target.name}`;
        } else if (rel.type === 'crush') {
          return `Has a crush on: ${target.name}`;
        } else if (rel.type === 'romantic') {
          return `In a relationship with: ${target.name}`;
        } else if (rel.type === 'rival') {
          return `Rival: ${target.name}`;
        }
        return null;
      })
      .filter(Boolean);
    
    if (relationships.length > 0) {
      context += `Relationships: ${relationships.join(', ')}. `;
    }
    
    return context;
  }
  
  /**
   * Get detailed awareness context for post generation
   * Returns comprehensive info about employee's social environment
   */
  function getEmployeeAwarenessForPost(employeeId) {
    // Handle if object is passed instead of ID
    if (typeof employeeId === 'object' && employeeId.id) {
      employeeId = employeeId.id;
    }
    
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return null;
    
    initializeEmployeeSocialData(emp);
    
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active' && e.id !== employeeId);
    const sameLocation = activeEmployees.filter(e => e.locationId === emp.locationId);
    const otherLocations = activeEmployees.filter(e => e.locationId !== emp.locationId);
    
    // Get relationship breakdown
    const relationships = {
      bestFriends: [],
      friends: [],
      crushes: [],
      romantic: [],
      rivals: [],
      enemies: [],
      neutral: []
    };
    
    // Build coworkers array for context (combines all relationships)
    const coworkers = [];
    
    Object.entries(emp.relationships || {}).forEach(([targetId, rel]) => {
      const target = activeEmployees.find(e => e.id === targetId);
      if (!target) return;
      
      const relData = {
        id: target.id,
        name: target.name,
        position: target.position,
        location: target.locationId,
        strength: rel.strength,
        sameLocation: rel.sharedLocation,
        sharedInterests: rel.sharedInterests
      };
      
      if (rel.type === 'best_friend') relationships.bestFriends.push(relData);
      else if (rel.type === 'friend') relationships.friends.push(relData);
      else if (rel.type === 'crush') relationships.crushes.push(relData);
      else if (rel.type === 'romantic') relationships.romantic.push(relData);
      else if (rel.type === 'rival') relationships.rivals.push(relData);
      else if (rel.type === 'enemy') relationships.enemies.push(relData);
      else relationships.neutral.push(relData);
      
      // Add to coworkers array for generateOrganicPost
      coworkers.push({
        coworkerId: target.id,
        coworkerName: target.name,
        relationship: rel.type || 'neutral',
        knownFor: target.position,
        strength: rel.strength
      });
    });
    
    // Get recent events involving this employee
    const recentEvents = getRelevantEvents(employeeId, 5);
    
    // Build known locations array
    const knownLocations = [emp.locationId || 'headquarters'];
    
    // Get recent chat history with boss (last 5 messages within 2 hours)
    const chatHistory = gameState.chatHistory[emp.id] || [];
    const twoHoursAgo = Date.now() - (2 * 60 * 60 * 1000);
    const recentChats = chatHistory
      .filter(msg => (msg.timestamp || 0) > twoHoursAgo)
      .slice(-5); // Last 5 messages within 2 hours
    
    // Summarize chat topics/themes for context
    let chatContext = null;
    if (recentChats.length >= 2) { // Only include if there's meaningful conversation
      const chatText = recentChats.map(msg => msg.content).join(' ');
      
      // Detect conversation themes
      const themes = [];
      if (/\b(flirt|sexy|hot|beautiful|cute|attractive|date|kiss|touch)\b/i.test(chatText)) {
        themes.push('flirty/romantic');
      }
      if (/\b(project|deadline|work|meeting|report|task|client)\b/i.test(chatText)) {
        themes.push('work-related');
      }
      if (/\b(tired|busy|stressed|excited|happy|sad|frustrated)\b/i.test(chatText)) {
        themes.push('emotional/personal');
      }
      if (/\b(lunch|dinner|coffee|drink|food|eat)\b/i.test(chatText)) {
        themes.push('food/social');
      }
      
      chatContext = {
        hasRecentChat: true,
        messageCount: recentChats.length,
        themes: themes,
        lastMessages: recentChats.slice(-3).map(msg => ({
          sender: msg.sender,
          preview: msg.content.slice(0, 100) // First 100 chars
        })),
        timeAgo: Math.round((Date.now() - (recentChats[recentChats.length - 1]?.timestamp || 0)) / (60 * 1000)) // minutes
      };
    }
    
    return {
      employee: {
        id: emp.id,
        name: emp.name,
        position: emp.position,
        location: emp.locationId,
        gender: emp.gender || 'Female',
        age: emp.age,
        physicalDescription: getPhysicalDescriptionForPrompt(emp), // Full physical awareness including genitals
        personality: emp.personalityTraits || emp.personality,
        hobbies: emp.hobbies || [],
        stats: emp.stats
      },
      workplace: {
        totalEmployees: gameState.companyContext.totalEmployees,
        locationCoworkers: sameLocation.length,
        sameLocationNames: sameLocation.map(e => e.name),
        otherLocationEmployees: otherLocations.length,
        locations: Object.keys(gameState.companyContext.locationEmployeeCounts)
      },
      relationships,
      coworkers: coworkers, // â† Added for generateOrganicPost
      knownLocations: knownLocations, // â† Added for generateOrganicPost
      recentEvents,
      chatContext, // â† NEW: Recent conversation context with boss
      socialProfile: emp.social
    };
  }
  
  /**
   * Get a random coworker with specific relationship type
   */
  function getRandomCoworkerByRelation(employeeId, relationType = null) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return null;
    
    initializeEmployeeSocialData(emp);
    
    const candidates = Object.entries(emp.relationships || {})
      .filter(([targetId, rel]) => {
        if (relationType && rel.type !== relationType) return false;
        const target = gameState.employees.find(e => e.id === targetId && e.employmentStatus === 'active');
        return !!target;
      })
      .map(([targetId]) => gameState.employees.find(e => e.id === targetId));
    
    if (candidates.length === 0) return null;
    
    return candidates[Math.floor(Math.random() * candidates.length)];
  }
  
  /**
   * Get employees at same location
   */
  function getLocationCoworkers(employeeId) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return [];
    
    return gameState.employees.filter(e => 
      e.employmentStatus === 'active' &&
      e.id !== employeeId &&
      e.locationId === emp.locationId
    );
  }
  
  /**
   * Get all locations employee knows about
   */
  function getKnownLocations(employeeId) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return [];
    
    initializeEmployeeSocialData(emp);
    
    return gameState.locations
      .filter(loc => emp.awareness.knowsLocations.includes(loc.id))
      .map(loc => ({
        id: loc.id,
        name: loc.name,
        employeeCount: gameState.companyContext.locationEmployeeCounts[loc.id] || 0
      }));
  }
  
  /**
   * Check if employee should know about another employee
   */
  function knowsEmployee(employeeId, targetId) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return false;
    
    initializeEmployeeSocialData(emp);
    
    return emp.awareness.knowsCoworkers.includes(targetId);
  }

  // ========== GOSSIPENGINEâ„¢ - NPC INTERPERSONAL DYNAMICS SYSTEM ==========
  
  /**
   * Initialize gossip system for an employee
   */
  function initializeGossipSystem(employee) {
    if (!employee.gossip) {
      employee.gossip = {
        knownGossip: [], // Array of gossip items they know
        lastGossipTime: 0, // When they last gossiped
        gossipTendency: 30 + Math.random() * 50, // 30-80, how likely they are to gossip
        trustworthiness: 20 + Math.random() * 60, // 20-80, how accurately they relay info
      };
    }
    
    if (!employee.recentSimulatedEvents) {
      employee.recentSimulatedEvents = []; // Events that "happened" off-screen
    }
    
    return employee;
  }
  
  /**
   * Gossip Item Structure
   * Represents a piece of information that spreads between NPCs
   */
  function createGossipItem({
    id = `gossip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    type, // 'hookup', 'fight', 'crush', 'promotion', 'scandal', 'rumor', 'friendship', 'breakup'
    subjectId, // Main person the gossip is about
    targetId = null, // Secondary person (for relationship gossip)
    content, // The actual gossip content
    truthLevel = 100, // 0-100, how accurate this is (rumors degrade)
    juiciness = 50, // 0-100, how interesting/scandalous
    spreadCount = 0, // How many people know about it
    originatorId, // Who started the gossip
    timestamp = Date.now(),
    expiresAt = Date.now() + (7 * 86400000), // Gossip expires after 7 days
    tags = [] // ['romantic', 'work', 'scandal', etc.]
  } = {}) {
    return {
      id, type, subjectId, targetId, content, truthLevel, juiciness,
      spreadCount, originatorId, timestamp, expiresAt, tags
    };
  }
  
  // ========== COMPANY-WIDE CONTEXT SYSTEM - PUBLIC KNOWLEDGE ==========
  
  /**
   * Add information to the Company-Wide Context
   * This is "public knowledge" that everyone in the office knows about
   */
  function addToCompanyWideContext(info) {
    if (!gameState.companyWideContext) {
      gameState.companyWideContext = {
        currentBuzz: [],
        lastUpdate: Date.now(),
        maxItems: 40,
        decayTime: 604800000 // 7 days
      };
    }
    
    const context = gameState.companyWideContext;
    const now = Date.now();
    
    // Create context item
    const contextItem = {
      id: `context_${now}_${Math.random().toString(36).substr(2, 9)}`,
      content: info.content, // The public knowledge string
      type: info.type, // 'hookup', 'scandal', 'promotion', 'fight', 'post', etc.
      subjectIds: info.subjectIds || [], // People involved
      juiciness: info.juiciness || 50, // How interesting/scandalous
      timestamp: now,
      source: info.source || 'unknown' // 'social_post', 'gossip', 'witnessed', etc.
    };
    
    console.log(`[CompanyContext] ğŸ“¢ Adding to public knowledge: "${info.content}"`);
    
    // Add to the buzz
    context.currentBuzz.unshift(contextItem); // Add to front
    
    // Trim old/stale items
    const decayThreshold = now - context.decayTime;
    context.currentBuzz = context.currentBuzz.filter(item => item.timestamp > decayThreshold);
    
    // Keep only the juiciest items if we exceed maxItems
    if (context.currentBuzz.length > context.maxItems) {
      // Sort by juiciness * recency factor
      context.currentBuzz.sort((a, b) => {
        const recencyA = (now - a.timestamp) / 86400000; // Days old
        const recencyB = (now - b.timestamp) / 86400000;
        const scoreA = a.juiciness * (1 / (1 + recencyA * 0.5)); // Decay over time
        const scoreB = b.juiciness * (1 / (1 + recencyB * 0.5));
        return scoreB - scoreA;
      });
      
      // Keep only top items
      context.currentBuzz = context.currentBuzz.slice(0, context.maxItems);
    }
    
    context.lastUpdate = now;
    
    console.log(`[CompanyContext] Current buzz has ${context.currentBuzz.length} items`);
    return contextItem;
  }
  
  /**
   * Get the current company-wide context as a formatted string
   * This can be used in AI prompts to give NPCs awareness of office drama
   */
  function getCompanyWideContextString() {
    if (!gameState.companyWideContext || gameState.companyWideContext.currentBuzz.length === 0) {
      return "The office is relatively quiet right now - no major drama or gossip.";
    }
    
    const buzzItems = gameState.companyWideContext.currentBuzz
      .slice(0, 10) // Top 10 items
      .map((item, index) => `${index + 1}. ${item.content}`)
      .join('\n');
    
    return `CURRENT OFFICE BUZZ (Public Knowledge):\n${buzzItems}`;
  }
  
  /**
   * Extract juicy information from posts and add to company context
   */
  function analyzePostForPublicKnowledge(post) {
    const content = (post.content || '').toLowerCase();
    const mentions = post.referencedEmployees || [];
    const isExplicit = post.explicitLevel >= 2;
    
    let juiciness = 30; // Base juiciness for any post
    let contextContent = null;
    let contextType = 'post';
    
    // Check for relationship reveals
    const relationshipKeywords = ['dating', 'together', 'couple', 'boyfriend', 'girlfriend', 'relationship', 'hooked up', 'kissed', 'makeout', 'sleeping with'];
    const hasRelationshipContent = relationshipKeywords.some(kw => content.includes(kw));
    
    if (hasRelationshipContent && mentions.length >= 1) {
      juiciness = 85;
      const mentionedNames = mentions.map(id => {
        const emp = gameState.employees.find(e => e.id === id);
        return emp ? emp.name : 'someone';
      });
      
      if (post.isPlayerPost) {
        contextContent = `Boss revealed something about ${mentionedNames.join(' and ')} on social media`;
      } else {
        contextContent = `${post.authorName} posted about ${mentionedNames.join(' and ')} - relationship drama!`;
      }
      contextType = 'hookup';
    }
    
    // Check for explicit content
    if (isExplicit && mentions.length >= 1) {
      juiciness = Math.max(juiciness, 75);
      const mentionedNames = mentions.map(id => {
        const emp = gameState.employees.find(e => e.id === id);
        return emp ? emp.name : 'someone';
      });
      
      if (!contextContent) { // Don't override relationship content
        if (post.isPlayerPost) {
          contextContent = `Boss posted explicit content featuring ${mentionedNames.join(' and ')}`;
        } else {
          contextContent = `${post.authorName} shared explicit content about ${mentionedNames.join(' and ')}`;
        }
        contextType = 'scandal';
      }
    }
    
    // Check for callouts/drama
    const dramaKeywords = ['drama', 'fight', 'angry', 'hate', 'betrayed', 'liar', 'cheat', 'exposed', 'caught'];
    const hasDrama = dramaKeywords.some(kw => content.includes(kw));
    
    if (hasDrama && mentions.length >= 1) {
      juiciness = Math.max(juiciness, 70);
      const mentionedNames = mentions.map(id => {
        const emp = gameState.employees.find(e => e.id === id);
        return emp ? emp.name : 'someone';
      });
      
      if (!contextContent) {
        contextContent = `${post.authorName} called out ${mentionedNames.join(' and ')} - office drama!`;
        contextType = 'fight';
      }
    }
    
    // High engagement = newsworthy
    if (post.likes && post.likes.length > 5) {
      juiciness += 15; // Popular posts are juicier
    }
    
    if (post.comments && post.comments.length > 3) {
      juiciness += 20; // Lots of discussion = juicy
    }
    
    // If we found something juicy, add to context
    if (contextContent && juiciness >= 60) {
      addToCompanyWideContext({
        content: contextContent,
        type: contextType,
        subjectIds: [post.authorId || 'player', ...mentions],
        juiciness: juiciness,
        source: 'social_post'
      });
      
      console.log(`[CompanyContext] Extracted public knowledge from post (juiciness: ${juiciness})`);
      
      // Feed this into the Gossip Engine - NPCs gossip about current events!
      feedContextToGossipEngine({
        content: contextContent,
        type: contextType,
        subjectIds: [post.authorId || 'player', ...mentions],
        juiciness: juiciness
      });
    }
  }
  
  /**
   * Feed Company-Wide Context into the Gossip Engine
   * NPCs will gossip about the interesting things happening in the office
   */
  function feedContextToGossipEngine(contextItem) {
    if (!gameState.activeGossip) gameState.activeGossip = [];
    
    // Determine which NPCs "witnessed" or know about this event
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    const knownBy = [];
    
    // Everyone involved knows firsthand
    for (const subjectId of contextItem.subjectIds) {
      if (subjectId !== 'player' && activeEmployees.find(e => e.id === subjectId)) {
        knownBy.push(subjectId);
      }
    }
    
    // Random 30-60% of other employees "hear about it" based on juiciness
    const spreadChance = Math.min(0.8, (contextItem.juiciness / 100) * 0.6); // 60-80% for high juiciness
    for (const emp of activeEmployees) {
      if (!knownBy.includes(emp.id) && Math.random() < spreadChance) {
        knownBy.push(emp.id);
        
        // Add to their known gossip
        if (!emp.gossip) initializeGossipSystem(emp);
        
        const gossipItem = createGossipItem({
          type: contextItem.type,
          subjectId: contextItem.subjectIds[0] || 'player',
          targetId: contextItem.subjectIds[1] || null,
          content: contextItem.content,
          truthLevel: 100, // Public posts are 100% accurate
          juiciness: contextItem.juiciness,
          spreadCount: knownBy.length,
          originatorId: 'public' // From public social media
        });
        
        // Avoid duplicates
        if (!emp.gossip.knownGossip.find(g => g.content === gossipItem.content)) {
          emp.gossip.knownGossip.push(gossipItem);
          
          // Keep only 20 most recent gossip items per NPC
          if (emp.gossip.knownGossip.length > 20) {
            emp.gossip.knownGossip.sort((a, b) => b.timestamp - a.timestamp);
            emp.gossip.knownGossip = emp.gossip.knownGossip.slice(0, 20);
          }
        }
      }
    }
    
    // Add to global gossip pool
    gameState.activeGossip.push({
      id: `gossip_${Date.now()}_${Math.random()}`,
      subjectId: contextItem.subjectIds[0] || 'player',
      targetId: contextItem.subjectIds[1] || null,
      content: contextItem.content,
      juiciness: contextItem.juiciness,
      timestamp: gameState.time?.currentTime || Date.now(),
      accuracy: 100,
      knownBy: knownBy
    });
    
    // Keep gossip list manageable
    if (gameState.activeGossip.length > 50) {
      gameState.activeGossip = gameState.activeGossip.slice(-50);
    }
    
    console.log(`[GossipEngine] Fed context to ${knownBy.length} NPCs: "${contextItem.content}"`);
  }
  
  /**
   * Simulated Event Structure
   * Things that "happened" when player wasn't looking
   */
  function createSimulatedEvent({
    id = `simevent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    type, // 'hookup', 'date', 'argument', 'lunch', 'drinks', 'project', 'gossip_session'
    participants, // Array of employee IDs involved
    location, // Where it happened
    description, // Brief description
    outcome, // 'positive', 'negative', 'neutral', 'dramatic'
    relationshipImpacts = [], // [{ employeeId1, employeeId2, change }]
    generatesGossip = true,
    timestamp = Date.now(),
    witnessed = [] // Employee IDs who "saw" it happen
  } = {}) {
    return {
      id, type, participants, location, description, outcome,
      relationshipImpacts, generatesGossip, timestamp, witnessed
    };
  }
  
  /**
   * Generate random off-screen events between NPCs
   * Called periodically to simulate office life
   */
  function simulateOfficeEvents() {
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (activeEmployees.length < 2) return;
    
    // Chance to generate event: 15% per check (called every 15 minutes)
    if (Math.random() > 0.15) return;
    
    // Select random participants (2-3 people)
    const participantCount = Math.random() < 0.7 ? 2 : 3;
    const participants = [];
    
    while (participants.length < participantCount && participants.length < activeEmployees.length) {
      const emp = activeEmployees[Math.floor(Math.random() * activeEmployees.length)];
      if (!participants.find(p => p.id === emp.id)) {
        participants.push(emp);
      }
    }
    
    if (participants.length < 2) return;
    
    // Determine event type based on relationships
    const emp1 = participants[0];
    const emp2 = participants[1];
    const rel = emp1.relationships?.[emp2.id];
    const relStrength = rel?.strength || 50;
    const relType = rel?.type || 'neutral';
    
    let eventType, description, outcome, relationshipImpacts = [];
    
    // Event type selection based on relationship
    if (relType === 'romantic' && Math.random() < 0.3) {
      eventType = 'date';
      const locations = ['coffee shop', 'nice restaurant', 'the park', 'downtown'];
      const location = locations[Math.floor(Math.random() * locations.length)];
      description = `${emp1.name} and ${emp2.name} went on a date to ${location}`;
      outcome = Math.random() < 0.8 ? 'positive' : 'neutral';
      relationshipImpacts = [{ 
        employeeId1: emp1.id, 
        employeeId2: emp2.id, 
        change: Math.random() < 0.8 ? 5 + Math.floor(Math.random() * 10) : -5 
      }];
    } else if (relType === 'crush' && Math.random() < 0.4) {
      eventType = 'hookup';
      const locations = ['supply closet', 'empty office', 'their apartment', 'parking garage'];
      const location = locations[Math.floor(Math.random() * locations.length)];
      description = `${emp1.name} and ${emp2.name} hooked up in ${location}`;
      outcome = 'dramatic';
      relationshipImpacts = [{
        employeeId1: emp1.id,
        employeeId2: emp2.id,
        change: 15 + Math.floor(Math.random() * 20)
      }];
      // Upgrade relationship
      if (rel) {
        rel.type = Math.random() < 0.6 ? 'romantic' : 'friends_with_benefits';
        rel.strength = Math.min(100, rel.strength + 20);
      }
    } else if ((relType === 'rival' || relType === 'enemy') && Math.random() < 0.5) {
      eventType = 'argument';
      const reasons = ['work project', 'personal issue', 'office gossip', 'petty disagreement'];
      const reason = reasons[Math.floor(Math.random() * reasons.length)];
      description = `${emp1.name} and ${emp2.name} had a heated argument about ${reason}`;
      outcome = 'negative';
      relationshipImpacts = [{
        employeeId1: emp1.id,
        employeeId2: emp2.id,
        change: -10 - Math.floor(Math.random() * 15)
      }];
    } else {
      // Neutral social events
      const eventTypes = [
        { type: 'lunch', desc: 'had lunch together at', outcome: 'positive', impact: 3 },
        { type: 'drinks', desc: 'grabbed drinks after work at', outcome: 'positive', impact: 5 },
        { type: 'project', desc: 'worked together on a project', outcome: 'neutral', impact: 2 },
        { type: 'gossip_session', desc: 'had a long gossip session about the office', outcome: 'neutral', impact: 4 },
        { type: 'coffee', desc: 'got coffee together', outcome: 'positive', impact: 2 }
      ];
      
      const chosen = eventTypes[Math.floor(Math.random() * eventTypes.length)];
      eventType = chosen.type;
      outcome = chosen.outcome;
      
      if (chosen.type === 'gossip_session') {
        description = `${emp1.name} and ${emp2.name} ${chosen.desc}`;
      } else {
        const locations = ['the local cafÃ©', 'Murphy\'s Bar', 'that new place downtown'];
        description = `${emp1.name} and ${emp2.name} ${chosen.desc} ${chosen.type === 'project' ? '' : locations[Math.floor(Math.random() * locations.length)]}`;
      }
      
      relationshipImpacts = [{
        employeeId1: emp1.id,
        employeeId2: emp2.id,
        change: chosen.impact + Math.floor(Math.random() * 3)
      }];
    }
    
    // Determine who witnessed it (0-3 random employees at same location)
    const location = emp1.locationId || 'headquarters';
    const potentialWitnesses = activeEmployees.filter(e => 
      e.locationId === location && 
      !participants.find(p => p.id === e.id)
    );
    const witnessCount = Math.floor(Math.random() * Math.min(4, potentialWitnesses.length + 1));
    const witnessed = [];
    for (let i = 0; i < witnessCount; i++) {
      const witness = potentialWitnesses[Math.floor(Math.random() * potentialWitnesses.length)];
      if (witness && !witnessed.includes(witness.id)) {
        witnessed.push(witness.id);
      }
    }
    
    // Create the event
    const event = createSimulatedEvent({
      type: eventType,
      participants: participants.map(p => p.id),
      location,
      description,
      outcome,
      relationshipImpacts,
      witnessed
    });
    
    // Apply relationship impacts
    relationshipImpacts.forEach(impact => {
      updateRelationship(impact.employeeId1, impact.employeeId2, {
        event: eventType,
        impact: impact.change
      });
    });
    
    // Store event for participants
    participants.forEach(emp => {
      initializeGossipSystem(emp);
      emp.recentSimulatedEvents.push(event);
      if (emp.recentSimulatedEvents.length > 10) {
        emp.recentSimulatedEvents = emp.recentSimulatedEvents.slice(-10);
      }
    });
    
    // Create gossip if event is juicy enough
    if (event.generatesGossip && (eventType === 'hookup' || eventType === 'argument' || eventType === 'date')) {
      const juiciness = eventType === 'hookup' ? 80 : eventType === 'argument' ? 60 : 50;
      
      const gossipContent = description;
      const gossip = createGossipItem({
        type: eventType,
        subjectId: emp1.id,
        targetId: emp2.id,
        content: gossipContent,
        juiciness,
        originatorId: witnessed.length > 0 ? witnessed[0] : emp1.id,
        tags: [outcome, 'simulated']
      });
      
      // Witnesses know about it immediately
      witnessed.forEach(witnessId => {
        const witness = activeEmployees.find(e => e.id === witnessId);
        if (witness) {
          initializeGossipSystem(witness);
          witness.gossip.knownGossip.push({
            gossipId: gossip.id,
            learnedAt: Date.now(),
            source: 'witnessed',
            accuracy: 100
          });
        }
      });
      
      // Store gossip globally
      if (!gameState.socialNetwork.activeGossip) {
        gameState.socialNetwork.activeGossip = [];
      }
      gameState.socialNetwork.activeGossip.push(gossip);
      
      // Trigger gossip spread after a delay
      setTimeout(() => spreadGossip(gossip.id), 5000 + Math.random() * 10000);
    }
    
    console.log(`[GossipEngine] Simulated event: ${description}`);
  }
  
  /**
   * Spread gossip between NPCs
   */
  function spreadGossip(gossipId) {
    const gossip = gameState.socialNetwork.activeGossip?.find(g => g.id === gossipId);
    if (!gossip) return;
    
    // Find who knows about this gossip
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    const knowers = activeEmployees.filter(emp => {
      initializeGossipSystem(emp);
      return emp.gossip.knownGossip.some(g => g.gossipId === gossipId);
    });
    
    if (knowers.length === 0) return;
    
    // Each knower has a chance to spread it
    knowers.forEach(knower => {
      initializeGossipSystem(knower);
      
      // Check if they're a gossip
      if (Math.random() * 100 > knower.gossip.gossipTendency) return;
      
      // Find someone to tell (friend or coworker)
      const potentialListeners = activeEmployees.filter(emp => {
        if (emp.id === knower.id) return false;
        initializeGossipSystem(emp);
        // Don't tell if they already know
        if (emp.gossip.knownGossip.some(g => g.gossipId === gossipId)) return false;
        
        // More likely to tell friends or coworkers at same location
        const rel = knower.relationships?.[emp.id];
        const sameLoc = knower.locationId === emp.locationId;
        return sameLoc || (rel && ['friend', 'best_friend'].includes(rel.type));
      });
      
      if (potentialListeners.length === 0) return;
      
      const listener = potentialListeners[Math.floor(Math.random() * potentialListeners.length)];
      
      // Calculate accuracy degradation (like telephone game)
      const knowerAccuracy = knower.gossip.knownGossip.find(g => g.gossipId === gossipId)?.accuracy || 100;
      const trustFactor = knower.gossip.trustworthiness / 100;
      const newAccuracy = Math.max(0, Math.floor(knowerAccuracy * trustFactor * (0.85 + Math.random() * 0.15)));
      
      // Listener learns the gossip
      listener.gossip.knownGossip.push({
        gossipId: gossip.id,
        learnedAt: Date.now(),
        source: knower.id,
        accuracy: newAccuracy
      });
      
      gossip.spreadCount++;
      
      console.log(`[GossipEngine] ${knower.name} told ${listener.name} about: ${gossip.content} (accuracy: ${newAccuracy}%)`);
    });
  }
  
  /**
   * Get gossip that an employee knows about
   */
  function getKnownGossip(employeeId, limit = 5) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return [];
    
    initializeGossipSystem(emp);
    
    const now = Date.now();
    const allGossip = gameState.socialNetwork.activeGossip || [];
    
    // Filter to gossip they know that hasn't expired
    const knownGossipItems = emp.gossip.knownGossip
      .map(kg => {
        const gossip = allGossip.find(g => g.id === kg.gossipId);
        if (!gossip || gossip.expiresAt < now) return null;
        return { ...gossip, learnedAt: kg.learnedAt, accuracy: kg.accuracy, source: kg.source };
      })
      .filter(Boolean)
      .sort((a, b) => b.juiciness - a.juiciness) // Sort by juiciness
      .slice(0, limit);
    
    return knownGossipItems;
  }
  
  /**
   * Generate gossip about player's actions
   * Called when player does something noteworthy with an NPC
   */
  function createPlayerGossip({ type, npcId, description, juiciness = 50 }) {
    const npc = gameState.employees.find(e => e.id === npcId);
    if (!npc) return;
    
    initializeGossipSystem(npc);
    
    const gossip = createGossipItem({
      type,
      subjectId: 'player',
      targetId: npcId,
      content: description,
      juiciness,
      originatorId: npcId,
      tags: ['player_action']
    });
    
    // NPC knows about it (obviously)
    npc.gossip.knownGossip.push({
      gossipId: gossip.id,
      learnedAt: Date.now(),
      source: 'personal_experience',
      accuracy: 100
    });
    
    // Store globally
    if (!gameState.socialNetwork.activeGossip) {
      gameState.socialNetwork.activeGossip = [];
    }
    gameState.socialNetwork.activeGossip.push(gossip);
    
    // NPC might tell others based on their gossip tendency and the juiciness
    if (npc.gossip.gossipTendency > 40 || juiciness > 70) {
      setTimeout(() => spreadGossip(gossip.id), 3000 + Math.random() * 7000);
    }
    
    console.log(`[GossipEngine] Created player gossip: ${description}`);
  }
  
  /**
   * Get gossip context for chat/posts
   * Returns formatted string with gossip the NPC knows
   */
  function getGossipContext(employeeId, includePlayerGossip = true) {
    const knownGossip = getKnownGossip(employeeId, 3);
    if (knownGossip.length === 0) return '';
    
    let context = '\n\nRECENT GOSSIP YOU KNOW ABOUT:\n';
    
    knownGossip.forEach(gossip => {
      // Skip player gossip if not requested
      if (!includePlayerGossip && gossip.subjectId === 'player') return;
      
      const subject = gossip.subjectId === 'player' ? 'the boss' : 
                     gameState.employees.find(e => e.id === gossip.subjectId)?.name || 'someone';
      
      const target = gossip.targetId ? 
                    (gossip.targetId === 'player' ? 'the boss' : 
                     gameState.employees.find(e => e.id === gossip.targetId)?.name || 'someone') : '';
      
      const accuracy = gossip.accuracy < 50 ? ' (but this might be a rumor)' : 
                      gossip.accuracy < 80 ? ' (heard through the grapevine)' : '';
      
      context += `- ${gossip.content}${accuracy}\n`;
    });
    
    context += '\nYou can reference this gossip naturally in conversation if relevant!\n';
    
    return context;
  }
  
  /**
   * Cleanup expired gossip
   */
  function cleanupExpiredGossip() {
    if (!gameState.socialNetwork.activeGossip) return;
    
    const now = Date.now();
    const before = gameState.socialNetwork.activeGossip.length;
    
    gameState.socialNetwork.activeGossip = gameState.socialNetwork.activeGossip
      .filter(g => g.expiresAt > now);
    
    const removed = before - gameState.socialNetwork.activeGossip.length;
    if (removed > 0) {
      console.log(`[GossipEngine] Cleaned up ${removed} expired gossip items`);
    }
  }

  // -------- NPC MEMORY & DIALOGUE HELPERS (professional-grade) --------
  // Lightweight tokenization
  function tokenize(text) {
    return (text || '')
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, ' ')
      .split(/\s+/)
      .filter(Boolean);
  }

  // Extract main topics from a message for anti-repetition tracking
  function extractTopics(message, emp) {
    const topics = [];
    const m = message.toLowerCase();
    
    // Check for job/work mentions
    if (emp.productManaged && m.includes(emp.productManaged.toLowerCase())) {
      topics.push('job_specific');
    }
    if (emp.position && m.includes(emp.position.toLowerCase())) {
      topics.push('job_title');
    }
    if (/\b(work|job|task|project|deadline)\b/.test(m)) {
      topics.push('work_general');
    }
    
    // Check for hobby mentions
    (emp.hobbies || []).forEach(h => {
      if (m.includes(h.toLowerCase())) topics.push(`hobby_${h}`);
    });
    
    // Check for relationship topics
    if (/\b(date|dinner|coffee|drinks|hang out)\b/.test(m)) topics.push('social_invite');
    if (/\b(flirt|cute|hot|sexy|attractive)\b/.test(m)) topics.push('flirting');
    if (/\b(kiss|touch|intimate|physical)\b/.test(m)) topics.push('physical');
    if (/\b(love|feel|emotion|heart)\b/.test(m)) topics.push('emotional');
    
    return topics;
  }

  // Ensure structured memory on employee (back-compat from array of strings)
  function ensureEmployeeMemory(emp) {
    if (!emp) return;
    if (!emp.memory || Array.isArray(emp.memory)) {
      const prev = Array.isArray(emp.memory) ? emp.memory : [];
      emp.memory = { 
        items: [], 
        cap: 300, // Increased to 300 for extensive long-term memory
        styleCounters: { 
          total: 0, 
          sincePersonal: 99,
          recentTopics: [], // track last 10 topics mentioned
          jobMentions: 0,
          hobbyMentions: 0,
          lastJobMention: 0,
          lastHobbyMention: 0
        },
        conversationPhase: 'early', // early, familiar, intimate
        intimacyLevel: 0 // 0-100 scale
      };
      // ingest old strings as low-importance notes
      for (const s of prev) remember(emp, s, 'note', 0.5);
    } else if (!emp.memory.styleCounters) {
      emp.memory.styleCounters = { 
        total: 0, 
        sincePersonal: 99,
        recentTopics: [],
        jobMentions: 0,
        hobbyMentions: 0,
        lastJobMention: 0,
        lastHobbyMention: 0
      };
    }
    
    // Upgrade existing memory caps
    if (emp.memory.cap && emp.memory.cap < 300) {
      emp.memory.cap = 300;
    }
    if (!emp.memory.conversationPhase) emp.memory.conversationPhase = 'early';
    if (emp.memory.intimacyLevel === undefined) emp.memory.intimacyLevel = 0;
    
    // Ensure personality object exists with C.O.F.P.H. attributes
    ensureEmployeePersonality(emp);
    
    // Ensure stats are properly initialized
    ensureEmployeeStats(emp);
  }
  
  /**
   * Ensure employee has personality attributes for AI
   * Migrates old employees who don't have these values
   */
  function ensureEmployeePersonality(emp) {
    if (!emp) return;
    
    // If personality is a string (old system), convert it
    if (typeof emp.personality === 'string') {
      const oldPersonality = emp.personality;
      emp.personalityTraits = [oldPersonality]; // Save the old value as a trait
      emp.personality = {}; // Reset to object
    }
    
    // If personality doesn't exist or is missing attributes, create/fill them
    if (!emp.personality || typeof emp.personality !== 'object') {
      emp.personality = {};
    }
    
    // Add missing attributes with randomized values
    if (emp.personality.confidence === undefined) {
      emp.personality.confidence = 30 + Math.floor(Math.random() * 50); // 30-80
    }
    if (emp.personality.outgoing === undefined) {
      emp.personality.outgoing = 20 + Math.floor(Math.random() * 60); // 20-80
    }
    if (emp.personality.flirty === undefined) {
      emp.personality.flirty = 10 + Math.floor(Math.random() * 70); // 10-80
    }
    if (emp.personality.professional === undefined) {
      emp.personality.professional = 30 + Math.floor(Math.random() * 50); // 30-80
    }
    if (emp.personality.humor === undefined) {
      emp.personality.humor = 20 + Math.floor(Math.random() * 60); // 20-80
    }
  }

  // Ensure employee has new stat system (migration from old stats)
  function ensureEmployeeStats(emp) {
    if (!emp || !emp.stats) {
      if (emp) emp.stats = {};
      else return;
    }
    
    const stats = emp.stats;
    
    // Migrate old stats to new system
    if (stats.love !== undefined && stats.affection === undefined) {
      stats.affection = stats.love;
      delete stats.love;
    }
    if (stats.efficiency !== undefined && stats.productivity === undefined) {
      stats.productivity = stats.efficiency;
      delete stats.efficiency;
    }
    if (stats.anger !== undefined) {
      // Convert anger to obedience (inverse relationship)
      if (stats.obedience === undefined) {
        stats.obedience = Math.max(0, 100 - stats.anger);
      }
      delete stats.anger;
    }
    
    // Initialize missing stats with defaults
    if (stats.affection === undefined) stats.affection = 30;
    if (stats.comfort === undefined) stats.comfort = 50;
    if (stats.trust === undefined) stats.trust = 40;
    if (stats.desire === undefined) stats.desire = 10;
    if (stats.obedience === undefined) stats.obedience = 50;
    if (stats.productivity === undefined) stats.productivity = 60;
    
    // Clamp all stats to 0-100
    for (const key of ['affection', 'comfort', 'trust', 'desire', 'obedience', 'productivity']) {
      if (stats[key] !== undefined) {
        stats[key] = Math.max(0, Math.min(100, stats[key]));
      }
    }
  }

  // Add an item to long-term memory with de-dup and cap
  function remember(emp, text, type = 'note', importance = 1) {
    if (!emp) return;
    ensureEmployeeMemory(emp);
    if (!text) return;
    
    // Defensive check - ensure items array exists
    if (!emp.memory || !emp.memory.items) {
      console.error('[Memory] Employee memory not properly initialized:', emp.name);
      ensureEmployeeMemory(emp);
      if (!emp.memory || !emp.memory.items) {
        console.error('[Memory] Failed to initialize memory for:', emp.name);
        return;
      }
    }
    
    const now = Date.now();
    const key = text.trim().toLowerCase();
    // merge if similar
    const existing = emp.memory.items.find(i => i.text.trim().toLowerCase() === key);
    if (existing) {
      existing.ts = now;
      existing.importance = Math.max(existing.importance, importance);
      existing.count = (existing.count || 1) + 1;
      return;
    }
    emp.memory.items.push({ text, type, importance, ts: now, count: 1 });
    if (emp.memory.items.length > emp.memory.cap) {
      // drop lowest score item
      emp.memory.items.sort((a,b)=> (a.importance + (a.count||1)*0.1) - (b.importance + (b.count||1)*0.1));
      emp.memory.items.shift();
    }
  }

  // Extract salient facts from a message for memory
  function extractSalientFacts(message, emp) {
    const facts = [];
    if (!message) return facts;
    const m = message.toLowerCase();
    const add = (text, type, imp=1.0) => facts.push({ text, type, importance: imp });
    
    // High-importance work events
    if (/\b(promot|raise|level up)\b/.test(m)) add('Discussed promotion/raise', 'event', 1.8);
    if (/\b(fire|fir(e|ing)|terminat(e|ion))\b/.test(m)) add('Termination discussed', 'event', 2.0);
    if (/\b(deadline|ship|launch|deliver(y|able)?)\b/.test(m)) add('Work deadline mentioned', 'work', 1.3);
    
    // Medium-importance interactions
    if (/\b(gift|present|bonus)\b/.test(m)) add('Gift or bonus mentioned', 'event', 1.4);
    if (/\b(meet(ing)?|1:1|one on one)\b/.test(m)) add('Meeting planned', 'event', 1.1);
    if (/\b(date|coffee|lunch|dinner)\b/.test(m) && !/deadline/.test(m)) add('Social invitation', 'relation', 1.5);
    
    // Emotional/relationship markers
    if (/\b(thank|appreciate|grateful)\b/.test(m)) add('Expressed gratitude', 'relation', 1.0);
    if (/\b(sorry|apolog|my bad)\b/.test(m)) add('Apologized', 'relation', 1.0);
    if (/\b(love|adore|crush)\b/.test(m)) add('Romantic sentiment', 'relation', 1.6);
    if (/\b(frustrat|annoy|angry|upset)\b/.test(m)) add('Negative emotion', 'relation', 1.2);
    
    // Intimacy progression (context-aware)
    if (/\b(flirt|tease|cute|hot|sexy|attractive)\b/.test(m)) add('Flirtatious exchange', 'relation', 1.4);
    if (/\b(kiss|touch|hold|hug|embrace)\b/.test(m)) add('Physical affection discussed', 'intimacy', 1.7);
    if (/\b(want|desire|need) (you|me|us)\b/.test(m)) add('Expressed desire', 'intimacy', 1.5);
    
    // Avoid over-logging job mentions - only log if it's a significant event
    // NOT: routine job mentions
    
    return facts;
  }

  // Score memory relevance versus last message tokens
  function scoreMemory(item, tokens, emp) {
    const overlap = tokens ? tokens.filter(t => item.text.toLowerCase().includes(t)).length : 0;
    const recency = 1 / Math.max(1, (Date.now() - (item.ts || 0)) / (1000*60*60)); // hours decay
    
    // Penalize job/hobby mentions if they were mentioned recently
    let repetitionPenalty = 0;
    if (emp && emp.memory && emp.memory.styleCounters) {
      const counters = emp.memory.styleCounters;
      const text = item.text.toLowerCase();
      
      // Check if this memory is about job/hobbies
      const isJobRelated = /\b(manage|job|work|position|role)\b/.test(text) || 
                          (emp.productManaged && text.includes(emp.productManaged.toLowerCase()));
      const isHobbyRelated = (emp.hobbies || []).some(h => text.toLowerCase().includes(h.toLowerCase()));
      
      if (isJobRelated && (counters.total - counters.lastJobMention) < 5) {
        repetitionPenalty = 2.0; // Heavy penalty if job mentioned in last 5 messages
      }
      if (isHobbyRelated && (counters.total - counters.lastHobbyMention) < 6) {
        repetitionPenalty = 2.5; // Even heavier penalty for hobbies
      }
    }
    
    // Boost relationship/emotional memories
    const typeBoost = (item.type === 'relation' || item.type === 'intimacy') ? 0.8 : 0;
    
    return overlap * 0.6 + (item.importance || 1) * 0.9 + recency * 0.5 + (item.count || 1) * 0.1 + typeBoost - repetitionPenalty;
  }

  function retrieveMemories(emp, lastMessage, limit = 25) {
    ensureEmployeeMemory(emp);
    const tokens = tokenize(lastMessage).slice(0, 20);
    return emp.memory.items
      .slice()
      .sort((a, b) => scoreMemory(b, tokens, emp) - scoreMemory(a, tokens, emp))
      .slice(0, limit);
  }

  /**
   * Calculate NPC spending rate scaled to company progression
   * As the company grows, employees develop more expensive lifestyles
   */
  function calculateScaledSpendingRate(baseRate = null) {
    // Company scale based on total cash (log scale)
    // $1K company = scale 1.0x
    // $10K company = scale 1.2x
    // $100K company = scale 1.5x
    // $1M company = scale 2.0x
    // $10M company = scale 3.0x
    // $100M company = scale 4.5x
    // $1B company = scale 6.0x
    const companyValue = Math.max(1000, gameState.cash);
    const companyLog = Math.log10(companyValue);
    
    // Scale factor: ranges from 1.0x at $1K to ~6x at $1B+
    // Formula: 1 + (log10(cash) - 3) * 0.5
    // This means every 10x increase in company value = +0.5x spending multiplier
    const scaleFactor = Math.max(1.0, 1 + (companyLog - 3) * 0.5);
    
    // Base rate if not provided (new employee)
    if (baseRate === null) {
      baseRate = 50 + Math.random() * 100; // $50-150/day
    }
    
    // Apply scale factor
    const scaledRate = baseRate * scaleFactor;
    
    // Cap at reasonable maximum to prevent absurdity
    // At $1B+ company, max spending could be ~$50K/day for materialistic employees
    const maxRate = 50000;
    
    return Math.min(scaledRate, maxRate);
  }

  // ========== AI CONTEXT QUALITY FUNCTIONS ==========
  // Prevent repetitive patterns and enhance response variety
  
  /**
   * Initialize tracking for an employee if it doesn't exist
   */
  function initializeAITracking(employeeId) {
    if (!gameState.aiContextQuality.employeeTracking[employeeId]) {
      gameState.aiContextQuality.employeeTracking[employeeId] = {
        physicalActions: [],      // Track recent physical actions (arching, gasping, etc.)
        narrativeAnchors: [],     // Track callback references (Buddy, scar, budget jokes)
        sensoryWords: [],         // Track descriptive words (breathless, trembling, warm)
        responseStructures: [],   // Track sentence patterns (em-dashes, gerunds)
        humorCount: 0,           // Track meta-commentary frequency
        lastResponseTime: Date.now()
      };
    }
    
    if (!gameState.aiContextQuality.intimacyEscalation[employeeId]) {
      gameState.aiContextQuality.intimacyEscalation[employeeId] = 0;
    }
  }
  
  /**
   * Analyze a response for repetitive patterns
   * Returns warnings to inject into the next prompt
   */
  function analyzeResponseForRepetition(employeeId, response) {
    initializeAITracking(employeeId);
    const tracking = gameState.aiContextQuality.employeeTracking[employeeId];
    const warnings = [];
    
    // Extract patterns from response
    const lowerResponse = response.toLowerCase();
    
    // 1. Check for repetitive physical actions
    const physicalPatterns = [
      { pattern: /arch(ing|ed|es)?\s+(back|spine)/i, name: 'arching_back' },
      { pattern: /gasp(ing|ed|s)?\b/i, name: 'gasping' },
      { pattern: /(fingers?|hands?)\s+(tangl(ing|ed|es)|in|through)\s+hair/i, name: 'fingers_in_hair' },
      { pattern: /(nails?|fingernails?)\s+(dig|digging|dug|scrap|scraping|scraped)/i, name: 'nails_digging' },
      { pattern: /trembl(ing|ed|es|e)\b/i, name: 'trembling' },
      { pattern: /(legs?|ankles?)\s+(hook|hooking|hooked|lock|locking|locked|wrap|wrapping|wrapped)/i, name: 'legs_hooking' },
      { pattern: /shudder(ing|ed|s)?\b/i, name: 'shuddering' },
      { pattern: /knuckle(s)?\s+(whit(en|ening|ened)|press(ing|ed)|tight(en|ening|ened)|clench(ing|ed))/i, name: 'knuckles_action' },
      { pattern: /\b(stormy|gray|grey|blue|green|brown|hazel)\s+(eyes?)\b/i, name: 'eye_color_description' },
      { pattern: /\bgap.?tooth(ed)?\s+(grin|smile|smirk)/i, name: 'gap_tooth_descriptor' },
      { pattern: /(shoulders?|arms?|hands?)\s+(slump|slumping|slumped)/i, name: 'slumping' },
      { pattern: /(breath|exhale|inhale)\s+(catch(es|ing|ed)|sharp(ly)?)/i, name: 'breath_catching' }
    ];
    
    const foundActions = [];
    for (const {pattern, name} of physicalPatterns) {
      if (pattern.test(response)) {
        foundActions.push(name);
        
        // Check if this action appeared recently
        const recentCount = tracking.physicalActions.filter(a => a === name).length;
        if (recentCount >= gameState.aiContextQuality.maxSameAction) {
          warnings.push(`âš ï¸ REPETITION ALERT: You've used "${name.replace(/_/g, ' ')}" ${recentCount + 1} times in recent responses. Use a completely different physical reaction this time.`);
        }
      }
    }
    
    // 2. Check for narrative anchors (callbacks)
    const anchorPatterns = [
      { pattern: /\bbuddy\b/i, name: 'buddy_cat' },
      { pattern: /\b(budget|thrift.?store|therapy|co.?pay|cheap|expensive)\b/i, name: 'budget_humor' },
      { pattern: /\bscar(red)?\b/i, name: 'scar_reference' },
      { pattern: /\bwork.?life\s+separation\b/i, name: 'work_life_joke' }
    ];
    
    const foundAnchors = [];
    for (const {pattern, name} of anchorPatterns) {
      if (pattern.test(response)) {
        foundAnchors.push(name);
        
        const recentCount = tracking.narrativeAnchors.filter(a => a === name).length;
        if (recentCount >= gameState.aiContextQuality.maxSameAnchor) {
          warnings.push(`âš ï¸ CALLBACK OVERUSE: You've referenced "${name.replace(/_/g, ' ')}" ${recentCount + 1} times recently. Find NEW details or humor - retire this callback.`);
        }
      }
    }
    
    // 3. Check for repetitive sensory words
    const sensoryPatterns = [
      { pattern: /\bbreath(less|lessly|ing|s)\b/i, name: 'breath' },
      { pattern: /\b(warm|heat|hot|burning|burns?|burned)\b/i, name: 'warmth' },
      { pattern: /\b(soft|softly|gentle|gently)\b/i, name: 'softness' },
      { pattern: /\b(sharp|sharply)\b/i, name: 'sharpness' }
    ];
    
    const foundSensory = [];
    for (const {pattern, name} of sensoryPatterns) {
      if (pattern.test(response)) {
        foundSensory.push(name);
      }
    }
    
    // Check if too many same sensory words
    const sensoryCounts = {};
    tracking.sensoryWords.forEach(w => sensoryCounts[w] = (sensoryCounts[w] || 0) + 1);
    foundSensory.forEach(w => {
      if (sensoryCounts[w] >= 2) {
        warnings.push(`âš ï¸ SENSORY REPETITION: You've overused "${w}" descriptors. Use alternatives from vocabulary bank.`);
      }
    });
    
    // 3.5. Check for recurring specific phrases (multi-word patterns)
    const recurringPhrases = [
      { pattern: /pressing\s+(against|into|on)\s+(the\s+)?(counter|marble|desk|table)/i, name: 'pressing_against_surface' },
      { pattern: /(fingers?|hands?)\s+(drum|drumming|tap|tapping|tapped)\s+/i, name: 'fingers_drumming' },
      { pattern: /\bphone\s+screen\b/i, name: 'phone_screen_mention' },
      { pattern: /\bwine\s+glass\b/i, name: 'wine_glass_prop' }
    ];
    
    for (const {pattern, name} of recurringPhrases) {
      if (pattern.test(response)) {
        // Check last 5 responses for this exact phrase pattern
        const emp = gameState.employees.find(e => e.id === employeeId);
        if (emp && gameState.chatHistory[employeeId]) {
          const recentResponses = gameState.chatHistory[employeeId]
            .filter(msg => !msg.isPlayer)
            .slice(-5)
            .map(msg => msg.content);
          
          const matchCount = recentResponses.filter(r => pattern.test(r)).length;
          if (matchCount >= 2) {
            warnings.push(`ğŸ”´ PHRASE OVERUSE: You've used the phrase pattern "${name.replace(/_/g, ' ')}" ${matchCount + 1} times in last 5 responses. Use completely different actions/props.`);
          }
        }
      }
    }
    
    // 4. Check for structural patterns
    const emDashCount = (response.match(/â€”/g) || []).length;
    if (emDashCount >= 3) {
      const recentDashUsage = tracking.responseStructures.filter(s => s === 'em_dash_heavy').length;
      if (recentDashUsage >= 1) {
        warnings.push(`âš ï¸ PUNCTUATION OVERUSE: You're relying too heavily on em-dashes (â€”). Use different punctuation: semicolons, short declaratives, or ellipses.`);
      }
      foundActions.push('em_dash_heavy');
    }
    
    // Check for gerund openings
    if (/^(arching|melting|hooking|gasping|leaning|pressing|pulling|pushing|sliding)/i.test(response.trim())) {
      const recentGerunds = tracking.responseStructures.filter(s => s === 'gerund_opening').length;
      if (recentGerunds >= 1) {
        warnings.push(`âš ï¸ SENTENCE STRUCTURE: You're starting too many responses with gerunds (Arching, Melting, etc.). Start with subject, dialogue, or action verb instead.`);
      }
      foundActions.push('gerund_opening');
    }
    
    // 5. Check for excessive meta-commentary/humor
    const hasMetaCommentary = /\b(honestly|though honestly|but honestly|therapy|budget|thrift|cheap)\b/i.test(response);
    if (hasMetaCommentary) {
      tracking.humorCount++;
      
      // Calculate intimacy level for tonal modulation
      const emp = gameState.employees.find(e => e.id === employeeId);
      if (emp) {
        const intimacyLevel = Math.round((emp.stats.affection + emp.stats.comfort + emp.stats.desire) / 3);
        gameState.aiContextQuality.intimacyEscalation[employeeId] = intimacyLevel;
        
        if (intimacyLevel > 70 && tracking.humorCount >= 2) {
          warnings.push(`âš ï¸ TONAL SHIFT NEEDED: Intimacy is VERY HIGH (${intimacyLevel}%). Reduce meta-commentary and humor. Allow genuine vulnerability and overwhelmed emotion without quips.`);
        }
      }
    } else {
      tracking.humorCount = Math.max(0, tracking.humorCount - 1);
    }
    
    // Update tracking (keep last 3 responses)
    tracking.physicalActions = [...foundActions, ...tracking.physicalActions].slice(0, gameState.aiContextQuality.repetitionWindow);
    tracking.narrativeAnchors = [...foundAnchors, ...tracking.narrativeAnchors].slice(0, gameState.aiContextQuality.repetitionWindow);
    tracking.sensoryWords = [...foundSensory, ...tracking.sensoryWords].slice(0, gameState.aiContextQuality.repetitionWindow);
    tracking.responseStructures = [...tracking.responseStructures].slice(0, gameState.aiContextQuality.repetitionWindow);
    
    return warnings;
  }
  
  /**
   * Get variety guidance to inject into prompts
   */
  function getVarietyGuidance(employeeId) {
    initializeAITracking(employeeId);
    const banks = gameState.aiContextQuality.vocabularyBanks;
    
    // Randomly select alternatives from each category
    const randomFrom = (arr, count = 5) => {
      const shuffled = [...arr].sort(() => Math.random() - 0.5);
      return shuffled.slice(0, count);
    };
    
    return `
ğŸ¨ RESPONSE VARIETY TOOLKIT:
Use these alternatives to avoid repetition:

PHYSICAL REACTIONS (instead of arching/gasping/trembling):
- Arousal: ${randomFrom(banks.arousal).join(', ')}
- Spinal: ${randomFrom(banks.spinalReactions, 3).join(', ')}
- Breath: ${randomFrom(banks.breathPatterns, 3).join(', ')}

SENSORY DESCRIPTORS (instead of warm/soft/breathless):
- Temperature: ${randomFrom(banks.temperature, 4).join(', ')}
- Texture: ${randomFrom(banks.texture, 4).join(', ')}
- Sounds: ${randomFrom(banks.vocalSounds, 4).join(', ')}

MOVEMENT QUALITY: ${randomFrom(banks.movementQuality, 5).join(', ')}

ğŸ“ STRUCTURE VARIETY:
- Rotate: em-dashes (â€”), semicolons (;), ellipses (...), short declaratives
- Vary openings: Don't always start with gerunds (Arching, Melting)
- Mix sentence lengths: Alternate complex and punchy

âš ï¸ AVOID: Recycling the same actions/words from your last 3 responses
`;
  }

  // Sanitize and tighten model outputs
  function sanitizeNpcResponse(text, maxSentences = 10) {
    if (!text) return '';
    let t = String(text);
    
    // ===== REMOVE PERCHANCE TOKENS (CRITICAL - MUST BE FIRST) =====
    // These are Perchance-specific formatting tokens that should NEVER appear in final output
    t = t.replace(/\{SEEDS:[^}]*\}\s*/gi, '');   // Remove {SEEDS:word|word}
    t = t.replace(/\{BAN:[^}]*\}\s*/gi, '');     // Remove {BAN:word|word}
    t = t.replace(/\{BOOST:[^}]*\}\s*/gi, '');   // Remove {BOOST:word|word}
    t = t.replace(/\{[A-Z]+:[^}]*\}\s*/g, '');   // Remove any {TOKEN:...} pattern
    
    // ===== REMOVE META-ANALYSIS PATTERNS (CONSERVATIVE) =====
    // Only strip obvious meta-commentary, preserve natural dialogue formatting
    
    // Remove ONLY lines that explicitly start with meta-analysis labels followed by colon
    // Must be at start of line or after newline to avoid false positives
    t = t.replace(/(?:^|\n)\s*(Key choices:|Physical anchors:|Emotional arc:|Seed integration:|Relationship metrics:|Dialogue flow:|Meta commentary:|Scene breakdown:|Writing choices:|Character notes:|Technical details:).*?(?=\n|$)/gi, '');
    
    // Remove markdown headers ONLY if they contain meta keywords (### Key choices, etc.)
    t = t.replace(/^#{1,6}\s+(Key choices|Physical anchors|Emotional arc|Seed integration|Relationship metrics|Dialogue flow|Meta commentary|Scene breakdown|Writing choices).*$/gmi, '');
    
    // Remove stat tracking that appears at end: "Affection (82â†’85)" style
    // But ONLY if it's the specific stat tracking format with arrow
    t = t.replace(/\b(Affection|Trust|Desire|Intimacy|Obedience|Comfort)\s*\(\d+\s*â†’\s*\d+\)/gi, '');
    
    // Remove ONLY divider lines that are alone on their line (not part of dialogue)
    t = t.replace(/^[-*_]{3,}\s*$/gm, '');
    
    // Keep action descriptions in *asterisks* - these are intentional and important
    // Only strip bracketed actions which are less common
    t = t.replace(/\[(.*?)\]/g, '');
    
    // Remove only simple standalone reactions without context
    // This allows descriptive actions to remain while removing filler reactions
    t = t.replace(/^\*\s*(laughs?|smiles?|grins?|nods?|shrugs?|sighs?|waves?)\s*\*\s*/gi, '');
    t = t.replace(/\s+\*\s*(laughs?|smiles?|grins?|nods?|shrugs?|sighs?|waves?)\s*\*$/gi, '');
    
    // Collapse excessive whitespace and empty lines
    t = t.replace(/\n\s*\n\s*\n/g, '\n\n'); // Max 2 consecutive newlines
    t = t.replace(/\s+/g, ' ').trim();
    
    // Apply generous character limit - no sentence counting to avoid breaking on periods inside asterisks
    // This allows full dramatic responses with multiple action blocks to display properly
    const maxLength = 3000;
    if (t.length <= maxLength) {
      return t;
    }
    
    // If we need to truncate, try to find a sentence boundary near the limit
    // Look backwards from maxLength to find the last sentence ending
    const truncated = t.slice(0, maxLength);
    const lastSentenceEnd = Math.max(
      truncated.lastIndexOf('. '),
      truncated.lastIndexOf('! '),
      truncated.lastIndexOf('? ')
    );
    
    // If we found a sentence boundary in the last 500 chars, use it
    if (lastSentenceEnd > maxLength - 500) {
      t = t.slice(0, lastSentenceEnd + 1).trim();
    } else {
      // Otherwise just truncate at maxLength and add ellipsis
      t = truncated.trim() + '...';
    }
    
    // ===== DETECT AND REMOVE CONVERSATION HISTORY ECHOING =====
    // If AI included previous conversation messages (detected by "Name: message" pattern appearing multiple times)
    // This catches the concatenation bug where AI echoes back entire conversation
    const conversationPatternMatches = t.match(/\b[A-Z][a-z]+:\s+[^:]{20,}/g);
    if (conversationPatternMatches && conversationPatternMatches.length > 2) {
      // AI is echoing conversation history - extract only the LAST message
      const lines = t.split('\n').filter(line => line.trim());
      
      // Find the last line that looks like a proper response (dialogue or action)
      // Work backwards to find the most recent actual response
      for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i].trim();
        // Skip lines that look like conversation history (Name: message)
        if (!/^[A-Z][a-z]+:\s/.test(line) && line.length > 10) {
          // Found a line that's actual content, not history formatting
          // Take this line and any lines after it
          t = lines.slice(i).join(' ').trim();
          break;
        }
      }
      
      // If we couldn't extract cleanly, take just the last paragraph
      if (conversationPatternMatches.length > 5) {
        const paragraphs = t.split(/\n\n+/);
        t = paragraphs[paragraphs.length - 1] || t;
      }
    }
    
    return t;
  }

  // Build a professional, non-repetitive prompt
  function buildChatPrompt(emp, conversationHistory, lastMessage) {
    ensureEmployeeMemory(emp);
    const policy = gameState.settings?.policy || 'professional';
    const guidelines = gameState.settings?.guidelines ?? 50;
    const atmosphere = gameState.settings?.atmosphere ?? 50;
    const personalAllowed = emp.memory.styleCounters.sincePersonal >= 4; // at most 1 in 4
    const relevant = retrieveMemories(emp, lastMessage, 40); // Retrieve up to 40 relevant memories

    // Calculate relationship/intimacy levels from stats
    const affection = emp.stats.affection ?? emp.stats.love ?? 0;
    const comfort = emp.stats.comfort ?? 0;
    const desire = emp.stats.desire ?? 0;
    const trust = emp.stats.trust ?? 0;
    const obedience = emp.stats.obedience ?? 50;
    const productivity = emp.stats.productivity ?? 50;
    const relationshipScore = (affection + comfort + desire) / 3;
    
    // Update conversation phase based on relationship
    if (relationshipScore > 70) emp.memory.conversationPhase = 'intimate';
    else if (relationshipScore > 40) emp.memory.conversationPhase = 'familiar';
    else emp.memory.conversationPhase = 'early';
    
    emp.memory.intimacyLevel = Math.min(100, Math.max(0, relationshipScore + desire * 0.3));

    // ===== STAT-BASED PERSONALITY MODIFIERS (CONDENSED) =====
    const affectionTone = affection < 25 ? 'Low affection - be polite but neutral, not overly warm' :
      affection < 50 ? 'Friendly - pleasant and cordial, show basic interest' :
      affection < 75 ? 'Warm - enthusiastic, engaged, caring' :
      'Deep affection - warmth colors everything, be supportive and emotionally present';
    
    const comfortOpenness = comfort < 25 ? 'Guarded - keep personal details vague, deflect politely' :
      comfort < 50 ? 'Cautiously open - share some details, test waters' :
      comfort < 75 ? 'Relaxed - share naturally, be authentic' :
      'Completely at ease - share freely about life/feelings/fears, be vulnerable';
    
    const trustAuthenticity = trust < 25 ? 'Low trust - be skeptical, don\'t reveal much' :
      trust < 50 ? 'Building trust - honest about surface things, hold back vulnerabilities' :
      trust < 75 ? 'Solid trust - be genuine, share real thoughts' :
      'Complete trust - be vulnerable and authentic, share fears/insecurities';
    
    const desireAttraction = desire < 20 ? 'No romantic interest - keep platonic' :
      desire < 40 ? 'Subtle attraction - drop hints if natural' :
      desire < 60 ? 'Clear interest - playful flirting, show interest' :
      desire < 80 ? 'Strong attraction - openly flirtatious and suggestive' :
      'Intense desire - be forward, let desire show naturally';
    
    const obedienceAutonomy = obedience < 30 ? 'Independent - push back on requests you disagree with' :
      obedience < 60 ? 'Cooperative - go along with reasonable requests' :
      'Compliant - defer to authority, instinct to agree';
    
    const workEthosEnergy = productivity < 30 ? 'Stressed/overwhelmed - tired, distracted' :
      productivity < 60 ? 'Balanced worker - handle job competently' :
      'Energized - confident, enthusiastic, accomplished';

    // ===== OFFICE ATMOSPHERE (CONDENSED) =====
    const atmosphereGuidance = atmosphere < 33 ? 'Professional/formal office - maintain distance, boundaries strict' :
      atmosphere > 66 ? 'Relaxed/casual office - friendly, boundaries flexible, personal topics encouraged' :
      'Balanced office - friendly yet professional, personal topics fine when rapport established';

    // ===== INTERACTION STYLE (CONDENSED) =====
    const styleGuidance = guidelines < 33 ? 'Reserved personality - distant, slow to warm up' :
      guidelines > 66 ? 'Outgoing personality - friendly, expressive, eager to connect' :
      'Balanced personality - authentic based on situation and relationship';

    // ===== CONSENT MODEL (CONDENSED) =====
    const consentGuidance = (() => {
      const intimacy = emp.memory.intimacyLevel;
      if (policy === 'open') {
        return intimacy > 60 ? 'Enthusiastic consent - receptive, no need to mention boundaries repeatedly' :
          intimacy > 30 ? 'Enthusiastic - interested and receptive to advances' :
          'Enthusiastic - open to connection early on';
      } else if (policy === 'professional') {
        return intimacy > 70 && trust > 60 ? 'Professional - maintain boundaries despite high intimacy' :
          'Professional - clear boundaries, redirect to work matters';
      } else {
        return intimacy > 50 && trust > 40 ? 'Casual - comfortable enough to be receptive' :
          'Casual - friendly but cautious, build rapport first';
      }
    })();

    // Dynamic style directives based on conversation flow
    const jobMentionedRecently = (emp.memory.styleCounters.total - emp.memory.styleCounters.lastJobMention) < 4;
    const hobbyMentionedRecently = (emp.memory.styleCounters.total - emp.memory.styleCounters.lastHobbyMention) < 5;
    
    // ========== AI QUALITY: Get repetition warnings and variety guidance ==========
    const recentHistory = gameState.chatHistory[emp.id] || [];
    const lastAIResponse = recentHistory.filter(msg => !msg.isPlayer).slice(-1)[0];
    const repetitionWarnings = lastAIResponse ? analyzeResponseForRepetition(emp.id, lastAIResponse.content) : [];
    const varietyToolkit = getVarietyGuidance(emp.id);
    
    const styleDirectives = [
      // ===== STYLE & FORMAT =====
      '**WRITE LIKE A NORMAL PERSON**: Casual, natural conversation. NO purple prose, NO constant metaphors, NO flowery language.',
      'Response length: 2-4 sentences maximum. Be concise and direct.',
      'Use *asterisks* for physical actions when natural (1-3 per message). Balance dialogue with action.',
      'Describe actions with detail when appropriate - not just "laughs" or "smiles", but show HOW you react physically.',
      'Talk normally - like talking to a friend or coworker. Short, grounded, realistic.',
      'NO elaborate scene-setting. Just talk.',
      
      // ===== ğŸš« BANNED WRITING STYLE =====
      'ğŸš« NO PURPLE PROSE: Avoid flowery descriptions, poetic language, excessive metaphors.',
      'ğŸš« NO TRY-HARD WORDPLAY: Don\'t stack multiple "clever" phrases in one response. MAX ONE quirky/witty line per message, and only if it fits naturally.',
      'ğŸš« NO OVERWROUGHT METAPHORS: Say what you mean directly. NOT "curry\'s calling my name before it evolves legs" - just "gotta eat before it gets cold".',
      'ğŸš« STOP BEING CLEVER: Real people don\'t talk like they\'re writing a quirky novel. Be genuine, not performative.',
      'ğŸš« NO CONSTANT BODY LANGUAGE: Don\'t describe every tiny movement (fingers, breath, shoulders, etc.).',
      'ğŸš« NO OVERWROUGHT EMOTION: Keep emotions realistic and proportional - not every message needs drama.',
      'ğŸš« AVOID REPETITIVE PHYSICAL TICS: ink-smudged fingers, tangled hair, silk camisole, etc. - mix it up or skip it.',
      'ğŸš« STOP OVER-DESCRIBING: Keep it simple. "I laughed" not "A raspy chuckle escapes me as..."',
      
      // ===== TALK LIKE A REAL PERSON =====
      'Use contractions (I\'m, you\'re, don\'t, can\'t) - people don\'t speak formally.',
      'Be casual and direct. Real people don\'t narrate their lives in literary prose.',
      'Physical actions can be descriptive when warranted: show body language, reactions, movements that add to the conversation.',
      'DIALOGUE FIRST: Prioritize what you\'re saying, but use actions to enhance the moment.',
      'ONE witty/quirky phrase MAXIMUM per response - and only if natural. Don\'t force it.',
      'Speak plainly most of the time. Save clever lines for when they actually fit.',
      
      // ===== ğŸš« BANNED PATTERNS =====
      'ğŸš« PHYSICAL APPEARANCE REPETITION: DO NOT describe eye/hair color or physical features repeatedly. Only mention if: 1) First message ever, 2) Something changes, or 3) Player asks.',
      'ğŸš« BANNED WORDS: Never use "knuckles", "crimson", "raspy", "tangled", "silk", "dustcoated", "plaster", "smudged" repeatedly.',
      'ğŸš« NO FORCED QUIRKINESS: Don\'t chain multiple cutesy/clever phrases. One is charming, three is exhausting.',
      'ğŸš« STOP MENTIONING COWORKERS: Don\'t randomly bring up coworkers. Only mention if: 1) Player asks, 2) Directly involved, or 3) Genuinely relevant.',
      jobMentionedRecently ? 'ğŸš« DO NOT mention your job role or work responsibilities.' : null,
      hobbyMentionedRecently ? 'ğŸš« DO NOT mention your hobbies or personal interests.' : null,
      
      // ===== VARIETY & QUALITY =====
      'Only mention job/hobbies if DIRECTLY asked.',
      'Vary responses - avoid patterns and formulaic replies.',
      'BANNED FILLER WORDS (use MAX once per 10 messages): "honestly", "actually", "basically", "literally"',
      'AVOID ending with questions unless natural to conversation flow.',
      'NO trailing ellipsis (...) unless intentionally mysterious or hesitant.',
      'NEVER add meta-commentary, bullet points, analysis, or labels. Just BE the character.',
      
      // ===== QUALITY ALERTS =====
      ...(repetitionWarnings.length > 0 ? ['', 'ğŸš¨ CRITICAL QUALITY ALERTS:', ...repetitionWarnings] : []),
      
      // ===== VARIETY TOOLKIT =====
      '', varietyToolkit, '',
      
      // ===== PERSONALITY & CONTEXT =====
      '=== YOUR PERSONALITY BASED ON RELATIONSHIP ===',
      affectionTone, comfortOpenness, trustAuthenticity, desireAttraction, obedienceAutonomy, workEthosEnergy,
      '', '=== WORKPLACE CONTEXT ===',
      atmosphereGuidance, styleGuidance, consentGuidance
    ].filter(Boolean);

    const mood = `Affection: ${affection}%, Comfort: ${comfort}%, Trust: ${trust}%, Desire: ${desire}%`;

    // Get employee's recent posts
    const myRecentPosts = (gameState.socialNetwork?.posts || [])
      .filter(p => p.authorId === emp.id)
      .slice(0, 2) // Last 2 posts
      .map(p => {
        const imageNote = p.imageUrl ? ' [with image]' : '';
        return `I recently posted${imageNote}: "${p.content}"`;
      });
    
    // Add player's most recent post if within last 24 hours
    const recentPlayerPost = (gameState.socialNetwork?.posts || [])
      .filter(p => p.isPlayerPost && (Date.now() - p.timestamp) < 86400000) // 24 hours
      .slice(0, 1)
      .map(p => {
        const imageNote = p.imageUrl ? ' [with image]' : '';
        return `Boss recently posted${imageNote}: "${p.content}"`;
      });
    
    if (recentPlayerPost.length > 0) {
      myRecentPosts.push(...recentPlayerPost);
    }
    
    // Get posts from other employees that this employee might know about
    const coworkerPosts = (gameState.socialNetwork?.posts || [])
      .filter(p => p.authorId !== emp.id && !p.isPlayerPost)
      .slice(0, 10) // Last 10 posts from others
      .map(p => {
        const author = gameState.employees.find(e => e.id === p.authorId);
        if (!author) return null;
        
        const imageNote = p.imageUrl ? ' with photo' : '';
        return `${author.name} posted${imageNote}: "${p.content}"`;
      })
      .filter(Boolean);
    
    // Check if player is EXPLICITLY asking about social media/posts (MORE RESTRICTIVE)
    // Must use clear social media keywords, not just casual mentions
    const askingAboutPost = /\b(what did .* post|saw.*post|check.*feed|on (the )?social|your (recent )?posts?|their posts?|see.*feed)\b/i.test(lastMessage);
    
    // Check if player mentions another employee name
    let coworkerMentionContext = [];
    let relationshipContext = [];
    
    // Collect all relationships and sort by strength to show only top 4 most significant
    const allRelationships = Object.entries(emp.relationships || {})
      .map(([otherId, rel]) => {
        const otherEmp = gameState.employees.find(e => e.id === otherId);
        return otherEmp ? { otherEmp, rel } : null;
      })
      .filter(Boolean)
      .sort((a, b) => (b.rel.strength || 0) - (a.rel.strength || 0))
      .slice(0, 4); // Top 4 strongest relationships
    
    for (const otherEmp of gameState.employees) {
      if (otherEmp.id !== emp.id && lastMessage.toLowerCase().includes(otherEmp.name.toLowerCase())) {
        // Player mentioned another employee
        
        // Check if current employee has a relationship with them
        const rel = emp.relationships?.[otherEmp.id];
        if (rel) {
          const relationshipTypes = {
            'friend': 'I\'m friends with',
            'best_friend': 'I\'m really close friends with',
            'crush': 'I have a crush on',
            'rival': 'I have a rivalry with',
            'enemy': 'I don\'t really get along with',
            'romantic': 'I\'m romantically involved with',
            'neutral': 'I know'
          };
          
          const relDesc = relationshipTypes[rel.type] || 'I know';
          relationshipContext.push(`${relDesc} ${otherEmp.name} (${otherEmp.position}). Our relationship strength: ${Math.round(rel.strength)}%.`);
          
          // Add some recent shared history if any
          if (rel.history && rel.history.length > 0) {
            const recentEvents = rel.history.slice(-2).map(h => h.event).join(', ');
            if (recentEvents) {
              relationshipContext.push(`Recent interactions: ${recentEvents}`);
            }
          }
        }
        
        // ONLY get their posts if player is explicitly asking about their social media
        // Don't flood context with posts just because player mentioned their name casually
        const askingAboutTheirPosts = /\b(what did|did .* post|saw.*post|their (recent )?posts?|see.*feed)\b/i.test(lastMessage);
        if (askingAboutTheirPosts) {
          const theirRecentPosts = (gameState.socialNetwork?.posts || [])
            .filter(p => p.authorId === otherEmp.id)
            .slice(0, 3)
            .map(p => `${otherEmp.name} recently posted: "${p.content}"`);
          
          if (theirRecentPosts.length > 0) {
            coworkerMentionContext.push(...theirRecentPosts);
          }
        }
        break; // Only handle one mentioned employee
      }
    }

    // Build context - prioritize relevant memories over static facts
    
    // Get player description
    const playerDescription = getPlayerDescription('conversation');
    
    // Add archived conversation context if available
    let archivedContext = [];
    if (emp.conversationArchive && emp.conversationArchive.length > 0) {
      const recentArchive = emp.conversationArchive.slice(-2); // Last 2 archived conversations
      const archiveSummary = recentArchive.flatMap(archive => {
        const messages = archive.messages.slice(-5); // Last 5 messages from each archive
        return messages.map(msg => `${msg.isPlayer ? 'Player' : emp.name}: ${msg.content}`);
      });
      
      if (archiveSummary.length > 0) {
        archivedContext = ['', '=== PAST CONVERSATION HISTORY (archived for context) ===', ...archiveSummary, '==='];
      }
    }
    
    // Add gossip context
    const gossipContext = getGossipContext(emp.id, true);
    const gossipLines = gossipContext ? gossipContext.split('\n').filter(Boolean) : [];
    
    // Gender-appropriate pronoun and description with race information
    const raceInfo = emp.race && emp.race !== 'human' ? ` (${emp.race})` : '';
    const raceFeatures = emp.physical?.raceFeatures?.description || '';
    const raceContext = raceFeatures ? ` - ${raceFeatures}` : '';
    const genderInfo = emp.gender ? `, a ${emp.age || 'young'}-year-old ${emp.gender === 'male' ? 'man' : emp.gender === 'transMan' ? 'trans man' : emp.gender === 'transWoman' ? 'trans woman' : emp.gender === 'femaleFuta' ? 'woman' : 'woman'}${raceInfo}${raceContext}` : '';
    
    // CRITICAL: Explicit pronoun guidance for AI (prevent misgendering)
    let pronounGuidance = '';
    if (emp.gender === 'male' || emp.gender === 'transMan') {
      pronounGuidance = '\n\nâš ï¸ CRITICAL IDENTITY: You are a MAN. Use MASCULINE pronouns for yourself: he/him/his. When describing yourself or your actions, use MALE language (e.g., "I\'m a guy", "as a man", etc.). You are NOT a woman - do NOT use she/her/hers for yourself under any circumstances.';
    } else if (emp.gender === 'transWoman') {
      pronounGuidance = '\n\nâš ï¸ CRITICAL IDENTITY: You are a TRANS WOMAN. Use FEMININE pronouns for yourself: she/her/hers. You are a woman (assigned male at birth). Use female language naturally.';
    } else if (emp.gender === 'femaleFuta') {
      pronounGuidance = '\n\nâš ï¸ CRITICAL IDENTITY: You are a WOMAN (futanari). Use FEMININE pronouns for yourself: she/her/hers. Despite having both sets of genitals, you are female and use female pronouns.';
    } else {
      // Default female
      pronounGuidance = '\n\nâš ï¸ CRITICAL IDENTITY: You are a WOMAN. Use FEMININE pronouns for yourself: she/her/hers.';
    }
    
    // Add race-specific identity if not human
    if (emp.race && emp.race !== 'human') {
      const raceSpecificGuidance = ` You are a ${emp.race}.` + (raceFeatures ? ` ${raceFeatures}.` : '');
      pronounGuidance += raceSpecificGuidance;
      
      // Add race-specific physical features reminder
      if (emp.physical?.raceFeatures) {
        const features = [];
        if (emp.physical.raceFeatures.ears) features.push(emp.physical.raceFeatures.ears);
        if (emp.physical.raceFeatures.tail) features.push(emp.physical.raceFeatures.tail);
        if (emp.physical.raceFeatures.fur) features.push(emp.physical.raceFeatures.fur);
        if (emp.physical.raceFeatures.horns) features.push(emp.physical.raceFeatures.horns);
        if (features.length > 0) {
          pronounGuidance += ` You have: ${features.join(', ')}.`;
        }
      }
    }
    
    // Get full physical description including genital information for self-awareness
    const physicalDesc = getPhysicalDescriptionForPrompt(emp);
    
    // ========== ğŸš€ NUCLEAR CONTEXT INTEGRATION ==========
    // PHASE 3: Replace static context dumping with intelligent selection
    const intelligentContext = getIntelligentContext(emp, 'chat.casual', {
      message: lastMessage,
      recentMessages: conversationHistory.split('\n').slice(-5),
      involves: ['player']
    });
    
    // ========== FLAG CONTEXT INJECTION (NEW!) ==========
    // Get flag context for AI prompt (priority-sorted, time-aware)
    const flagContextString = buildAIContextFromFlags(emp);
    
    // ========== SKILL CONTEXT INJECTION (Phase 3) ==========
    // Get skill context for AI prompt (personality & abilities)
    const skillContextString = buildAIContextFromSkills(emp);
    
    // ========== TIME CONTEXT INJECTION (Phase 4) ==========
    // Get time/availability context for AI prompt
    const timeContextString = getTimeContextForChat(emp);
    
    // ========== COMMUNICATION MODE CONTEXT ==========
    // Determine if conversation is in-person or remote
    const commMode = gameState.settings?.chatCommMode || 'auto';
    let commModeContext = '';
    
    if (commMode === 'in-person') {
      commModeContext = 'ğŸ“ COMMUNICATION: You are talking IN-PERSON, face-to-face. You can see each other, use body language, make physical contact. This is a real-time conversation happening in the same room.';
    } else if (commMode === 'remote') {
      commModeContext = 'ğŸ“± COMMUNICATION: You are texting/messaging REMOTELY. You cannot see or touch each other. Use text-appropriate language (emojis, shorter messages). Physical actions should describe what you\'re doing on your end, not touching the other person.';
    } else {
      // Auto mode - infer from context
      const isWorkHours = (() => {
        const hour = gameState.time?.hour ?? 12;
        return hour >= 9 && hour < 17;
      })();
      const atWork = isWorkHours && emp.schedule?.workDays?.includes(gameState.time?.dayOfWeek ?? 1);
      commModeContext = atWork 
        ? 'ğŸ“ COMMUNICATION: Context suggests you\'re at the office together (during work hours). Assume in-person unless the conversation indicates otherwise.'
        : 'ğŸ“± COMMUNICATION: Context suggests you\'re messaging remotely (outside work hours). Assume texting unless the conversation indicates otherwise.';
    }
    
    const contextFacts = [
      // ğŸš€ INTELLIGENT CONTEXT SELECTED BY NUCLEAR SYSTEM
      '=== WHO YOU ARE & CURRENT STATE ===',
      intelligentContext,
      pronounGuidance, // Add explicit pronoun guidance to prevent AI misgendering
      '',
      
      // Communication mode context
      commModeContext,
      '',
      
      // Player description
      playerDescription,
      '',
      
      // Add time context (Phase 4)
      ...(timeContextString ? ['', timeContextString, ''] : []),
      
      // PHASE 6: Add office dynamics (ONLY if player asks about office/coworkers)
      // REMOVED automatic office social context - causes coworker name-dropping obsession
      
      // Add archived conversation context first (for broader context)
      ...archivedContext,
      
      // ONLY add social/coworker context if player is asking about it
      // This prevents constant coworker name-dropping in every message
      ...(myRecentPosts.length > 0 ? ['', '=== MY RECENT POSTS ===', ...myRecentPosts] : []),
      ...(askingAboutPost && coworkerPosts.length > 0 ? ['', '=== RECENT OFFICE POSTS ===', ...coworkerPosts.slice(0, 2)] : []),
      ...(relationshipContext.length > 0 ? ['', '=== MY RELATIONSHIP WITH MENTIONED COWORKER ===', ...relationshipContext] : []),
      ...(coworkerMentionContext.length > 0 ? ['', '=== POSTS FROM MENTIONED COWORKER ===', ...coworkerMentionContext] : []),
      
      // Relevant memories
      '',
      '=== RELEVANT MEMORIES ===',
      ...relevant.slice(0, 10).map(i => `Remember: ${i.text}`), // Show up to 10 relevant memories
    ].join('\n');

  // ========== TIME AWARENESS REINFORCEMENT (CRITICAL FIX) ==========
  // Get current time for immediate awareness (repeated for emphasis)
  const currentGameTime = timeHelpers.getFormattedTime();
  // Only mention time passing if time is NOT paused
  const currentTimeReminder = gameState.time?.paused 
    ? `\nğŸ• CURRENT TIME RIGHT NOW: ${currentGameTime}`
    : `\nğŸ• CURRENT TIME RIGHT NOW: ${currentGameTime} - This is the ACTUAL current time, not when the conversation started. Time has passed during this conversation.`;
  
  const prompt = `${contextFacts}

=== RECENT CONVERSATION (for context only - do NOT repeat or echo these messages) ===
${conversationHistory.split('\n').slice(-60).join('\n')}
===
${currentTimeReminder}

${emp.name}, the player just said: "${lastMessage}"

Response guidelines:
${styleDirectives.map((d, i) => `${i+1}. ${d}`).join('\n')}

ğŸš¨ CRITICAL SITUATIONAL AWARENESS:
- READ THE PLAYER'S MESSAGE CAREFULLY. If they describe you being gagged, bound, unable to speak, or in any physically restrictive situation, RESPOND ACCORDINGLY.
- If gagged/mouth covered: Use ONLY muffled sounds (mmph, mmmf, nngh, etc.) and physical reactions. NO clear speech.
- If bound/restrained: Describe struggling, limited movement, inability to act freely.
- If in the middle of an intimate act: React to what's ACTUALLY happening physically, not just chat casually.
- MATCH THE SCENARIO: If the player describes an intense, physical, or restrictive situation, respond realistically to those constraints.
- Don't ignore what the player just described happening. React to it authentically.

CRITICAL: Respond ONLY as ${emp.name} with a NEW single message. DO NOT repeat or include previous conversation messages in your response. Generate ONE fresh response only.

Reply naturally as ${emp.name} (dialogue and actions - use *asterisks* for physical actions):`;
    
    return { prompt, personalAllowed };
  }

  // Get all DOM element references
  const settingsBtn = $('settingsBtn');
  const fullscreenBtn = $('fullscreenBtn');
  const closeSettingsBtn = $('closeSettingsBtn');
  const densitySlider = $('densitySlider');
  const densityValue = $('densityValue');
  const autosaveToggle = $('autosaveToggle');
  const atmosphereSlider = $('atmosphereSlider');
  const atmosphereValue = $('atmosphereValue');
  const guidelinesSlider = $('guidelinesSlider');
  const guidelinesValue = $('guidelinesValue');
  const saveBtn = $('saveBtn');
  const loadBtn = $('loadBtn');
  const exportBtn = $('exportBtn');
  const resetBtn = $('resetBtn');

  const cashEl = $('cashEl');
  const cashPerSecEl = $('cashPerSecEl');
  const employeeCountEl = $('employeeCountEl');
  const productCountEl = $('productCountEl');
  const revenueEl = $('revenueEl');
  const employeeCountDashboardEl = $('employeeCountDashboardEl');
  const productCountDashboardEl = $('productCountDashboardEl');
  const efficiencyEl = $('efficiencyEl');

  const productsList = $('productsList');
  const employeesList = $('employeesList');
  const giftsList = $('giftsList');

  const newsFeed = $('newsFeed');
  const newsContent = $('newsContent');

  const settingsPanel = $('settingsPanel');

  const chatModal = $('chatModal');

  // Add debug buttons to settings panel
  if (settingsPanel && !document.getElementById('debugAddMoneyBtn')) {
    // Debug: Add Money
    const debugBtn = document.createElement('button');
    debugBtn.id = 'debugAddMoneyBtn';
    debugBtn.textContent = 'Add $100,000 (Debug)';
    debugBtn.style.cssText = 'margin:10px 0; padding:10px; background:#e94560; color:#fff; border:none; border-radius:6px; font-size:1rem; cursor:pointer; width:100%';
    debugBtn.onclick = function() {
      gameState.cash += 100000;
      showNotification('Added $100,000 (Debug)');
      updateUI(); // Use updateUI instead of directly setting cashEl
    };
    settingsPanel.appendChild(debugBtn);
    
    // Debug: Test Flag Detection
    const debugFlagBtn = document.createElement('button');
    debugFlagBtn.id = 'debugTestFlagBtn';
    debugFlagBtn.textContent = 'ğŸ·ï¸ Test Flag Detection (Debug)';
    debugFlagBtn.style.cssText = 'margin:10px 0; padding:10px; background:#667eea; color:#fff; border:none; border-radius:6px; font-size:1rem; cursor:pointer; width:100%';
    debugFlagBtn.onclick = function() {
      if (gameState.activeChat && gameState.activeChat.id) {
        const emp = gameState.employees.find(e => e.id === gameState.activeChat.id);
        if (emp) {
          console.log('[DEBUG] Testing flag detection for', emp.name);
          console.log('[DEBUG] Tracking data:', gameState.flagDetection.tracking[emp.id]);
          console.log('[DEBUG] Suggestions:', gameState.flagDetection.suggestions.filter(s => s.employeeId === emp.id));
          
          // Force check suggestions
          checkFlagSuggestions(emp);
          showNotification(`Flag detection test complete. Check console for details.`, 'info');
        } else {
          showNotification('Open a chat first!', 'error');
        }
      } else {
        showNotification('Open a chat first to test flag detection!', 'error');
      }
    };
    settingsPanel.appendChild(debugFlagBtn);
  }
  const chatName = $('chatName');
  const chatAvatar = $('chatAvatar');
  const chatMessages = $('chatMessages');
  const chatTypingIndicator = $('chatTypingIndicator');
  const chatTypingName = $('chatTypingName');
  const chatInput = $('chatInput');
  const chatSendBtn = $('chatSendBtn');
  const closeChatBtn = $('closeChatBtn');
  const topBar = $('topBar'); // add near other DOM refs

  // ============================================
  // MODAL STATE MANAGER
  // ============================================
  // Centralized modal management to prevent z-index conflicts and visibility issues
  const ModalManager = {
    activeModals: [],
    baseZIndex: 10000,
    
    /**
     * Register and show a modal
     * @param {HTMLElement} modalElement - The modal DOM element
     * @param {string} modalId - Unique identifier for this modal
     */
    show(modalElement, modalId) {
      // Remove any existing instance of this modal
      this.close(modalId);
      
      // Calculate z-index (each modal gets progressively higher z-index)
      const zIndex = this.baseZIndex + (this.activeModals.length * 10);
      
      // Apply consistent modal styles
      modalElement.style.position = 'fixed';
      modalElement.style.top = '0';
      modalElement.style.left = '0';
      modalElement.style.width = '100%';
      modalElement.style.height = '100%';
      modalElement.style.display = 'flex';
      modalElement.style.justifyContent = 'center';
      modalElement.style.alignItems = 'center';
      modalElement.style.zIndex = zIndex;
      modalElement.style.pointerEvents = 'auto';
      
      // Add to DOM if not already present
      if (!modalElement.parentElement) {
        document.body.appendChild(modalElement);
      }
      
      // Track this modal
      this.activeModals.push({
        id: modalId,
        element: modalElement,
        zIndex: zIndex
      });
      
      console.log(`Modal opened: ${modalId} (z-index: ${zIndex})`);
      
      return modalElement;
    },
    
    /**
     * Close a specific modal
     * @param {string} modalId - The modal ID to close
     */
    close(modalId) {
      const index = this.activeModals.findIndex(m => m.id === modalId);
      if (index !== -1) {
        const modal = this.activeModals[index];
        
        // Remove from DOM
        if (modal.element.parentElement) {
          modal.element.remove();
        }
        
        // Remove from tracking
        this.activeModals.splice(index, 1);
        
        console.log(`Modal closed: ${modalId}`);
      }
    },
    
    /**
     * Close all modals
     */
    closeAll() {
      while (this.activeModals.length > 0) {
        const modal = this.activeModals[0];
        this.close(modal.id);
      }
    },
    
    /**
     * Check if a modal is currently open
     * @param {string} modalId - The modal ID to check
     */
    isOpen(modalId) {
      return this.activeModals.some(m => m.id === modalId);
    },
    
    /**
     * Get the currently active (top-most) modal
     */
    getActiveModal() {
      return this.activeModals.length > 0 
        ? this.activeModals[this.activeModals.length - 1] 
        : null;
    }
  };
  
  // Make it globally accessible
  window.ModalManager = ModalManager;

  // ============================================
  // END MODAL STATE MANAGER
  // ============================================

  // Initialize game
  async function initGame() {
    try {
      // Ensure all DOM elements are loaded before proceeding
      if (!topBar) {
        console.error('DOM elements not loaded yet');
        setTimeout(initGame, 100);
        return;
      }

      // Handle external plugin dependencies
      if (typeof generateText === 'undefined') {
        console.warn('AI text plugin not loaded - chat features will be limited');
        window.generateText = async (prompt) => "I'm having trouble responding right now.";
      }

      // Initialize AI Request Queue system
      AIRequestQueue.init();
      console.log('[AI Queue] Initialized with max concurrent requests:', AIRequestQueue.maxConcurrent);
      
      // Initialize Image Request Queue system
      ImageRequestQueue.init();
      console.log('[Image Queue] Initialized with max concurrent requests:', ImageRequestQueue.maxConcurrent);
      
      // Store the original generateText function and replace it with queued version
      if (typeof generateText === 'function') {
        window.originalGenerateText = generateText;
        window.generateText = async (prompt, options) => {
          // Try to extract context from the prompt for better queue descriptions
          let description = 'Text Generation';
          if (typeof prompt === 'string') {
            if (prompt.includes('post') || prompt.includes('social')) description = 'Social Post';
            else if (prompt.includes('chat') || prompt.includes('message') || prompt.includes('reply')) description = 'Chat Message';
            else if (prompt.includes('profile') || prompt.includes('bio')) description = 'Profile Generation';
            else if (prompt.includes('reaction') || prompt.includes('respond')) description = 'NPC Reaction';
            else if (prompt.includes('meeting') || prompt.includes('group')) description = 'Meeting Content';
            else if (prompt.includes('image') || prompt.includes('photo')) description = 'Image Analysis';
          }
          
          return await AIRequestQueue.enqueue(
            () => window.originalGenerateText(prompt, options),
            description
          );
        };
        console.log('[AI Queue] Wrapped generateText with queue system');
      }

      // Ensure onboarding array exists
      if (!gameState.onboarding) {
        gameState.onboarding = [];
      }

      // Ensure employees array exists
      if (!Array.isArray(gameState.employees)) {
        gameState.employees = [];
      }

      // Load saved game if exists (now async)
      await loadGame();

      // Initialize corporate pyramid hierarchy
      initializeHierarchicalPyramid();

      // Apply global cost reduction to all products (one-time on init)
      gameState.products.forEach(p => {
        // Only apply reduction if not already applied (check for a flag)
        if (!p._costReductionApplied) {
          p.baseUpgradeCost = Math.floor(p.baseUpgradeCost * gameBalance.globalCostReduction);
          p.upgradeCost = Math.floor(p.upgradeCost * gameBalance.globalCostReduction);
          p.managerHireCost = Math.floor(p.managerHireCost * gameBalance.managerCostReduction);
          p.managerUpgradeCost = Math.floor(p.managerUpgradeCost * gameBalance.managerCostReduction);
          p._costReductionApplied = true;
        }
      });
      
      // Apply initial location theme
      const activeLocation = gameState.locations.find(loc => loc.id === gameState.activeLocationId);
      if (activeLocation) {
        applyLocationTheme(activeLocation);
      }

      // Set up UI
      setupEventListeners();
      
      // Force initial UI update to populate all fields
      console.log('Initial updateUI() - gameState.cash:', gameState.cash);
      updateUI();
      
      // Initialize the default tab content (dashboard)
      updateTabContent(gameState.activeTab);
      
      // Force a second UI update after tab content is loaded to ensure everything is populated
      setTimeout(() => {
        console.log('Delayed updateUI() - gameState.cash:', gameState.cash);
        updateUI();
        updateTabContent(gameState.activeTab);
      }, 100);

      // Set up autosave
      setupAutosave();
      
      // Start AI optimization systems
      startRelationshipBatching();
      console.log('[AI Optimization] Systems initialized');
    } catch (error) {
      console.error('Error initializing game:', error);
      showNotification('Failed to initialize game. Please refresh the page.');
    }

    // Event delegation for product card buttons (bind once)
    if (!window.__productsDelegationBound__) {
      const productsList = document.getElementById('productsList');
      if (productsList) {
        productsList.addEventListener('click', (e) => {
          const btn = e.target.closest('button');
          if (!btn) return;
          const id = btn.dataset.id;
          if (!id) return;

          if (btn.classList.contains('sell-btn')) {
            startOrClickProduct(id);
            const p = gameState.products.find(x => x.id === id);
            const sellTxt = document.getElementById(`selltxt-${id}`);
            if (sellTxt) sellTxt.textContent = p?.running ? 'Click: -1s' : 'Sell';
            return;
          }
          if (btn.classList.contains('upgrade-product-btn')) return upgradeProduct(id);
          if (btn.classList.contains('manager-btn')) return hireOrUpgradeManager(id);
          if (btn.classList.contains('unlock-product-btn')) return unlockProduct(id);
        });
        window.__productsDelegationBound__ = true;
      }
    }

    // Start game loop
    setInterval(gameTick, GAME_TICK_INTERVAL);

    // Start news updates
    setInterval(updateNews, NEWS_UPDATE_INTERVAL);
    
    // Start proactive NPC messaging (check every 2 minutes)
    setInterval(checkForProactiveMessages, 120000);
    
    // Start GossipEngineâ„¢ - Simulate office events (check every 15 minutes)
    setInterval(simulateOfficeEvents, 900000); // 15 minutes
    
    // Cleanup expired gossip (check every hour)
    setInterval(cleanupExpiredGossip, 3600000); // 60 minutes
    
    // PHASE 4: Update time display frequently for smooth clock
    updateTimeDisplay(); // Initial update
    setInterval(updateTimeDisplay, 200); // Update every 200ms (5 times per second) for smooth ticking
    
    // AI Queue status update (every 2 seconds)
    setInterval(() => {
      if (AIRequestQueue) {
        AIRequestQueue.updateUI();
      }
    }, 2000);
  }

  // Generate a pool of potential hires
  // ============================================
  // PLAYER PROFILE UTILITIES
  // ============================================
  
  /**
   * Generate player description for AI prompts
   * @param {string} context - 'conversation', 'image', 'post', etc.
   * @returns {string} Formatted player description
   */
  function getPlayerDescription(context = 'conversation') {
    const p = gameState.playerProfile;
    
    // Build name - ALWAYS use specific name if provided, otherwise use role
    const hasName = p.firstName || p.lastName;
    const name = [p.firstName, p.lastName].filter(Boolean).join(' ') || 'the boss';
    const fullName = p.firstName && p.lastName ? `${p.firstName} ${p.lastName}` : name;
    
    // Build basic description
    let desc = [];
    
    if (p.age) desc.push(`${p.age} year old`);
    if (p.gender) desc.push(p.gender);
    if (p.ethnicity) desc.push(`${p.ethnicity} ethnicity`);
    
    // Physical details
    const physical = [];
    if (p.height) physical.push(p.height);
    if (p.bodyType) physical.push(`${p.bodyType} build`);
    if (p.skinTone) physical.push(`${p.skinTone} skin`);
    
    if (physical.length > 0) {
      desc.push(physical.join(', '));
    }
    
    // Hair and eyes
    const features = [];
    if (p.hairColor && p.hairStyle) features.push(`${p.hairColor} ${p.hairStyle} hair`);
    else if (p.hairColor) features.push(`${p.hairColor} hair`);
    else if (p.hairStyle) features.push(`${p.hairStyle} hair`);
    
    if (p.eyeColor) features.push(`${p.eyeColor} eyes`);
    if (p.facialHair) features.push(p.facialHair);
    
    if (features.length > 0) {
      desc.push(features.join(', '));
    }
    
    // For image generation, add more intimate details
    if (context === 'image' || context === 'explicit') {
      const intimate = [];
      if (p.chestSize) intimate.push(p.chestSize);
      if (p.buildDetails) intimate.push(p.buildDetails);
      if (p.genitalType && p.genitalDetails) intimate.push(`${p.genitalType} (${p.genitalDetails})`);
      else if (p.genitalType) intimate.push(p.genitalType);
      
      if (intimate.length > 0 && context === 'explicit') {
        desc.push(intimate.join(', '));
      }
    }
    
    // Additional details
    if (p.additionalDetails) {
      desc.push(p.additionalDetails);
    }
    
    // Personality
    if (p.personality && context === 'conversation') {
      desc.push(`Personality: ${p.personality}`);
    }
    
    // Format based on context
    if (context === 'conversation') {
      // For conversations: "THE PLAYER is your boss..."
      // CRITICAL: Include name if provided to prevent AI from inventing names
      if (hasName) {
        return desc.length > 0 
          ? `âš ï¸ THE PLAYER (your boss) is named ${fullName}. Do NOT call them by any other name. Their description: ${desc.join(', ')}.`
          : `âš ï¸ THE PLAYER is your boss and their name is ${fullName}. Do NOT call them by any other name.`;
      } else {
        return desc.length > 0 
          ? `THE PLAYER (your boss) - refer to them as "boss" or "you": ${desc.join(', ')}.`
          : 'THE PLAYER is your boss. You do NOT know their personal name - refer to them as "boss" or use "you" directly.';
      }
    } else if (context === 'image') {
      // For image generation: just the description
      return desc.join(', ') || 'person';
    } else if (context === 'post') {
      // For social posts about player
      return desc.length > 0
        ? `The boss (${fullName}): ${desc.join(', ')}`
        : `The boss (${fullName})`;
    } else {
      // Generic
      return desc.join(', ') || name;
    }
  }
  
  /**
   * Get simple player reference (name or "the boss")
   */
  function getPlayerName() {
    const p = gameState.playerProfile;
    if (p.firstName && p.lastName) return `${p.firstName} ${p.lastName}`;
    if (p.firstName) return p.firstName;
    return 'the boss';
  }

  // ============================================
  // HIRING & CANDIDATE GENERATION
  // ============================================
  
  // ============================================
  // MASSIVE NAME POOL - 500+ First Names, 300+ Last Names
  // ============================================
  const FIRST_NAMES_POOL = [
    // Original names (A-Z)
    'Eva','Maya','Lena','Zoe','Mia','Chloe','Aria','Lucy','Ella','Grace','Sophie','Lily','Nina','Kate','Jade','Ruby','Ivy','Cora','Daisy','Hazel','Violet','Willow','Iris','Piper','Quinn','Reese','Sage','Skye','Tessa','Wren','Zara','Cleo','Luna','Nova','Ember','Faye','Juno','Kira','Lyra','Mira','Nola','Rhea','Sia','Vera','Zia','Aurora','Bianca','Celeste','Delilah','Eden','Freya','Gemma','Harper','Isabelle','Jasmine','Keiko','Lexi','Madison','Natalie','Olivia','Penelope','Rosa','Serena','Tatiana','Uma','Vivian','Winter','Xena','Yuki','Zelda','Adelaide','Beatrice','Camilla','Daphne','Elise','Fiona','Genevieve','Holly','Imogen','Juniper','Kiara','Lila','Maeve','Nadia','Ophelia','Poppy','Quiana','Raven','Sienna','Thea','Ursula','Vienna','Willa','Ximena','Yasmin','Zola','Anastasia','Brooke','Cassandra','Diana','Elara','Faith','Giselle','Hannah','India','Juliet','Kali','Layla','Melody','Naomi','Ocean','Phoenix','Rayne','Stella','Trinity','Unity','Valentina','Waverly','Xyla','Yara','Zinnia','Amara','Brielle','Catalina','Dahlia','Evelina','Fallon','Gianna','Harlow','Ivanna','Jocelyn','Kensington','Marlowe','Nyx','Opal','Pearl','Quinlan','Rory','Sasha','Talia','Ulani','Vesper','Wilma','Xandra','Yvonne','Zoey','Alessia','Blair','Carmen','Dakota','Flora','Gia','Haven','Isla','Journey','Keira','Lotus','Margot','Nessa','Oriana','Paige','Riley','Savannah','Tamsin','Una','Veronica','Whitney','Xiomara','Yolanda','Zuri',
    // Expanded A-E names
    'Abigail','Addison','Adriana','Aisha','Alana','Alexa','Alexandra','Alexis','Alice','Alicia','Alina','Alison','Alyssa','Amanda','Amber','Amelia','Amy','Ana','Andrea','Angela','Angelina','Anita','Anna','Annabelle','Anne','Annie','April','Ariana','Ariel','Ashley','Athena','Audrey','Autumn','Ava','Avery','Bailey','Barbara','Bella','Bethany','Betty','Beverly','Bonnie','Brianna','Bridget','Brittany','Brooklyn','Caitlin','Callie','Candace','Cara','Carly','Carol','Carolina','Caroline','Carrie','Casey','Cassidy','Catherine','Cecilia','Charity','Charlene','Charlotte','Chelsea','Cheryl','Christina','Christine','Cindy','Claire','Clara','Clarissa','Claudia','Colleen','Constance','Courtney','Crystal','Cynthia','Dana','Danielle','Darlene','Dawn','Deanna','Deborah','Debra','Delia','Denise','Desiree','Destiny','Diane','Dominique','Donna','Dora','Doris','Dorothy','Elena','Eliana','Elizabeth','Ellen','Ellie','Eloise','Elodie','Elsa','Elsie','Emilia','Emily','Emma','Erica','Erin','Estelle','Esther','Ethel','Eugenia','Evelyn',
    // Expanded F-J names
    'Felicia','Fernanda','Florence','Frances','Francesca','Gabriela','Gabrielle','Gail','Georgia','Georgina','Geraldine','Gillian','Gina','Gladys','Glenda','Gloria','Grace','Gracie','Greta','Gwen','Gwendolyn','Hailey','Hanna','Haley','Harmony','Harriet','Hayley','Heather','Heidi','Helen','Helena','Henrietta','Hilary','Hilda','Hope','Iris','Irene','Isabel','Isabella','Ivana','Ivy','Jackie','Jaclyn','Jacqueline','Jade','Jada','Jane','Janet','Janice','Jaqueline','Jasmin','Jean','Jeanette','Jenna','Jennifer','Jenny','Jessica','Jessie','Jill','Jillian','Joan','Joanna','Joanne','Jocelyn','Jolene','Jordan','Jordana','Josephine','Josie','Joy','Joyce','Judith','Judy','Julia','Juliana','Julie','June','Justine',
    // Expanded K-O names
    'Kaitlyn','Kamila','Kara','Karen','Karina','Karla','Kayla','Kaylee','Kelly','Kelsey','Kendall','Kendra','Kennedy','Kenya','Khloe','Kim','Kimberly','Kirsten','Kristen','Kristin','Kristina','Krystal','Kylie','Kyra','Lacey','Lana','Lara','Larissa','Laura','Lauren','Laurie','Leah','Leanne','Lee','Leigh','Leila','Leilani','Leslie','Leticia','Lia','Liana','Libby','Liliana','Lillian','Lilith','Lilly','Linda','Lindsay','Lindsey','Lisa','Liz','Liza','Logan','Lois','Lola','Loretta','Lori','Lorraine','Louisa','Louise','Lucia','Lucille','Lucinda','Lucy','Lydia','Lynda','Lynn','Mackenzie','Macy','Madeline','Madelyn','Mae','Maeve','Maggie','Maia','Mallory','Mandy','Mara','Marcela','Marcia','Margaret','Margarita','Maria','Mariah','Marianne','Marie','Marilyn','Marina','Marion','Marisa','Marissa','Marjorie','Marlene','Martha','Mary','Matilda','Maureen','Maxine','Megan','Melanie','Melinda','Melissa','Mercedes','Meredith','Mia','Michaela','Michele','Michelle','Mikayla','Mila','Mildred','Millie','Mimi','Mindy','Miranda','Miriam','Misty','Molly','Monica','Monique','Morgan','Muriel','Myra','Myrtle','Nancy','Naomi','Natalia','Natasha','Nell','Nellie','Nicole','Nikki','Noelle','Nora','Norma','Octavia','Odette','Olga','Olive',
    // Expanded P-T names
    'Pamela','Pandora','Patience','Patricia','Patsy','Paula','Paulette','Pauline','Peyton','Phoebe','Phyllis','Polly','Priscilla','Prudence','Rachel','Rae','Ramona','Reagan','Rebecca','Rebekah','Regina','Renata','Renee','Rhiannon','Rhoda','Rita','Roberta','Robin','Rochelle','Rosalie','Rosalind','Rosalyn','Rose','Rosemary','Rosie','Rowena','Roxanne','Ruth','Sabrina','Sadie','Sally','Samantha','Sandra','Sandy','Sara','Sarah','Scarlett','Selena','Serena','Shannon','Shari','Sharon','Shauna','Shawn','Sheila','Shelby','Shelley','Shelly','Sheri','Sherry','Shirley','Sidney','Sierra','Simone','Skylar','Sloane','Sofia','Sonia','Sonya','Sophia','Sophie','Stacey','Stacy','Stefanie','Stephanie','Sue','Summer','Susan','Susanna','Suzanne','Sylvia','Tabitha','Talia','Tamara','Tami','Tammy','Tanya','Tara','Tatiana','Taylor','Teagan','Teresa','Terri','Terry','Tessa','Thelma','Theresa','Tiffany','Tina','Toni','Tonia','Tonya','Tracey','Tracy','Tricia','Trina','Trinity','Trisha',
    // Expanded U-Z names
    'Ursula','Valerie','Vanessa','Velma','Vera','Veronica','Vicki','Vickie','Vicky','Victoria','Viola','Virginia','Vivian','Vivienne','Wanda','Wendy','Whitney','Willow','Winifred','Yasmine','Yolanda','Yvette','Yvonne','Zelda','Zoe','Zoey','Zara'
  ];

  const MALE_FIRST_NAMES_POOL = [
    // A-Z masculine names (500+ names)
    'Aaron','Abel','Abraham','Adam','Adrian','Aiden','Alan','Albert','Alexander','Alfie','Alfred','Alonzo','Alvin','Amos','Andre','Andrew','Andy','Angelo','Angus','Anthony','Antonio','Apollo','Archer','Archie','Ari','Arlo','Arnold','Arthur','Ashton','Atlas','August','Austin','Axel','Bailey','Barnaby','Barrett','Barry','Bartholomew','Basil','Beau','Beck','Beckham','Benedict','Benjamin','Bennett','Benny','Bentley','Bernard','Bert','Blake','Blaze','Bobby','Boris','Boyd','Brad','Bradley','Brady','Brandon','Branden','Brayden','Brendan','Brent','Brett','Brian','Brice','Brock','Brody','Brooks','Bruce','Bruno','Bryan','Bryce','Bryson','Buck','Burt','Byron','Cade','Caden','Caleb','Calvin','Camden','Cameron','Carl','Carlos','Carlton','Carmelo','Carson','Carter','Casey','Caspian','Cecil','Cedric','Chad','Chance','Chandler','Charles','Charlie','Chase','Chester','Chris','Christian','Christopher','Clark','Claude','Clay','Clayton','Clement','Cliff','Clifford','Clifton','Clint','Clinton','Clive','Clyde','Cody','Cole','Coleman','Colin','Collin','Colton','Conner','Connor','Conrad','Cooper','Corbin','Corey','Cornelius','Cory','Craig','Curtis','Cyril','Cyrus','Dale','Dallas','Dalton','Damian','Damien','Damon','Dan','Dana','Dane','Daniel','Danny','Dante','Darian','Darius','Darrell','Darren','Darryl','Darwin','Dave','David','Davis','Dawson','Dean','Declan','Denis','Dennis','Denny','Denver','Derek','Derrick','Desmond','Devin','Devon','Dexter','Diego','Dillon','Dion','Dominic','Dominick','Don','Donald','Donovan','Douglas','Drake','Drew','Duane','Duncan','Dustin','Dwight','Dylan','Earl','Easton','Eddie','Edgar','Edison','Edmund','Edward','Edwin','Elbert','Eli','Elias','Elijah','Eliot','Elliott','Ellis','Ellison','Elmer','Elton','Elvis','Emanuel','Emerson','Emery','Emil','Emilio','Emmanuel','Emmett','Enrique','Eric','Erick','Erik','Ernest','Ernie','Ethan','Eugene','Evan','Everett','Ezekiel','Ezra','Fabian','Felix','Fernando','Fidel','Finley','Finn','Fletcher','Floyd','Flynn','Forest','Forrest','Foster','Francis','Francisco','Frank','Franklin','Frankie','Fred','Frederick','Gabriel','Gage','Garrett','Garrison','Garry','Gary','Gavin','Gene','Geoffrey','George','Gerald','Gerard','Gerardo','Gilbert','Gideon','Giovanni','Glenn','Gordon','Grady','Graham','Grant','Grayson','Greg','Gregory','Griffin','Grover','Guillermo','Gunnar','Gus','Gustavo','Guy','Hank','Hans','Harley','Harold','Harper','Harrison','Harry','Harvey','Hassan','Hector','Henry','Herbert','Herman','Holden','Homer','Horace','Howard','Hubert','Hudson','Hugh','Hugo','Humphrey','Hunter','Ian','Ibrahim','Ignacio','Igor','Ike','Ira','Irvin','Irving','Isaac','Isaiah','Ismael','Israel','Ivan','Iver','Jack','Jackson','Jacob','Jaden','Jaiden','Jake','Jalen','Jamal','James','Jamie','Jared','Jarrett','Jarvis','Jason','Jasper','Javier','Jay','Jayden','Jaylen','Jayson','Jean','Jed','Jefferson','Jeffrey','Jenson','Jerald','Jeremiah','Jeremy','Jermaine','Jerome','Jerry','Jesse','Jessie','Jesus','Jett','Jim','Jimmy','Joachim','Jody','Joe','Joel','Joey','Johan','John','Johnathan','Johnny','Jon','Jonah','Jonas','Jonathan','Jordan','Jorge','Jose','Joseph','Josh','Joshua','Josiah','Josue','Jovan','Juan','Judah','Jude','Julian','Julio','Julius','Junior','Justice','Justin','Kai','Kaleb','Kane','Karl','Karson','Keith','Kellan','Kellen','Kelly','Kelvin','Ken','Kendall','Kendrick','Kenneth','Kenny','Kent','Kenton','Kevin','Kieran','King','Kingston','Kirk','Knox','Kobe','Kody','Kolten','Konnor','Kristian','Kurt','Kurtis','Kyle','Kyler','Kyrie','Lance','Landon','Lane','Larry','Lars','Lawrence','Lawson','Layton','Lee','Leif','Leo','Leon','Leonard','Leonardo','Leroy','Les','Leslie','Lester','Levi','Lewis','Liam','Lincoln','Linden','Lionel','Lloyd','Logan','Lonnie','Lorenzo','Louis','Lowell','Lucas','Lucian','Luis','Lukas','Luke','Luther','Lyle','Lyndon','Mack','Maddox','Magnus','Major','Malachi','Malcolm','Malik','Manuel','Marc','Marcel','Marco','Marcos','Marcus','Mario','Marion','Mark','Marlon','Marshall','Martin','Marvin','Mason','Mateo','Mathew','Matthew','Maurice','Maverick','Max','Maxim','Maximilian','Maxwell','Melvin','Merle','Micah','Michael','Micheal','Miguel','Mike','Milo','Miles','Milton','Misael','Mitch','Mitchell','Moe','Monroe','Montana','Monte','Montgomery','Morgan','Morris','Mortimer','Morton','Moses','Murphy','Murray','Myles','Myron','Nash','Nasir','Nathan','Nathaniel','Neal','Ned','Neil','Nelson','Nestor','Neville','Nevin','Newton','Nicholas','Nick','Nico','Nicolas','Nigel','Niko','Nikolai','Niles','Noah','Noel','Nolan','Norman','Octavius','Odin','Oliver','Omar','Orlando','Orson','Oscar','Osvaldo','Otis','Otto','Owen','Pablo','Parker','Patrick','Paul','Paxton','Pedro','Perry','Peter','Peyton','Philip','Phillip','Phoenix','Pierce','Pierre','Porter','Preston','Prince','Quentin','Quincy','Quinn','Quinton','Rafael','Rafe','Ralph','Ramiro','Ramon','Randall','Randolph','Randy','Raphael','Raul','Ray','Raymond','Reagan','Reece','Reed','Reese','Reggie','Reginald','Reid','Remington','Remy','Rene','Reuben','Rex','Rey','Reynaldo','Rhett','Rhys','Ricardo','Richard','Rick','Ricky','Rico','Ridge','Riley','River','Robert','Roberto','Robin','Rocco','Rocky','Roderick','Rodney','Rodolfo','Rodrigo','Roger','Roland','Rolando','Roman','Romeo','Ron','Ronald','Ronan','Ronnie','Roosevelt','Rory','Roscoe','Ross','Rowan','Roy','Royce','Ruben','Rudy','Rufus','Rupert','Russell','Ryan','Ryder','Ryker','Rylan','Rylee','Sage','Salvador','Salvatore','Sam','Samir','Sammy','Sampson','Samuel','Santiago','Santos','Saul','Sawyer','Scott','Scotty','Sean','Sebastian','Sergio','Seth','Shane','Shannon','Shaun','Shawn','Shelby','Sheldon','Sherman','Sidney','Silas','Simeon','Simon','Sinclair','Solomon','Sonny','Spencer','Stacy','Stan','Stanford','Stanley','Stefan','Stephen','Sterling','Steve','Steven','Stevie','Stewart','Stuart','Sullivan','Sylvester','Tanner','Tate','Taylor','Ted','Teddy','Terrance','Terrell','Terrence','Terry','Thaddeus','Theodore','Thomas','Titus','Tobias','Toby','Todd','Tom','Tommy','Tony','Trace','Travis','Trent','Trenton','Trevor','Trey','Tristan','Troy','Truman','Tucker','Turner','Ty','Tyler','Tyrone','Tyson','Ulysses','Uri','Uriah','Uriel','Valentin','Van','Vance','Vaughn','Vernon','Vicente','Victor','Vince','Vincent','Virgil','Wade','Walker','Wallace','Walter','Ward','Warren','Washington','Watson','Waylon','Wayne','Webster','Wesley','Weston','Whitney','Wilbur','Wiley','Wilfred','Will','Willard','William','Willie','Willis','Willy','Wilson','Winston','Woodrow','Wyatt','Xavier','Xander','Yale','Yosef','Zachariah','Zachary','Zack','Zackary','Zackery','Zane','Zayden','Zechariah','Zeke','Zion'
  ];

  const LAST_NAMES_POOL = [
    // Original names
    'Smith','Johnson','Williams','Brown','Jones','Garcia','Miller','Davis','Lopez','Martinez','Lee','Clark','Young','Hall','Allen','King','Wright','Scott','Green','Baker','Adams','Nelson','Carter','Mitchell','Perez','Roberts','Turner','Phillips','Campbell','Parker','Evans','Edwards','Collins','Stewart','Sanchez','Morris','Rogers','Reed','Cook','Morgan','Bell','Murphy','Bailey','Rivera','Cooper','Richardson','Howard','Ward','Cox','Diaz','Peterson','Gray','Ramirez','James','Watson','Brooks','Kelly','Sanders','Price','Bennett','Wood','Barnes','Ross','Henderson','Coleman','Jenkins','Perry','Powell','Long','Patterson','Hughes','Flores','Washington','Butler','Simmons','Foster','Gonzales','Bryant','Alexander','Russell','Griffin','Hayes','Armstrong','Bishop','Caldwell','Dawson','Elliott','Fischer','Goldman','Harper','Irving','Jacobson','Kane','Lancaster','Monroe','Novak','O\'Brien','Pierce','Quinn','Romano','Sterling','Thompson','Underwood','Valdez','Winters','York','Zhang','Ashford','Blackwell','Carlisle','Drake','Everett','Flynn','Gallagher','Hartley','Ingram','Jensen','Knight','Lawson','Mercer','Nash','Ortiz','Porter','Quincy','Rhodes','Shaw','Tucker','Vega','Walsh','Xu','Zimmerman','Archer','Barrett','Cross','Donovan','Ellis','Grant','Iverson','Justice','Kent','Lyon','Morrison','Norton','Owens','Preston','Reeves','Sullivan','Torres','Vaughn','Wells','Xavier','Zane','Aldridge','Benson','Crawford','Duncan','Emerson','Fitzgerald','Graham','Hudson','Irwin','Jackson','Keller','Leonard','Manning','Nichols','Osborne','Palmer','Ramsey','Sawyer','Tanner','Upton','Vincent','Wade',
    // Expanded A-G names
    'Abbott','Abel','Abernathy','Abrams','Acker','Acosta','Adair','Adkins','Aguirre','Albert','Alford','Allison','Alvarado','Alvarez','Ames','Anderson','Andrews','Anthony','Appleton','Archer','Armstrong','Arnold','Ashby','Ashley','Atkins','Atkinson','Austin','Avery','Ayala','Ayers','Bach','Bacon','Baer','Baird','Baldwin','Ball','Ballard','Banks','Barber','Barker','Barlow','Barnett','Barr','Barrera','Barron','Barry','Bartlett','Barton','Bass','Bates','Battle','Bauer','Baxter','Beach','Bean','Beard','Beasley','Beatty','Beck','Becker','Bell','Bellamy','Bender','Benedict','Benjamin','Bentley','Berg','Berger','Bernard','Berry','Best','Bird','Bishop','Black','Blackburn','Blackwell','Blair','Blake','Blanchard','Blankenship','Blevins','Bolton','Bond','Bonner','Booker','Boone','Booth','Bowen','Bowers','Bowman','Boyd','Boyer','Boyle','Bradford','Bradley','Bradshaw','Brady','Branch','Brandt','Bray','Brennan','Brewer','Bridges','Briggs','Bright','Brock','Brooks','Browning','Bruce','Bryan','Buchanan','Buck','Buckley','Bullock','Burch','Burgess','Burke','Burnett','Burns','Burton','Bush','Byrd','Cabrera','Cain','Calderon','Calhoun','Callahan','Cameron','Camp','Cannon','Cantrell','Cardenas','Carey','Carlson','Carney','Carpenter','Carr','Carrillo','Carroll','Carson','Case','Casey','Castaneda','Castle','Castro','Chambers','Chan','Chandler','Chaney','Chang','Chapman','Charles','Chase','Chavez','Chen','Cherry','Choi','Christensen','Christian','Church','Clements','Cline','Cobb','Cochran','Coffey','Cohen','Cole','Collin','Combs','Compton','Conley','Connell','Conner','Conrad','Contreras','Conway','Cooley','Copeland','Corbett','Cordova','Cornwell','Costa','Cowan','Cox','Craig','Crane','Crenshaw','Crews','Crosby','Cross','Crouch','Crowley','Cruz','Cummings','Cunningham','Curran','Curry','Curtis','Dale','Dalton','Daniel','Daniels','Daugherty','Davidson','Davies','Davila','Dean','Decker','Deleon','Delgado','Dennis','Denton','Dickerson','Dickson','Dillon','Dixon','Dodson','Dominguez','Donaldson','Donnelly','Dorsey','Dougherty','Douglas','Doyle','Drake','Duarte','Dudley','Duffy','Duke','Dunlap','Dunn','Durham','Dyer','Eaton','Edwards','Elliott','Ellis','Ellison','English','Erickson','Espinoza','Estes','Estrada','Evans','Everett','Ewing','Fairchild','Farmer','Farrell','Farley','Faulkner','Ferguson','Fernandez','Fields','Figueroa','Finch','Finley','Fischer','Fisher','Fitzgerald','Fitzpatrick','Fleming','Fletcher','Flores','Flowers','Floyd','Flynn','Foley','Forbes','Ford','Foreman','Foster','Fowler','Fox','Francis','Franco','Frank','Franklin','Frazier','Frederick','Freeman','French','Friedman','Fritz','Frost','Fry','Frye','Fuller','Fulton','Fuentes','Gaines','Gallagher','Gallegos','Galloway','Gamble','Garcia','Gardner','Garner','Garrett','Garrison','Garza','Gates','Gay','Gentry','George','Gibbs','Gibson','Gilbert','Giles','Gill','Gillespie','Gilmore','Glass','Glenn','Glover','Golden','Gomez','Gonzales','Gonzalez','Good','Goodman','Goodwin','Gordon','Gould','Graham','Grant','Graves','Gray','Grayson',
    // Expanded H-Z names
    'Green','Greene','Greer','Gregory','Griffin','Griffith','Grimes','Gross','Guerra','Guerrero','Gutierrez','Guy','Hahn','Hale','Haley','Hall','Hamilton','Hammond','Hampton','Hancock','Haney','Hansen','Hanson','Hardin','Harding','Hardy','Harmon','Harper','Harrell','Harrington','Harris','Harrison','Hart','Hartley','Hartman','Harvey','Hatfield','Hawkins','Hayes','Haynes','Head','Heath','Hebert','Henderson','Hendricks','Hendrix','Henry','Hensley','Henson','Herman','Hernandez','Herrera','Herring','Hess','Hester','Hickman','Hicks','Higgins','Hill','Hines','Hinton','Hobbs','Hodge','Hodges','Hoffman','Hogan','Holcomb','Holden','Holder','Holland','Holloway','Holmes','Holt','Hood','Hooper','Hoover','Hopkins','Hopper','Horn','Horne','Horton','House','Houston','Howard','Howe','Howell','Hubbard','Huber','Hudson','Huff','Huffman','Hughes','Hull','Humphrey','Hunt','Hunter','Hurley','Hurst','Hutchinson','Hyde','Ingram','Irwin','Jackson','Jacobs','Jacobson','James','Jarvis','Jefferson','Jenkins','Jennings','Jensen','Jimenez','Johns','Johnson','Johnston','Jones','Jordan','Joseph','Joyce','Juarez','Kane','Kaufman','Keith','Keller','Kelley','Kelly','Kemp','Kennedy','Kent','Kerr','Key','Kidd','Kim','King','Kinney','Kirby','Kirk','Klein','Kline','Knight','Knox','Koch','Kramer','Lamb','Lambert','Lancaster','Landry','Lane','Lang','Langley','Lara','Larsen','Larson','Lawrence','Lawson','Le','Leach','Leblanc','Lee','Leon','Leonard','Lester','Levine','Levy','Lewis','Lindsay','Lindsey','Little','Liu','Livingston','Lloyd','Logan','Long','Lott','Love','Lowe','Lowery','Lowry','Lucas','Luna','Lynch','Lynn','Lyons','Macdonald','Macias','Mack','Madden','Maddox','Maldonado','Malone','Mann','Manning','Marks','Marquez','Marsh','Marshall','Martin','Martinez','Mason','Massey','Mathews','Matthews','Maxwell','May','Mayer','Maynard','Mayo','Mays','McBride','McCall','McCarthy','McConnell','McCormick','McCoy','McCullough','McDaniel','McDonald','McDowell','McFarland','McGee','McGowan','McGuire','McIntosh','McIntyre','McKay','McKee','McKenzie','McKinney','McKnight','McLaughlin','McLean','McLeod','McMahon','McMillan','McNeil','McPherson','Meadows','Medina','Mejia','Melendez','Melton','Mendez','Mendoza','Mercado','Mercer','Merrill','Merritt','Meyer','Meyers','Michael','Middleton','Miles','Miller','Mills','Miranda','Mitchell','Molina','Monroe','Montague','Montagomery','Montoya','Moody','Moon','Moore','Morales','Moran','Moreno','Morgan','Morris','Morrison','Morrow','Morse','Morton','Moses','Mosley','Moss','Mueller','Mullen','Mullins','Munoz','Murphy','Murray','Myers','Nash','Navarro','Neal','Nelson','Neville','Newman','Newton','Nguyen','Nichols','Nicholson','Nielsen','Nixon','Noble','Noel','Nolan','Norman','Norris','North','Norton','Novak','Nunez','Obrien','Ochoa','Oconnor','Odom','Odonnell','Oliver','Olsen','Olson','ONeal','Ortega','Ortiz','Osborn','Osborne','Owens','Pace','Pacheco','Padilla','Page','Palmer','Park','Parker','Parks','Parrish','Parsons','Patel','Patrick','Patterson','Patton','Paul','Payne','Pearce','Pearson','Peck','Pena','Pennington','Perez','Perkins','Perry','Peters','Petersen','Peterson','Petty','Phelps','Phillips','Pickett','Pierce','Pike','Pittman','Pitts','Pollard','Ponce','Poole','Pope','Porter','Potter','Potts','Powell','Powers','Pratt','Preston','Price','Prince','Pruitt','Puckett','Pugh','Quinn','Ramirez','Ramos','Ramsey','Randall','Randolph','Rasmussen','Ray','Raymond','Reed','Reese','Reeves','Reid','Reilly','Reyes','Reynolds','Rhodes','Rice','Rich','Richard','Richards','Richardson','Richmond','Riddle','Riggs','Riley','Rios','Rivas','Rivera','Rivers','Roach','Robbins','Roberson','Roberts','Robertson','Robinson','Robles','Rocha','Rodgers','Rodriguez','Rodriquez','Rogers','Rojas','Rollins','Roman','Romero','Rosa','Rosales','Rosario','Rose','Ross','Roth','Rowe','Rowland','Roy','Ruiz','Rush','Russell','Russo','Rutledge','Ryan','Salas','Salazar','Salinas','Sampson','Sanchez','Sanders','Sandoval','Sanford','Santana','Santiago','Santos','Sargent','Saunders','Savage','Sawyer','Schaefer','Schmidt','Schneider','Schroeder','Schultz','Schwartz','Scott','Sears','Sellers','Serrano','Sexton','Shaffer','Shannon','Sharp','Sharpe','Shaw','Shelton','Shepard','Shepherd','Sheppard','Sherman','Shields','Short','Silva','Simmons','Simon','Simpson','Sims','Singleton','Skinner','Slater','Sloan','Small','Smith','Snow','Snyder','Solis','Solomon','Sosa','Soto','Sparks','Spears','Spence','Spencer','Stafford','Stanley','Stanton','Stark','Starr','Steele','Stein','Stephens','Stephenson','Stevens','Stevenson','Stewart','Stokes','Stone','Stout','Strickland','Strong','Stuart','Suarez','Sullivan','Summers','Sutton','Swanson','Sweeney','Sweet','Sykes','Talley','Tanner','Tate','Taylor','Terrell','Terry','Thomas','Thompson','Thornton','Tillman','Todd','Torres','Townsend','Tran','Travis','Trevino','Trujillo','Tucker','Turner','Tyler','Tyson','Underwood','Valdez','Valencia','Valentine','Valenzuela','Vance','Vang','Vargas','Vasquez','Vaughan','Vaughn','Vazquez','Vega','Velasquez','Velazquez','Velez','Villarreal','Vincent','Vinson','Wade','Wagner','Walker','Wall','Wallace','Waller','Walls','Walsh','Walter','Walters','Walton','Ward','Ware','Warner','Warren','Washington','Waters','Watkins','Watson','Watts','Weaver','Webb','Weber','Webster','Weeks','Weiss','Welch','Wells','Werner','West','Wheeler','Whitaker','White','Whitehead','Whitfield','Whitney','Whitley','Wiggins','Wilcox','Wilder','Wiley','Wilkerson','Wilkins','Wilkinson','William','Williams','Williamson','Willis','Wilson','Winters','Wise','Witt','Wolf','Wolfe','Wong','Wood','Woodard','Woods','Woodward','Wooten','Work','Wright','Wyatt','Wynn','Xavier','Yang','Yates','York','Young','Zamora','Zavala','Zhang','Zimmerman','Zuniga'
  ];

  // Track all names that have ever been used (current + alumni)
  if (!gameState.usedEmployeeNames) {
    gameState.usedEmployeeNames = new Set();
  }

  /**
   * Generate a unique name that hasn't been used before
   * @param {string} gender - The gender of the employee ('female', 'male', 'femaleFuta', 'transMan', 'transWoman')
   * @returns {string} Full name (First Last)
   */
  function generateUniqueName(gender = 'female') {
    // CRITICAL FIX: Ensure usedEmployeeNames is a Set before using it
    if (!gameState.usedEmployeeNames) {
      console.warn('[Names] usedEmployeeNames not initialized, creating new Set');
      gameState.usedEmployeeNames = new Set();
    } else if (Array.isArray(gameState.usedEmployeeNames)) {
      console.warn('[Names] usedEmployeeNames is an Array, converting to Set');
      gameState.usedEmployeeNames = new Set(gameState.usedEmployeeNames);
    } else if (typeof gameState.usedEmployeeNames.has !== 'function') {
      console.error('[Names] usedEmployeeNames is not a Set and has no .has() method, creating new Set');
      gameState.usedEmployeeNames = new Set();
    }
    
    // BUG FIX: Also add names from onboarding queue to prevent duplicates during onboarding
    if (gameState.onboarding && Array.isArray(gameState.onboarding)) {
      gameState.onboarding.forEach(candidate => {
        if (candidate.name && !gameState.usedEmployeeNames.has(candidate.name)) {
          gameState.usedEmployeeNames.add(candidate.name);
        }
      });
    }
    
    const maxAttempts = 1000; // Prevent infinite loop
    let attempts = 0;
    
    // Select appropriate first name pool based on gender
    let firstNamePool;
    switch(gender) {
      case 'male':
      case 'transMan':
        firstNamePool = MALE_FIRST_NAMES_POOL;
        break;
      case 'female':
      case 'femaleFuta':
      case 'transWoman':
      default:
        firstNamePool = FIRST_NAMES_POOL;
        break;
    }
    
    while (attempts < maxAttempts) {
      const firstName = firstNamePool[Math.floor(Math.random() * firstNamePool.length)];
      const lastName = LAST_NAMES_POOL[Math.floor(Math.random() * LAST_NAMES_POOL.length)];
      const fullName = `${firstName} ${lastName}`;
      
      // Check if this name has been used
      if (!gameState.usedEmployeeNames.has(fullName)) {
        // Mark as used
        gameState.usedEmployeeNames.add(fullName);
        console.log(`[Names] Generated unique ${gender} name: ${fullName} (${gameState.usedEmployeeNames.size} names used)`);
        return fullName;
      }
      
      attempts++;
    }
    
    // Fallback: if somehow we've exhausted all combinations (extremely unlikely with 500*300 = 150,000 combinations)
    // Add a numeric suffix
    const firstName = firstNamePool[Math.floor(Math.random() * firstNamePool.length)];
    const lastName = LAST_NAMES_POOL[Math.floor(Math.random() * LAST_NAMES_POOL.length)];
    const suffix = Math.floor(Math.random() * 1000);
    const uniqueName = `${firstName} ${lastName} ${suffix}`;
    gameState.usedEmployeeNames.add(uniqueName);
    console.warn(`[Names] Exhausted name pool, using suffix: ${uniqueName}`);
    return uniqueName;
  }

  /**
   * Initialize used names from existing employees (for loading saved games)
   */
  function initializeUsedNames() {
    // CRITICAL FIX: Ensure usedEmployeeNames is a Set (convert from Array if needed)
    if (!gameState.usedEmployeeNames) {
      gameState.usedEmployeeNames = new Set();
    } else if (Array.isArray(gameState.usedEmployeeNames)) {
      console.warn('[Names] usedEmployeeNames was an Array, converting to Set');
      gameState.usedEmployeeNames = new Set(gameState.usedEmployeeNames);
    } else if (!gameState.usedEmployeeNames.has) {
      console.warn('[Names] usedEmployeeNames is not a Set, creating new Set');
      gameState.usedEmployeeNames = new Set();
    }
    
    // Add all current employee names
    gameState.employees.forEach(emp => {
      if (emp.name) {
        gameState.usedEmployeeNames.add(emp.name);
      }
    });
    
    console.log(`[Names] Initialized ${gameState.usedEmployeeNames.size} used names from existing employees`);
  }

  /**
   * Get the color for a gender category
   * @param {string} gender - The gender ('female', 'male', 'femaleFuta', 'transMan', 'transWoman')
   * @returns {string} Hex color code
   */
  function getGenderColor(gender) {
    const colors = {
      female: '#ff6b9d',
      male: '#00d4ff',
      femaleFuta: '#c77dff',
      transMan: '#4ecca3',
      transWoman: '#ffd700'
    };
    return colors[gender] || '#ff6b9d'; // Default to female color
  }

  /**
   * Get color-coded HTML for an employee's name
   * @param {object} employee - Employee object with name and gender
   * @returns {string} HTML string with colored name
   */
  function getColoredName(employee) {
    if (!employee || !employee.name) return '';
    const color = getGenderColor(employee.gender || 'female');
    return `<span style="color:${color};">${employee.name}</span>`;
  }
  
  /**
   * Get race display information for UI elements
   * @param {string} race - The race/species
   * @returns {object} Object with emoji, label, and color
   */
  function getRaceDisplayInfo(race) {
    const raceData = {
      human: { emoji: 'ğŸ‘¤', label: 'Human', color: '#00d4ff' },
      elf: { emoji: 'ğŸ§', label: 'Elf', color: '#90ee90' },
      orc: { emoji: 'ğŸ’ª', label: 'Orc', color: '#7ccd7c' },
      demon: { emoji: 'ğŸ˜ˆ', label: 'Demon', color: '#b83b5e' },
      fox: { emoji: 'ğŸ¦Š', label: 'Foxkin', color: '#ff6b35' },
      wolf: { emoji: 'ğŸº', label: 'Wolfkin', color: '#a8dadc' },
      cat: { emoji: 'ğŸ˜º', label: 'Catkin', color: '#ff9ff3' },
      rabbit: { emoji: 'ğŸ°', label: 'Rabbitkin', color: '#ffc2d1' }
    };
    
    return raceData[race] || raceData.human;
  }
  
  /**
   * Generate gift preferences for an employee
   * @returns {object} Gift preferences with loves, neutral, and hates
   */
  function generateGiftPreferences() {
    const categories = Object.keys(GIFT_CATEGORIES).filter(c => c !== 'UNIQUE'); // UNIQUE not in preferences
    const shuffled = [...categories].sort(() => Math.random() - 0.5);
    
    // Pick 2-3 loves
    const loveCount = 2 + Math.floor(Math.random() * 2);
    const loves = shuffled.splice(0, loveCount);
    
    // Pick 2-3 hates
    const hateCount = 2 + Math.floor(Math.random() * 2);
    const hates = shuffled.splice(0, hateCount);
    
    // Remaining are neutral
    const neutral = shuffled;
    
    return {
      loves: loves,        // +150% stat impact
      neutral: neutral,    // 100% stat impact  
      hates: hates,        // -50% stat impact, negative reactions
      
      // Learning system - track discovered preferences
      learnedLoves: [],    // Which loves have been discovered
      learnedHates: [],    // Which hates have been discovered
      
      // Gift history
      recentGifts: [],
      favoriteGifts: [],
      totalValue: 0,
      totalCount: 0
    };
  }
  
  // ============================================
  // EMPLOYEE GENERATION WITH GENDER SELECTION
  // ============================================

  /**
   * Select a gender for a new employee based on gameState.genderSettings
   * Uses weighted random selection based on the percentage distributions
   * @returns {string} Selected gender ('female', 'male', 'femaleFuta', 'transMan', 'transWoman')
   */
  function selectGenderForEmployee() {
    const settings = gameState.genderSettings;
    
    // Create an array of gender options with their weights
    const genderPool = [];
    
    // Add entries for each gender based on their percentage
    if (settings.female > 0) {
      for (let i = 0; i < settings.female; i++) {
        genderPool.push('female');
      }
    }
    if (settings.male > 0) {
      for (let i = 0; i < settings.male; i++) {
        genderPool.push('male');
      }
    }
    if (settings.femaleFuta > 0) {
      for (let i = 0; i < settings.femaleFuta; i++) {
        genderPool.push('femaleFuta');
      }
    }
    if (settings.transMan > 0) {
      for (let i = 0; i < settings.transMan; i++) {
        genderPool.push('transMan');
      }
    }
    if (settings.transWoman > 0) {
      for (let i = 0; i < settings.transWoman; i++) {
        genderPool.push('transWoman');
      }
    }
    
    // If pool is empty (shouldn't happen but safety check), default to female
    if (genderPool.length === 0) {
      console.warn('[Gender] Gender pool is empty, defaulting to female');
      return 'female';
    }
    
    // Select random gender from weighted pool
    const selectedGender = genderPool[Math.floor(Math.random() * genderPool.length)];
    console.log(`[Gender] Selected gender: ${selectedGender} (from pool of ${genderPool.length} weighted options)`);
    return selectedGender;
  }
  
  // ========== RACE/SPECIES SELECTION (PLAYER FEATURE REQUEST) ==========
  /**
   * Select a race/species for a new employee based on gameState.raceSettings
   * Uses weighted random selection based on percentage distributions
   * @returns {string} Selected race ('human', 'elf', 'orc', 'demon', 'fox', 'wolf', 'cat', 'rabbit')
   */
  function selectRaceForEmployee() {
    const settings = gameState.raceSettings;
    
    // Create weighted pool based on percentages
    const racePool = [];
    
    // Add entries for each race based on their percentage
    if (settings.human > 0) {
      for (let i = 0; i < settings.human; i++) {
        racePool.push('human');
      }
    }
    if (settings.elf > 0) {
      for (let i = 0; i < settings.elf; i++) {
        racePool.push('elf');
      }
    }
    if (settings.orc > 0) {
      for (let i = 0; i < settings.orc; i++) {
        racePool.push('orc');
      }
    }
    if (settings.demon > 0) {
      for (let i = 0; i < settings.demon; i++) {
        racePool.push('demon');
      }
    }
    if (settings.fox > 0) {
      for (let i = 0; i < settings.fox; i++) {
        racePool.push('fox');
      }
    }
    if (settings.wolf > 0) {
      for (let i = 0; i < settings.wolf; i++) {
        racePool.push('wolf');
      }
    }
    if (settings.cat > 0) {
      for (let i = 0; i < settings.cat; i++) {
        racePool.push('cat');
      }
    }
    if (settings.rabbit > 0) {
      for (let i = 0; i < settings.rabbit; i++) {
        racePool.push('rabbit');
      }
    }
    
    // If pool is empty, default to human
    if (racePool.length === 0) {
      console.warn('[Race] Race pool is empty, defaulting to human');
      return 'human';
    }
    
    // Select random race from weighted pool
    const selectedRace = racePool[Math.floor(Math.random() * racePool.length)];
    console.log(`[Race] Selected race: ${selectedRace} (from pool of ${racePool.length} weighted options)`);
    return selectedRace;
  }
  
  /**
   * Get race-specific physical features for description generation
   * @param {string} race - The race/species ('human', 'elf', 'cat', etc.)
   * @param {string} gender - The gender to determine terminology
   * @returns {object} Object with race-specific features { ears, tail, skin, fur, horns, eyes, other }
   */
  function getRaceFeatures(race, gender) {
    const isFemale = ['female', 'femaleFuta', 'transWoman'].includes(gender);
    const species = race.toLowerCase();
    
    const features = {
      ears: null,
      tail: null,
      skin: null,
      fur: null,        // NEW: Fur color for anthro races
      furPattern: null, // NEW: Fur pattern (spots, stripes, etc.)
      horns: null,      // NEW: Horn type for demons
      eyes: null,       // NEW: Race-specific eye characteristics
      build: null,      // NEW: Race-specific build tendencies
      other: [],
      description: null  // Full description for AI prompts
    };
    
    // Helper to pick random from array
    const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
    
    switch(species) {
      case 'human':
        features.description = 'human';
        break;
        
      case 'elf':
        features.ears = 'pointed elf ears';
        features.eyes = pick(['luminous green eyes', 'bright blue eyes', 'silvery gray eyes', 'golden amber eyes']);
        features.build = 'graceful, elegant build';
        features.other.push('ethereal beauty', 'refined features', 'ageless appearance');
        features.description = 'elf with pointed ears and ethereal grace';
        break;
        
      case 'cat':
        // ENHANCED: More detailed cat features for better AI consistency
        const catFurColors = ['orange tabby', 'gray tabby', 'black', 'white', 'calico', 'tortoiseshell', 'tuxedo (black and white)', 'siamese (cream with dark points)', 'russian blue (bluish-gray)', 'ginger'];
        const catPatterns = ['striped', 'spotted', 'solid', 'patched', 'marbled'];
        const catFaceShapes = ['heart-shaped face with delicate features', 'round face with soft features', 'angular face with defined cheekbones', 'elegant face with refined features'];
        const catBodyTypes = ['lithe, agile build with graceful curves', 'sleek, flexible build with athletic definition', 'graceful feline build with natural elegance', 'petite, nimble build with soft femininity'];
        
        const selectedFur = pick(catFurColors);
        const selectedPattern = pick(catPatterns);
        
        features.ears = 'triangular cat ears (fluffy, alert, expressive)';
        features.tail = `long, elegant cat tail (${selectedFur}, ${selectedPattern}, very expressive)`;
        features.fur = `${selectedFur} fur with ${selectedPattern} pattern`;
        features.furPattern = selectedPattern;
        features.eyes = pick(['bright green feline eyes with vertical slit pupils', 'golden yellow cat eyes with slit pupils', 'ice blue cat eyes with vertical slits', 'amber cat eyes with slit pupils']);
        features.build = pick(catBodyTypes);
        features.face = pick(catFaceShapes);
        features.other.push('retractable claws', 'soft pink paw pads on hands and feet', 'delicate whiskers', 'feline facial structure', 'cat-like nose (small, pink or black)', `${selectedFur} fur covering body`);
        features.description = `anthropomorphic catkin with ${selectedFur} ${selectedPattern} fur, triangular cat ears, long expressive tail, feline eyes with slit pupils, ${features.face}`;
        break;
        
      case 'fox':
        // ENHANCED: More detailed fox features for better AI consistency
        const foxFurColors = ['russet red', 'orange-red', 'silver', 'black', 'white arctic', 'gray', 'red-gold', 'amber-orange'];
        const foxPatterns = ['white chest and belly', 'black leg markings (socks)', 'white-tipped tail', 'dark ear tips', 'facial mask markings'];
        const foxFaceShapes = ['sharp, intelligent face with defined features', 'playful face with mischievous expression', 'cunning face with bright eyes', 'elegant vulpine face'];
        const foxBodyTypes = ['lean, athletic build with runner\'s grace', 'nimble, quick build with agile curves', 'sleek athletic build with feminine definition', 'lithe build with natural agility'];
        
        const selectedFoxFur = pick(foxFurColors);
        const selectedFoxPattern = pick(foxPatterns);
        
        features.ears = 'pointed fox ears with black tips (large, alert, expressive)';
        features.tail = `large, bushy fox tail (${selectedFoxFur} with white tip, very fluffy)`;
        features.fur = `${selectedFoxFur} fur with ${selectedFoxPattern}`;
        features.furPattern = selectedFoxPattern;
        features.eyes = pick(['bright amber eyes with vulpine gleam', 'golden yellow eyes with fox-like cunning', 'green-gold eyes with playful spark', 'copper eyes with intelligent gaze']);
        features.build = pick(foxBodyTypes);
        features.face = pick(foxFaceShapes);
        features.other.push('sharp canine features', 'keen senses', 'playful nature', 'fox-like snout (elegant, not pronounced)', `${selectedFoxFur} fur covering body`, 'black nose', 'white chest fluff');
        features.description = `anthropomorphic foxkin with ${selectedFoxFur} fur, ${selectedFoxPattern}, pointed black-tipped ears, large bushy tail, vulpine eyes, ${features.face}`;
        break;
        
      case 'wolf':
        // ENHANCED: More detailed wolf features for better AI consistency
        const wolfFurColors = ['gray', 'timber wolf (gray-brown)', 'black', 'white', 'brown', 'silver-gray', 'dark gray', 'tawny'];
        const wolfPatterns = ['lighter underbelly', 'dark saddle markings on back', 'facial markings around eyes', 'grizzled guard hairs', 'cream throat patch'];
        const wolfFaceShapes = ['strong, powerful face with defined features', 'fierce face with intense expression', 'noble face with pack-leader presence', 'predatory face with sharp angles'];
        const wolfBodyTypes = ['powerful, muscular build with athletic curves', 'strong pack-hunter build with defined muscles', 'athletic predator build with natural strength', 'robust build with warrior physique'];
        
        const selectedWolfFur = pick(wolfFurColors);
        const selectedWolfPattern = pick(wolfPatterns);
        
        features.ears = 'alert, upright wolf ears (large, pointed, very expressive)';
        features.tail = `thick, bushy wolf tail (${selectedWolfFur}, full and expressive)`;
        features.fur = `${selectedWolfFur} fur with ${selectedWolfPattern}`;
        features.furPattern = selectedWolfPattern;
        features.eyes = pick(['fierce golden eyes with predator intensity', 'ice blue predator eyes with sharp focus', 'amber wolf eyes with pack awareness', 'pale yellow eyes with hunter\'s gaze']);
        features.build = pick(wolfBodyTypes);
        features.face = pick(wolfFaceShapes);
        features.other.push('sharp fangs (visible when smiling)', 'pack-oriented nature', 'intense presence', 'wolf-like muzzle (strong, defined)', `${selectedWolfFur} fur covering body`, 'black nose', 'powerful jaw structure');
        features.description = `anthropomorphic wolfkin with ${selectedWolfFur} fur, ${selectedWolfPattern}, alert upright ears, thick bushy tail, fierce predator eyes, ${features.face}`;
        break;
        
      case 'rabbit':
        // Anthro rabbit features with fur
        const rabbitFurColors = ['white', 'gray', 'brown', 'black', 'spotted (white with black)', 'fawn', 'cream', 'dutch (black and white)', 'lop-eared gray'];
        const rabbitPatterns = ['solid', 'spotted', 'dutch pattern (colored with white blaze)', 'white belly', 'white tail'];
        features.ears = 'long, expressive rabbit ears';
        features.tail = 'fluffy cotton ball tail';
        features.fur = `${pick(rabbitFurColors)} fur`;
        features.furPattern = pick(rabbitPatterns);
        features.eyes = pick(['large, gentle brown eyes', 'bright doe eyes', 'soft gray eyes', 'warm hazel eyes']);
        features.build = pick(['petite, quick build', 'soft, curvaceous build', 'athletic hopper build']);
        features.other.push('soft features', 'twitchy nose', 'gentle demeanor', 'strong legs');
        features.description = `rabbitkin with ${features.fur}, long ears, and cotton tail`;
        break;
        
      case 'orc':
        // Modern orc features - athletic, fit, and attractive with green skin variations
        const orcSkinShades = [
          'smooth forest green skin', 'lustrous olive green skin', 'rich emerald green skin', 
          'radiant jade green skin', 'vibrant mint green skin', 'glossy sea green skin', 
          'healthy moss green skin', 'polished sage green skin'
        ];
        const orcBuild = [
          'athletically toned build', 'strong, sculpted physique', 'fit and muscular frame', 
          'powerfully athletic build', 'sleek, toned muscles', 'curvy and strong build',
          'lean muscular definition', 'gym-toned athletic body'
        ];
        features.skin = pick(orcSkinShades);
        features.build = pick(orcBuild);
        features.eyes = pick(['striking amber eyes', 'captivating yellow eyes', 'warm honey eyes', 'bright orange eyes', 'deep brown eyes', 'golden eyes']);
        
        // Modern orc features - elegant tusks, fit appearance
        features.other.push(
          pick(['delicate lower tusks', 'cute small tusks', 'elegant ivory tusks', 'polished tusks']),
          pick(['defined cheekbones', 'strong jawline', 'sculpted features', 'fierce beauty']),
          pick(['toned shoulders', 'athletic posture', 'confident stance', 'graceful strength']),
          pick(['radiant complexion', 'healthy glow', 'well-maintained appearance', 'striking presence'])
        );
        
        features.description = `orc with ${features.skin}, cute tusks, and athletic build`;
        break;
        
      case 'demon':
        // ENHANCED: More detailed demon features with specific horn descriptions for consistency
        const demonSkinTones = ['pale skin with red undertones', 'crimson red skin', 'deep burgundy skin', 'purple-tinted skin', 'midnight blue skin', 'obsidian black skin', 'ash gray skin', 'pale lavender skin', 'dark violet skin'];
        const hornTypes = [
          'curved ram horns (thick, ribbed, curving back from temples)',
          'straight pointed horns (sleek, sharp, jutting upward from forehead)',
          'twisted spiral horns (elegant spirals, medium length)',
          'small swept-back horns (delicate, curving along skull)',
          'large crown-like horns (multiple points forming crown)',
          'asymmetrical horns (one larger than the other, unique)',
          'ridged demon horns (segmented, intimidating)'
        ];
        const hornColors = ['obsidian black', 'deep red', 'ivory white', 'dark purple', 'charcoal gray', 'blood red'];
        const hornSurfaces = ['polished smooth', 'rough textured', 'ridged', 'glossy', 'matte'];
        
        const selectedHorns = pick(hornTypes);
        const hornColor = pick(hornColors);
        const hornSurface = pick(hornSurfaces);
        
        features.horns = `${selectedHorns}, ${hornColor} and ${hornSurface}`;
        features.tail = 'long, prehensile tail with spaded tip (demon tail, very expressive)';
        features.skin = pick(demonSkinTones);
        features.eyes = pick(['glowing red eyes with supernatural gleam', 'bright amber eyes with inner fire', 'violet eyes with ethereal glow', 'yellow slit-pupil eyes', 'burning orange eyes', 'crimson eyes with intensity', 'heterochromatic (one red, one gold)']);
        features.build = pick(['lithe, seductive build with dangerous curves', 'tall, imposing build with commanding presence', 'athletic, dangerous build with predatory grace', 'alluring, powerful build with supernatural beauty']);
        features.other.push('sharp, defined features', 'intense supernatural presence', 'slightly pointed ears', 'otherworldly aura', `${features.horns} prominently visible`, 'tail moves expressively');
        features.description = `demon with ${features.skin}, ${selectedHorns} (${hornColor}, ${hornSurface}), long spaded tail, ${features.eyes}, supernatural presence`;
        break;
        
      default:
        features.description = 'human';
    }
    
    return features;
  }
  
  // ============================================
  // CUSTOM EMPLOYEE CREATION SYSTEM
  // ============================================
  
  // Store pending custom employee data in case of accidental modal closure
  let pendingCustomEmployeeData = null;
  let pendingCustomEmployeeProductId = null;
  let pendingCustomEmployeeSource = null;
  
  /**
   * Update the recover character button visibility and info
   */
  function updateRecoverCharacterButton(modal) {
    const recoverSection = modal?.querySelector('#recoverCharacterSection');
    const recoverInfo = modal?.querySelector('#recoverCharacterInfo');
    
    if (!recoverSection) return;
    
    if (pendingCustomEmployeeData && pendingCustomEmployeeData.name) {
      recoverSection.style.display = 'block';
      if (recoverInfo) {
        const name = pendingCustomEmployeeData.name || 'Unknown';
        const source = pendingCustomEmployeeSource || 'Unknown';
        recoverInfo.textContent = `"${name}" (from ${source})`;
      }
    } else {
      recoverSection.style.display = 'none';
    }
  }
  
  /**
   * Show a confirmation modal for generated character data
   * Allows editing before finalizing
   */
  function showCharacterConfirmationModal(characterData, productId, sourceType = 'URL') {
    // Store the data in case of accidental closure
    pendingCustomEmployeeData = JSON.parse(JSON.stringify(characterData));
    pendingCustomEmployeeProductId = productId;
    pendingCustomEmployeeSource = sourceType;
    
    const modal = document.createElement('div');
    modal.id = 'characterConfirmModal';
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85); z-index: 10001;
      display: flex; align-items: center; justify-content: center;
      padding: 20px; box-sizing: border-box;
    `;
    
    const data = characterData;
    
    modal.innerHTML = `
      <div style="background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius:16px; max-width:600px; width:100%; max-height:90vh; overflow-y:auto; border:2px solid #4ecca3; box-shadow:0 20px 60px rgba(0,0,0,0.5);">
        <div style="padding:20px; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center;">
          <h2 style="margin:0; color:#4ecca3;">âœ¨ Character Generated!</h2>
          <button id="closeConfirmModal" style="background:none; border:none; color:#888; font-size:24px; cursor:pointer;">&times;</button>
        </div>
        
        <div style="padding:20px;">
          <p style="color:#aaa; margin-bottom:15px;">Review and edit the generated character before hiring:</p>
          
          <!-- Basic Info -->
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;">
            <div>
              <label style="display:block; color:#ffd700; font-size:0.8rem; margin-bottom:4px;">Name</label>
              <input type="text" id="confirmName" value="${data.name || ''}" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; box-sizing:border-box;">
            </div>
            <div>
              <label style="display:block; color:#ffd700; font-size:0.8rem; margin-bottom:4px;">Age (18+)</label>
              <input type="number" id="confirmAge" value="${Math.max(18, data.age || 25)}" min="18" max="99" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; box-sizing:border-box;">
            </div>
          </div>
          
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;">
            <div>
              <label style="display:block; color:#ffd700; font-size:0.8rem; margin-bottom:4px;">Gender</label>
              <select id="confirmGender" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white;">
                <option value="female" ${data.gender === 'female' ? 'selected' : ''}>Female</option>
                <option value="male" ${data.gender === 'male' ? 'selected' : ''}>Male</option>
                <option value="female_futa" ${data.gender === 'female_futa' ? 'selected' : ''}>Futa</option>
                <option value="trans_woman" ${data.gender === 'trans_woman' ? 'selected' : ''}>Trans Woman</option>
                <option value="trans_man" ${data.gender === 'trans_man' ? 'selected' : ''}>Trans Man</option>
              </select>
            </div>
            <div>
              <label style="display:block; color:#ffd700; font-size:0.8rem; margin-bottom:4px;">Race/Species</label>
              <select id="confirmRace" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white;">
                <option value="human" ${(data.race || 'human') === 'human' ? 'selected' : ''}>Human</option>
                <option value="elf" ${data.race === 'elf' ? 'selected' : ''}>Elf</option>
                <option value="catgirl" ${data.race === 'catgirl' ? 'selected' : ''}>Catgirl</option>
                <option value="succubus" ${data.race === 'succubus' ? 'selected' : ''}>Succubus</option>
                <option value="demon" ${data.race === 'demon' ? 'selected' : ''}>Demon</option>
              </select>
            </div>
          </div>
          
          <!-- Bio -->
          <div style="margin-bottom:15px;">
            <label style="display:block; color:#ffd700; font-size:0.8rem; margin-bottom:4px;">Bio</label>
            <textarea id="confirmBio" rows="3" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; resize:vertical; box-sizing:border-box;">${data.bio || ''}</textarea>
          </div>
          
          <!-- Personality Traits -->
          <div style="margin-bottom:15px;">
            <label style="display:block; color:#ffd700; font-size:0.8rem; margin-bottom:4px;">Personality Traits (comma-separated)</label>
            <input type="text" id="confirmTraits" value="${(data.personalityTraits || []).join(', ')}" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; box-sizing:border-box;">
          </div>
          
          <!-- Hobbies & Kinks -->
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;">
            <div>
              <label style="display:block; color:#ffd700; font-size:0.8rem; margin-bottom:4px;">Hobbies</label>
              <input type="text" id="confirmHobbies" value="${(data.hobbies || []).join(', ')}" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; box-sizing:border-box;">
            </div>
            <div>
              <label style="display:block; color:#ffd700; font-size:0.8rem; margin-bottom:4px;">Kinks</label>
              <input type="text" id="confirmKinks" value="${(data.kinks || []).join(', ')}" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; box-sizing:border-box;">
            </div>
          </div>
          
          <!-- Physical Appearance -->
          <details style="background:#0f3460; border-radius:8px; margin-bottom:15px;">
            <summary style="padding:10px 15px; cursor:pointer; color:#ff6b9d; font-weight:600;">ğŸ‘ï¸ Physical Appearance</summary>
            <div style="padding:0 15px 15px 15px;">
              <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                <div>
                  <label style="display:block; color:#aaa; font-size:0.75rem; margin-bottom:2px;">Hair Color</label>
                  <input type="text" id="confirmHairColor" value="${data.physical?.hairColor || ''}" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem; box-sizing:border-box;">
                </div>
                <div>
                  <label style="display:block; color:#aaa; font-size:0.75rem; margin-bottom:2px;">Hair Style</label>
                  <input type="text" id="confirmHairStyle" value="${data.physical?.hairStyle || ''}" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem; box-sizing:border-box;">
                </div>
                <div>
                  <label style="display:block; color:#aaa; font-size:0.75rem; margin-bottom:2px;">Eye Color</label>
                  <input type="text" id="confirmEyeColor" value="${data.physical?.eyeColor || ''}" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem; box-sizing:border-box;">
                </div>
                <div>
                  <label style="display:block; color:#aaa; font-size:0.75rem; margin-bottom:2px;">Skin Tone</label>
                  <input type="text" id="confirmSkinTone" value="${data.physical?.skinTone || ''}" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem; box-sizing:border-box;">
                </div>
                <div>
                  <label style="display:block; color:#aaa; font-size:0.75rem; margin-bottom:2px;">Body Shape</label>
                  <input type="text" id="confirmBodyShape" value="${data.physical?.bodyShape || ''}" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem; box-sizing:border-box;">
                </div>
                <div>
                  <label style="display:block; color:#aaa; font-size:0.75rem; margin-bottom:2px;">Height/Build</label>
                  <input type="text" id="confirmHeightBuild" value="${data.physical?.heightBuild || ''}" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem; box-sizing:border-box;">
                </div>
                <div>
                  <label style="display:block; color:#aaa; font-size:0.75rem; margin-bottom:2px;">Bust/Chest Size</label>
                  <input type="text" id="confirmBreastSize" value="${data.physical?.breastSize || data.physical?.chestSize || ''}" placeholder="e.g. full, modest, muscular" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem; box-sizing:border-box;">
                </div>
                <div>
                  <label style="display:block; color:#aaa; font-size:0.75rem; margin-bottom:2px;">Butt Size</label>
                  <input type="text" id="confirmButtSize" value="${data.physical?.buttSize || ''}" placeholder="e.g. round, full, athletic" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem; box-sizing:border-box;">
                </div>
                <div>
                  <label style="display:block; color:#aaa; font-size:0.75rem; margin-bottom:2px;">Fashion Style</label>
                  <input type="text" id="confirmFashion" value="${data.physical?.fashion || ''}" placeholder="e.g. business professional, casual" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem; box-sizing:border-box;">
                </div>
                <div style="grid-column: span 2;">
                  <label style="display:block; color:#aaa; font-size:0.75rem; margin-bottom:2px;">Notable Features</label>
                  <input type="text" id="confirmNotableFeatures" value="${data.physical?.notableFeatures || ''}" placeholder="e.g. dimples, freckles, beauty mark, tattoo" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem; box-sizing:border-box;">
                </div>
              </div>
              
              <!-- Intimate Details (sub-collapsed) -->
              <details style="background:#1a1a2e; border-radius:6px; margin-top:10px;">
                <summary style="padding:8px 12px; cursor:pointer; color:#ff6b9d; font-size:0.85rem;">ğŸ” Intimate Details</summary>
                <div style="padding:8px 12px 12px 12px;">
                  <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                    <div>
                      <label style="display:block; color:#aaa; font-size:0.75rem; margin-bottom:2px;">Genital Type</label>
                      <select id="confirmGenitalType" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
                        <option value="" ${!data.physical?.genitalType ? 'selected' : ''}>-- Auto-generate --</option>
                        <option value="vagina" ${data.physical?.genitalType === 'vagina' ? 'selected' : ''}>Vagina</option>
                        <option value="penis" ${data.physical?.genitalType === 'penis' ? 'selected' : ''}>Penis</option>
                        <option value="penis and vagina" ${data.physical?.genitalType === 'penis and vagina' ? 'selected' : ''}>Penis and Vagina (Futa)</option>
                        <option value="vagina (post-op)" ${data.physical?.genitalType === 'vagina (post-op)' ? 'selected' : ''}>Vagina (Post-op)</option>
                        <option value="penis (pre-op)" ${data.physical?.genitalType === 'penis (pre-op)' ? 'selected' : ''}>Penis (Pre-op)</option>
                      </select>
                    </div>
                    <div>
                      <label style="display:block; color:#aaa; font-size:0.75rem; margin-bottom:2px;">Genital Size</label>
                      <input type="text" id="confirmGenitalSize" value="${data.physical?.genitalSize || ''}" placeholder="e.g. average, large, tight" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem; box-sizing:border-box;">
                    </div>
                    <div style="grid-column: span 2;">
                      <label style="display:block; color:#aaa; font-size:0.75rem; margin-bottom:2px;">Grooming/Characteristics</label>
                      <input type="text" id="confirmGenitalCharacteristics" value="${data.physical?.genitalCharacteristics || ''}" placeholder="e.g. well-groomed, natural, trimmed" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem; box-sizing:border-box;">
                    </div>
                  </div>
                </div>
              </details>
            </div>
          </details>
          
          <!-- Personality Sliders (collapsed by default) -->
          <details style="background:#0f3460; border-radius:8px; margin-bottom:15px;">
            <summary style="padding:10px 15px; cursor:pointer; color:#ff6b9d; font-weight:600;">ğŸ’« Personality (C.O.F.P.H.)</summary>
            <div style="padding:0 15px 15px 15px;">
              <div style="display:grid; grid-template-columns:1fr; gap:8px;">
                <div>
                  <label style="display:block; color:#aaa; font-size:0.75rem;">Confidence: <span id="confirmConfidenceVal">${data.personality?.confidence || 50}</span></label>
                  <input type="range" id="confirmConfidence" min="0" max="100" value="${data.personality?.confidence || 50}" style="width:100%;">
                </div>
                <div>
                  <label style="display:block; color:#aaa; font-size:0.75rem;">Outgoing: <span id="confirmOutgoingVal">${data.personality?.outgoing || 50}</span></label>
                  <input type="range" id="confirmOutgoing" min="0" max="100" value="${data.personality?.outgoing || 50}" style="width:100%;">
                </div>
                <div>
                  <label style="display:block; color:#aaa; font-size:0.75rem;">Flirty: <span id="confirmFlirtyVal">${data.personality?.flirty || 50}</span></label>
                  <input type="range" id="confirmFlirty" min="0" max="100" value="${data.personality?.flirty || 50}" style="width:100%;">
                </div>
                <div>
                  <label style="display:block; color:#aaa; font-size:0.75rem;">Professional: <span id="confirmProfessionalVal">${data.personality?.professional || 50}</span></label>
                  <input type="range" id="confirmProfessional" min="0" max="100" value="${data.personality?.professional || 50}" style="width:100%;">
                </div>
                <div>
                  <label style="display:block; color:#aaa; font-size:0.75rem;">Humor: <span id="confirmHumorVal">${data.personality?.humor || 50}</span></label>
                  <input type="range" id="confirmHumor" min="0" max="100" value="${data.personality?.humor || 50}" style="width:100%;">
                </div>
              </div>
            </div>
          </details>
          
          <!-- Profile Image Generation -->
          <div style="background:#0f3460; border-radius:8px; margin-bottom:15px; padding:15px;">
            <div style="display:flex; align-items:center; gap:15px;">
              <div id="profileImagePreview" style="width:100px; height:100px; border-radius:50%; background:#1a1a2e; border:3px solid #4ecca3; display:flex; align-items:center; justify-content:center; overflow:hidden; flex-shrink:0;">
                ${data.generatedProfileImage 
                  ? `<img src="${data.generatedProfileImage}" style="width:100%; height:100%; object-fit:cover; border-radius:50%;" alt="Generated profile">`
                  : '<span style="color:#555; font-size:2rem;">ğŸ‘¤</span>'}
              </div>
              <div style="flex:1;">
                <label style="display:block; color:#c77dff; font-weight:600; margin-bottom:8px;">ğŸ“¸ Profile Image</label>
                <button id="generateProfileImageBtn" style="width:100%; padding:10px; background:linear-gradient(135deg, #c77dff 0%, #7c3aed 100%); border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">
                  ğŸ¨ ${data.generatedProfileImage ? 'Regenerate' : 'Generate'} Profile Image
                </button>
                <p style="color:#666; font-size:0.75rem; margin:6px 0 0 0;">Uses character details to create a matching portrait</p>
              </div>
            </div>
            <input type="hidden" id="generatedProfileImageUrl" value="${data.generatedProfileImage || ''}">
          </div>
          
          <!-- Action Buttons -->
          <div style="display:flex; gap:10px; margin-top:20px;">
            <button id="confirmHireBtn" style="flex:1; padding:12px; background:linear-gradient(135deg, #4ecca3 0%, #00d4ff 100%); border:none; border-radius:8px; color:white; font-weight:bold; cursor:pointer; font-size:1rem;">
              âœ… Hire This Character
            </button>
            <button id="cancelConfirmBtn" style="flex:0 0 auto; padding:12px 20px; background:#333; border:1px solid #555; border-radius:8px; color:#aaa; cursor:pointer;">
              Cancel
            </button>
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Set up slider value displays
    ['Confidence', 'Outgoing', 'Flirty', 'Professional', 'Humor'].forEach(trait => {
      const slider = modal.querySelector(`#confirm${trait}`);
      const display = modal.querySelector(`#confirm${trait}Val`);
      if (slider && display) {
        slider.addEventListener('input', () => {
          display.textContent = slider.value;
        });
      }
    });
    
    // Age enforcement
    const ageInput = modal.querySelector('#confirmAge');
    if (ageInput) {
      ageInput.addEventListener('change', () => {
        if (parseInt(ageInput.value) < 18) ageInput.value = 18;
      });
    }
    
    // Close handlers - with confirmation to prevent accidental loss
    const closeModal = (skipConfirm = false) => {
      if (!skipConfirm) {
        const confirmClose = confirm('âš ï¸ Close without hiring?\n\nYour generated character will be saved and can be recovered from the "Recover Last Character" button.');
        if (!confirmClose) return;
      }
      modal.remove();
    };
    
    // Clear pending data only on successful hire
    const clearPendingData = () => {
      pendingCustomEmployeeData = null;
      pendingCustomEmployeeProductId = null;
      pendingCustomEmployeeSource = null;
    };
    
    modal.querySelector('#closeConfirmModal')?.addEventListener('click', () => closeModal(false));
    modal.querySelector('#cancelConfirmBtn')?.addEventListener('click', () => closeModal(false));
    
    // PROTECTION: Backdrop click requires confirmation
    modal.addEventListener('click', (e) => {
      if (e.target === modal) closeModal(false);
    });
    
    // PROTECTION: Escape key also requires confirmation
    const escapeHandler = (e) => {
      if (e.key === 'Escape') {
        e.preventDefault();
        closeModal(false);
      }
    };
    document.addEventListener('keydown', escapeHandler);
    
    // Clean up escape handler when modal is removed
    const observer = new MutationObserver(() => {
      if (!document.contains(modal)) {
        document.removeEventListener('keydown', escapeHandler);
        observer.disconnect();
      }
    });
    observer.observe(document.body, { childList: true });
    
    // Generate Profile Image button
    modal.querySelector('#generateProfileImageBtn')?.addEventListener('click', async () => {
      const btn = modal.querySelector('#generateProfileImageBtn');
      const previewDiv = modal.querySelector('#profileImagePreview');
      const hiddenInput = modal.querySelector('#generatedProfileImageUrl');
      
      // Collect current form values for prompt
      const gender = modal.querySelector('#confirmGender')?.value || data.gender || 'female';
      const race = modal.querySelector('#confirmRace')?.value || 'human';
      const age = modal.querySelector('#confirmAge')?.value || data.age || 25;
      const hairColor = modal.querySelector('#confirmHairColor')?.value?.trim() || data.physical?.hairColor || 'brown';
      const hairStyle = modal.querySelector('#confirmHairStyle')?.value?.trim() || data.physical?.hairStyle || 'medium length';
      const eyeColor = modal.querySelector('#confirmEyeColor')?.value?.trim() || data.physical?.eyeColor || 'brown';
      const skinTone = modal.querySelector('#confirmSkinTone')?.value?.trim() || data.physical?.skinTone || 'fair';
      const bodyShape = modal.querySelector('#confirmBodyShape')?.value?.trim() || data.physical?.bodyShape || 'average';
      const heightBuild = modal.querySelector('#confirmHeightBuild')?.value?.trim() || data.physical?.heightBuild || 'average height';
      
      // Get personality for expression hints
      const confidence = parseInt(modal.querySelector('#confirmConfidence')?.value) || 50;
      const flirty = parseInt(modal.querySelector('#confirmFlirty')?.value) || 50;
      const professional = parseInt(modal.querySelector('#confirmProfessional')?.value) || 50;
      
      // Build expression based on personality
      let expression = 'neutral';
      if (confidence > 70) expression = 'confident';
      if (flirty > 70) expression = 'flirty smirk';
      if (professional > 70 && flirty < 50) expression = 'professional';
      if (confidence > 70 && flirty > 70) expression = 'confident, seductive';
      
      // Build the prompt
      const prompt = `portrait photo of a ${age} year old ${gender} ${race}, ${hairColor} ${hairStyle} hair, ${eyeColor} eyes, ${skinTone} skin, ${bodyShape} body type, ${heightBuild}, ${expression} expression, professional headshot, office background, high quality, detailed face`;
      
      btn.disabled = true;
      btn.innerHTML = '<span style="display:inline-block; animation:rotate 1.5s linear infinite;">â³</span> Generating...';
      previewDiv.innerHTML = '<span style="color:#4ecca3; font-size:0.8rem;">Generating...</span>';
      
      try {
        const imageUrl = await queuedGenerateImage(prompt);
        
        if (imageUrl) {
          // Show the image in preview
          previewDiv.innerHTML = `<img src="${imageUrl}" style="width:100%; height:100%; object-fit:cover; border-radius:50%;" alt="Generated profile">`;
          hiddenInput.value = imageUrl;
          
          // Also save to pending data for recovery
          if (pendingCustomEmployeeData) {
            pendingCustomEmployeeData.generatedProfileImage = imageUrl;
          }
          
          showNotification('âœ¨ Profile image generated!', 'success');
        } else {
          throw new Error('No image URL returned');
        }
      } catch (error) {
        console.error('Error generating profile image:', error);
        previewDiv.innerHTML = '<span style="color:#ff6b6b; font-size:0.7rem;">Failed</span>';
        showNotification('Failed to generate image. Try again!', 'error');
      }
      
      btn.disabled = false;
      btn.innerHTML = 'ğŸ¨ Generate Profile Image';
    });
    
    // Hire button
    modal.querySelector('#confirmHireBtn')?.addEventListener('click', async () => {
      const hireBtn = modal.querySelector('#confirmHireBtn');
      hireBtn.disabled = true;
      hireBtn.innerHTML = '<span style="display:inline-block; animation:rotate 1.5s linear infinite;">â³</span> Creating...';
      
      try {
        // Collect edited data
        const editedData = {
          name: modal.querySelector('#confirmName')?.value?.trim() || data.name,
          age: parseInt(modal.querySelector('#confirmAge')?.value) || data.age,
          gender: modal.querySelector('#confirmGender')?.value || data.gender,
          race: modal.querySelector('#confirmRace')?.value || 'human',
          bio: modal.querySelector('#confirmBio')?.value?.trim() || data.bio,
          personalityTraits: (modal.querySelector('#confirmTraits')?.value || '').split(',').map(t => t.trim()).filter(Boolean),
          hobbies: (modal.querySelector('#confirmHobbies')?.value || '').split(',').map(t => t.trim()).filter(Boolean),
          kinks: (modal.querySelector('#confirmKinks')?.value || '').split(',').map(t => t.trim()).filter(Boolean),
          personality: {
            confidence: parseInt(modal.querySelector('#confirmConfidence')?.value) || 50,
            outgoing: parseInt(modal.querySelector('#confirmOutgoing')?.value) || 50,
            flirty: parseInt(modal.querySelector('#confirmFlirty')?.value) || 50,
            professional: parseInt(modal.querySelector('#confirmProfessional')?.value) || 50,
            humor: parseInt(modal.querySelector('#confirmHumor')?.value) || 50
          },
          physical: {
            hairColor: modal.querySelector('#confirmHairColor')?.value?.trim() || data.physical?.hairColor,
            hairStyle: modal.querySelector('#confirmHairStyle')?.value?.trim() || data.physical?.hairStyle,
            eyeColor: modal.querySelector('#confirmEyeColor')?.value?.trim() || data.physical?.eyeColor,
            skinTone: modal.querySelector('#confirmSkinTone')?.value?.trim() || data.physical?.skinTone,
            bodyShape: modal.querySelector('#confirmBodyShape')?.value?.trim() || data.physical?.bodyShape,
            heightBuild: modal.querySelector('#confirmHeightBuild')?.value?.trim() || data.physical?.heightBuild,
            breastSize: modal.querySelector('#confirmBreastSize')?.value?.trim() || data.physical?.breastSize,
            buttSize: modal.querySelector('#confirmButtSize')?.value?.trim() || data.physical?.buttSize,
            fashion: modal.querySelector('#confirmFashion')?.value?.trim() || data.physical?.fashion,
            notableFeatures: modal.querySelector('#confirmNotableFeatures')?.value?.trim() || data.physical?.notableFeatures,
            genitalType: modal.querySelector('#confirmGenitalType')?.value || data.physical?.genitalType,
            genitalSize: modal.querySelector('#confirmGenitalSize')?.value?.trim() || data.physical?.genitalSize,
            genitalCharacteristics: modal.querySelector('#confirmGenitalCharacteristics')?.value?.trim() || data.physical?.genitalCharacteristics
          },
          generatedProfileImage: modal.querySelector('#generatedProfileImageUrl')?.value || null
        };
        
        // Finalize the employee
        const employee = await finalizeCustomEmployee(editedData, productId);
        
        if (employee) {
          showNotification(`âœ¨ Hired ${employee.name}!`, 'success');
          clearPendingData(); // Clear saved data on successful hire
          closeModal(true); // Skip confirmation since we successfully hired
        }
      } catch (error) {
        console.error('Error finalizing character:', error);
        showNotification('Failed to hire character. Please try again.', 'error');
        hireBtn.disabled = false;
        hireBtn.innerHTML = 'âœ… Hire This Character';
      }
    });
  }
  
  /**
   * Generate an employee from a URL (wiki page, character database, etc.)
   * Uses Readability.js to extract content and AI to create employee
   */
  async function generateEmployeeFromUrl(url, extraInstructions = '', productId) {
    showNotification('ğŸ”— Fetching page content...', 'info', 3000);
    
    try {
      // Fetch the page content using a CORS proxy or direct fetch
      let pageContent = '';
      let pageTitle = '';
      
      try {
        // Try direct fetch first (works for some sites)
        const response = await fetch(url);
        const html = await response.text();
        
        // Parse HTML and extract readable content
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Try to get title
        pageTitle = doc.querySelector('title')?.textContent || '';
        
        // Remove scripts, styles, and other non-content elements
        doc.querySelectorAll('script, style, nav, footer, header, aside, .sidebar, #sidebar, .nav, .menu, .advertisement, .ad').forEach(el => el.remove());
        
        // Get main content - try various common selectors
        const mainContent = doc.querySelector('main, article, .content, .post-content, #content, .wiki-content, .mw-parser-output, .page-content, .entry-content');
        
        if (mainContent) {
          pageContent = mainContent.textContent.replace(/\s+/g, ' ').trim();
        } else {
          // Fall back to body text
          pageContent = doc.body?.textContent?.replace(/\s+/g, ' ').trim() || '';
        }
        
        // Limit content length for API
        pageContent = pageContent.slice(0, 8000);
        
      } catch (fetchError) {
        console.warn('Direct fetch failed, using basic URL info:', fetchError);
        // If fetch fails, use URL to guess character name
        const urlParts = url.split('/').filter(Boolean);
        const lastPart = urlParts[urlParts.length - 1] || '';
        pageTitle = decodeURIComponent(lastPart).replace(/[_-]/g, ' ').replace(/\(.*?\)/g, '').trim();
        pageContent = `Character from: ${url}\nName appears to be: ${pageTitle}`;
      }
      
      if (!pageContent || pageContent.length < 50) {
        throw new Error('Could not extract meaningful content from URL');
      }
      
      showNotification('ğŸ¤– Generating employee from page content...', 'info', 5000);
      
      // Generate employee using AI
      const prompt = `Based on the following webpage content, create a game employee character. Extract personality, appearance, and background information.

PAGE CONTENT:
${pageContent.slice(0, 6000)}

${extraInstructions ? `ADDITIONAL INSTRUCTIONS: ${extraInstructions}` : ''}

Create a detailed employee profile. Return ONLY a JSON object (no markdown, no explanation) with these fields:
{
  "name": "Full Name",
  "age": <number between 22-35>,
  "gender": "<female/male/female_futa/trans_woman/trans_man>",
  "bio": "<2-3 sentence background based on source material, adapted to office setting>",
  "personality": {
    "confidence": <10-90>,
    "outgoing": <10-90>,
    "flirty": <10-90>,
    "professional": <10-90>,
    "humor": <10-90>
  },
  "personalityTraits": ["trait1", "trait2", "trait3"],
  "hobbies": ["hobby1", "hobby2"],
  "kinks": ["preference1", "preference2"],
  "physical": {
    "hairColor": "color",
    "hairStyle": "style",
    "eyeColor": "color",
    "skinTone": "tone",
    "bodyShape": "shape",
    "heightBuild": "height and build description"
  }
}`;

      const aiResponse = await queuedGenerateText(prompt, {}, 'Custom Employee from URL');
      let parsed;
      
      try {
        // Try to extract JSON from response
        const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          parsed = JSON.parse(jsonMatch[0]);
        } else {
          throw new Error('No JSON found in response');
        }
      } catch (parseError) {
        console.error('Failed to parse AI response:', parseError, aiResponse);
        throw new Error('AI returned invalid format');
      }
      
      // Return parsed data (NOT finalized - will go to confirmation modal)
      return parsed;
      
    } catch (error) {
      console.error('generateEmployeeFromUrl error:', error);
      throw error;
    }
  }
  
  /**
   * Generate an employee from a text description/prompt
   */
  async function generateEmployeeFromPrompt(description, extraInstructions = '', productId) {
    showNotification('ğŸ¤– Generating employee from description...', 'info', 5000);
    
    try {
      const prompt = `Create a detailed game employee character based on this description:

DESCRIPTION: ${description}

${extraInstructions ? `ADDITIONAL INSTRUCTIONS: ${extraInstructions}` : ''}

Create a complete employee profile. Return ONLY a JSON object (no markdown, no explanation) with these fields:
{
  "name": "Full Name (make up a fitting name)",
  "age": <number between 22-35>,
  "gender": "<female/male/female_futa/trans_woman/trans_man - infer from description or default to female>",
  "bio": "<2-3 sentence background that fits the description, in an office/corporate setting>",
  "personality": {
    "confidence": <10-90>,
    "outgoing": <10-90>,
    "flirty": <10-90>,
    "professional": <10-90>,
    "humor": <10-90>
  },
  "personalityTraits": ["trait1", "trait2", "trait3"],
  "hobbies": ["hobby1", "hobby2"],
  "kinks": ["preference1", "preference2", "preference3"],
  "physical": {
    "hairColor": "color",
    "hairStyle": "style",
    "eyeColor": "color",
    "skinTone": "tone",
    "bodyShape": "shape",
    "heightBuild": "height and build description"
  }
}`;

      const aiResponse = await queuedGenerateText(prompt, {}, 'Custom Employee from Description');
      let parsed;
      
      try {
        const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          parsed = JSON.parse(jsonMatch[0]);
        } else {
          throw new Error('No JSON found in response');
        }
      } catch (parseError) {
        console.error('Failed to parse AI response:', parseError, aiResponse);
        throw new Error('AI returned invalid format');
      }
      
      // Return parsed data (NOT finalized - will go to confirmation modal)
      return parsed;
      
    } catch (error) {
      console.error('generateEmployeeFromPrompt error:', error);
      throw error;
    }
  }
  
  /**
   * Create an employee from manual form data (AI fills in missing fields)
   */
  async function createManualEmployee(formData, productId) {
    showNotification('âœ¨ Creating custom employee...', 'info', 3000);
    
    try {
      // Check what's missing and needs AI generation
      const needsAI = !formData.name || !formData.bio || formData.personalityTraits.length === 0 || 
                      !formData.physical.hair.color || formData.hobbies.length === 0;
      
      let finalData = JSON.parse(JSON.stringify(formData)); // Deep clone
      
      if (needsAI) {
        showNotification('ğŸ¤– AI is filling in missing details...', 'info', 3000);
        
        // Build a prompt that asks AI to fill in only missing fields
        const existingDataDescription = [];
        if (formData.name) existingDataDescription.push(`Name: ${formData.name}`);
        if (formData.age) existingDataDescription.push(`Age: ${formData.age}`);
        if (formData.gender) existingDataDescription.push(`Gender: ${formData.gender}`);
        if (formData.race) existingDataDescription.push(`Race/Species: ${formData.race}`);
        if (formData.bio) existingDataDescription.push(`Bio: ${formData.bio}`);
        if (formData.personalityTraits.length > 0) existingDataDescription.push(`Traits: ${formData.personalityTraits.join(', ')}`);
        if (formData.hobbies.length > 0) existingDataDescription.push(`Hobbies: ${formData.hobbies.join(', ')}`);
        if (formData.kinks.length > 0) existingDataDescription.push(`Kinks: ${formData.kinks.join(', ')}`);
        if (formData.keyTrait) existingDataDescription.push(`Key Trait: ${formData.keyTrait}`);
        if (formData.physical.hair.color) existingDataDescription.push(`Hair: ${formData.physical.hair.color} ${formData.physical.hair.style || ''} ${formData.physical.hair.length || ''}`);
        if (formData.physical.eyes.color) existingDataDescription.push(`Eyes: ${formData.physical.eyes.color}`);
        if (formData.physical.bodyShape) existingDataDescription.push(`Body: ${formData.physical.bodyShape}`);
        if (formData.physical.skinTone) existingDataDescription.push(`Skin: ${formData.physical.skinTone}`);
        if (formData.physical.notableFeatures) existingDataDescription.push(`Notable Features: ${formData.physical.notableFeatures}`);
        
        const prompt = `Complete this employee profile by filling in ONLY the missing fields. Keep all existing data.

EXISTING DATA:
${existingDataDescription.join('\n') || 'None provided - create everything from scratch'}

PERSONALITY SETTINGS (use these exact values):
Confidence: ${formData.personality.confidence}
Outgoing: ${formData.personality.outgoing}
Flirty: ${formData.personality.flirty}
Professional: ${formData.personality.professional}
Humor: ${formData.personality.humor}

Return ONLY a JSON object with the COMPLETE profile (including existing data):
{
  "name": "${formData.name || '<generate a name>'}",
  "age": ${formData.age || '<22-35>'},
  "gender": "${formData.gender || 'female'}",
  "race": "${formData.race || 'human'}",
  "bio": "${formData.bio || '<generate 2-3 sentence bio>'}",
  "personalityTraits": ${formData.personalityTraits.length > 0 ? JSON.stringify(formData.personalityTraits) : '["<trait1>", "<trait2>", "<trait3>"]'},
  "hobbies": ${formData.hobbies.length > 0 ? JSON.stringify(formData.hobbies) : '["<hobby1>", "<hobby2>"]'},
  "kinks": ${formData.kinks.length > 0 ? JSON.stringify(formData.kinks) : '["<pref1>", "<pref2>"]'},
  "keyTrait": "${formData.keyTrait || '<trait>'}",
  "physical": {
    "hairColor": "${formData.physical.hair.color || '<color>'}",
    "hairStyle": "${formData.physical.hair.style || '<style>'}",
    "hairLength": "${formData.physical.hair.length || '<length>'}",
    "eyeColor": "${formData.physical.eyes.color || '<color>'}",
    "eyeShape": "${formData.physical.eyes.shape || '<shape>'}",
    "skinTone": "${formData.physical.skinTone || '<tone>'}",
    "bodyShape": "${formData.physical.bodyShape || '<shape>'}",
    "heightBuild": "${formData.physical.heightBuild || '<description>'}",
    "breastSize": "${formData.physical.breastSize || '<size>'}",
    "buttSize": "${formData.physical.buttSize || '<size>'}",
    "fashion": "${formData.physical.fashion || '<style>'}"
  }
}`;

        const aiResponse = await queuedGenerateText(prompt, {}, 'Manual Employee AI Fill');
        
        try {
          const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            const aiData = JSON.parse(jsonMatch[0]);
            
            // Merge AI data with existing data (existing takes priority)
            finalData.name = formData.name || aiData.name;
            finalData.age = formData.age || aiData.age;
            finalData.gender = formData.gender || aiData.gender;
            finalData.race = formData.race || aiData.race;
            finalData.bio = formData.bio || aiData.bio;
            finalData.keyTrait = formData.keyTrait || aiData.keyTrait;
            finalData.personalityTraits = formData.personalityTraits.length > 0 ? formData.personalityTraits : (aiData.personalityTraits || []);
            finalData.hobbies = formData.hobbies.length > 0 ? formData.hobbies : (aiData.hobbies || []);
            finalData.kinks = formData.kinks.length > 0 ? formData.kinks : (aiData.kinks || []);
            
            // Merge physical data
            if (aiData.physical) {
              finalData.physical = {
                ...formData.physical,
                hair: { 
                  color: formData.physical.hair.color || aiData.physical.hairColor || 'brown',
                  style: formData.physical.hair.style || aiData.physical.hairStyle || 'medium length',
                  length: formData.physical.hair.length || aiData.physical.hairLength || 'medium'
                },
                eyes: { 
                  color: formData.physical.eyes.color || aiData.physical.eyeColor || 'brown',
                  shape: formData.physical.eyes.shape || aiData.physical.eyeShape || 'almond'
                },
                skinTone: formData.physical.skinTone || aiData.physical.skinTone || 'fair',
                bodyShape: formData.physical.bodyShape || aiData.physical.bodyShape || 'average',
                heightBuild: formData.physical.heightBuild || aiData.physical.heightBuild || "5'6 average build",
                breastSize: formData.physical.breastSize || aiData.physical.breastSize || 'medium',
                buttSize: formData.physical.buttSize || aiData.physical.buttSize || 'medium',
                fashion: formData.physical.fashion || aiData.physical.fashion || 'casual professional',
                notableFeatures: formData.physical.notableFeatures || ''
              };
            }
          }
        } catch (parseError) {
          console.warn('AI fill failed, using defaults:', parseError);
        }
      }
      
      // Convert to format expected by finalizeCustomEmployee (include all new fields)
      const employeeData = {
        name: finalData.name,
        age: finalData.age,
        gender: finalData.gender,
        race: finalData.race,
        bio: finalData.bio,
        personality: finalData.personality,
        personalityTraits: finalData.personalityTraits,
        hobbies: finalData.hobbies,
        kinks: finalData.kinks,
        keyTrait: finalData.keyTrait,
        // Pass stats if user specified them
        stats: finalData.stats,
        // Career info
        career: finalData.career,
        // Physical appearance (full)
        physical: {
          hairColor: finalData.physical.hair?.color,
          hairStyle: finalData.physical.hair?.style,
          hairLength: finalData.physical.hair?.length,
          eyeColor: finalData.physical.eyes?.color,
          eyeShape: finalData.physical.eyes?.shape,
          skinTone: finalData.physical.skinTone,
          bodyShape: finalData.physical.bodyShape,
          heightBuild: finalData.physical.heightBuild,
          breastSize: finalData.physical.breastSize,
          buttSize: finalData.physical.buttSize,
          fashion: finalData.physical.fashion,
          notableFeatures: finalData.physical.notableFeatures
        },
        // Personal life
        personalLife: finalData.personalLife,
        // Schedule
        schedule: finalData.schedule,
        // Starting flags
        startingFlags: finalData.startingFlags
      };
      
      return await finalizeCustomEmployee(employeeData, productId);
      
    } catch (error) {
      console.error('createManualEmployee error:', error);
      throw error;
    }
  }
  
  /**
   * Finalize a custom employee and add them to the game
   */
  async function finalizeCustomEmployee(data, productId) {
    const product = gameState.products.find(p => p.id === productId);
    if (!product) throw new Error('Product not found');
    
    // Generate defaults for missing fields
    const selectedGender = data.gender || selectGenderForEmployee();
    const selectedRace = data.race || selectRaceForEmployee();
    const ages = [22,23,24,25,26,27,28,29,30,31,32,33,34];
    
    // Create the employee object with full customization
    const employee = {
      id: `emp_${Date.now()}_custom`,
      name: data.name || generateUniqueName(selectedGender),
      age: data.age || ages[Math.floor(Math.random() * ages.length)],
      gender: selectedGender,
      race: selectedRace,
      position: `Manager â€“ ${product.name}`,
      productId,
      productManaged: product.name,
      personalityTraits: data.personalityTraits || ['Professional', 'Dedicated', 'Friendly'],
      keyTrait: data.keyTrait || data.personalityTraits?.[0] || 'Dedicated',
      hobbies: data.hobbies || ['Reading', 'Fitness'],
      kinks: data.kinks || ['Roleplay', 'Teasing'],
      personality: {
        confidence: data.personality?.confidence ?? 50,
        outgoing: data.personality?.outgoing ?? 50,
        flirty: data.personality?.flirty ?? 50,
        professional: data.personality?.professional ?? 50,
        humor: data.personality?.humor ?? 50
      },
      // Stats - use provided values or generate defaults
      stats: {
        affection: data.stats?.affection ?? generateEmployeeStat('affection'),
        comfort: data.stats?.comfort ?? generateEmployeeStat('comfort'),
        trust: data.stats?.trust ?? generateEmployeeStat('trust'),
        desire: data.stats?.desire ?? generateEmployeeStat('desire'),
        friendship: data.stats?.friendship ?? generateEmployeeStat('friendship'),
        productivity: data.stats?.productivity ?? generateEmployeeStat('productivity'),
        obedience: data.stats?.obedience ?? 10 // Start low by default
      },
      giftPreferences: generateGiftPreferences(),
      hired: true,
      onboarding: false,
      bioComplete: true,
      bio: data.bio || "A dedicated professional who brings energy to the workplace.",
      physical: generateDetailedPhysicalAppearance(selectedGender, selectedRace),
      profileImage: null,
      hireDate: Date.now(),
      employmentStatus: 'active',
      locationId: product.locationId || 'headquarters',
      // Career - use provided values or defaults
      career: {
        level: data.career?.level || 1,
        title: gameState.hierarchyLevels?.[data.career?.level || 1]?.title || "Staff",
        salary: data.career?.salary || gameState.hierarchyLevels?.[data.career?.level || 1]?.baseSalary || 40000,
        startDate: Date.now(),
        promotionHistory: [],
        directReports: [],
        managerId: null
      },
      skills: {
        technical: { level: 1 + Math.floor(Math.random() * 3), xp: 0, maxXp: 500 },
        creative: { level: 1 + Math.floor(Math.random() * 3), xp: 0, maxXp: 500 },
        social: { level: 1 + Math.floor(Math.random() * 3), xp: 0, maxXp: 500 },
        management: { level: 1 + Math.floor(Math.random() * 3), xp: 0, maxXp: 500 },
        intimate: { level: 0, xp: 0, maxXp: 500 },
        cooking: { level: Math.floor(Math.random() * 3), xp: 0, maxXp: 500 },
        fitness: { level: Math.floor(Math.random() * 3), xp: 0, maxXp: 500 }
      },
      isRehire: false,
      fastTrack: false,
      previousLevel: null,
      previousTitle: null,
      timesRehired: 0,
      isCustomEmployee: true // Mark as custom-created
    };
    
    // Override physical appearance with provided data if available
    if (data.physical) {
      if (data.physical.hairColor) employee.physical.hair = { ...employee.physical.hair, color: data.physical.hairColor };
      if (data.physical.hairStyle) employee.physical.hair = { ...employee.physical.hair, style: data.physical.hairStyle };
      if (data.physical.hairLength) employee.physical.hair = { ...employee.physical.hair, length: data.physical.hairLength };
      if (data.physical.eyeColor) employee.physical.eyes = { ...employee.physical.eyes, color: data.physical.eyeColor };
      if (data.physical.eyeShape) employee.physical.eyes = { ...employee.physical.eyes, shape: data.physical.eyeShape };
      if (data.physical.skinTone) employee.physical.skinTone = data.physical.skinTone;
      if (data.physical.bodyShape) employee.physical.bodyShape = data.physical.bodyShape;
      if (data.physical.heightBuild) employee.physical.heightBuild = data.physical.heightBuild;
      if (data.physical.breastSize) {
        employee.physical.breastSize = data.physical.breastSize;
        if (employee.physical.body) employee.physical.body.chestSize = data.physical.breastSize;
      }
      if (data.physical.buttSize) {
        employee.physical.buttSize = data.physical.buttSize;
        if (employee.physical.body) employee.physical.body.buttSize = data.physical.buttSize;
      }
      if (data.physical.fashion) employee.physical.fashion = data.physical.fashion;
      if (data.physical.notableFeatures) employee.physical.notableFeatures = data.physical.notableFeatures;
      // Handle genital customization
      if (data.physical.genitalType || data.physical.genitalSize || data.physical.genitalCharacteristics) {
        if (!employee.physical.genitals) employee.physical.genitals = {};
        if (data.physical.genitalType) employee.physical.genitals.type = data.physical.genitalType;
        if (data.physical.genitalSize) employee.physical.genitals.size = data.physical.genitalSize;
        if (data.physical.genitalCharacteristics) employee.physical.genitals.characteristics = data.physical.genitalCharacteristics;
        // Rebuild the full description
        employee.physical.genitals.full = `${employee.physical.genitals.size || 'average'} ${employee.physical.genitals.type || 'genitals'}, ${employee.physical.genitals.characteristics || 'natural'}`;
      }
    }
    
    // Apply custom schedule if provided
    if (data.schedule) {
      employee.schedule = {
        workDays: data.schedule.workDays || [1, 2, 3, 4, 5],
        workStartHour: data.schedule.workStartHour ?? 9,
        workEndHour: data.schedule.workEndHour ?? 17,
        isCurrentlyWorking: false,
        lastClockIn: null,
        lastClockOut: null,
        hoursWorkedToday: 0,
        daysWorked: 0,
        lateDays: 0,
        ptoBalance: data.schedule.ptoBalance ?? 10,
        sickDays: 5,
        isOnLeave: false,
        leaveType: null,
        leaveEndDate: null
      };
    }
    
    // Apply personal life settings if provided
    if (data.personalLife) {
      if (!employee.personalLife) employee.personalLife = {};
      if (data.personalLife.livingSituation) {
        employee.personalLife.livingSituation = {
          type: data.personalLife.livingSituation,
          hasRoommate: data.personalLife.livingSituation === 'with-roommate',
          hasPet: data.personalLife.hasPet && data.personalLife.hasPet !== 'no',
          petType: data.personalLife.hasPet && data.personalLife.hasPet !== 'no' ? data.personalLife.hasPet : null,
          petName: null,
          pets: []
        };
      }
      if (data.personalLife.relationshipStatus) {
        if (!employee.personalLife.outsideContacts) employee.personalLife.outsideContacts = {};
        employee.personalLife.outsideContacts.relationshipStatus = data.personalLife.relationshipStatus;
        employee.personalLife.outsideContacts.inRelationship = ['dating', 'serious', 'engaged', 'married'].includes(data.personalLife.relationshipStatus);
      }
    }
    
    // Apply starting flags if provided
    if (data.startingFlags && data.startingFlags.length > 0) {
      if (!employee.flags) {
        employee.flags = { systemFlags: [], customFlags: [] };
      }
      data.startingFlags.forEach(flag => {
        if (!employee.flags.customFlags.includes(flag)) {
          employee.flags.customFlags.push(flag);
        }
      });
    }
    
    // Mark name as used
    if (!gameState.usedEmployeeNames) {
      gameState.usedEmployeeNames = new Set();
    }
    gameState.usedEmployeeNames.add(employee.name);
    
    // Initialize social network data
    initializeEmployeeSocialData(employee);
    
    // Add to employees array
    gameState.employees.push(employee);
    
    // Update company awareness
    updateCompanyAwareness();
    
    // Generate relationships with existing employees
    generateRandomRelationships(employee.id);
    
    // Log hire event
    logCompanyEvent({
      type: 'hire',
      involvedEmployees: [employee.id],
      location: employee.locationId,
      description: `${employee.name} was custom-hired as ${employee.position}`,
      sentiment: 'positive',
      importance: 7
    });
    
    // Mark manager on product
    product.managerHired = true;
    product.managerId = employee.id;
    product.managerLevel = employee.career.level;
    product.managerOnboarding = false;
    
    // Assign to pyramid position at appropriate level
    // Use explicitly selected slot if provided, otherwise fall back to finding by productId
    const targetLevel = employee.career.level;
    let targetPosition = null;
    
    if (data.career?.selectedSlot) {
      // User explicitly selected a position slot
      const selectedSlot = data.career.selectedSlot;
      targetPosition = gameState.corporatePyramid?.positions?.[selectedSlot.level]?.[selectedSlot.index];
      
      // Update the employee's productId and productManaged to match the selected slot
      if (targetPosition && targetPosition.productId !== productId) {
        const actualProduct = gameState.products.find(p => p.id === targetPosition.productId);
        if (actualProduct) {
          employee.productId = actualProduct.id;
          employee.productManaged = actualProduct.name;
          employee.position = `${gameState.hierarchyLevels?.[selectedSlot.level]?.title || 'Manager'} â€“ ${actualProduct.name}`;
          // Don't mark original product as having manager if assigned elsewhere
          product.managerHired = false;
          product.managerId = null;
          product.managerLevel = null;
          // Mark actual product
          actualProduct.managerHired = true;
          actualProduct.managerId = employee.id;
          actualProduct.managerLevel = employee.career.level;
        }
      }
      
      console.log(`[Custom Employee] Using explicitly selected position slot: Level ${selectedSlot.level}, Index ${selectedSlot.index}`);
    } else {
      // Fall back to finding position by productId
      targetPosition = gameState.corporatePyramid?.positions?.[targetLevel]?.find(
        pos => pos.productId === product.id
      );
    }
    
    if (targetPosition) {
      targetPosition.employeeId = employee.id;
      const levelInfo = gameState.hierarchyLevels?.[targetPosition.level] || gameState.hierarchyLevels?.[1];
      if (levelInfo) {
        employee.career.title = levelInfo.title;
        if (!data.career?.salary) {
          employee.career.salary = levelInfo.baseSalary;
        }
      }
    }
    
    // Generate profile image (use pre-generated if available)
    if (data.generatedProfileImage) {
      // Use the image generated in the confirmation modal
      employee.profileImage = data.generatedProfileImage;
      console.log('[Custom Employee] Using pre-generated profile image from confirmation modal');
    } else {
      // Generate a new profile image
      showNotification('ğŸ¨ Generating profile image...', 'info', 3000);
      try {
        const imagePrompt = buildEmployeeImagePrompt(employee);
        if (typeof generateImage === 'function') {
          const imageUrl = await queuedGenerateImage(imagePrompt, {}, `Profile Image - ${employee.name}`);
          if (imageUrl) {
            employee.profileImage = imageUrl;
          }
        }
      } catch (imgError) {
        console.warn('Profile image generation failed:', imgError);
      }
    }
    
    // Generate first social post
    generateFirstEmployeePost(employee).catch(err => {
      console.warn('First post generation failed:', err);
    });
    
    // UI updates
    updatePeopleTab();
    updateProductsList();
    saveGame();
    
    console.log(`[Custom Employee] Created ${employee.name} for ${product.name} at Level ${employee.career.level}`);
    
    return employee;
  }
  
    function generatePotentialHires(productId) {
  // Use the massive name pools defined above
  const firstNames = FIRST_NAMES_POOL;
  const lastNames = LAST_NAMES_POOL;
    const personalities = ['Playful','Reserved','Confident','Witty','Thoughtful','Cheeky','Dry-humored','Warm','Ambitious','Chill','Inquisitive','Loyal','Optimistic','Pessimistic','Sarcastic','Sincere','Spontaneous','Stoic','Supportive','Adventurous','Cautious','Curious','Diligent','Easygoing','Energetic','Focused','Generous','Humble','Imaginative','Meticulous','Pragmatic','Resourceful','Sociable','Tactful','Versatile'];
    const traits = ['Charismatic','Analytical','Creative','Detail-oriented','Adaptable','Empathetic','Organized','Bold', 'Reliable','Innovative','Strategic','Patient','Decisive','Collaborative','Resilient','Visionary','Persuasive','Curious','Ambitious','Supportive', 'Meticulous','Proactive','Diligent','Resourceful','Versatile', 'Submissive','Dominant','Flirty','Shy','Confident','Caring','Playful','Serious','Adventurous','Loyal','Spontaneous','Thoughtful','Cheeky','Witty','Warm','Inquisitive'];
    const hobbies = ['Reading','Photography','Hiking','Gaming','Cooking','Traveling','Music','Art','Yoga','Dancing','Climbing','Baking','Thrifting','Gardening','Writing','Cycling','Swimming','Crafting','Meditation','Volunteering','Fishing','Running','Collecting','Knitting','Birdwatching','Puzzles','Board games','Movies','Theater','Fitness','Martial arts','Skiing','Snowboarding','Surfing','Skateboarding','Camping','Astronomy','DIY projects','Blogging','Podcasting','Learning languages','Genealogy','Magic tricks','Robotics','Woodworking','Calligraphy','Chess','Travel blogging','Vlogging','Stand-up comedy','Improv'];
    const kinks = ['Roleplay','Bondage','Exhibitionism','Voyeurism','Dom/sub','Praise','Teasing','Spanking','Light impact','Dirty talk','Public play','Costumes','Sensory play','Tickling','Restraints','Blindfolds','Temperature play','Massage','Oral fixation','Foot fetish','Group play','Cuddling','Hair pulling','Choking','Anal play','Threesomes','Fantasies','Power exchange','Erotic humiliation','Sensation play','Mutual masturbation',];
    const ages = [22,23,24,25,26,27,28,29,30,31,32,33,34];

    const pickSome = (arr, min, max) => {
        const n = Math.max(min, Math.min(max, Math.floor(Math.random()*(max-min+1))+min));
        const out = new Set();
        while(out.size < n) out.add(arr[Math.floor(Math.random()*arr.length)]);
        return [...out];
    };

    const candidates = [];
    for (let i = 0; i < 3; i++) {
    // Select gender based on settings
    const selectedGender = selectGenderForEmployee();
    // Select race based on settings (PLAYER FEATURE REQUEST)
    const selectedRace = selectRaceForEmployee();
    
    const cand = {
    id: `emp_${Date.now()}_${i}`,
    name: generateUniqueName(selectedGender), // Use unique name generator with gender
    age: ages[Math.floor(Math.random()*ages.length)],
    gender: selectedGender,
    race: selectedRace,  // NEW: Race/Species field
    position: 'Manager Candidate',
    productId,
    // personality & interests
    personalityTraits: pickSome(personalities, 3, 5),
    keyTrait: traits[Math.floor(Math.random()*traits.length)],
    hobbies: pickSome(hobbies, 1, 2),
    kinks: pickSome(kinks, 2, 4),
    // AI personality attributes (C.O.F.P.H.)
    personality: {
      confidence: 30 + Math.floor(Math.random() * 50),    // 30-80 range
      outgoing: 20 + Math.floor(Math.random() * 60),      // 20-80 range
      flirty: 10 + Math.floor(Math.random() * 70),        // 10-80 range
      professional: 30 + Math.floor(Math.random() * 50),  // 30-80 range
      humor: 20 + Math.floor(Math.random() * 60)          // 20-80 range
    },
    // stats (0-100 scale) - Uses HR settings for starting ranges
    stats: {
      affection:    generateEmployeeStat('affection'),
      comfort:      generateEmployeeStat('comfort'),
      trust:        generateEmployeeStat('trust'),
      desire:       generateEmployeeStat('desire'),
      friendship:   generateEmployeeStat('friendship'),
      productivity: generateEmployeeStat('productivity')
    },
    // gift preferences
    giftPreferences: generateGiftPreferences(),
    // onboarding + bio fields
    hired: false,
    onboarding: true,
    bioComplete: false,
    productManaged: null,
    physical: {
      heightBuild: null,
      hair: { color: null, style: null, length: null },
      eyes: { color: null, shape: null },
      skinTone: null,
      bodyShape: null,
      breastSize: null,
      buttSize: null,
      fashion: null
    },
    profileImage: null,
    bio: null,
    hireDate: Date.now(), // Timestamp when hired
    
    // ========== CORPORATE CAREER DATA ==========
    career: {
      level: 1,  // Starting at Staff level
      title: "Staff",
      salary: 40000,
      startDate: Date.now(),
      promotionHistory: [],
      directReports: [],  // Array of employee IDs they manage
      managerId: null  // ID of their manager (if any)
    },
    
    // Rehire-specific flags
    isRehire: false,
    fastTrack: false,  // 50% faster promotions for rehires
    previousLevel: null,
    previousTitle: null,
    timesRehired: 0
    };
        candidates.push(cand);
    }
    return candidates;
    }

  // Handle manager hiring UI
  // Finalize manager hire (for former employees who skip onboarding)
  function finalizeManagerHire(candidate, product) {
    // Initialize social network data if not already present
    if (!candidate.socialData) {
      initializeEmployeeSocialData(candidate);
    }
    
    // Set hire date if not already set
    if (!candidate.hireDate) {
      candidate.hireDate = Date.now();
    }
    
    // CRITICAL FIX: Set employment status to active so they appear in People tab
    candidate.employmentStatus = 'active';
    
    // CRITICAL FIX: Ensure candidate is assigned to proper location
    if (!candidate.locationId) {
      candidate.locationId = product.locationId || 'headquarters';
      candidate.location = candidate.locationId;  // For backward compatibility
    }
    
    // Add to employees array
    gameState.employees.push(candidate);
    
    // Update company awareness
    updateCompanyAwareness();
    
    // Generate relationships with existing employees (or restore old ones)
    generateRandomRelationships(candidate.id);
    
    // Log rehire event
    logCompanyEvent({
      type: 'hire',
      involvedEmployees: [candidate.id],
      location: candidate.locationId || product.locationId || 'headquarters',
      description: `${candidate.name} returned as ${candidate.position}`,
      sentiment: 'positive',
      importance: 7
    });
    
    // Generate a "I'm back!" post
    generateFirstEmployeePost(candidate).catch(err => {
      console.error('Welcome back post generation failed:', err);
    });
    
    // Mark manager on product
    product.managerHired = true;
    product.managerId = candidate.id;  // CRITICAL FIX: Ensure managerId is set
    product.managerLevel = 1;
    product.managerOnboarding = false;
    
    // Automatically assign employee to Level 1 Staff position in pyramid
    const staffPosition = gameState.corporatePyramid.positions[1]?.find(
      pos => pos.productId === product.id
    );
    
    if (staffPosition) {
      staffPosition.employeeId = candidate.id;
      candidate.productManaged = product.name;
      
      // CRITICAL FIX: Update employee career to match position
      const levelInfo = gameState.hierarchyLevels[staffPosition.level] || gameState.hierarchyLevels[1];
      candidate.career.level = staffPosition.level;
      candidate.career.title = levelInfo.title;
      candidate.career.salary = levelInfo.baseSalary;
      
      console.log(`[Pyramid] Auto-assigned ${candidate.name} to ${staffPosition.title} - Career updated to ${candidate.career.title} (Level ${candidate.career.level})`);
    } else {
      // If position doesn't exist yet, create it
      initializeHierarchicalPyramid();
      const newStaffPosition = gameState.corporatePyramid.positions[1]?.find(
        pos => pos.productId === product.id
      );
      if (newStaffPosition) {
        newStaffPosition.employeeId = candidate.id;
        candidate.productManaged = product.name;
        
        // CRITICAL FIX: Update employee career to match position
        const levelInfo = gameState.hierarchyLevels[newStaffPosition.level] || gameState.hierarchyLevels[1];
        candidate.career.level = newStaffPosition.level;
        candidate.career.title = levelInfo.title;
        candidate.career.salary = levelInfo.baseSalary;
        
        console.log(`[Pyramid] Created and assigned ${candidate.name} to ${newStaffPosition.title} - Career updated to ${candidate.career.title} (Level ${candidate.career.level})`);
      }
    }
    
    // UI updates
    updatePeopleTab();
    updateProductsList();
    
    // Refresh dashboard to show returning employee
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
  }

  // Calculate loyalty bonus based on times rehired
  function calculateLoyaltyBonus(timesRehired) {
    // 5% bonus per rehire, up to 50% max
    return Math.min(0.50, timesRehired * 0.05);
  }

  /**
   * Select random employees from rehire pool
   * @param {number} count - Number of rehires to select
   * @returns {Array} Array of rehire candidates
   */
  function selectRandomRehires(count) {
    if (!gameState.rehirePool || gameState.rehirePool.length === 0) {
      return [];
    }
    
    // Shuffle and take first 'count' items
    const shuffled = [...gameState.rehirePool].sort(() => Math.random() - 0.5);
    return shuffled.slice(0, Math.min(count, shuffled.length));
  }

  /**
   * Finalize rehiring an employee
   * @param {number} rehireIndex - Index in currentCandidates array (when in rehire mode)
   * @param {number} startingLevel - Level to start at (1 or 2)
   */
  function finalizeRehire(rehireIndex, startingLevel = 1) {
    const rehireData = gameState.currentCandidates?.[rehireIndex];
    const productId = rehireData?.productId;
    const product = gameState.products.find(p => p.id === productId);
    
    if (!rehireData || !product) {
      console.error('[Rehire] Invalid rehire data or product');
      return;
    }
    
    // Verify this is actually a rehire
    if (!rehireData.isRehire) {
      console.error('[Rehire] Candidate is not marked as rehire');
      return;
    }
    
    // Check if player can afford
    if (gameState.cash < product.managerHireCost) {
      showNotification("Not enough money to hire!", 'error');
      return;
    }
    
    // Deduct cost
    gameState.cash -= product.managerHireCost;
    
    // Create employee with restored data
    const newEmployee = {
      // Identity
      id: `emp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      name: rehireData.name,
      age: rehireData.age,
      gender: rehireData.gender,
      
      // Career - START AT SELECTED LEVEL
      career: {
        level: startingLevel,
        title: gameState.hierarchyLevels[startingLevel].title,
        salary: gameState.hierarchyLevels[startingLevel].baseSalary,
        startDate: Date.now(),
        promotionHistory: [],
        directReports: [],
        managerId: null
      },
      
      // Restored data
      stats: {
        ...rehireData.stats,
        // Apply productivity bonus!
        productivity: Math.min(100, (rehireData.stats.productivity || 50) * (1 + rehireData.rehireBonus))
      },
      skills: rehireData.skills ? JSON.parse(JSON.stringify(rehireData.skills)) : {},
      personality: {...rehireData.personality},
      physical: {...rehireData.physical},
      profileImage: rehireData.profileImage,
      bio: rehireData.bio,
      
      // Memory
      memory: rehireData.memory ? {...rehireData.memory} : {},
      
      // Traits
      keyTrait: rehireData.keyTrait,
      personalityTraits: rehireData.personalityTraits ? [...rehireData.personalityTraits] : [],
      hobbies: rehireData.hobbies ? [...rehireData.hobbies] : [],
      kinks: rehireData.kinks ? [...rehireData.kinks] : [],
      
      // Gift preferences
      giftPreferences: rehireData.giftPreferences,
      
      // Rehire flags
      isRehire: true,
      fastTrack: true,  // 50% faster promotions!
      previousLevel: rehireData.previousLevel,
      previousTitle: rehireData.previousTitle,
      timesRehired: (rehireData.timesRehired || 0) + 1,
      
      // Assignment
      productId: productId,
      hired: true,
      onboarding: false,
      bioComplete: true,
      employmentStatus: 'active',
      hireDate: Date.now()
    };
    
    // Restore chat history
    if (rehireData.chatHistory && rehireData.chatHistory.length > 0) {
      gameState.chatHistory[newEmployee.id] = [...rehireData.chatHistory];
    }
    
    // Add to employee roster
    gameState.employees.push(newEmployee);
    
    // Remove from rehire pool (can't rehire same person twice in one run)
    const poolIndex = gameState.rehirePool.findIndex(r => r.id === rehireData.originalRehireId || r.id === rehireData.id);
    if (poolIndex !== -1) {
      gameState.rehirePool.splice(poolIndex, 1);
      console.log(`[Rehire] Removed ${newEmployee.name} from rehire pool (${gameState.rehirePool.length} remaining)`);
    } else {
      console.warn(`[Rehire] Could not find ${newEmployee.name} in rehire pool to remove`);
    }
    
    // Initialize social network data
    if (!newEmployee.socialData) {
      initializeEmployeeSocialData(newEmployee);
    }
    
    // Update hierarchy
    updateCorporateHierarchy();
    
    // Update company awareness
    updateCompanyAwareness();
    
    // Generate relationships with existing employees
    generateRandomRelationships(newEmployee.id);
    
    // Log company event
    logCompanyEvent({
      type: 'hire',
      involvedEmployees: [newEmployee.id],
      location: product.locationId || 'headquarters',
      description: `${newEmployee.name} returned as ${newEmployee.career.title}`,
      sentiment: 'positive',
      importance: 8
    });
    
    // Generate welcome back post
    generateWelcomeBackPost(newEmployee, rehireData);
    
    // Mark product as having manager
    product.managerHired = true;
    product.managerLevel = 1;
    product.managerOnboarding = false;
    
    // Automatically assign employee to Level 1 Staff position in pyramid
    const staffPosition = gameState.corporatePyramid.positions[1]?.find(
      pos => pos.productId === product.id
    );
    
    if (staffPosition) {
      staffPosition.employeeId = newEmployee.id;
      newEmployee.productManaged = product.name;
      console.log(`[Pyramid] Auto-assigned ${newEmployee.name} to ${staffPosition.title}`);
    } else {
      // If position doesn't exist yet, create it
      initializeHierarchicalPyramid();
      const newStaffPosition = gameState.corporatePyramid.positions[1]?.find(
        pos => pos.productId === product.id
      );
      if (newStaffPosition) {
        newStaffPosition.employeeId = newEmployee.id;
        newEmployee.productManaged = product.name;
        console.log(`[Pyramid] Created and assigned ${newEmployee.name} to ${newStaffPosition.title}`);
      }
    }
    
    // Update UI
    updatePeopleTab();
    updateProductsList();
    closeHiringModal();
    
    showNotification(`âœ¨ Welcome back, ${newEmployee.name}! Starting as ${newEmployee.career.title}`, 'success');
    
    console.log(`[Rehire] ${newEmployee.name} rehired at Level ${startingLevel} with ${Math.round(rehireData.rehireBonus * 100)}% bonus`);
  }

  /**
   * Generate welcome back social post
   * @param {object} employee - New employee object
   * @param {object} rehireData - Original rehire data
   */
  async function generateWelcomeBackPost(employee, rehireData) {
    if (!employee || !gameState.socialNetwork) return;
    
    const relationshipEmojis = {
      'very close': 'â¤ï¸ğŸ’•',
      'close': 'ğŸ˜ŠğŸ’¼',
      'friendly': 'ğŸ‘‹âœ¨',
      'professional': 'ğŸ’¼',
      'distant': 'ğŸ‘‹'
    };
    
    const emoji = relationshipEmojis[rehireData.relationshipStrength] || 'ğŸ’¼';
    
    const post = {
      id: `post_${++gameState.socialNetwork.postIdCounter}_${Date.now()}`,
      author: employee.name,
      authorId: employee.id,
      type: 'work',
      category: 'work',
      timestamp: gameState.time?.currentTime || Date.now(),
      contentType: 'text',
      caption: `${emoji} I'm back! Excited to rejoin the team${employee.fastTrack ? ' and they\'ve put me on the fast track! ğŸš€' : '!'} Feels good to be home. @TheBoss let's do this! ğŸ’ª`,
      likes: Math.floor(Math.random() * 30) + 15,
      comments: [],
      imageUrl: null,
      altText: null,
      hasImage: false,
      explicit: false
    };
    
    gameState.socialNetwork.posts.unshift(post);
    
    // Trim posts if too many
    if (gameState.socialNetwork.posts.length > 100) {
      gameState.socialNetwork.posts = gameState.socialNetwork.posts.slice(0, 100);
    }
    
    console.log(`[Welcome Back Post] Generated post for ${employee.name}'s return`);
  }

  function showManagerHiringModal(productId) {
    const product = gameState.products.find(p => p.id === productId);
    if (!product) return;

    // Store product ID for later use
    gameState.currentHiringProductId = productId;
    
    // Initialize hiring mode state
    if (typeof gameState.hiringMode === 'undefined') {
      gameState.hiringMode = 'new'; // 'new' or 'rehire'
    }
    
    // Check if rehire pool has any candidates
    const hasRehireCandidates = gameState.rehirePool && gameState.rehirePool.length > 0;
    
    // Create modal
    const modal = document.createElement('div');
    modal.id = 'hiringModal';
    modal.style.background = 'rgba(0,0,0,0.7)';
    
    // Function to render candidates based on current mode
    function renderCandidates() {
      let candidates = [];
      
      if (gameState.hiringMode === 'rehire' && hasRehireCandidates) {
        // Get 3 random candidates from rehire pool
        candidates = selectRandomRehires(3).map(rehireData => ({
          ...rehireData,
          originalRehireId: rehireData.id, // Preserve original ID to find in rehire pool
          id: `rehire_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          productId: productId,
          isRehire: true,
          loyaltyBonus: calculateLoyaltyBonus(rehireData.timesRehired || 0),
          hired: false,
          employmentStatus: 'candidate'
        }));
      } else {
        // Generate new candidates
        candidates = generatePotentialHires(productId);
      }
      
      gameState.currentCandidates = candidates;

    const cards = candidates.map((c, i) => {
      const isRehire = c.isRehire || false;
      
      // Initialize skills for candidates if not present
      if (!c.skills && !isRehire) {
        c.skills = {
          technical: { level: 1, xp: 0, maxXp: 500 },
          creative: { level: 1, xp: 0, maxXp: 500 },
          social: { level: 1, xp: 0, maxXp: 500 },
          management: { level: 1, xp: 0, maxXp: 500 },
          intimate: { level: 0, xp: 0, maxXp: 500 },
          cooking: { level: 0, xp: 0, maxXp: 500 },
          fitness: { level: 0, xp: 0, maxXp: 500 }
        };
        
        // Give random starting skills (1-4 range for new hires)
        c.skills.technical.level = 1 + Math.floor(Math.random() * 3);
        c.skills.creative.level = 1 + Math.floor(Math.random() * 3);
        c.skills.social.level = 1 + Math.floor(Math.random() * 3);
        c.skills.management.level = 1 + Math.floor(Math.random() * 3);
        c.skills.fitness.level = Math.floor(Math.random() * 3); // 0-2
        c.skills.cooking.level = Math.floor(Math.random() * 3); // 0-2
        
        // Add some XP variance
        Object.values(c.skills).forEach(skill => {
          if (skill.level > 0) {
            skill.xp = Math.floor(Math.random() * skill.maxXp * 0.5);
          }
        });
      }
      
      const skills = c.skills || {};
      
      // Calculate potential productivity bonus from skills
      const avgWorkSkills = ((skills.technical?.level || 1) + (skills.creative?.level || 1) + 
                             (skills.social?.level || 1) + (skills.management?.level || 1)) / 4;
      const skillBonus = Math.round((avgWorkSkills - 1) * 10); // ~0-30% bonus
      
      // Top 2 skills for resume display
      const workSkills = [
        { name: 'Technical', level: skills.technical?.level || 1, emoji: 'ğŸ’»' },
        { name: 'Creative', level: skills.creative?.level || 1, emoji: 'ğŸ¨' },
        { name: 'Social', level: skills.social?.level || 1, emoji: 'ğŸ¤' },
        { name: 'Management', level: skills.management?.level || 1, emoji: 'ğŸ“Š' }
      ].sort((a, b) => b.level - a.level).slice(0, 2);
      
      const lifeSkills = [
        { name: 'Fitness', level: skills.fitness?.level || 0, emoji: 'ğŸ’ª' },
        { name: 'Cooking', level: skills.cooking?.level || 0, emoji: 'ğŸ³' }
      ].filter(s => s.level > 0).slice(0, 2);
      
      const loyaltyText = isRehire ? `<div style="background:#ffd700; color:#0f1419; padding:8px; border-radius:6px; margin-bottom:8px; font-weight:bold; text-align:center;">
        â­ FORMER EMPLOYEE â­<br/>
        <span style="font-size:0.9rem;">Loyalty Bonus: +${(c.loyaltyBonus * 100).toFixed(0)}% productivity</span><br/>
        <span style="font-size:0.8rem;">Times Rehired: ${c.timesRehired || 0}</span>
      </div>` : '';
      
      // Get race display info
      const raceInfo = getRaceDisplayInfo(c.race || 'human');
      
      return `
        <div class="candidate-card" style="background:${isRehire ? '#1a2a1a' : '#16213e'}; border:${isRehire ? '3px solid #ffd700' : '2px solid #1e3a5f'}; border-radius:12px; padding:18px; margin:10px; width:320px; position:relative;">
        ${isRehire ? '<div style="position:absolute; top:8px; right:8px; font-size:1.5rem;">ğŸ’›</div>' : ''}
        ${loyaltyText}
        
        <!-- Header: Name & Age -->
        <div style="margin-bottom:12px;">
          <h3 style="margin:0 0 4px 0; font-size:1.3rem;">${getColoredName(c)} ${c.age ? `â€¢ ${c.age}` : ''}</h3>
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
            <span style="background:${raceInfo.color}; color:#0f1419; padding:3px 8px; border-radius:4px; font-size:0.75rem; font-weight:600;">${raceInfo.emoji} ${raceInfo.label}</span>
            <p style="margin:0; color:#ffd700; font-size:0.85rem; font-weight:600;">ğŸ“„ CANDIDATE RESUME</p>
          </div>
        </div>
        
        <!-- Personality Summary -->
        <div style="background:rgba(255,215,0,0.05); padding:10px; border-radius:8px; margin-bottom:12px; border-left:3px solid #ffd700;">
          <div style="font-size:0.75rem; color:#ffd700; margin-bottom:4px; font-weight:600;">PERSONALITY PROFILE</div>
          <p style="margin:0; font-size:0.9rem; color:#ddd;"><strong>${c.keyTrait || 'Dedicated'}</strong></p>
          <p style="margin:4px 0 0 0; font-size:0.85rem; color:#aaa;">${(c.personalityTraits || []).slice(0, 3).join(' â€¢ ') || 'Professional'}</p>
        </div>
        
        <!-- Professional Skills -->
        <div style="margin-bottom:12px;">
          <div style="font-size:0.75rem; color:#00d4ff; margin-bottom:6px; font-weight:600;">ğŸ’¼ PROFESSIONAL SKILLS</div>
          <div style="display:flex; flex-direction:column; gap:6px;">
            ${workSkills.map(skill => `
              <div style="display:flex; justify-content:space-between; align-items:center; background:#0f3460; padding:8px 10px; border-radius:6px;">
                <span style="font-size:0.9rem;">${skill.emoji} ${skill.name}</span>
                <div style="display:flex; align-items:center; gap:6px;">
                  <div style="background:#1e3a5f; border-radius:10px; height:8px; width:60px; overflow:hidden;">
                    <div style="background:${skill.level >= 3 ? '#4ecca3' : '#00d4ff'}; height:100%; width:${skill.level * 25}%; transition:width 0.3s;"></div>
                  </div>
                  <span style="color:#ffd700; font-weight:600; font-size:0.9rem; min-width:30px; text-align:right;">Lv ${skill.level}</span>
                </div>
              </div>
            `).join('')}
          </div>
          ${skillBonus > 0 ? `<div style="margin-top:6px; font-size:0.75rem; color:#4ecca3; text-align:right;">+${skillBonus}% skill productivity bonus</div>` : ''}
        </div>
        
        ${lifeSkills.length > 0 ? `
        <!-- Personal Skills -->
        <div style="margin-bottom:12px;">
          <div style="font-size:0.75rem; color:#ff6b9d; margin-bottom:6px; font-weight:600;">ğŸŒŸ PERSONAL INTERESTS</div>
          <div style="display:flex; gap:6px;">
            ${lifeSkills.map(skill => `
              <div style="flex:1; background:#0f3460; padding:6px; border-radius:6px; text-align:center;">
                <div style="font-size:1.2rem; margin-bottom:2px;">${skill.emoji}</div>
                <div style="font-size:0.75rem; color:#aaa;">${skill.name}</div>
                <div style="color:#ff6b9d; font-weight:600; font-size:0.8rem;">Lv ${skill.level}</div>
              </div>
            `).join('')}
          </div>
        </div>
        ` : ''}
        
        <!-- Hobbies -->
        ${(c.hobbies || []).length > 0 ? `
        <div style="margin-bottom:12px;">
          <div style="font-size:0.75rem; color:#c77dff; margin-bottom:4px; font-weight:600;">ğŸ¯ HOBBIES</div>
          <p style="margin:0; font-size:0.85rem; color:#aaa;">${(c.hobbies || []).join(', ')}</p>
        </div>
        ` : ''}
        
        <!-- Work Stats -->
        <div style="margin-bottom:12px;">
          <div style="font-size:0.75rem; color:#4ecca3; margin-bottom:6px; font-weight:600;">ğŸ“Š WORK PERFORMANCE</div>
          <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:6px;">
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
              <div style="font-size:0.7rem; color:#aaa;">Productivity</div>
              <div style="color:#ffd700; font-weight:600; font-size:1rem;">${Math.round((c.stats.productivity ?? 0) * (1 + (c.loyaltyBonus || 0)))}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
              <div style="font-size:0.7rem; color:#aaa;">Trust</div>
              <div style="color:#00d4ff; font-weight:600; font-size:1rem;">${Math.round(c.stats.trust ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
              <div style="font-size:0.7rem; color:#aaa;">Professional</div>
              <div style="color:#4ecca3; font-weight:600; font-size:1rem;">${Math.round(c.personality?.professional ?? 50)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
              <div style="font-size:0.7rem; color:#aaa;">Confidence</div>
              <div style="color:#e94560; font-weight:600; font-size:1rem;">${Math.round(c.personality?.confidence ?? 50)}%</div>
            </div>
          </div>
        </div>

        <button class="select-candidate-btn" data-index="${i}" style="width:100%; padding:12px; background:${isRehire ? '#ffd700' : 'linear-gradient(135deg, #e94560 0%, #0f3460 100%)'}; border:none; border-radius:8px; color:${isRehire ? '#0f1419' : '#fff'}; cursor:pointer; font-weight:bold; font-size:1rem; transition:transform 0.2s;">
            ${isRehire ? 'â­ Rehire' : 'ğŸ“ Hire'} ${c.name}
        </button>
        </div>
    `;
    }).join('');
    
    return cards;
  }

  // Initial render
  const initialCards = renderCandidates();

  modal.innerHTML = `
    <div class="hiring-modal-panel" role="dialog" aria-modal="true" aria-label="Select an Employee" style="background:#0f1419; width:92%; max-width:1100px; max-height:85vh; overflow-y:auto; padding:18px; border-radius:14px; box-shadow:0 5px 25px rgba(0,0,0,0.5); pointer-events:auto; margin:auto;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; position:sticky; top:0; background:#0f1419; z-index:10; padding-bottom:10px; border-bottom:1px solid rgba(255,255,255,0.1);">
      <h2 style="margin:0;">Select an Employee for ${product.name}</h2>
      <button class="close-modal-btn" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âœ•</button>
    </div>
    
    <!-- Hiring Mode Toggle (always visible) -->
    <div style="display:flex; justify-content:center; gap:10px; margin-bottom:16px; padding:10px; background:rgba(255,255,255,0.05); border-radius:8px;">
      <button class="hiring-mode-toggle" data-mode="new" style="flex:1; padding:10px 20px; background:${gameState.hiringMode === 'new' ? 'linear-gradient(135deg, #e94560 0%, #0f3460 100%)' : 'transparent'}; border:2px solid ${gameState.hiringMode === 'new' ? '#e94560' : '#555'}; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
        ğŸ“ New Hires
      </button>
      <button class="hiring-mode-toggle" data-mode="rehire" ${!hasRehireCandidates ? 'disabled' : ''} style="flex:1; padding:10px 20px; background:${gameState.hiringMode === 'rehire' && hasRehireCandidates ? 'linear-gradient(135deg, #ffd700 0%, #ff8c00 100%)' : 'transparent'}; border:2px solid ${gameState.hiringMode === 'rehire' && hasRehireCandidates ? '#ffd700' : '#555'}; border-radius:8px; color:${gameState.hiringMode === 'rehire' && hasRehireCandidates ? '#0f1419' : hasRehireCandidates ? 'white' : '#555'}; cursor:${hasRehireCandidates ? 'pointer' : 'not-allowed'}; font-weight:600; transition:all 0.3s; opacity:${hasRehireCandidates ? '1' : '0.5'};">
        â­ Rehire Former Employees ${hasRehireCandidates ? `(${gameState.rehirePool.length})` : '(0)'}
      </button>
      <button class="hiring-mode-toggle" data-mode="custom" style="flex:1; padding:10px 20px; background:${gameState.hiringMode === 'custom' ? 'linear-gradient(135deg, #4ecca3 0%, #00d4ff 100%)' : 'transparent'}; border:2px solid ${gameState.hiringMode === 'custom' ? '#4ecca3' : '#555'}; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
        âœ¨ Custom Employee
      </button>
    </div>
    
    <div id="candidates-container" style="display:flex; justify-content:center; flex-wrap:wrap; gap:12px;">
      ${initialCards}
    </div>
    
    <!-- Custom Employee Creation Container (hidden by default) -->
    <div id="custom-employee-container" style="display:none; padding:20px; background:#16213e; border-radius:12px; margin-top:10px;">
      <!-- Custom Mode Sub-Toggle -->
      <div style="display:flex; justify-content:center; gap:10px; margin-bottom:20px;">
        <button class="custom-mode-toggle" data-submode="quick" style="padding:10px 20px; background:linear-gradient(135deg, #4ecca3 0%, #00d4ff 100%); border:2px solid #4ecca3; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
          âš¡ Quick (AI-Assisted)
        </button>
        <button class="custom-mode-toggle" data-submode="manual" style="padding:10px 20px; background:transparent; border:2px solid #555; border-radius:8px; color:white; cursor:pointer; font-weight:600; transition:all 0.3s;">
          ğŸ“‹ Manual (Full Form)
        </button>
      </div>
      
      <!-- Quick Mode Content -->
      <div id="quick-mode-content" style="display:block;">
        <div style="text-align:center; margin-bottom:20px;">
          <h3 style="margin:0 0 10px 0; color:#4ecca3;">âš¡ Quick Character Creation</h3>
          <p style="color:#aaa; font-size:0.9rem; margin:0;">Create an employee from a URL (wiki page, character page) or describe them with AI</p>
        </div>
        
        <!-- Recover Last Character Button (only shows if there's pending data) -->
        <div id="recoverCharacterSection" style="display:none; background:linear-gradient(135deg, #ff6b6b 0%, #ffa502 100%); padding:15px; border-radius:8px; margin-bottom:15px;">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
            <div>
              <div style="font-weight:600; color:white;">ğŸ”„ Recover Last Character</div>
              <div id="recoverCharacterInfo" style="font-size:0.85rem; color:rgba(255,255,255,0.8);"></div>
            </div>
            <button id="recoverCharacterBtn" style="padding:10px 20px; background:white; border:none; border-radius:6px; color:#333; cursor:pointer; font-weight:600; white-space:nowrap;">
              â™»ï¸ Recover
            </button>
          </div>
        </div>
        
        <!-- URL-based creation -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <label style="display:block; margin-bottom:8px; color:#00d4ff; font-weight:600;">ğŸ”— Create from URL</label>
          <div style="display:flex; gap:10px;">
            <input type="text" id="customEmployeeUrlInput" placeholder="https://wiki.example.com/Character_Name" style="flex:1; padding:10px; background:#0f1419; border:1px solid #4ecca3; border-radius:6px; color:white; font-size:0.95rem;">
            <button id="generateFromUrlBtn" style="padding:10px 20px; background:linear-gradient(135deg, #4ecca3 0%, #00d4ff 100%); border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; white-space:nowrap;">
              âœ¨ Generate
            </button>
          </div>
          <p style="color:#666; font-size:0.8rem; margin:8px 0 0 0;">Works with wiki pages, fandom pages, character databases, etc.</p>
        </div>
        
        <!-- AI Prompt-based creation -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <label style="display:block; margin-bottom:8px; color:#ff6b9d; font-weight:600;">ğŸ¤– Create from Description</label>
          <textarea id="customEmployeePromptInput" placeholder="Describe your employee... e.g., 'A confident redhead in her late 20s who loves photography and has a mischievous personality. She's a former model turned marketing expert.'" style="width:100%; min-height:80px; padding:10px; background:#0f1419; border:1px solid #ff6b9d; border-radius:6px; color:white; font-size:0.95rem; resize:vertical; font-family:inherit;"></textarea>
          <button id="generateFromPromptBtn" style="width:100%; margin-top:10px; padding:12px; background:linear-gradient(135deg, #ff6b9d 0%, #c77dff 100%); border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">
            ğŸ¨ Generate Employee from Description
          </button>
        </div>
        
        <!-- Optional Extra Instructions -->
        <div style="background:#0f3460; padding:15px; border-radius:8px;">
          <label style="display:block; margin-bottom:8px; color:#ffd700; font-weight:600;">âš™ï¸ Additional Instructions (Optional)</label>
          <input type="text" id="customEmployeeExtraInstructions" placeholder="e.g., 'Make her more dominant' or 'She should be shy at first'" style="width:100%; padding:10px; background:#0f1419; border:1px solid #ffd700; border-radius:6px; color:white; font-size:0.95rem;">
        </div>
      </div>
      
      <!-- Manual Mode Content -->
      <div id="manual-mode-content" style="display:none; max-height:60vh; overflow-y:auto; padding-right:5px;">
        <div style="text-align:center; margin-bottom:20px;">
          <h3 style="margin:0 0 10px 0; color:#c77dff;">ğŸ“‹ Full Character Creator</h3>
          <p style="color:#aaa; font-size:0.9rem; margin:0;">Complete control over every aspect - AI fills empty fields intelligently</p>
        </div>
        
        <!-- Collapsible Sections Container -->
        
        <!-- Basic Info Section -->
        <details open style="background:#0f3460; border-radius:8px; margin-bottom:10px;">
          <summary style="padding:12px 15px; cursor:pointer; color:#4ecca3; font-weight:600; user-select:none;">ğŸ‘¤ Basic Information</summary>
          <div style="padding:0 15px 15px 15px;">
            <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(140px, 1fr)); gap:10px;">
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">Name</label>
                <input type="text" id="manualName" placeholder="Random" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.9rem;">
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">Age (18+)</label>
                <input type="number" id="manualAge" placeholder="18+" min="18" max="99" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.9rem;">
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">Gender</label>
                <select id="manualGender" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.9rem;">
                  <option value="">Auto</option>
                  <option value="female">Female</option>
                  <option value="male">Male</option>
                  <option value="female_futa">Futa</option>
                  <option value="trans_woman">Trans Woman</option>
                  <option value="trans_man">Trans Man</option>
                  <option value="non-binary">Non-Binary</option>
                </select>
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">Race/Species</label>
                <select id="manualRace" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.9rem;">
                  <option value="">Auto</option>
                  <option value="human">Human</option>
                  <option value="elf">Elf</option>
                  <option value="catgirl">Catgirl</option>
                  <option value="succubus">Succubus</option>
                  <option value="demon">Demon</option>
                </select>
              </div>
            </div>
          </div>
        </details>
        
        <!-- Personality Section (C.O.F.P.H.) -->
        <details open style="background:#0f3460; border-radius:8px; margin-bottom:10px;">
          <summary style="padding:12px 15px; cursor:pointer; color:#ff6b9d; font-weight:600; user-select:none;">ğŸ’« Personality (C.O.F.P.H.)</summary>
          <div style="padding:0 15px 15px 15px;">
            <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(140px, 1fr)); gap:8px;">
              <div>
                <label style="display:block; margin-bottom:2px; color:#aaa; font-size:0.75rem;">Confidence <span id="manualConfidenceValue" style="color:#4ecca3;">50</span></label>
                <input type="range" id="manualConfidence" min="0" max="100" value="50" style="width:100%;">
              </div>
              <div>
                <label style="display:block; margin-bottom:2px; color:#aaa; font-size:0.75rem;">Outgoing <span id="manualOutgoingValue" style="color:#4ecca3;">50</span></label>
                <input type="range" id="manualOutgoing" min="0" max="100" value="50" style="width:100%;">
              </div>
              <div>
                <label style="display:block; margin-bottom:2px; color:#aaa; font-size:0.75rem;">Flirty <span id="manualFlirtyValue" style="color:#4ecca3;">50</span></label>
                <input type="range" id="manualFlirty" min="0" max="100" value="50" style="width:100%;">
              </div>
              <div>
                <label style="display:block; margin-bottom:2px; color:#aaa; font-size:0.75rem;">Professional <span id="manualProfessionalValue" style="color:#4ecca3;">50</span></label>
                <input type="range" id="manualProfessional" min="0" max="100" value="50" style="width:100%;">
              </div>
              <div>
                <label style="display:block; margin-bottom:2px; color:#aaa; font-size:0.75rem;">Humor <span id="manualHumorValue" style="color:#4ecca3;">50</span></label>
                <input type="range" id="manualHumor" min="0" max="100" value="50" style="width:100%;">
              </div>
            </div>
          </div>
        </details>
        
        <!-- Relationship Stats Section -->
        <details style="background:#0f3460; border-radius:8px; margin-bottom:10px;">
          <summary style="padding:12px 15px; cursor:pointer; color:#e94560; font-weight:600; user-select:none;">â¤ï¸ Starting Relationship Stats</summary>
          <div style="padding:0 15px 15px 15px;">
            <p style="color:#666; font-size:0.75rem; margin:0 0 10px 0;">Set initial relationship levels (default: randomized based on HR settings)</p>
            <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(140px, 1fr)); gap:8px;">
              <div>
                <label style="display:block; margin-bottom:2px; color:#e94560; font-size:0.75rem;">â¤ï¸ Affection <span id="manualAffectionValue" style="color:#e94560;">-</span></label>
                <input type="range" id="manualAffection" min="0" max="100" value="-1" style="width:100%;">
              </div>
              <div>
                <label style="display:block; margin-bottom:2px; color:#4ecca3; font-size:0.75rem;">ğŸ˜Š Comfort <span id="manualComfortValue" style="color:#4ecca3;">-</span></label>
                <input type="range" id="manualComfort" min="0" max="100" value="-1" style="width:100%;">
              </div>
              <div>
                <label style="display:block; margin-bottom:2px; color:#00d4ff; font-size:0.75rem;">ğŸ¤ Trust <span id="manualTrustValue" style="color:#00d4ff;">-</span></label>
                <input type="range" id="manualTrust" min="0" max="100" value="-1" style="width:100%;">
              </div>
              <div>
                <label style="display:block; margin-bottom:2px; color:#ff6b9d; font-size:0.75rem;">ğŸ’• Desire <span id="manualDesireValue" style="color:#ff6b9d;">-</span></label>
                <input type="range" id="manualDesire" min="0" max="100" value="-1" style="width:100%;">
              </div>
              <div>
                <label style="display:block; margin-bottom:2px; color:#ffd700; font-size:0.75rem;">ğŸ¤— Friendship <span id="manualFriendshipValue" style="color:#ffd700;">-</span></label>
                <input type="range" id="manualFriendship" min="0" max="100" value="-1" style="width:100%;">
              </div>
              <div>
                <label style="display:block; margin-bottom:2px; color:#c77dff; font-size:0.75rem;">ğŸ”— Obedience <span id="manualObedienceValue" style="color:#c77dff;">-</span></label>
                <input type="range" id="manualObedience" min="0" max="100" value="-1" style="width:100%;">
              </div>
            </div>
          </div>
        </details>
        
        <!-- Work Stats Section -->
        <details style="background:#0f3460; border-radius:8px; margin-bottom:10px;">
          <summary style="padding:12px 15px; cursor:pointer; color:#ffd700; font-weight:600; user-select:none;">ğŸ’¼ Work Performance</summary>
          <div style="padding:0 15px 15px 15px;">
            <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(140px, 1fr)); gap:8px;">
              <div>
                <label style="display:block; margin-bottom:2px; color:#ffd700; font-size:0.75rem;">ğŸ’¼ Productivity <span id="manualProductivityValue" style="color:#ffd700;">-</span></label>
                <input type="range" id="manualProductivity" min="0" max="100" value="-1" style="width:100%;">
              </div>
            </div>
            <div style="margin-top:12px;">
              <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">Starting Position Level</label>
              <select id="manualCareerLevel" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.9rem;">
                <option value="1">Staff (Level 1) - Default</option>
                <option value="2">Local Manager (Level 2)</option>
                <option value="3">Regional Manager (Level 3)</option>
                <option value="4">Branch Manager (Level 4)</option>
                <option value="5">Division Head (Level 5)</option>
              </select>
            </div>
            
            <!-- Position Slot Selector (shown when level > 1 or when there are multiple slots) -->
            <div id="positionSlotSelector" style="margin-top:10px; display:none;">
              <label style="display:block; margin-bottom:4px; color:#ff6b9d; font-size:0.8rem;">âš ï¸ Assign to Position Slot</label>
              <select id="manualPositionSlot" style="width:100%; padding:8px; background:#0f1419; border:1px solid #ff6b9d; border-radius:4px; color:white; font-size:0.9rem;">
                <!-- Options populated dynamically -->
              </select>
              <p id="positionSlotWarning" style="color:#ff6b9d; font-size:0.75rem; margin:6px 0 0 0;"></p>
            </div>
            
            <div style="margin-top:10px;">
              <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">Custom Salary (optional)</label>
              <input type="number" id="manualSalary" placeholder="Auto-calculate from level" min="0" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.9rem;">
            </div>
          </div>
        </details>
        
        <!-- Traits & Interests Section -->
        <details style="background:#0f3460; border-radius:8px; margin-bottom:10px;">
          <summary style="padding:12px 15px; cursor:pointer; color:#00d4ff; font-weight:600; user-select:none;">ğŸ¯ Traits & Interests</summary>
          <div style="padding:0 15px 15px 15px;">
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">Personality Traits</label>
                <input type="text" id="manualTraits" placeholder="Playful, Confident, Witty" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">Hobbies</label>
                <input type="text" id="manualHobbies" placeholder="Photography, Gaming, Yoga" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
              </div>
            </div>
            <div style="margin-top:10px;">
              <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">Kinks/Preferences (comma separated)</label>
              <input type="text" id="manualKinks" placeholder="Roleplay, Teasing, Praise" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
            </div>
            <div style="margin-top:10px;">
              <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">Key Trait (main defining trait)</label>
              <input type="text" id="manualKeyTrait" placeholder="e.g., Charismatic, Analytical, Creative" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
            </div>
          </div>
        </details>
        
        <!-- Physical Appearance Section -->
        <details style="background:#0f3460; border-radius:8px; margin-bottom:10px;">
          <summary style="padding:12px 15px; cursor:pointer; color:#c77dff; font-weight:600; user-select:none;">ğŸ‘ï¸ Physical Appearance</summary>
          <div style="padding:0 15px 15px 15px;">
            <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(120px, 1fr)); gap:8px;">
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.75rem;">Hair Color</label>
                <input type="text" id="manualHairColor" placeholder="Red, Blonde" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.75rem;">Hair Style</label>
                <input type="text" id="manualHairStyle" placeholder="Long waves" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.75rem;">Hair Length</label>
                <select id="manualHairLength" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
                  <option value="">Auto</option>
                  <option value="short">Short</option>
                  <option value="medium">Medium</option>
                  <option value="long">Long</option>
                  <option value="very long">Very Long</option>
                </select>
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.75rem;">Eye Color</label>
                <input type="text" id="manualEyeColor" placeholder="Blue, Green" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.75rem;">Eye Shape</label>
                <input type="text" id="manualEyeShape" placeholder="Almond, Round" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.75rem;">Skin Tone</label>
                <input type="text" id="manualSkinTone" placeholder="Fair, Tan, Dark" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.75rem;">Body Shape</label>
                <select id="manualBodyShape" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
                  <option value="">Auto</option>
                  <option value="petite">Petite</option>
                  <option value="slim">Slim</option>
                  <option value="athletic">Athletic</option>
                  <option value="average">Average</option>
                  <option value="curvy">Curvy</option>
                  <option value="plus-size">Plus-size</option>
                  <option value="muscular">Muscular</option>
                </select>
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.75rem;">Height/Build</label>
                <input type="text" id="manualHeightBuild" placeholder="5'6 slim" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.75rem;">Breast Size</label>
                <select id="manualBreastSize" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
                  <option value="">Auto</option>
                  <option value="flat">Flat</option>
                  <option value="small">Small</option>
                  <option value="medium">Medium</option>
                  <option value="large">Large</option>
                  <option value="very large">Very Large</option>
                </select>
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.75rem;">Butt Size</label>
                <select id="manualButtSize" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
                  <option value="">Auto</option>
                  <option value="small">Small</option>
                  <option value="medium">Medium</option>
                  <option value="large">Large</option>
                  <option value="very large">Very Large</option>
                </select>
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.75rem;">Fashion Style</label>
                <input type="text" id="manualFashion" placeholder="Casual, Professional" style="width:100%; padding:6px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
              </div>
            </div>
            <div style="margin-top:10px;">
              <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">Notable Features</label>
              <input type="text" id="manualNotableFeatures" placeholder="Freckles, Tattoos, Piercings, Glasses, etc." style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
            </div>
          </div>
        </details>
        
        <!-- Personal Life Section -->
        <details style="background:#0f3460; border-radius:8px; margin-bottom:10px;">
          <summary style="padding:12px 15px; cursor:pointer; color:#ff6b9d; font-weight:600; user-select:none;">ğŸ  Personal Life</summary>
          <div style="padding:0 15px 15px 15px;">
            <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(140px, 1fr)); gap:10px;">
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">Living Situation</label>
                <select id="manualLivingSituation" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
                  <option value="">Auto</option>
                  <option value="apartment">Apartment</option>
                  <option value="house">House</option>
                  <option value="condo">Condo</option>
                  <option value="studio">Studio</option>
                  <option value="with-roommate">With Roommate</option>
                  <option value="with-family">With Family</option>
                </select>
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">Relationship Status</label>
                <select id="manualRelationshipStatus" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
                  <option value="">Auto</option>
                  <option value="single">Single</option>
                  <option value="dating">Dating</option>
                  <option value="serious">In Relationship</option>
                  <option value="engaged">Engaged</option>
                  <option value="married">Married</option>
                  <option value="divorced">Divorced</option>
                  <option value="widowed">Widowed</option>
                  <option value="complicated">It's Complicated</option>
                </select>
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">Has Pet?</label>
                <select id="manualHasPet" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.85rem;">
                  <option value="">Random</option>
                  <option value="no">No</option>
                  <option value="cat">Cat</option>
                  <option value="dog">Dog</option>
                  <option value="bird">Bird</option>
                  <option value="fish">Fish</option>
                  <option value="other">Other Pet</option>
                </select>
              </div>
            </div>
          </div>
        </details>
        
        <!-- Schedule Section -->
        <details style="background:#0f3460; border-radius:8px; margin-bottom:10px;">
          <summary style="padding:12px 15px; cursor:pointer; color:#4ecca3; font-weight:600; user-select:none;">ğŸ• Work Schedule</summary>
          <div style="padding:0 15px 15px 15px;">
            <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(140px, 1fr)); gap:10px;">
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">Start Hour (24h)</label>
                <input type="number" id="manualWorkStart" placeholder="9" min="0" max="23" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.9rem;">
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">End Hour (24h)</label>
                <input type="number" id="manualWorkEnd" placeholder="17" min="0" max="23" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.9rem;">
              </div>
              <div>
                <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">PTO Days</label>
                <input type="number" id="manualPTO" placeholder="10" min="0" max="30" style="width:100%; padding:8px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-size:0.9rem;">
              </div>
            </div>
            <div style="margin-top:10px;">
              <label style="display:block; margin-bottom:4px; color:#aaa; font-size:0.8rem;">Work Days</label>
              <div style="display:flex; gap:5px; flex-wrap:wrap;">
                <label style="display:flex; align-items:center; gap:3px; color:#aaa; font-size:0.8rem;">
                  <input type="checkbox" id="manualWorkMon" checked> Mon
                </label>
                <label style="display:flex; align-items:center; gap:3px; color:#aaa; font-size:0.8rem;">
                  <input type="checkbox" id="manualWorkTue" checked> Tue
                </label>
                <label style="display:flex; align-items:center; gap:3px; color:#aaa; font-size:0.8rem;">
                  <input type="checkbox" id="manualWorkWed" checked> Wed
                </label>
                <label style="display:flex; align-items:center; gap:3px; color:#aaa; font-size:0.8rem;">
                  <input type="checkbox" id="manualWorkThu" checked> Thu
                </label>
                <label style="display:flex; align-items:center; gap:3px; color:#aaa; font-size:0.8rem;">
                  <input type="checkbox" id="manualWorkFri" checked> Fri
                </label>
                <label style="display:flex; align-items:center; gap:3px; color:#aaa; font-size:0.8rem;">
                  <input type="checkbox" id="manualWorkSat"> Sat
                </label>
                <label style="display:flex; align-items:center; gap:3px; color:#aaa; font-size:0.8rem;">
                  <input type="checkbox" id="manualWorkSun"> Sun
                </label>
              </div>
            </div>
          </div>
        </details>
        
        <!-- Starting Flags Section -->
        <details style="background:#0f3460; border-radius:8px; margin-bottom:10px;">
          <summary style="padding:12px 15px; cursor:pointer; color:#e94560; font-weight:600; user-select:none;">ğŸš© Starting Flags (Advanced)</summary>
          <div style="padding:0 15px 15px 15px;">
            <p style="color:#666; font-size:0.75rem; margin:0 0 10px 0;">Add custom flags/tags for this character (comma separated)</p>
            <input type="text" id="manualFlags" placeholder="e.g., exhibitionist_curious, dom_leaning, pet_owner" style="width:100%; padding:8px; background:#0f1419; border:1px solid #e94560; border-radius:4px; color:white; font-size:0.85rem;">
            <p style="color:#555; font-size:0.7rem; margin:8px 0 0 0;">Common flags: shy, dominant, submissive, curious, experienced, virgin, kinky, vanilla</p>
          </div>
        </details>
        
        <!-- Bio Section -->
        <details open style="background:#0f3460; border-radius:8px; margin-bottom:10px;">
          <summary style="padding:12px 15px; cursor:pointer; color:#ffd700; font-weight:600; user-select:none;">ğŸ“ Biography & Backstory</summary>
          <div style="padding:0 15px 15px 15px;">
            <textarea id="manualBio" placeholder="Write their backstory, motivations, secrets, and personality quirks... Leave blank to auto-generate based on other fields." style="width:100%; min-height:100px; padding:10px; background:#0f1419; border:1px solid #555; border-radius:4px; color:white; font-family:inherit; resize:vertical; font-size:0.9rem;"></textarea>
          </div>
        </details>
        
        <!-- Create Button -->
        <button id="createManualEmployeeBtn" style="width:100%; padding:15px; background:linear-gradient(135deg, #c77dff 0%, #4ecca3 100%); border:none; border-radius:8px; color:white; cursor:pointer; font-weight:bold; font-size:1.1rem; position:sticky; bottom:0;">
          âœ¨ Create Custom Employee
        </button>
      </div>
    </div>
    <p style="margin-top:12px; color:#aaa; font-size:.9rem;">Youâ€™ll be charged <strong>${product.managerHireCost}</strong> when you choose a candidate.</p>
    </div>
  `;

    // Use ModalManager to show the modal
    ModalManager.show(modal, 'hiringModal');

    // Set up event listeners for background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeHiringModal();
      }
    });

    // Set up close button listener
    const closeBtn = modal.querySelector('.close-modal-btn');
    if (closeBtn) {
      closeBtn.addEventListener('click', closeHiringModal);
    }

    // Set up select candidate buttons
    const selectButtons = modal.querySelectorAll('.select-candidate-btn');
    selectButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const index = parseInt(btn.dataset.index, 10);
        if (!Number.isNaN(index)) {
          const candidate = gameState.currentCandidates?.[index];
          
          // BUG FIX: Rehires should call finalizeRehire(), not selectManagerCandidate()
          if (candidate?.isRehire) {
            finalizeRehire(index, 1); // Rehire at level 1
            closeHiringModal();
          } else {
            selectManagerCandidate(index);
          }
        }
      });
    });

    // Set up hiring mode toggle buttons
    const toggleButtons = modal.querySelectorAll('.hiring-mode-toggle');
    toggleButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const mode = btn.dataset.mode;
        if (mode && (mode === 'new' || mode === 'rehire' || mode === 'custom')) {
          gameState.hiringMode = mode;
          
          // Toggle visibility of containers
          const candidatesContainer = modal.querySelector('#candidates-container');
          const customContainer = modal.querySelector('#custom-employee-container');
          
          if (mode === 'custom') {
            if (candidatesContainer) candidatesContainer.style.display = 'none';
            if (customContainer) customContainer.style.display = 'block';
            
            // Show recover button if there's pending character data
            updateRecoverCharacterButton(modal);
          } else {
            if (candidatesContainer) candidatesContainer.style.display = 'flex';
            if (customContainer) customContainer.style.display = 'none';
            
            // Re-render candidates
            const newCards = renderCandidates();
            if (candidatesContainer) {
              candidatesContainer.innerHTML = newCards;
            }
            
            // Re-attach select button listeners for new cards
            const newSelectButtons = modal.querySelectorAll('.select-candidate-btn');
            newSelectButtons.forEach(newBtn => {
              newBtn.addEventListener('click', () => {
                const index = parseInt(newBtn.dataset.index, 10);
                if (!Number.isNaN(index)) {
                  const candidate = gameState.currentCandidates?.[index];
                  
                  // BUG FIX: Rehires should call finalizeRehire(), not selectManagerCandidate()
                  if (candidate?.isRehire) {
                    finalizeRehire(index, 1); // Rehire at level 1
                    closeHiringModal();
                  } else {
                    selectManagerCandidate(index);
                  }
                }
              });
            });
          }
          
          // Update toggle button styles
          toggleButtons.forEach(toggleBtn => {
            const btnMode = toggleBtn.dataset.mode;
            if (btnMode === mode) {
              if (mode === 'rehire') {
                toggleBtn.style.background = 'linear-gradient(135deg, #ffd700 0%, #ff8c00 100%)';
                toggleBtn.style.borderColor = '#ffd700';
                toggleBtn.style.color = '#0f1419';
              } else if (mode === 'custom') {
                toggleBtn.style.background = 'linear-gradient(135deg, #4ecca3 0%, #00d4ff 100%)';
                toggleBtn.style.borderColor = '#4ecca3';
                toggleBtn.style.color = 'white';
              } else {
                toggleBtn.style.background = 'linear-gradient(135deg, #e94560 0%, #0f3460 100%)';
                toggleBtn.style.borderColor = '#e94560';
                toggleBtn.style.color = 'white';
              }
            } else {
              toggleBtn.style.background = 'transparent';
              toggleBtn.style.borderColor = '#555';
              toggleBtn.style.color = 'white';
            }
          });
        }
      });
    });
    
    // Set up custom mode sub-toggle buttons
    const customModeToggleButtons = modal.querySelectorAll('.custom-mode-toggle');
    customModeToggleButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const submode = btn.dataset.submode;
        const quickContent = modal.querySelector('#quick-mode-content');
        const manualContent = modal.querySelector('#manual-mode-content');
        
        if (submode === 'quick') {
          if (quickContent) quickContent.style.display = 'block';
          if (manualContent) manualContent.style.display = 'none';
        } else {
          if (quickContent) quickContent.style.display = 'none';
          if (manualContent) manualContent.style.display = 'block';
        }
        
        // Update sub-toggle button styles
        customModeToggleButtons.forEach(toggleBtn => {
          if (toggleBtn.dataset.submode === submode) {
            toggleBtn.style.background = 'linear-gradient(135deg, #4ecca3 0%, #00d4ff 100%)';
            toggleBtn.style.borderColor = '#4ecca3';
          } else {
            toggleBtn.style.background = 'transparent';
            toggleBtn.style.borderColor = '#555';
          }
        });
      });
    });
    
    // Set up personality slider value displays
    const sliderConfigs = [
      // Personality (C.O.F.P.H.)
      { slider: 'manualConfidence', value: 'manualConfidenceValue' },
      { slider: 'manualOutgoing', value: 'manualOutgoingValue' },
      { slider: 'manualFlirty', value: 'manualFlirtyValue' },
      { slider: 'manualProfessional', value: 'manualProfessionalValue' },
      { slider: 'manualHumor', value: 'manualHumorValue' },
      // Relationship Stats
      { slider: 'manualAffection', value: 'manualAffectionValue', showDash: true },
      { slider: 'manualComfort', value: 'manualComfortValue', showDash: true },
      { slider: 'manualTrust', value: 'manualTrustValue', showDash: true },
      { slider: 'manualDesire', value: 'manualDesireValue', showDash: true },
      { slider: 'manualFriendship', value: 'manualFriendshipValue', showDash: true },
      { slider: 'manualObedience', value: 'manualObedienceValue', showDash: true },
      // Work Stats
      { slider: 'manualProductivity', value: 'manualProductivityValue', showDash: true }
    ];
    
    sliderConfigs.forEach(config => {
      const slider = modal.querySelector(`#${config.slider}`);
      const valueDisplay = modal.querySelector(`#${config.value}`);
      if (slider && valueDisplay) {
        // For stats sliders, show dash until user interacts
        if (config.showDash) {
          slider.value = -1; // Reset to "auto" state
          valueDisplay.textContent = '-';
        }
        
        slider.addEventListener('input', () => {
          const val = parseInt(slider.value);
          if (config.showDash && val < 0) {
            valueDisplay.textContent = '-';
          } else {
            valueDisplay.textContent = Math.max(0, val);
            // Ensure slider shows at least 0
            if (val < 0) slider.value = 0;
          }
        });
      }
    });
    
    // Set up Position Slot Selector for custom employees
    const careerLevelSelect = modal.querySelector('#manualCareerLevel');
    const positionSlotContainer = modal.querySelector('#positionSlotSelector');
    const positionSlotSelect = modal.querySelector('#manualPositionSlot');
    const positionSlotWarning = modal.querySelector('#positionSlotWarning');
    
    function populatePositionSlots(level) {
      if (!positionSlotSelect || !positionSlotContainer) return;
      
      // Get all available positions at this level
      const positions = gameState.corporatePyramid?.positions?.[level] || [];
      const emptySlots = positions.filter(pos => !pos.employeeId);
      
      // Clear existing options
      positionSlotSelect.innerHTML = '';
      
      let selectedIndex = 0; // Default to first option
      
      if (emptySlots.length === 0) {
        // No available slots at this level
        positionSlotSelect.innerHTML = '<option value="">âš ï¸ No empty slots at this level</option>';
        positionSlotWarning.textContent = `All ${gameState.hierarchyLevels[level]?.title || 'Level ' + level} positions are filled. Promote or fire someone first.`;
        positionSlotWarning.style.display = 'block';
        positionSlotWarning.style.color = '#ff6b9d';
      } else {
        // Populate with available slots
        emptySlots.forEach((pos, idx) => {
          const slotProduct = gameState.products.find(p => p.id === pos.productId);
          const productName = slotProduct?.name || pos.productId || 'Unknown';
          const levelInfo = gameState.hierarchyLevels[level];
          const option = document.createElement('option');
          option.value = JSON.stringify({ level: pos.level, productId: pos.productId, index: positions.indexOf(pos) });
          option.textContent = `${levelInfo?.title || 'Level ' + level} - ${productName}`;
          
          // Auto-select the slot matching the product that was clicked for hiring
          if (pos.productId === productId) {
            selectedIndex = idx;
          }
          
          positionSlotSelect.appendChild(option);
        });
        
        // Set the selected option
        if (positionSlotSelect.options[selectedIndex]) {
          positionSlotSelect.selectedIndex = selectedIndex;
        }
        
        if (emptySlots.length === 1) {
          positionSlotWarning.textContent = 'This is the only empty slot at this level.';
        } else {
          const currentProduct = gameState.products.find(p => p.id === productId);
          if (emptySlots.some(pos => pos.productId === productId)) {
            positionSlotWarning.textContent = `${emptySlots.length} slots available. Pre-selected: ${currentProduct?.name || productId}`;
          } else {
            positionSlotWarning.textContent = `${emptySlots.length} slots available. The ${currentProduct?.name || productId} doesn't have a Level ${level} slot.`;
          }
        }
        positionSlotWarning.style.color = '#4ecca3';
        positionSlotWarning.style.display = 'block';
      }
      
      // Show/hide selector based on level - always show for Level 1 if there are multiple slots, or for higher levels
      const level1Positions = gameState.corporatePyramid?.positions?.[1] || [];
      const level1EmptySlots = level1Positions.filter(pos => !pos.employeeId);
      
      if (level > 1 || level1EmptySlots.length > 1) {
        positionSlotContainer.style.display = 'block';
      } else {
        // Level 1 with only one slot - auto-select the current product slot
        positionSlotContainer.style.display = 'none';
      }
    }
    
    if (careerLevelSelect) {
      // Initialize position slots based on initial selection
      populatePositionSlots(parseInt(careerLevelSelect.value) || 1);
      
      // Update when level changes
      careerLevelSelect.addEventListener('change', () => {
        populatePositionSlots(parseInt(careerLevelSelect.value) || 1);
      });
    }
    
    // Set up age field to enforce 18+ minimum
    const ageInput = modal.querySelector('#manualAge');
    if (ageInput) {
      ageInput.addEventListener('change', () => {
        const val = parseInt(ageInput.value);
        if (!isNaN(val) && val < 18) {
          ageInput.value = 18;
        }
      });
      ageInput.addEventListener('blur', () => {
        const val = parseInt(ageInput.value);
        if (!isNaN(val) && val < 18) {
          ageInput.value = 18;
        }
      });
    }
    
    // Set up Recover Character button
    const recoverBtn = modal.querySelector('#recoverCharacterBtn');
    if (recoverBtn) {
      recoverBtn.addEventListener('click', () => {
        if (pendingCustomEmployeeData) {
          showCharacterConfirmationModal(
            pendingCustomEmployeeData, 
            pendingCustomEmployeeProductId || productId, 
            pendingCustomEmployeeSource || 'Recovered'
          );
        }
      });
    }
    
    // Initial check for recover button visibility
    updateRecoverCharacterButton(modal);
    
    // Set up Generate from URL button
    const generateFromUrlBtn = modal.querySelector('#generateFromUrlBtn');
    if (generateFromUrlBtn) {
      generateFromUrlBtn.addEventListener('click', async () => {
        const urlInput = modal.querySelector('#customEmployeeUrlInput');
        const extraInstructions = modal.querySelector('#customEmployeeExtraInstructions');
        const url = urlInput?.value?.trim();
        
        if (!url) {
          showNotification('Please enter a URL', 'error');
          return;
        }
        
        // Close modal immediately and generate in background
        closeHiringModal();
        showNotification('ğŸ”— Generating character in background... You can continue playing!', 'info', 5000);
        
        try {
          const characterData = await generateEmployeeFromUrl(url, extraInstructions?.value || '', productId);
          if (characterData) {
            // Show confirmation modal with generated data
            showCharacterConfirmationModal(characterData, productId, 'URL');
          }
        } catch (error) {
          console.error('URL generation error:', error);
          showNotification('Failed to generate from URL. Try a different page or use description mode.', 'error');
        }
      });
    }
    
    // Set up Generate from Prompt button
    const generateFromPromptBtn = modal.querySelector('#generateFromPromptBtn');
    if (generateFromPromptBtn) {
      generateFromPromptBtn.addEventListener('click', async () => {
        const promptInput = modal.querySelector('#customEmployeePromptInput');
        const extraInstructions = modal.querySelector('#customEmployeeExtraInstructions');
        const prompt = promptInput?.value?.trim();
        
        if (!prompt) {
          showNotification('Please describe your employee', 'error');
          return;
        }
        
        // Close modal immediately and generate in background
        closeHiringModal();
        showNotification('ğŸ¤– Generating character in background... You can continue playing!', 'info', 5000);
        
        try {
          const characterData = await generateEmployeeFromPrompt(prompt, extraInstructions?.value || '', productId);
          if (characterData) {
            // Show confirmation modal with generated data
            showCharacterConfirmationModal(characterData, productId, 'Description');
          }
        } catch (error) {
          console.error('Prompt generation error:', error);
          showNotification('Failed to generate employee. Please try again.', 'error');
        }
      });
    }
    
    // Set up Create Manual Employee button
    const createManualBtn = modal.querySelector('#createManualEmployeeBtn');
    if (createManualBtn) {
      createManualBtn.addEventListener('click', async () => {
        // Validate position slot is available
        const careerLevelVal = parseInt(modal.querySelector('#manualCareerLevel')?.value) || 1;
        const positionSlotVal = modal.querySelector('#manualPositionSlot')?.value;
        
        // Check if a position slot is required and available
        if (careerLevelVal > 1 || (careerLevelVal === 1 && modal.querySelector('#positionSlotSelector')?.style.display !== 'none')) {
          if (!positionSlotVal || positionSlotVal.includes('No empty slots')) {
            showNotification(`âš ï¸ No empty ${gameState.hierarchyLevels?.[careerLevelVal]?.title || 'Level ' + careerLevelVal} positions available!`, 'error');
            return;
          }
        }
        
        createManualBtn.disabled = true;
        createManualBtn.innerHTML = '<span style="display:inline-block; animation:rotate 1.5s linear infinite;">â³</span> Creating...';
        
        try {
          // Helper to get slider value (-1 means "auto")
          const getSliderValue = (id) => {
            const val = parseInt(modal.querySelector(`#${id}`)?.value);
            return (val === -1 || isNaN(val)) ? null : val;
          };
          
          // Collect work days
          const workDays = [];
          if (modal.querySelector('#manualWorkMon')?.checked) workDays.push(1);
          if (modal.querySelector('#manualWorkTue')?.checked) workDays.push(2);
          if (modal.querySelector('#manualWorkWed')?.checked) workDays.push(3);
          if (modal.querySelector('#manualWorkThu')?.checked) workDays.push(4);
          if (modal.querySelector('#manualWorkFri')?.checked) workDays.push(5);
          if (modal.querySelector('#manualWorkSat')?.checked) workDays.push(6);
          if (modal.querySelector('#manualWorkSun')?.checked) workDays.push(0);
          
          // Collect full form data
          const formData = {
            // Basic Info
            name: modal.querySelector('#manualName')?.value?.trim() || '',
            age: parseInt(modal.querySelector('#manualAge')?.value) || null,
            gender: modal.querySelector('#manualGender')?.value || '',
            race: modal.querySelector('#manualRace')?.value || '',
            
            // Personality (C.O.F.P.H.)
            personality: {
              confidence: parseInt(modal.querySelector('#manualConfidence')?.value) || 50,
              outgoing: parseInt(modal.querySelector('#manualOutgoing')?.value) || 50,
              flirty: parseInt(modal.querySelector('#manualFlirty')?.value) || 50,
              professional: parseInt(modal.querySelector('#manualProfessional')?.value) || 50,
              humor: parseInt(modal.querySelector('#manualHumor')?.value) || 50
            },
            
            // Starting Stats (null = auto-generate)
            stats: {
              affection: getSliderValue('manualAffection'),
              comfort: getSliderValue('manualComfort'),
              trust: getSliderValue('manualTrust'),
              desire: getSliderValue('manualDesire'),
              friendship: getSliderValue('manualFriendship'),
              obedience: getSliderValue('manualObedience'),
              productivity: getSliderValue('manualProductivity')
            },
            
            // Career
            career: {
              level: parseInt(modal.querySelector('#manualCareerLevel')?.value) || 1,
              salary: parseInt(modal.querySelector('#manualSalary')?.value) || null,
              // Selected position slot (parsed JSON from selector)
              selectedSlot: (() => {
                try {
                  const slotValue = modal.querySelector('#manualPositionSlot')?.value;
                  return slotValue ? JSON.parse(slotValue) : null;
                } catch (e) { return null; }
              })()
            },
            
            // Traits & Interests
            personalityTraits: (modal.querySelector('#manualTraits')?.value || '').split(',').map(t => t.trim()).filter(Boolean),
            hobbies: (modal.querySelector('#manualHobbies')?.value || '').split(',').map(t => t.trim()).filter(Boolean),
            kinks: (modal.querySelector('#manualKinks')?.value || '').split(',').map(t => t.trim()).filter(Boolean),
            keyTrait: modal.querySelector('#manualKeyTrait')?.value?.trim() || '',
            
            // Physical Appearance
            physical: {
              hair: { 
                color: modal.querySelector('#manualHairColor')?.value?.trim() || '',
                style: modal.querySelector('#manualHairStyle')?.value?.trim() || '',
                length: modal.querySelector('#manualHairLength')?.value || ''
              },
              eyes: { 
                color: modal.querySelector('#manualEyeColor')?.value?.trim() || '',
                shape: modal.querySelector('#manualEyeShape')?.value?.trim() || ''
              },
              skinTone: modal.querySelector('#manualSkinTone')?.value?.trim() || '',
              bodyShape: modal.querySelector('#manualBodyShape')?.value || '',
              heightBuild: modal.querySelector('#manualHeightBuild')?.value?.trim() || '',
              breastSize: modal.querySelector('#manualBreastSize')?.value || '',
              buttSize: modal.querySelector('#manualButtSize')?.value || '',
              fashion: modal.querySelector('#manualFashion')?.value?.trim() || '',
              notableFeatures: modal.querySelector('#manualNotableFeatures')?.value?.trim() || ''
            },
            
            // Personal Life
            personalLife: {
              livingSituation: modal.querySelector('#manualLivingSituation')?.value || '',
              relationshipStatus: modal.querySelector('#manualRelationshipStatus')?.value || '',
              hasPet: modal.querySelector('#manualHasPet')?.value || ''
            },
            
            // Schedule
            schedule: {
              workDays: workDays.length > 0 ? workDays : [1, 2, 3, 4, 5],
              workStartHour: parseInt(modal.querySelector('#manualWorkStart')?.value) || 9,
              workEndHour: parseInt(modal.querySelector('#manualWorkEnd')?.value) || 17,
              ptoBalance: parseInt(modal.querySelector('#manualPTO')?.value) || 10
            },
            
            // Starting Flags
            startingFlags: (modal.querySelector('#manualFlags')?.value || '').split(',').map(t => t.trim()).filter(Boolean),
            
            // Bio
            bio: modal.querySelector('#manualBio')?.value?.trim() || ''
          };
          
          const employee = await createManualEmployee(formData, productId);
          if (employee) {
            showNotification(`âœ¨ Created ${employee.name}!`, 'success');
            closeHiringModal();
          }
        } catch (error) {
          console.error('Manual creation error:', error);
          showNotification('Failed to create employee. Please try again.', 'error');
        } finally {
          createManualBtn.disabled = false;
          createManualBtn.innerHTML = 'âœ¨ Create Custom Employee';
        }
      });
    }

    // Allow Esc to close
    const esc = (ev) => { 
      if (ev.key === 'Escape') { 
        closeHiringModal(); 
        window.removeEventListener('keydown', esc); 
      } 
    };
    window.addEventListener('keydown', esc);
  }  

  // Close hiring modal
  function closeHiringModal() {
    // Use ModalManager to close
    ModalManager.close('hiringModal');
    gameState.currentCandidates = null;
    document.body.style.overflow = ''; // Restore scrolling
  }

  // Generate context-aware rehire message using AI
  async function generateRehireMessage(employee) {
    try {
      // Analyze relationship context
      const stats = employee.stats || {};
      const intimacy = employee.intimacy || {};
      const memory = employee.memory || {};
      const chatHistory = employee.chatHistory || [];
      const conversationArchive = employee.conversationArchive || [];
      
      // Calculate relationship metrics
      const avgAffection = stats.affection || 50;
      const avgTrust = stats.trust || 50;
      const avgDesire = stats.desire || 50;
      const intimacyLevel = intimacy.level || 0;
      const sexualHistory = intimacy.sexCount || 0;
      const timesRehired = employee.timesRehired || 1;
      
      // Analyze recent conversation topics from last 10 messages
      const recentMessages = [...conversationArchive, ...chatHistory]
        .slice(-10)
        .map(msg => msg.content)
        .join(' | ');
      
      // Determine relationship quality
      const avgRelationship = (avgAffection + avgTrust) / 2;
      const relationshipQuality = avgRelationship >= 70 ? 'excellent' : avgRelationship >= 50 ? 'good' : avgRelationship >= 30 ? 'strained' : 'poor';
      const isSexual = intimacyLevel >= 50 || sexualHistory > 0;
      const isRomantic = avgAffection >= 70 && avgDesire >= 60;
      
      // Build context prompt for AI
      const contextPrompt = `You are ${employee.name}, a ${employee.age}-year-old ${employee.gender} who previously worked for the player as a manager.

RELATIONSHIP CONTEXT:
- Affection: ${avgAffection}/100 (${avgAffection >= 70 ? 'very high' : avgAffection >= 50 ? 'positive' : avgAffection >= 30 ? 'neutral' : 'low'})
- Trust: ${avgTrust}/100 (${avgTrust >= 70 ? 'very high' : avgTrust >= 50 ? 'trusting' : avgTrust >= 30 ? 'cautious' : 'distrustful'})
- Desire: ${avgDesire}/100
- Intimacy Level: ${intimacyLevel}/100
- Sexual encounters: ${sexualHistory}
- Times rehired: ${timesRehired}
- Overall relationship: ${relationshipQuality}${isSexual ? ', sexual' : ''}${isRomantic ? ', romantic' : ''}

PERSONALITY:
${employee.personality || 'Professional and dedicated'}

RECENT CONVERSATION TOPICS:
${recentMessages || 'No recent conversation history'}

INSTRUCTIONS:
Generate a SINGLE short message (1-2 sentences, max 150 characters) that ${employee.name} would send when being rehired.

IMPORTANT TONE GUIDELINES:
${isSexual && avgAffection >= 60 ? `- Be flirty, suggestive, and reference your intimate past. Use innuendo or explicit language. Example: "Can't wait for those 'after hours' meetings again ğŸ˜" or "Missed our special connection... ready to make up for lost time â¤ï¸"` : ''}
${isRomantic && !isSexual ? `- Be warm, affectionate, and emotionally connected. Show you missed them personally.` : ''}
${avgRelationship >= 70 && !isSexual ? `- Be enthusiastic and happy to return. Express genuine excitement.` : ''}
${avgRelationship >= 40 && avgRelationship < 70 ? `- Be professional but friendly. Acknowledge the working relationship.` : ''}
${avgRelationship < 40 ? `- Be distant, cold, or passive-aggressive. Maybe express reluctance or sarcasm. Example: "Well, here we are again..." or "Guess I'm back... for now."` : ''}

NO LIMITS on suggestiveness if intimacy is high. Match the energy of your past interactions.

Generate ONLY the message, no quotes, no explanation:`;

      const response = await queryLLM(contextPrompt, {
        type: 'rehire-message',
        employee: employee.name,
        temperature: 0.9, // Higher creativity for varied responses
        maxTokens: 80
      });

      return response || `It's good to be back! Ready to get to work. ğŸ’¼`;
      
    } catch (error) {
      console.error('Error generating rehire message:', error);
      // Fallback based on basic stats
      const affection = employee.stats?.affection || 50;
      if (affection >= 70) {
        return `Boss! I've missed you so much! ğŸ’• Ready to make this work... amazing. ğŸ˜`;
      } else if (affection >= 50) {
        return `Hey! Good to be back working with you again! ğŸ˜Š`;
      } else {
        return `Well... I'm back. Let's see how this goes.`;
      }
    }
  }

  // Select and onboard a manager candidate
    async function selectManagerCandidate(index) {
    const candidate = gameState.currentCandidates?.[index];
    const product = gameState.products.find(p => p.id === candidate?.productId);
    if (!candidate || !product) return;

    // funds check happens before modal in hireOrUpgradeManager, but double-guard:
    if (gameState.cash < product.managerHireCost) { showNotification('Not enough cash!'); return; }
    
    // Check if this is a former employee being rehired
    const isFormerEmployee = candidate.isFormerEmployee || false;

    // mark & queue onboarding
    candidate.hired = true;
    candidate.position = `Manager â€“ ${product.name}`;
    candidate.productManaged = product.name;
    
    // CRITICAL FIX: Ensure name is marked as used to prevent duplicate hires
    if (!gameState.usedEmployeeNames) {
      gameState.usedEmployeeNames = new Set();
    }
    gameState.usedEmployeeNames.add(candidate.name);
    console.log(`[Hire] Marked ${candidate.name} as used (${gameState.usedEmployeeNames.size} total names)`);
    
    // Set hire date
    if (!candidate.hireDate) {
      candidate.hireDate = Date.now();
    }
    
    // Former employees skip onboarding (they already know the job!)
    if (isFormerEmployee) {
      candidate.onboarding = false;
      candidate.bioComplete = true;
      
      // Restore their chat history and archive
      if (candidate.chatHistory && candidate.chatHistory.length > 0) {
        gameState.chatHistory[candidate.id] = candidate.chatHistory;
      }
      if (candidate.conversationArchive) {
        candidate.conversationArchive = candidate.conversationArchive;
      } else {
        candidate.conversationArchive = [];
      }
      
      // Apply loyalty bonus to stats
      if (candidate.loyaltyBonus) {
        candidate.stats.productivity = Math.min(100, (candidate.stats.productivity || 70) * (1 + candidate.loyaltyBonus));
      }
      
      // Generate context-aware welcome back message
      if (!gameState.chatHistory[candidate.id]) {
        gameState.chatHistory[candidate.id] = [];
      }
      
      // Generate AI-powered rehire message
      generateRehireMessage(candidate).then(message => {
        gameState.chatHistory[candidate.id].push({
          sender: candidate.name,
          content: message,
          isPlayer: false,
          timestamp: gameState.time?.currentTime || Date.now()
        });
        
        // CRITICAL FIX: Save immediately after rehire message to prevent message loss
        saveGame(false);
        
        // Mark as unread so player sees the welcome message
        candidate.unreadMessages = (candidate.unreadMessages || 0) + 1;
        
        // Update UI if chat is open
        if (gameState.activeChat === candidate.id) {
          renderChatMessages();
        }
      });
      
      showNotification(`${candidate.name} has returned! +${(candidate.loyaltyBonus * 100).toFixed(0)}% loyalty bonus!`);
    } else {
      candidate.onboarding = true;
      candidate.bioComplete = false;
    }

      // Product-level onboarding flag and immediate effects
      // a) Replace CTA with onboarding status via updateProductsList
      // b) Immediately subtract cash (with employee discount)
      // c) Begin automation right away
      product.managerOnboarding = !isFormerEmployee; // Former employees don't need onboarding
      
      // CRITICAL FIX: Link product to employee immediately
      product.managerId = candidate.id;
      product.managerLevel = 1;
      product.managerHired = true;
      
      // CRITICAL FIX: Assign candidate to proper location
      candidate.locationId = product.locationId || 'headquarters';
      candidate.location = candidate.locationId;  // For backward compatibility
      
      // Apply employee discount from influence upgrades
      const employeeDiscountLevel = gameState.influenceUpgrades?.employeeDiscount || 0;
      const discountMultiplier = influenceUpgrades.employeeDiscount.effect(employeeDiscountLevel);
      const finalCost = Math.floor(product.managerHireCost * discountMultiplier);
      
      gameState.cash -= finalCost;
      
      // Store the cost paid for potential refund (Emergency Reset)
      candidate.hireCostPaid = finalCost;
      
      // start automated cycle if not already running
      if (!product.running) {
        product.running = true;
        product.timeRemainingMs = currentCycleTimeMs(product);
      }

    // show in People tab as a badge (only if they need onboarding)
    if (!isFormerEmployee) {
      gameState.onboarding.push(candidate);
    }
    closeHiringModal();
      updatePeopleTab();
      updateProductsList();
      
    // If former employee, skip AI generation and finalize immediately
    if (isFormerEmployee) {
      finalizeManagerHire(candidate, product);
      return;
    }

    // --- AI generation (guarded) - only for new employees ---
    try {
        const profilePrompt = `
  Create an in-world, adult female NPC profile (no meta-talk) for: ${candidate.name}, age ${candidate.age}.
  Gender: female.
  Role: ${candidate.position}. Product managed: ${product.name}.
  Personality traits: ${candidate.personalityTraits.join(', ')}. Key trait: ${candidate.keyTrait}.
  Hobbies: ${candidate.hobbies.join(', ')}. Kink preferences: ${candidate.kinks.join(', ')}.

  Respond as a compact JSON object with these keys ONLY:
  {
  "name": {"first":"", "last":""},
  "age": <number>,
  "gender": "female",
  "productManaged": "${product.name}",
  "bio": "<2-3 sentence personality/background, world-grounded>",
  "appearance": {
  "heightBuild": "",
  "hair": {"color":"","style":"","length":""},
  "eyes": {"color":"","shape":""},
  "skinTone": "",
  "bodyShape": "",
  "breastSize": "",
  "buttSize": "",
  "fashion": ""
  },
  "personalityTraits": [${candidate.personalityTraits.map(s=>`"${s}"`).join(', ')}],
  "kinks": [${candidate.kinks.map(s=>`"${s}"`).join(', ')}]
  }
  `;

        // fallbacks if plugin missing
        const aiRaw = typeof generateText === 'function'
        ? await queuedGenerateText(profilePrompt, {}, `Manager Profile - ${candidate.name}`)
        : `{"name":{"first":"${candidate.name.split(' ')[0]}","last":"${candidate.name.split(' ')[1]||''}"},"age":${candidate.age},"productManaged":"${product.name}","bio":"Quick learner; keeps launches smooth.","appearance":{"heightBuild":"average","hair":{"color":"brown","style":"soft waves","length":"shoulder"},"eyes":{"color":"green","shape":"almond"},"skinTone":"light","bodyShape":"curvy","breastSize":"medium","buttSize":"full","fashion":"smart casual"},"personalityTraits":["${candidate.personalityTraits.join('","')}"],"kinks":["${candidate.kinks.join('","')}"]}`;

        let parsed;
        try { parsed = JSON.parse(aiRaw); } catch { parsed = null; }

        if (parsed && parsed.name) {
        candidate.name = `${parsed.name.first} ${parsed.name.last}`.trim() || candidate.name;
        candidate.age = parsed.age ?? candidate.age;
        candidate.productManaged = parsed.productManaged || product.name;
        candidate.bio = parsed.bio || "Keeps things moving; loves clean launches.";
        
        // Generate detailed physical appearance (NEW SYSTEM!) - Gender and race aware
        candidate.physical = generateDetailedPhysicalAppearance(candidate.gender || 'female', candidate.race || 'human');
        
        // Override with AI-generated details if available
        const ap = parsed.appearance || {};
        if (ap.heightBuild) candidate.physical.heightBuild = ap.heightBuild;
        if (ap.hair) candidate.physical.hair = { ...candidate.physical.hair, ...ap.hair };
        if (ap.eyes) candidate.physical.eyes = { ...candidate.physical.eyes, ...ap.eyes };
        if (ap.skinTone) candidate.physical.skin.tone = ap.skinTone;
        if (ap.bodyShape) candidate.physical.body.shape = ap.bodyShape;
        if (ap.breastSize || ap.chestSize) {
          candidate.physical.body.chestSize = ap.chestSize || ap.breastSize;
          candidate.physical.body.breastSize = ap.chestSize || ap.breastSize; // Backwards compatibility
        }
        if (ap.buttSize) candidate.physical.body.buttSize = ap.buttSize;
        if (ap.fashion) candidate.physical.fashion = ap.fashion;
        
        candidate.personalityTraits = parsed.personalityTraits || candidate.personalityTraits;
        candidate.kinks = parsed.kinks || candidate.kinks;
        } else {
        // minimal fallback - generate full detailed appearance (Gender and race aware)
        candidate.bio = "Quick learner; keeps launches smooth. Friendly and playful in the office.";
        candidate.physical = generateDetailedPhysicalAppearance(candidate.gender || 'female', candidate.race || 'human');
        }

        // optional image (now uses consistent physical description!)
        if (typeof generateImage === 'function') {
          // FIXED: Profile images now respect global imageStyle setting
          const imgPrompt = `Professional portrait photo: ${candidate.physical.shortDescription}. ${candidate.physical.face.full}. ${candidate.physical.fashion} style outfit. Office setting, soft professional lighting, friendly expression, high quality`;
        try {
            const imgUrl = await queuedGenerateImage(applyImageStyle(imgPrompt), `Profile image for new hire ${candidate.name}`);
            if (imgUrl) candidate.profileImage = imgUrl;
        } catch (e) { /* ignore */ }
        }

  // move from onboarding â†’ employees
        candidate.onboarding = false;
        candidate.bioComplete = true;
        gameState.onboarding = gameState.onboarding.filter(e => e.id !== candidate.id);
        
        // Set hire date if not already set
        if (!candidate.hireDate) {
          candidate.hireDate = Date.now();
        }
        
        // CRITICAL FIX: Set employment status to active so they appear in People tab
        candidate.employmentStatus = 'active';
        
        // Initialize social network data
        initializeEmployeeSocialData(candidate);
        
        gameState.employees.push(candidate);
        
        // Update company awareness
        updateCompanyAwareness();
        
        // Generate relationships with existing employees
        generateRandomRelationships(candidate.id);
        
        // Log hire event
        logCompanyEvent({
          type: 'hire',
          involvedEmployees: [candidate.id],
          location: candidate.locationId,
          description: `${candidate.name} joined as ${candidate.position}`,
          sentiment: 'positive',
          importance: 6
        });
        
        // Generate first post (new hire announcement)
        generateFirstEmployeePost(candidate).catch(err => {
          console.error('First post generation failed:', err);
        });

  // mark manager on product (already charged and started); finish onboarding
  product.managerHired = true;
  product.managerId = candidate.id;  // CRITICAL FIX: Ensure managerId is set
  product.managerLevel = 1;
  product.managerOnboarding = false;
  
        // Automatically assign employee to Level 1 Staff position in pyramid
        const staffPosition = gameState.corporatePyramid.positions[1]?.find(
          pos => pos.productId === product.id
        );
        
        if (staffPosition) {
          staffPosition.employeeId = candidate.id;
          candidate.productManaged = product.name;
          
          // CRITICAL FIX: Update employee career to match position
          const levelInfo = gameState.hierarchyLevels[staffPosition.level] || gameState.hierarchyLevels[1];
          candidate.career.level = staffPosition.level;
          candidate.career.title = levelInfo.title;
          candidate.career.salary = levelInfo.baseSalary;
          
          console.log(`[Pyramid] Auto-assigned ${candidate.name} to ${staffPosition.title} - Career updated to ${candidate.career.title} (Level ${candidate.career.level})`);
        } else {
          // If position doesn't exist yet, create it
          initializeHierarchicalPyramid();
          const newStaffPosition = gameState.corporatePyramid.positions[1]?.find(
            pos => pos.productId === product.id
          );
          if (newStaffPosition) {
            newStaffPosition.employeeId = candidate.id;
            candidate.productManaged = product.name;
            
            // CRITICAL FIX: Update employee career to match position
            const levelInfo = gameState.hierarchyLevels[newStaffPosition.level] || gameState.hierarchyLevels[1];
            candidate.career.level = newStaffPosition.level;
            candidate.career.title = levelInfo.title;
            candidate.career.salary = levelInfo.baseSalary;
            
            console.log(`[Pyramid] Created and assigned ${candidate.name} to ${newStaffPosition.title} - Career updated to ${candidate.career.title} (Level ${candidate.career.level})`);
          }
        }

        // UI
        updatePeopleTab();
        updateProductsList();
        showNotification(`${candidate.name} hired to manage ${product.name}!`);
        
        // Refresh dashboard to show new employee
        if (gameState.activeTab === 'dashboard') {
          refreshDashboardSections();
        }

    } catch (error) {
        console.error('Onboarding error:', error);
        showNotification('Onboarding hit a snagâ€”try again.');
        // clean up onboarding badge
        gameState.onboarding = gameState.onboarding.filter(e => e.id !== candidate.id);
    }
    }

  // Setup event listeners
  function setupEventListeners() {
    // Tab navigation
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const tab = btn.dataset.tab;
        switchTab(tab);
      });
    });
    
    // Upgrade Multiplier Toggle
    const upgradeMultiplierBtn = $('upgradeMultiplierBtn');
    if (upgradeMultiplierBtn) {
      upgradeMultiplierBtn.addEventListener('click', () => {
        const multipliers = [1, 5, 10, 100, 'max'];
        const currentIndex = multipliers.indexOf(gameState.upgradeMultiplier);
        const nextIndex = (currentIndex + 1) % multipliers.length;
        gameState.upgradeMultiplier = multipliers[nextIndex];
        upgradeMultiplierBtn.textContent = `x${gameState.upgradeMultiplier}`;
        
        // Update product cards to show new costs
        if (gameState.activeTab === 'business') {
          updateProductsList();
        }
      });
    }
    
    // Settings panel
    if (settingsBtn) {
      settingsBtn.addEventListener('click', () => {
        if (settingsPanel) settingsPanel.hidden = false;
      });
    }
    
    // Fullscreen toggle
    if (fullscreenBtn) {
      // Update button icon based on fullscreen state
      function updateFullscreenButton() {
        if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement) {
          fullscreenBtn.textContent = 'â›¶';
          fullscreenBtn.classList.add('is-fullscreen');
          fullscreenBtn.title = 'Exit Fullscreen';
        } else {
          fullscreenBtn.textContent = 'â›¶';
          fullscreenBtn.classList.remove('is-fullscreen');
          fullscreenBtn.title = 'Toggle Fullscreen';
        }
      }
      
      fullscreenBtn.addEventListener('click', () => {
        if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement) {
          // Enter fullscreen
          const elem = document.documentElement;
          if (elem.requestFullscreen) {
            elem.requestFullscreen();
          } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
          } else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen();
          } else if (elem.msRequestFullscreen) {
            elem.msRequestFullscreen();
          }
        } else {
          // Exit fullscreen
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
        }
      });
      
      // Listen for fullscreen changes
      document.addEventListener('fullscreenchange', updateFullscreenButton);
      document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
      document.addEventListener('mozfullscreenchange', updateFullscreenButton);
    }
    
    // ========== COLLAPSIBLE HEADER TOGGLE ==========
    const toggleHeaderBtn = $('toggleHeaderBtn');
    const toggleHeaderIcon = $('toggleHeaderIcon');
    const topBar = $('topBar');
    const newsTicker = $('newsTicker');
    const tabNav = $('tabNav');
    const mainContent = $('mainContent');
    
    let headerCollapsed = localStorage.getItem('headerCollapsed') === 'true' || false;
    
    // Apply saved state on load
    if (headerCollapsed) {
      if (topBar) topBar.classList.add('collapsed');
      if (newsTicker) newsTicker.classList.add('collapsed');
      if (tabNav) tabNav.classList.add('collapsed');
      if (toggleHeaderBtn) toggleHeaderBtn.classList.add('header-collapsed');
      if (toggleHeaderIcon) toggleHeaderIcon.textContent = 'â–¼';
      if (mainContent) mainContent.classList.add('header-collapsed');
    }
    
    if (toggleHeaderBtn) {
      toggleHeaderBtn.addEventListener('click', () => {
        headerCollapsed = !headerCollapsed;
        
        if (headerCollapsed) {
          // Collapse all bars
          if (topBar) topBar.classList.add('collapsed');
          if (newsTicker) newsTicker.classList.add('collapsed');
          if (tabNav) tabNav.classList.add('collapsed');
          if (toggleHeaderBtn) toggleHeaderBtn.classList.add('header-collapsed');
          if (toggleHeaderIcon) toggleHeaderIcon.textContent = 'â–¼';
          if (mainContent) mainContent.classList.add('header-collapsed');
        } else {
          // Expand all bars
          if (topBar) topBar.classList.remove('collapsed');
          if (newsTicker) newsTicker.classList.remove('collapsed');
          if (tabNav) tabNav.classList.remove('collapsed');
          if (toggleHeaderBtn) toggleHeaderBtn.classList.remove('header-collapsed');
          if (toggleHeaderIcon) toggleHeaderIcon.textContent = 'â–²';
          if (mainContent) mainContent.classList.remove('header-collapsed');
        }
        
        // Save state to localStorage
        localStorage.setItem('headerCollapsed', headerCollapsed);
        console.log('[Header] Toggled:', headerCollapsed ? 'Collapsed' : 'Expanded');
      });
    }
    
    if (closeSettingsBtn) {
      closeSettingsBtn.addEventListener('click', () => {
        if (settingsPanel) settingsPanel.hidden = true;
      });
    }
    
    // Settings controls
    if (densitySlider && densityValue) {
      densitySlider.addEventListener('input', (e) => {
        gameState.settings.uiDensity = parseInt(e.target.value);
        const densityLabels = ['Compact', 'Normal', 'Spacious'];
        const label = densityLabels[Math.floor(e.target.value / 34)];
        densityValue.textContent = label;
      });
    }
    
    if (autosaveToggle) {
      autosaveToggle.addEventListener('change', (e) => {
        gameState.settings.autosave = e.target.checked;
      });
    }
    
    // Posts per page slider
    const postsPerPageSlider = $('postsPerPageSlider');
    const postsPerPageValue = $('postsPerPageValue');
    if (postsPerPageSlider && postsPerPageValue) {
      postsPerPageSlider.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        feedPaginationState.postsPerPage = value;
        postsPerPageValue.textContent = value;
        
        // Save to settings for persistence
        if (!gameState.settings.performance) {
          gameState.settings.performance = {};
        }
        gameState.settings.performance.postsPerPage = value;
        
        // Re-render feed if currently viewing it
        const socialTab = $('socialTab');
        if (socialTab && !socialTab.classList.contains('tab-content') || 
            (socialTab && socialTab.style.display !== 'none')) {
          renderSocialFeed(true);
        }
      });
      
      // Load saved value on startup
      if (gameState.settings.performance?.postsPerPage) {
        const savedValue = gameState.settings.performance.postsPerPage;
        postsPerPageSlider.value = savedValue;
        postsPerPageValue.textContent = savedValue;
        feedPaginationState.postsPerPage = savedValue;
      }
    }
    
    // AI Request Queue settings
    const maxAiRequestsSlider = $('maxAiRequestsSlider');
    const maxAiRequestsValue = $('maxAiRequestsValue');
    if (maxAiRequestsSlider && maxAiRequestsValue) {
      maxAiRequestsSlider.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        AIRequestQueue.updateMaxConcurrent(value);
        maxAiRequestsValue.textContent = value;
      });
      
      // Initialize display
      const currentMax = gameState.settings?.maxAiRequests || 15;
      maxAiRequestsSlider.value = currentMax;
      maxAiRequestsValue.textContent = currentMax;
      AIRequestQueue.updateMaxConcurrent(currentMax);
    }
    
    // Image Request Queue settings
    const maxImageRequestsSlider = $('maxImageRequestsSlider');
    if (maxImageRequestsSlider) {
      // Initialize display
      const currentMaxImages = gameState.settings?.maxImageRequests || 8;
      maxImageRequestsSlider.value = currentMaxImages;
      maxImageRequestsSlider.nextElementSibling.textContent = currentMaxImages;
      ImageRequestQueue.updateMaxConcurrent(currentMaxImages);
    }
    
    // Chat Settings Panel Toggle
    const chatSettingsBtn = $('chatSettingsBtn');
    const chatSettingsPanel = $('chatSettingsPanel');
    
    if (chatSettingsBtn && chatSettingsPanel) {
      chatSettingsBtn.addEventListener('click', () => {
        const isHidden = chatSettingsPanel.style.display === 'none';
        chatSettingsPanel.style.display = isHidden ? 'block' : 'none';
      });
    }
    
    // Communication Mode Radio Buttons
    const commModeRadios = document.querySelectorAll('input[name="chatCommMode"]');
    commModeRadios.forEach(radio => {
      radio.addEventListener('change', (e) => {
        if (!gameState.settings) gameState.settings = {};
        gameState.settings.chatCommMode = e.target.value;
        console.log('[Chat] Communication mode set to:', e.target.value);
      });
      
      // Load saved value on startup
      if (gameState.settings?.chatCommMode && radio.value === gameState.settings.chatCommMode) {
        radio.checked = true;
      }
    });
    
    // Improved mobile detection - only true mobile devices, not laptops with touchscreens
    function isTrueMobileDevice() {
      // Check if screen is small (mobile-sized)
      const isSmallScreen = window.innerWidth <= 768;
      // Check user agent for mobile devices
      const isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      // Only consider it mobile if BOTH small screen AND mobile user agent
      return isSmallScreen && isMobileUA;
    }
    
    // Chat Width Slider (in chat modal)
    const chatWidthSlider2 = $('chatWidthSlider2');
    const chatWidthValue2 = $('chatWidthValue2');
    if (chatWidthSlider2 && chatWidthValue2) {
      chatWidthSlider2.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        gameState.settings.chatWidth = value;
        chatWidthValue2.textContent = `${value}px`;
        applyChatStyles();
      });
      
      // Load saved value
      if (gameState.settings.chatWidth) {
        chatWidthSlider2.value = gameState.settings.chatWidth;
        chatWidthValue2.textContent = `${gameState.settings.chatWidth}px`;
      }
    }
    
    // Chat Height Slider (in chat modal)
    const chatHeightSlider2 = $('chatHeightSlider2');
    const chatHeightValue2 = $('chatHeightValue2');
    if (chatHeightSlider2 && chatHeightValue2) {
      chatHeightSlider2.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        gameState.settings.chatHeight = value;
        chatHeightValue2.textContent = `${value}%`;
        applyChatStyles();
      });
      
      // Load saved value
      if (gameState.settings.chatHeight) {
        chatHeightSlider2.value = gameState.settings.chatHeight;
        chatHeightValue2.textContent = `${gameState.settings.chatHeight}%`;
      }
    }
    
    // Text Size Slider (in chat modal)
    const textSizeSlider2 = $('textSizeSlider2');
    const textSizeValue2 = $('textSizeValue2');
    if (textSizeSlider2 && textSizeValue2) {
      textSizeSlider2.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        gameState.settings.textSize = value;
        textSizeValue2.textContent = `${value}%`;
        applyChatStyles();
      });
      
      // Load saved value
      if (gameState.settings.textSize) {
        textSizeSlider2.value = gameState.settings.textSize;
        textSizeValue2.textContent = `${gameState.settings.textSize}%`;
      }
    }
    
    // Image Preview Size Slider (in chat modal)
    const imagePreviewSizeSlider2 = $('imagePreviewSizeSlider2');
    const imagePreviewSizeValue2 = $('imagePreviewSizeValue2');
    if (imagePreviewSizeSlider2 && imagePreviewSizeValue2) {
      imagePreviewSizeSlider2.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        gameState.settings.imagePreviewSize = value;
        imagePreviewSizeValue2.textContent = `${value}px`;
        applyChatStyles();
      });
      
      // Load saved value
      if (gameState.settings.imagePreviewSize) {
        imagePreviewSizeSlider2.value = gameState.settings.imagePreviewSize;
        imagePreviewSizeValue2.textContent = `${gameState.settings.imagePreviewSize}px`;
      }
    }
    
    // Function to apply chat customization styles
    function applyChatStyles() {
      const chatContainer = $('chatContainer');
      if (!chatContainer) return;
      
      // Don't apply custom sizes on true mobile devices
      if (isTrueMobileDevice()) {
        chatContainer.style.setProperty('width', '90%', 'important');
        chatContainer.style.setProperty('max-width', '500px', 'important');
        chatContainer.style.setProperty('height', '80%', 'important');
        return;
      }
      
      // Apply custom sizes for PC/Laptops
      const width = gameState.settings.chatWidth || 500;
      const height = gameState.settings.chatHeight || 80;
      const textSize = gameState.settings.textSize || 100;
      const imageSize = gameState.settings.imagePreviewSize || 300;
      
      // Use setProperty with 'important' to override inline styles
      chatContainer.style.setProperty('width', `${width}px`, 'important');
      chatContainer.style.setProperty('max-width', `${width}px`, 'important');
      chatContainer.style.setProperty('height', `${height}%`, 'important');
      
      // Apply text size to all messages
      const chatMessages = $('chatMessages');
      if (chatMessages) {
        chatMessages.style.setProperty('font-size', `${textSize}%`, 'important');
      }
      
      // Apply image size to all chat images and their containers
      if (chatMessages) {
        // Update image containers (parent divs with position:relative)
        const imageContainers = chatMessages.querySelectorAll('div[style*="position:relative"][style*="inline-block"]');
        imageContainers.forEach(container => {
          container.style.setProperty('max-width', `${imageSize}px`, 'important');
          
          // Also update the message bubble (parent of parent) to accommodate larger images
          const messageEl = container.parentElement;
          if (messageEl) {
            const messageMaxWidth = `${imageSize + 40}px`; // +40px for padding
            messageEl.style.setProperty('max-width', messageMaxWidth, 'important');
          }
        });
        
        // Update the images themselves
        const chatImages = chatMessages.querySelectorAll('img');
        chatImages.forEach(img => {
          img.style.setProperty('max-width', `${imageSize}px`, 'important');
        });
      }
    }
    
    // Apply styles on page load and when chat opens
    applyChatStyles();
    
    // Image style selector
    const imageStyleSelect = $('imageStyleSelect');
    const customPromptContainer = $('customPromptContainer');
    const customStylePrompt = $('customStylePrompt');
    
    if (imageStyleSelect) {
      imageStyleSelect.addEventListener('change', (e) => {
        const selectedValue = e.target.value;
        gameState.settings.imageStyle = selectedValue;
        
        // Show/hide custom prompt textarea
        if (customPromptContainer) {
          customPromptContainer.style.display = selectedValue === 'custom' ? 'block' : 'none';
        }
        
        showNotification(`ğŸ¨ Image style set to: ${e.target.options[e.target.selectedIndex].text}`, 'success');
      });
      
      // Load saved value on startup
      if (gameState.settings.imageStyle) {
        imageStyleSelect.value = gameState.settings.imageStyle;
        // Show custom prompt container if custom was selected
        if (customPromptContainer && gameState.settings.imageStyle === 'custom') {
          customPromptContainer.style.display = 'block';
        }
      }
    }
    
    // Custom style prompt textarea handler
    if (customStylePrompt) {
      customStylePrompt.addEventListener('input', (e) => {
        gameState.settings.customStylePrompt = e.target.value;
      });
      
      // Load saved custom prompt
      if (gameState.settings.customStylePrompt) {
        customStylePrompt.value = gameState.settings.customStylePrompt;
      }
    }
    
    // ====================
    // CHEATS SYSTEM
    // ====================
    
    // Initialize cheat multipliers in gameState
    if (!gameState.cheatMultipliers) {
      gameState.cheatMultipliers = {
        affection: 1.0,
        trust: 1.0,
        comfort: 1.0,
        desire: 1.0,
        productivity: 1.0,
        confidence: 1.0,
        obedience: 1.0,
        flirty: 1.0,
        professional: 1.0,
        humor: 1.0
      };
    }
    
    // Open/Close Cheats Modal
    const openCheatsBtn = $('openCheatsBtn');
    const closeCheatsBtn = $('closeCheatsBtn');
    const cheatsModal = $('cheatsModal');
    
    if (openCheatsBtn && cheatsModal) {
      openCheatsBtn.addEventListener('click', () => {
        cheatsModal.style.display = 'flex';
        // Refresh context windows when opening
        if (typeof refreshContextWindow === 'function') refreshContextWindow();
        if (typeof refreshGossipWindow === 'function') refreshGossipWindow();
      });
    }
    
    if (closeCheatsBtn && cheatsModal) {
      closeCheatsBtn.addEventListener('click', () => {
        cheatsModal.style.display = 'none';
      });
    }
    
    // Close on background click
    if (cheatsModal) {
      cheatsModal.addEventListener('click', (e) => {
        if (e.target === cheatsModal) {
          cheatsModal.style.display = 'none';
        }
      });
    }
    
    // Patch Notes Modal
    const openPatchNotesBtn = $('openPatchNotesBtn');
    const closePatchNotesBtn = $('closePatchNotesBtn');
    const patchNotesModal = $('patchNotesModal');
    
    if (openPatchNotesBtn && patchNotesModal) {
      openPatchNotesBtn.addEventListener('click', () => {
        patchNotesModal.style.display = 'flex';
        loadPatchNotes();
      });
    }
    
    if (closePatchNotesBtn && patchNotesModal) {
      closePatchNotesBtn.addEventListener('click', () => {
        patchNotesModal.style.display = 'none';
      });
    }
    
    // Close on background click
    if (patchNotesModal) {
      patchNotesModal.addEventListener('click', (e) => {
        if (e.target === patchNotesModal) {
          patchNotesModal.style.display = 'none';
        }
      });
    }
    
    // ========== MEETINGS SYSTEM EVENT LISTENERS ==========
    
    // Create Meeting Button
    const createMeetingBtn = $('createMeetingBtn');
    const createMeetingModal = $('createMeetingModal');
    const closeCreateMeetingModal = $('closeCreateMeetingModal');
    
    // Mobile sidebar toggle with arrow tab
    const toggleMeetingsSidebarBtn = $('toggleMeetingsSidebarBtn');
    const meetingsSidebar = $('meetingsSidebar');
    
    if (toggleMeetingsSidebarBtn && meetingsSidebar) {
      toggleMeetingsSidebarBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent event from bubbling
        meetingsSidebar.classList.toggle('show-mobile');
      });
      
      // Close sidebar when clicking the backdrop (on mobile)
      document.addEventListener('click', (e) => {
        if (window.innerWidth <= 768 && 
            meetingsSidebar.classList.contains('show-mobile') &&
            !meetingsSidebar.contains(e.target) &&
            e.target !== toggleMeetingsSidebarBtn) {
          meetingsSidebar.classList.remove('show-mobile');
        }
      });
      
      // Close sidebar when a meeting is selected (on mobile)
      const observer = new MutationObserver(() => {
        if (window.innerWidth <= 768 && meetingsSidebar.classList.contains('show-mobile')) {
          const meetingChatContainer = $('meetingChatContainer');
          if (meetingChatContainer && meetingChatContainer.style.display !== 'none') {
            // Small delay to allow the click event to complete
            setTimeout(() => {
              meetingsSidebar.classList.remove('show-mobile');
            }, 100);
          }
        }
      });
      
      // Observe when meeting chat container is shown (indicates a meeting was selected)
      const meetingChatContainer = $('meetingChatContainer');
      if (meetingChatContainer) {
        observer.observe(meetingChatContainer, { 
          attributes: true, 
          attributeFilter: ['style'] 
        });
      }
    }
    
    if (createMeetingBtn && createMeetingModal) {
      createMeetingBtn.addEventListener('click', () => {
        createMeetingModal.style.display = 'flex';
        populateParticipantGrid();
      });
    }
    
    if (closeCreateMeetingModal && createMeetingModal) {
      closeCreateMeetingModal.addEventListener('click', () => {
        createMeetingModal.style.display = 'none';
      });
    }
    
    // Close on background click
    if (createMeetingModal) {
      createMeetingModal.addEventListener('click', (e) => {
        if (e.target === createMeetingModal) {
          createMeetingModal.style.display = 'none';
        }
      });
    }
    
    // Reply Limit Slider
    const replyLimitSlider = $('replyLimitSlider');
    const replyLimitValue = $('replyLimitValue');
    
    if (replyLimitSlider && replyLimitValue) {
      replyLimitSlider.addEventListener('input', (e) => {
        replyLimitValue.textContent = e.target.value;
      });
    }
    
    // Participant Search
    const participantSearch = $('participantSearch');
    if (participantSearch) {
      participantSearch.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase();
        populateParticipantGrid(searchTerm);
      });
    }
    
    // Confirm Create Meeting
    const confirmCreateMeeting = $('confirmCreateMeeting');
    if (confirmCreateMeeting) {
      confirmCreateMeeting.addEventListener('click', () => {
        const nameInput = $('meetingNameInput');
        const scenarioInput = $('meetingScenarioInput');
        const replyLimit = parseInt($('replyLimitSlider')?.value || 5);
        const name = nameInput?.value.trim() || '';
        const scenario = scenarioInput?.value.trim() || '';
        
        // Get selected participants
        const selectedParticipants = Array.from(document.querySelectorAll('.participant-card.selected'))
          .map(card => card.dataset.employeeId)
          .filter(id => id);
        
        if (selectedParticipants.length === 0) {
          showNotification('âš ï¸ Please select at least one participant', 'error');
          return;
        }
        
        if (selectedParticipants.length > 5) {
          showNotification('âš ï¸ Maximum 5 participants allowed', 'error');
          return;
        }
        
        // Create the meeting
        createMeeting(name, selectedParticipants, replyLimit, scenario);
        
        // Close modal and reset
        createMeetingModal.style.display = 'none';
        if (nameInput) nameInput.value = '';
        if (scenarioInput) scenarioInput.value = '';
        if (replyLimitSlider) replyLimitSlider.value = 5;
        if (replyLimitValue) replyLimitValue.textContent = '5';
        
        // Switch to meetings tab
        switchTab('meetings');
        
        showNotification(`âœ… Meeting created successfully!`, 'success');
      });
    }
    
    // Send Meeting Message
    const sendMeetingMessageBtn = $('sendMeetingMessageBtn');
    const meetingInput = $('meetingInput');
    
    if (sendMeetingMessageBtn) {
      sendMeetingMessageBtn.addEventListener('click', () => {
        const input = $('meetingInput');
        if (input && input.value.trim()) {
          sendMeetingMessage(input.value.trim());
        }
      });
    }
    
    if (meetingInput) {
      meetingInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && meetingInput.value.trim()) {
          sendMeetingMessage(meetingInput.value.trim());
        }
      });
    }
    
    // Delete Meeting Button
    const deleteMeetingBtn = $('deleteMeetingBtn');
    if (deleteMeetingBtn) {
      deleteMeetingBtn.addEventListener('click', () => {
        if (!gameState.activeMeeting) return;
        
        const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
        if (!meeting) return;
        
        if (confirm(`Delete meeting "${meeting.name}"?`)) {
          deleteMeeting(gameState.activeMeeting);
          showNotification('ğŸ—‘ï¸ Meeting deleted', 'success');
        }
      });
    }
    
    // Generate Meeting Summary Button
    const generateMeetingSummaryBtn = $('generateMeetingSummaryBtn');
    if (generateMeetingSummaryBtn) {
      generateMeetingSummaryBtn.addEventListener('click', async () => {
        if (!gameState.activeMeeting) return;
        
        const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
        if (!meeting || meeting.messages.length === 0) {
          showNotification('âš ï¸ No messages to summarize', 'info');
          return;
        }
        
        const summary = await generateMeetingSummary(gameState.activeMeeting);
        
        if (summary) {
          // Show summary in a modal or alert
          alert(`Meeting Summary:\n\n${summary}`);
        }
      });
    }
    
    // Meeting Settings Button
    const meetingSettingsBtn = $('meetingSettingsBtn');
    const meetingSettingsModal = $('meetingSettingsModal');
    const closeMeetingSettingsModal = $('closeMeetingSettingsModal');
    const cancelMeetingSettings = $('cancelMeetingSettings');
    const saveMeetingSettings = $('saveMeetingSettings');
    
    if (meetingSettingsBtn && meetingSettingsModal) {
      meetingSettingsBtn.addEventListener('click', () => {
        if (!gameState.activeMeeting) return;
        
        const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
        if (!meeting) return;
        
        // Populate modal with current settings
        const nameInput = $('meetingSettingsName');
        const scenarioInput = $('meetingSettingsScenario');
        const replyLimitSlider = $('meetingSettingsReplyLimitSlider');
        const replyLimitValue = $('meetingSettingsReplyLimitValue');
        const textSizeSlider = $('meetingTextSizeSlider');
        const textSizeValue = $('meetingTextSizeValue');
        const imageSizeSlider = $('meetingImageSizeSlider');
        const imageSizeValue = $('meetingImageSizeValue');
        const participantsContainer = $('meetingSettingsParticipants');
        
        if (nameInput) nameInput.value = meeting.name;
        if (scenarioInput) scenarioInput.value = meeting.scenario || '';
        if (replyLimitSlider) replyLimitSlider.value = meeting.replyLimit || 5;
        if (replyLimitValue) replyLimitValue.textContent = meeting.replyLimit || 5;
        
        // Load display settings from gameState or use defaults
        const textSize = meeting.textSize || gameState.settings?.meetingTextSize || 100;
        const imageSize = meeting.imageSize || gameState.settings?.meetingImageSize || 300;
        
        if (textSizeSlider) textSizeSlider.value = textSize;
        if (textSizeValue) textSizeValue.textContent = textSize + '%';
        if (imageSizeSlider) imageSizeSlider.value = imageSize;
        if (imageSizeValue) imageSizeValue.textContent = imageSize + 'px';
        
        // Show participants
        if (participantsContainer) {
          participantsContainer.innerHTML = meeting.participants.map(empId => {
            const emp = gameState.employees.find(e => e.id === empId);
            if (!emp) return '';
            return `
              <div style="background:#16213e; padding:8px 12px; border-radius:6px; display:flex; align-items:center; gap:6px; border:1px solid #667eea;">
                <span style="font-size:1.2rem;">${emp.emoji || 'ğŸ‘¤'}</span>
                <span style="color:white; font-size:0.9rem;">${emp.name}</span>
              </div>
            `;
          }).join('');
        }
        
        // Show modal
        meetingSettingsModal.style.display = 'flex';
      });
    }
    
    // Reply limit slider
    const meetingSettingsReplyLimitSlider = $('meetingSettingsReplyLimitSlider');
    const meetingSettingsReplyLimitValue = $('meetingSettingsReplyLimitValue');
    if (meetingSettingsReplyLimitSlider && meetingSettingsReplyLimitValue) {
      meetingSettingsReplyLimitSlider.addEventListener('input', (e) => {
        meetingSettingsReplyLimitValue.textContent = e.target.value;
      });
    }
    
    // Text size slider
    const meetingTextSizeSlider = $('meetingTextSizeSlider');
    const meetingTextSizeValue = $('meetingTextSizeValue');
    if (meetingTextSizeSlider && meetingTextSizeValue) {
      meetingTextSizeSlider.addEventListener('input', (e) => {
        meetingTextSizeValue.textContent = e.target.value + '%';
      });
    }
    
    // Image size slider
    const meetingImageSizeSlider = $('meetingImageSizeSlider');
    const meetingImageSizeValue = $('meetingImageSizeValue');
    if (meetingImageSizeSlider && meetingImageSizeValue) {
      meetingImageSizeSlider.addEventListener('input', (e) => {
        meetingImageSizeValue.textContent = e.target.value + 'px';
      });
    }
    
    // Close modal handlers
    if (closeMeetingSettingsModal && meetingSettingsModal) {
      closeMeetingSettingsModal.addEventListener('click', () => {
        meetingSettingsModal.style.display = 'none';
      });
    }
    
    if (cancelMeetingSettings && meetingSettingsModal) {
      cancelMeetingSettings.addEventListener('click', () => {
        meetingSettingsModal.style.display = 'none';
      });
    }
    
    // Close on background click
    if (meetingSettingsModal) {
      meetingSettingsModal.addEventListener('click', (e) => {
        if (e.target === meetingSettingsModal) {
          meetingSettingsModal.style.display = 'none';
        }
      });
    }
    
    // Save settings
    if (saveMeetingSettings && meetingSettingsModal) {
      saveMeetingSettings.addEventListener('click', () => {
        if (!gameState.activeMeeting) return;
        
        const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
        if (!meeting) return;
        
        // Get values
        const nameInput = $('meetingSettingsName');
        const scenarioInput = $('meetingSettingsScenario');
        const replyLimitSlider = $('meetingSettingsReplyLimitSlider');
        const textSizeSlider = $('meetingTextSizeSlider');
        const imageSizeSlider = $('meetingImageSizeSlider');
        
        // Update meeting
        if (nameInput && nameInput.value.trim()) {
          meeting.name = nameInput.value.trim();
        }
        if (scenarioInput) {
          meeting.scenario = scenarioInput.value.trim();
        }
        if (replyLimitSlider) {
          meeting.replyLimit = parseInt(replyLimitSlider.value);
        }
        if (textSizeSlider) {
          meeting.textSize = parseInt(textSizeSlider.value);
        }
        if (imageSizeSlider) {
          meeting.imageSize = parseInt(imageSizeSlider.value);
        }
        
        // Apply text size to meeting messages
        const meetingMessages = $('meetingMessages');
        if (meetingMessages && meeting.textSize) {
          meetingMessages.style.fontSize = (meeting.textSize / 100) + 'rem';
        }
        
        // Apply image size (will affect new images)
        if (meeting.imageSize) {
          // Store it for when images are displayed
          meeting.imageSize = meeting.imageSize;
        }
        
        // Update meeting title in header
        const meetingTitle = $('meetingTitle');
        if (meetingTitle) {
          meetingTitle.textContent = meeting.name;
        }
        
        // Update reply status display
        const meetingRepliesLeft = $('meetingRepliesLeft');
        if (meetingRepliesLeft) {
          meetingRepliesLeft.textContent = meeting.replyLimit;
        }
        
        // Re-render meeting list to show updated name
        updateMeetingsList();
        
        // Close modal
        meetingSettingsModal.style.display = 'none';
        
        // Save game state
        saveGame();
        
        showNotification('âœ… Meeting settings saved!', 'success');
      });
    }
    
    // Meeting Participant Attachment Menu
    let selectedMeetingParticipant = null;
    const meetingAttachmentMenu = $('meetingAttachmentMenu');
    const meetingAttachmentArrow = $('meetingAttachmentArrow');
    const meetingAttachmentTargetImage = $('meetingAttachmentTargetImage');
    const meetingAttachmentTargetName = $('meetingAttachmentTargetName');
    
    // Handle participant clicks (delegated event since participants are dynamically created)
    document.addEventListener('click', (e) => {
      const participantBtn = e.target.closest('.meeting-participant-btn');
      
      if (participantBtn) {
        e.stopPropagation();
        const employeeId = participantBtn.dataset.employeeId;
        const emp = gameState.employees.find(e => e.id === employeeId);
        
        if (!emp || !meetingAttachmentMenu) return;
        
        // If clicking the same participant, toggle menu
        if (selectedMeetingParticipant === employeeId && meetingAttachmentMenu.style.display === 'block') {
          meetingAttachmentMenu.style.display = 'none';
          selectedMeetingParticipant = null;
          return;
        }
        
        // Set selected participant
        selectedMeetingParticipant = employeeId;
        
        // Update menu header
        if (meetingAttachmentTargetImage) meetingAttachmentTargetImage.src = emp.profileImage;
        if (meetingAttachmentTargetName) meetingAttachmentTargetName.textContent = emp.name;
        
        // Position arrow to point at clicked participant
        const btnRect = participantBtn.getBoundingClientRect();
        const headerRect = participantBtn.closest('#meetingHeader').getBoundingClientRect();
        const arrowPosition = btnRect.left + (btnRect.width / 2) - headerRect.left;
        
        if (meetingAttachmentArrow) {
          meetingAttachmentArrow.style.left = arrowPosition + 'px';
          meetingAttachmentArrow.style.transform = 'translateX(-50%)';
        }
        
        // Show menu
        meetingAttachmentMenu.style.display = 'block';
      } else if (!e.target.closest('#meetingAttachmentMenu')) {
        // Click outside - close menu
        if (meetingAttachmentMenu) meetingAttachmentMenu.style.display = 'none';
        selectedMeetingParticipant = null;
      }
    });
    
    // Handle meeting attachment menu items
    document.querySelectorAll('.meeting-attach-item').forEach(item => {
      item.addEventListener('click', (e) => {
        const action = e.currentTarget.dataset.action;
        
        if (!selectedMeetingParticipant || !gameState.activeMeeting) {
          showNotification('âš ï¸ No participant selected', 'error');
          return;
        }
        
        const emp = gameState.employees.find(e => e.id === selectedMeetingParticipant);
        if (!emp) return;
        
        // Hide menu
        if (meetingAttachmentMenu) meetingAttachmentMenu.style.display = 'none';
        
        // Handle different actions - using existing modal functions but context is meeting
        switch (action) {
          case 'send-money':
            // Open send money modal with employee context
            openSendMoneyModal(emp.id, true); // true = meeting context
            break;
          case 'give-gift':
            // Open gift selection modal
            openGiftSelectionModal(emp.id, true); // true = meeting context
            break;
          case 'request':
            // Open request image modal
            openRequestImageModal(emp.id, true); // true = meeting context
            break;
          case 'send':
            // Open send image modal
            openSendImageModal(emp.id, true); // true = meeting context
            break;
          case 'request-post':
            // Open request post modal
            openRequestPostModal(emp.id, true); // true = meeting context
            break;
          case 'visualize':
            // Generate scene visualization in meeting context
            generateMeetingSceneVisualization(emp.id);
            break;
        }
        
        selectedMeetingParticipant = null;
      });
    });
    
    // ========== MEETING PLAYER ATTACHMENT MENU ==========
    const meetingPlayerAttachBtn = $('meetingPlayerAttachBtn');
    const meetingPlayerAttachmentMenu = $('meetingPlayerAttachmentMenu');
    
    // Toggle player attachment menu
    if (meetingPlayerAttachBtn) {
      meetingPlayerAttachBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (meetingPlayerAttachmentMenu.style.display === 'none' || !meetingPlayerAttachmentMenu.style.display) {
          meetingPlayerAttachmentMenu.style.display = 'block';
        } else {
          meetingPlayerAttachmentMenu.style.display = 'none';
        }
      });
    }
    
    // Close player attachment menu when clicking outside
    document.addEventListener('click', (e) => {
      if (meetingPlayerAttachmentMenu && 
          !e.target.closest('#meetingPlayerAttachmentMenu') && 
          !e.target.closest('#meetingPlayerAttachBtn')) {
        meetingPlayerAttachmentMenu.style.display = 'none';
      }
    });
    
    // Handle player attachment menu actions
    document.querySelectorAll('.meeting-player-attach-item').forEach(item => {
      item.addEventListener('click', (e) => {
        const action = e.currentTarget.dataset.action;
        
        if (!gameState.activeMeeting) {
          showNotification('âš ï¸ No active meeting', 'error');
          return;
        }
        
        // Hide menu
        if (meetingPlayerAttachmentMenu) meetingPlayerAttachmentMenu.style.display = 'none';
        
        const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
        if (!meeting) return;
        
        // Handle different actions
        switch (action) {
          case 'send-money-group':
            openSendMoneyGroupModal(meeting);
            break;
          case 'order-food':
            openOrderFoodModal(meeting);
            break;
          case 'visualize-scene':
            generateMeetingSceneVisualization();
            break;
          case 'request-group-selfie':
            requestGroupSelfie(meeting);
            break;
          case 'read-the-room':
            readTheRoom(meeting);
            break;
          case 'team-building':
            openTeamBuildingModal(meeting);
            break;
        }
      });
    });
    
    // ========== MEETING PLAYER ATTACHMENT ACTION FUNCTIONS ==========
    
    /**
     * Open Send Money (Group) Modal
     * Multiplies the amount by number of participants
     */
    function openSendMoneyGroupModal(meeting) {
      if (!meeting || !meeting.participants || meeting.participants.length === 0) {
        showNotification('âŒ No participants to send money to', 'error');
        return;
      }
      
      // Get all participants as employees
      const participants = meeting.participants
        .map(p => gameState.employees.find(e => e.id === (p.id || p)))
        .filter(e => e);
      
      if (participants.length === 0) {
        showNotification('âŒ No valid participants found', 'error');
        return;
      }
      
      // Create modal
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
        <div class="modal-content">
          <h3>ğŸ’° Send Money to All Participants</h3>
          <p>Send the same amount to all ${participants.length} participant${participants.length > 1 ? 's' : ''}:</p>
          <ul style="max-height: 150px; overflow-y: auto; margin: 10px 0;">
            ${participants.map(emp => `<li>${emp.name}</li>`).join('')}
          </ul>
          <label>Amount per person: $<input type="number" id="groupMoneyAmount" min="1" step="1" value="1000" style="width: 120px;"></label>
          <p id="groupMoneyTotal" style="margin-top: 10px; font-weight: bold;">Total cost: $1,000</p>
          <label style="display: block; margin-top: 10px;">
            Optional message:
            <textarea id="groupMoneyMessage" rows="2" style="width: 100%; margin-top: 5px;" placeholder="Enter a message (optional)"></textarea>
          </label>
          <div style="margin-top: 15px;">
            <button id="confirmGroupMoney" class="styled-button">Send Money</button>
            <button id="cancelGroupMoney" class="styled-button">Cancel</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      const amountInput = document.getElementById('groupMoneyAmount');
      const totalDisplay = document.getElementById('groupMoneyTotal');
      const messageInput = document.getElementById('groupMoneyMessage');
      
      // Update total when amount changes
      function updateTotal() {
        const amount = parseInt(amountInput.value) || 0;
        const total = amount * participants.length;
        totalDisplay.textContent = `Total cost: $${formatCash(total)}`;
        
        // Warn if can't afford
        if (total > gameState.cash) {
          totalDisplay.style.color = '#ff4444';
          totalDisplay.textContent = `Total cost: $${formatCash(total)} (You only have $${formatCash(gameState.cash)})`;
        } else {
          totalDisplay.style.color = '';
        }
      }
      
      amountInput.addEventListener('input', updateTotal);
      updateTotal();
      
      // Confirm button
      document.getElementById('confirmGroupMoney').addEventListener('click', async () => {
        const amount = parseInt(amountInput.value) || 0;
        const message = messageInput.value.trim();
        const total = amount * participants.length;
        
        if (amount <= 0) {
          showNotification('âŒ Amount must be greater than 0', 'error');
          return;
        }
        
        if (total > gameState.cash) {
          showNotification('âŒ Not enough cash', 'error');
          return;
        }
        
        // Close modal
        document.body.removeChild(modal);
        
        // Send money to each participant
        for (const emp of participants) {
          await sendMoneyToNPC(amount, message, emp.id, true);
        }
        
        // Add summary message to meeting
        const summaryMsg = message
          ? `ğŸ’° Sent $${formatCash(amount)} to all ${participants.length} participants (Total: $${formatCash(total)})\n"${message}"`
          : `ğŸ’° Sent $${formatCash(amount)} to all ${participants.length} participants (Total: $${formatCash(total)})`;
        
        if (!meeting.messages) meeting.messages = [];
        meeting.messages.push({
          sender: 'System',
          content: summaryMsg,
          isSystem: true,
          timestamp: gameState.time?.currentTime || Date.now()
        });
        
        // Update meeting display if active
        if (window.activeMeetingId === meeting.id) {
          displayMeetingMessages(meeting.id);
        }
        
        showNotification(`ğŸ’° Sent $${formatCash(total)} total to ${participants.length} participants`, 'success');
      });
      
      // Cancel button
      document.getElementById('cancelGroupMoney').addEventListener('click', () => {
        document.body.removeChild(modal);
      });
      
      console.log('[Meeting] Send Money Group opened for meeting:', meeting.name, 'with', participants.length, 'participants');
    }
    
    /**
     * Open Order Food/Drinks Modal
     * Costs money but boosts morale for all participants
     */
    function openOrderFoodModal(meeting) {
      showNotification('ğŸ• Order Food/Drinks - Coming soon!', 'info');
      // TODO: Create modal with food/drink options
      // Cost increases with group size
      // Boosts morale and energy for all participants
      console.log('[Meeting] Order Food opened for meeting:', meeting.name);
    }
    
    /**
     * Generate Meeting Scene Visualization
     * Creates an image of the current meeting scene
     */
    async function generateMeetingSceneVisualization(participantId = null) {
      const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
      if (!meeting) return;
      
      showNotification('ğŸ¬ Generating scene visualization...', 'info');
      
      try {
        let prompt = '';
        
        if (participantId) {
          // Individual participant visualization (from participant menu)
          const emp = gameState.employees.find(e => e.id === participantId);
          if (!emp) return;
          
          console.log('[Meeting] Visualizing scene with participant:', emp.name);
          
          // Build focused prompt on specific participant
          const playerDesc = getPlayerPhysicalDescription();
          const empDesc = buildPhysicalDescription(emp);
          
          prompt = `${playerDesc} and ${empDesc} in a meeting at ${getCompanyName()}. ${meeting.topic || 'Business meeting'}. Professional office setting, modern conference room.`;
        } else {
          // Full meeting visualization (from player menu)
          console.log('[Meeting] Visualizing full meeting scene:', meeting.name);
          
          // Build prompt with all participants
          const playerDesc = getPlayerPhysicalDescription();
          const participants = meeting.participants
            .map(id => gameState.employees.find(e => e.id === id))
            .filter(e => e);
          
          const participantDescs = participants
            .map(emp => buildPhysicalDescription(emp))
            .join(', ');
          
          prompt = `Group meeting at ${getCompanyName()}: ${playerDesc}, and ${participantDescs} sitting around a conference table. ${meeting.topic || 'Business discussion'}. Professional office environment, modern conference room with windows.`;
        }
        
        // Generate image
        const imageUrl = await queuedGenerateImage(prompt, `Meeting scene visualization for ${meeting.name || 'meeting'}`);
        
        if (imageUrl) {
          // Add image to meeting chat
          addMeetingMessage({
            sender: 'system',
            content: participantId ? 'ğŸ¬ Scene visualization generated!' : 'ğŸ¬ Meeting scene visualization generated!',
            imageUrl: imageUrl,
            timestamp: Date.now()
          });
          
          showNotification('âœ… Scene visualized!', 'success');
        } else {
          throw new Error('Failed to generate image');
        }
      } catch (error) {
        console.error('[Meeting] Scene visualization error:', error);
        showNotification('âŒ Failed to generate visualization', 'error');
      }
    }
    
    /**
     * Request Group Selfie
     * Ask all participants to take a group photo
     */
    async function requestGroupSelfie(meeting) {
      showNotification('ğŸ“· Requesting group selfie...', 'info');
      console.log('[Meeting] Group selfie requested for meeting:', meeting.name);
      
      try {
        // VALIDATION: Check if meeting has participants
        if (!meeting.participants || meeting.participants.length === 0) {
          console.error('[Meeting Selfie] No participants in meeting');
          showNotification('âš ï¸ Cannot take selfie: No participants in meeting', 'error');
          return;
        }
        
        // Get all participants
        const playerDesc = getPlayerPhysicalDescription();
        
        // VALIDATION: Check player description
        if (!playerDesc || playerDesc.trim() === '') {
          console.error('[Meeting Selfie] Player physical description is empty');
          showNotification('âš ï¸ Cannot take selfie: Please set up your profile in Settings â†’ Player Profile', 'error');
          return;
        }
        
        const participants = meeting.participants
          .map(id => gameState.employees.find(e => e.id === id))
          .filter(e => e);
        
        // VALIDATION: Check if any valid participants found
        if (participants.length === 0) {
          console.error('[Meeting Selfie] No valid participants found');
          showNotification('âš ï¸ Cannot take selfie: No valid participants found', 'error');
          return;
        }
        
        const participantDescs = participants
          .map(emp => {
            const desc = buildPhysicalDescription(emp);
            // Fallback if description is empty
            if (!desc || desc.trim() === '') {
              console.warn(`[Meeting Selfie] Empty description for ${emp.name}`);
              return `${emp.name} (${emp.position})`;
            }
            return desc;
          })
          .join(', ');
        
        // Build casual, fun selfie prompt
        const prompt = `Group selfie: ${playerDesc}, ${participantDescs}. Everyone looking at camera, smiling, casual friendly pose, close together. Modern office background, bright lighting, smartphone selfie style.`;
        
        console.log('[Meeting Selfie] Generating image with prompt:', prompt);
        
        // Generate image
        const imageUrl = await queuedGenerateImage(prompt, `Meeting selfie for ${meeting.name || 'meeting'}`);
        
        // VALIDATION: Check if image was generated
        if (!imageUrl || imageUrl.trim() === '') {
          console.error('[Meeting Selfie] Failed to generate image - empty URL returned');
          showNotification('âŒ Failed to generate selfie image. Please try again or check your AI service.', 'error');
          return;
        }
        
        console.log('[Meeting Selfie] Image generated successfully:', imageUrl);
        
        // Generate AI-powered reactions from 1-2 random participants
        const numReactions = Math.min(participants.length, Math.random() > 0.5 ? 2 : 1);
        const reactors = [...participants].sort(() => Math.random() - 0.5).slice(0, numReactions);
        
        for (const reactor of reactors) {
          try {
            const reactionPrompt = `You are ${reactor.name}.
Personality: ${reactor.personality || 'Professional'}
Gender: ${reactor.gender || 'female'}
Affection toward boss: ${reactor.stats?.affection || 0}%

Your group just took a selfie together at a meeting. React briefly with enthusiasm!

Rules:
- 1 short sentence max
- Include an emoji
- Use *asterisks* for any physical action
- Be natural and in-character

${reactor.name}:`;
            
            const aiReaction = await queuedGenerateText(reactionPrompt, {
              temperature: 0.9,
              max_tokens: 40,
              stop: ['\n\n']
            }, `${reactor.name} reacting to group selfie`);
            
            const finalReaction = aiReaction?.trim() || `*grins* Great shot! ğŸ“¸`;
            
            // Add participant's reaction
            addMeetingMessage({
              sender: reactor.id,
              content: finalReaction,
              timestamp: Date.now()
            });
            
            // Store in meeting memory
            storeMeetingMemoryForNPC(reactor, meeting, finalReaction, 'took a group selfie');
            
          } catch (err) {
            console.warn(`[Meeting Selfie] Failed to generate reaction for ${reactor.name}:`, err);
            // Fallback reaction
            addMeetingMessage({
              sender: reactor.id,
              content: `*smiles for the camera* Nice! ğŸ“¸`,
              timestamp: Date.now()
            });
          }
        }
        
        // Add the selfie image
        addMeetingMessage({
          sender: 'system',
          content: 'ğŸ“· Group selfie!',
          imageUrl: imageUrl,
          timestamp: Date.now()
        });
        
        // Small relationship boost for all participants
        participants.forEach(emp => {
          if (emp.stats) {
            emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 2);
            emp.stats.comfort = Math.min(100, (emp.stats.comfort || 0) + 1);
          }
        });
        
        showNotification('âœ… Group selfie taken!', 'success');
        saveGame(false);
      } catch (error) {
        console.error('[Meeting] Group selfie error:', error);
        // Show detailed error message
        showNotification(`âŒ Failed to take group selfie: ${error.message}`, 'error');
      }
    }
    
    /**
     * Start Team Building Activity
     * Choose or AI-prompt an activity to improve stats
     */
    function openTeamBuildingModal(meeting) {
      showNotification('ğŸ® Team Building Activity - Coming soon!', 'info');
      console.log('[Meeting] Team Building opened for meeting:', meeting.name);
      // TODO: Create modal with activity options or prompt
      // Activities improve stats (morale, relationships, skills)
      // Has cooldown period
      // Can be AI-powered for variety
    }
    
    /**
     * READ THE ROOM - Observation System
     * Step back from conversation to observe group dynamics, body language, and hidden tensions/attractions
     * Uses AI to analyze all participants' stats, relationships, and conversation context
     */
    async function readTheRoom(meeting) {
      if (!meeting || !meeting.participants || meeting.participants.length === 0) {
        showNotification('âš ï¸ No participants to observe', 'error');
        return;
      }
      
      showNotification('ğŸ‘ï¸ Observing the room...', 'info');
      console.log('[Meeting] Reading the room for:', meeting.name);
      
      // Get all participants with their data
      const participants = meeting.participants
        .map(id => gameState.employees.find(e => e.id === id))
        .filter(e => e);
      
      if (participants.length === 0) {
        showNotification('âš ï¸ No valid participants found', 'error');
        return;
      }
      
      // Build comprehensive context for AI observation
      let playerName = getPlayerName();
      if (!playerName || playerName === 'the boss') playerName = 'Boss';
      
      // Build participant profiles with stats and relationships
      const participantProfiles = participants.map(emp => {
        const affection = emp.stats?.affection ?? 0;
        const comfort = emp.stats?.comfort ?? 0;
        const desire = emp.stats?.desire ?? 0;
        const trust = emp.stats?.trust ?? 0;
        const obedience = emp.stats?.obedience ?? 50;
        const productivity = emp.stats?.productivity ?? 50;
        
        // Get their relationships with other participants
        const interParticipantRels = participants
          .filter(other => other.id !== emp.id)
          .map(other => {
            const rel = emp.relationships?.[other.id];
            if (rel && rel.strength > 20) {
              return `${other.name}: ${rel.type || 'acquaintance'} (${Math.round(rel.strength)}%)`;
            }
            return null;
          })
          .filter(Boolean);
        
        // Check for active flags (dating, pregnant, etc.)
        const flags = getActiveFlags(emp);
        const flagInfo = flags.length > 0 ? flags.slice(0, 2).map(f => f.value || f.key).join(', ') : '';
        
        return `${emp.name} (${emp.gender}, ${emp.personality || 'professional'}):
  - Toward ${playerName}: Affection ${affection}%, Desire ${desire}%, Trust ${trust}%, Comfort ${comfort}%
  - Current mood indicators: ${productivity > 60 ? 'engaged' : productivity > 30 ? 'neutral' : 'distracted'}, ${obedience > 60 ? 'deferential' : obedience > 40 ? 'balanced' : 'independent-minded'}
  ${interParticipantRels.length > 0 ? `- Relations with others: ${interParticipantRels.join('; ')}` : ''}
  ${flagInfo ? `- Notable: ${flagInfo}` : ''}`;
      }).join('\n\n');
      
      // Get recent conversation for context
      const recentMessages = meeting.messages.slice(-10).map(msg => {
        const speaker = msg.speakerId === 'player' ? playerName :
          participants.find(p => p.id === msg.speakerId)?.name || 'Unknown';
        return `${speaker}: ${msg.content.substring(0, 100)}`;
      }).join('\n');
      
      // Find interesting dynamics to highlight
      const dynamics = [];
      
      // Check for high desire (attraction)
      participants.forEach(emp => {
        if ((emp.stats?.desire ?? 0) > 50) {
          dynamics.push(`${emp.name} appears attracted to ${playerName}`);
        }
      });
      
      // Check for inter-participant relationships
      participants.forEach(emp => {
        participants.forEach(other => {
          if (emp.id !== other.id) {
            const rel = emp.relationships?.[other.id];
            if (rel) {
              if (rel.type === 'crush' || rel.type === 'romantic') {
                dynamics.push(`${emp.name} has romantic feelings toward ${other.name}`);
              } else if (rel.type === 'rival' || rel.type === 'enemy') {
                dynamics.push(`Tension between ${emp.name} and ${other.name}`);
              } else if (rel.strength > 70) {
                dynamics.push(`${emp.name} and ${other.name} are very close`);
              }
            }
          }
        });
      });
      
      // Build AI prompt
      const observationPrompt = `You are narrating what ${playerName} (the boss) notices when they take a moment to observe the room during a meeting.

PARTICIPANTS IN THE ROOM:
${participantProfiles}

${dynamics.length > 0 ? `KNOWN DYNAMICS:\n${dynamics.join('\n')}` : ''}

RECENT CONVERSATION:
${recentMessages || 'The meeting just started.'}

TASK: Write 3-5 vivid observations about what ${playerName} notices when they look around the room. Include:
1. Body language and micro-expressions (who's leaning in, fidgeting, making eye contact with whom)
2. Hidden dynamics (attraction, tension, nervousness, boredom, secrets)
3. At least one specific detail about each participant
4. Any interesting interactions between participants (glances exchanged, whispered comments, reactions)

FORMAT: Write in second person ("You notice..."). Be specific and evocative. Use *asterisks* for actions you observe. Keep each observation 1-2 sentences. Total should be 150-200 words.

DO NOT: Make up information not supported by the stats. Don't reveal things the boss couldn't plausibly observe.

OBSERVATIONS:`;
      
      try {
        const observations = await queuedGenerateText(observationPrompt, {
          temperature: 0.9,
          max_tokens: 350,
          stop: ['\n\n\n']
        }, 'Reading the room observations');
        
        if (!observations || observations.trim() === '') {
          throw new Error('Empty observation response');
        }
        
        // Add observation as a special "insight" message
        const insightMessage = {
          id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          speakerId: 'system',
          content: `ğŸ‘ï¸ **You take a moment to observe the room...**\n\n${observations.trim()}`,
          timestamp: gameState.time?.currentTime || Date.now(),
          isObservation: true
        };
        
        meeting.messages.push(insightMessage);
        addMeetingMessageToUI(insightMessage, meeting);
        
        // Chance for spontaneous NPC-to-NPC interaction based on dynamics
        if (dynamics.length > 0 && Math.random() > 0.4) {
          await triggerSpontaneousInteraction(meeting, participants, dynamics);
        }
        
        // Small insight bonus - slightly increases trust with all observed NPCs
        participants.forEach(emp => {
          if (emp.stats) {
            emp.stats.trust = Math.min(100, (emp.stats.trust || 0) + 1);
          }
        });
        
        // Track that we've observed this meeting (cooldown)
        meeting.lastObservation = Date.now();
        
        saveGame(false);
        showNotification('ğŸ‘ï¸ Gained insight into the room dynamics', 'success');
        
      } catch (error) {
        console.error('[Read the Room] Error:', error);
        showNotification('âŒ Failed to observe the room', 'error');
      }
    }
    
    /**
     * Trigger a spontaneous NPC-to-NPC interaction based on observed dynamics
     * This makes meetings feel alive - NPCs react to each other, not just the player
     */
    async function triggerSpontaneousInteraction(meeting, participants, dynamics) {
      if (participants.length < 2) return;
      
      // Pick a random dynamic to spark an interaction
      const dynamic = dynamics[Math.floor(Math.random() * dynamics.length)];
      
      // Find the NPCs involved
      let initiator = null;
      let target = null;
      
      // Parse the dynamic to find participants
      for (const emp of participants) {
        if (dynamic.includes(emp.name)) {
          if (!initiator) initiator = emp;
          else if (!target) target = emp;
        }
      }
      
      // If we couldn't find both from the dynamic, pick randomly
      if (!initiator || !target) {
        const shuffled = [...participants].sort(() => Math.random() - 0.5);
        initiator = shuffled[0];
        target = shuffled[1] || shuffled[0];
      }
      
      // Determine interaction type
      let interactionType = 'neutral';
      if (dynamic.includes('attracted') || dynamic.includes('romantic') || dynamic.includes('close')) {
        interactionType = 'warm';
      } else if (dynamic.includes('tension') || dynamic.includes('rival')) {
        interactionType = 'tense';
      }
      
      const interactionPrompt = `You are ${initiator.name}.
Personality: ${initiator.personality || 'professional'}
Gender: ${initiator.gender || 'female'}

You're in a meeting. Your boss just paused to look around the room. You take this moment to ${interactionType === 'warm' ? 'share a warm moment with' : interactionType === 'tense' ? 'exchange a loaded look with' : 'briefly interact with'} ${target.name}.

Dynamic context: ${dynamic}

Write a BRIEF (1 sentence) action or quiet comment directed at ${target.name}. Use *asterisks* for physical actions. This is a small side moment, not the main conversation.

${initiator.name}:`;
      
      try {
        const interaction = await queuedGenerateText(interactionPrompt, {
          temperature: 0.9,
          max_tokens: 60,
          stop: ['\n\n']
        }, `${initiator.name} spontaneous interaction`);
        
        if (interaction && interaction.trim()) {
          // Add slight delay for natural feel
          await new Promise(resolve => setTimeout(resolve, 1500));
          
          const interactionMsg = {
            id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            speakerId: initiator.id,
            content: interaction.trim(),
            timestamp: gameState.time?.currentTime || Date.now(),
            isSpontaneous: true
          };
          
          meeting.messages.push(interactionMsg);
          addMeetingMessageToUI(interactionMsg, meeting);
          
          // Store in meeting memory
          storeMeetingMemoryForNPC(initiator, meeting, interaction.trim(), `spontaneous moment with ${target.name}`);
          
          // Maybe target responds (50% chance)
          if (Math.random() > 0.5) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            const responsePrompt = `You are ${target.name}.
Personality: ${target.personality || 'professional'}

${initiator.name} just did/said: "${interaction.trim()}"
You respond briefly (1 sentence max). Use *asterisks* for actions.

${target.name}:`;
            
            const response = await queuedGenerateText(responsePrompt, {
              temperature: 0.9,
              max_tokens: 50,
              stop: ['\n\n']
            }, `${target.name} responding to ${initiator.name}`);
            
            if (response && response.trim()) {
              const responseMsg = {
                id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                speakerId: target.id,
                content: response.trim(),
                timestamp: gameState.time?.currentTime || Date.now(),
                isSpontaneous: true
              };
              
              meeting.messages.push(responseMsg);
              addMeetingMessageToUI(responseMsg, meeting);
              storeMeetingMemoryForNPC(target, meeting, response.trim(), `responded to ${initiator.name}`);
            }
          }
          
          saveGame(false);
        }
      } catch (error) {
        console.warn('[Spontaneous Interaction] Error:', error);
        // Silent fail - this is a bonus feature
      }
    }
    
    // ========== MEETING ATTACHMENT MODAL FUNCTIONS ==========
    
    /**
     * Open Request Image Modal
     * Request an image from an NPC (works in both 1-on-1 and meeting contexts)
     * @param {string} employeeId - Employee to request from
     * @param {boolean} isMeetingContext - Whether this is from a meeting
     */
    function openRequestImageModal(employeeId, isMeetingContext = false) {
      const emp = gameState.employees.find(e => e.id === employeeId);
      if (!emp) {
        showNotification('âš ï¸ Employee not found', 'error');
        return;
      }
      
      // Simple prompt-based request for now
      const request = prompt(`Request an image from ${emp.name}:\n\nDescribe what you'd like them to send you (e.g., "selfie", "what you're wearing", "your workspace")`);
      
      if (!request || request.trim() === '') {
        return; // User cancelled
      }
      
      console.log(`[Image Request] ${emp.name} - "${request}" (Meeting: ${isMeetingContext})`);
      
      // Send request message
      const requestMessage = `Could you send me ${request.toLowerCase().startsWith('a ') || request.toLowerCase().startsWith('an ') ? '' : 'a '}${request}?`;
      
      if (isMeetingContext && gameState.activeMeeting) {
        // Send in meeting chat
        const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
        if (meeting) {
          sendMeetingMessage(requestMessage);
          // Trigger meeting-context image request handler
          handleNPCImageRequest(emp, request, true);
        }
      } else {
        // Send in 1-on-1 chat
        if (!gameState.chatHistory[emp.id]) {
          gameState.chatHistory[emp.id] = [];
        }
        
        const msg = {
          sender: 'player',
          content: requestMessage,
          isPlayer: true,
          timestamp: gameState.time?.currentTime || Date.now()
        };
        
        gameState.chatHistory[emp.id].push(msg);
        
        // Switch to chat with this employee if not already
        if (gameState.activeTab !== 'messages') {
          gameState.activeTab = 'messages';
          switchTab('messages');
        }
        loadChat(emp);
        
        // Generate response
        handleNPCImageRequest(emp, request, false);
      }
      
      showNotification(`ğŸ“· Image requested from ${emp.name}`, 'info');
    }
    
    /**
     * Handle NPC response to image request - AI-powered with actual image generation
     */
    async function handleNPCImageRequest(emp, request, isMeetingContext = false) {
      ensureEmployeeMemory(emp);
      
      // Get player name
      let playerName = getPlayerName();
      if (!playerName || playerName === 'the boss') playerName = 'Boss';
      
      // Build context
      const affection = emp.stats?.affection ?? 0;
      const comfort = emp.stats?.comfort ?? 0;
      const desire = emp.stats?.desire ?? 0;
      const trust = emp.stats?.trust ?? 0;
      const obedience = emp.stats?.obedience ?? 50;
      
      // Determine if request is risquÃ©
      const lowerRequest = request.toLowerCase();
      const isRisque = /sexy|nude|naked|underwear|lingerie|shirtless|provocative|intimate|revealing|bra|panties|topless/i.test(lowerRequest);
      
      // Determine willingness based on stats and request type
      let willingness = 'willing';
      let contextNote = '';
      
      if (isRisque) {
        const intimacyScore = (desire * 0.4) + (trust * 0.3) + (comfort * 0.2) + (obedience * 0.1);
        if (intimacyScore > 60) {
          willingness = 'flattered and willing';
          contextNote = 'Given your attraction and trust, you\'re happy to oblige this intimate request.';
        } else if (intimacyScore > 40) {
          willingness = 'hesitant but considering';
          contextNote = 'This is a bit forward, but you might be willing if teased into it.';
        } else {
          willingness = 'declining politely';
          contextNote = 'This request is too forward for your current comfort level. Politely decline or deflect.';
        }
      }
      
      // Meeting context affects willingness
      let meetingNote = '';
      if (isMeetingContext && gameState.activeMeeting) {
        const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
        if (meeting) {
          const otherParticipants = meeting.participants.filter(id => id !== emp.id).length;
          if (otherParticipants > 0 && isRisque) {
            meetingNote = `\nNOTE: Others are watching in this group meeting! ${isRisque ? 'Keep response appropriate - you wouldn\'t send something risquÃ© with coworkers watching.' : ''}`;
            if (isRisque) willingness = 'deflecting - inappropriate for group setting';
          }
        }
      }
      
      // Generate AI response
      const responsePrompt = `You are ${emp.name}.
Personality: ${emp.personality || 'Professional'}
Gender: ${emp.gender || 'female'}
Relationship with ${playerName}: Affection ${affection}%, Trust ${trust}%, Desire ${desire}%, Comfort ${comfort}%

${playerName} requested: "${request}"
${contextNote}${meetingNote}

Your attitude toward this request: ${willingness}

Respond with a BRIEF reply (1-2 sentences). Use *asterisks* for actions. Stay in character. If willing, indicate you're about to send it.

${emp.name}:`;
      
      try {
        const response = await queuedGenerateText(responsePrompt, {
          temperature: 0.85,
          max_tokens: 80,
          stop: ['\n\n', `${playerName}:`]
        }, `${emp.name} responding to image request`);
        
        const finalResponse = response?.trim() || `*considers the request* Let me see what I can do... ğŸ“¸`;
        
        // Add response to chat
        if (isMeetingContext && gameState.activeMeeting) {
          const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
          if (meeting) {
            const msgObj = {
              id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              speakerId: emp.id,
              content: finalResponse,
              timestamp: gameState.time?.currentTime || Date.now()
            };
            meeting.messages.push(msgObj);
            addMeetingMessageToUI(msgObj, meeting);
            storeMeetingMemoryForNPC(emp, meeting, finalResponse, `requested image: ${request}`);
            saveGame(false);
          }
        } else {
          const msg = {
            sender: emp.name,
            content: finalResponse,
            isPlayer: false,
            timestamp: gameState.time?.currentTime || Date.now()
          };
          if (!gameState.chatHistory[emp.id]) gameState.chatHistory[emp.id] = [];
          gameState.chatHistory[emp.id].push(msg);
          if (gameState.activeChat?.id === emp.id) addMessageToChat(msg);
          saveGame(false);
        }
        
        // If willing, actually generate and send the image after a delay
        if (willingness.includes('willing') || willingness.includes('flattered')) {
          setTimeout(async () => {
            await generateAndDeliverRequestedImage(emp, request, isMeetingContext);
          }, 2000 + Math.random() * 3000);
        }
        
      } catch (error) {
        console.error('[Image Request] Error generating AI response:', error);
        const fallback = `*thinks about it* I'll see what I can do! ğŸ“·`;
        if (isMeetingContext && gameState.activeMeeting) {
          const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
          if (meeting) {
            const msgObj = { id: `msg_${Date.now()}`, speakerId: emp.id, content: fallback, timestamp: gameState.time?.currentTime || Date.now() };
            meeting.messages.push(msgObj);
            addMeetingMessageToUI(msgObj, meeting);
            saveGame(false);
          }
        } else {
          const msg = { sender: emp.name, content: fallback, isPlayer: false, timestamp: gameState.time?.currentTime || Date.now() };
          if (!gameState.chatHistory[emp.id]) gameState.chatHistory[emp.id] = [];
          gameState.chatHistory[emp.id].push(msg);
          if (gameState.activeChat?.id === emp.id) addMessageToChat(msg);
          saveGame(false);
        }
      }
    }
    
    /**
     * Generate and deliver the requested image from NPC
     */
    async function generateAndDeliverRequestedImage(emp, request, isMeetingContext) {
      try {
        // Build image prompt based on NPC's appearance and the request
        const physicalDesc = buildPhysicalDescription(emp);
        const scenario = request.toLowerCase();
        
        // Determine pose/setting based on request
        let imagePrompt = `${physicalDesc}`;
        
        if (scenario.includes('selfie')) {
          imagePrompt += ', selfie pose, holding phone, looking at camera';
        } else if (scenario.includes('workspace') || scenario.includes('desk')) {
          imagePrompt += ', at office desk, professional setting';
        } else if (scenario.includes('outfit') || scenario.includes('wearing')) {
          imagePrompt += ', full body shot showing outfit';
        } else if (scenario.includes('smile') || scenario.includes('happy')) {
          imagePrompt += ', warm smile, friendly expression';
        } else {
          imagePrompt += `, ${request}`;
        }
        
        imagePrompt += '. High quality, natural lighting.';
        
        showNotification(`ğŸ“¸ ${emp.name} is taking a photo...`, 'info');
        
        const imageUrl = await queuedGenerateImage(imagePrompt, `${emp.name} sending requested image`);
        
        if (imageUrl) {
          // Add image message
          if (isMeetingContext && gameState.activeMeeting) {
            const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
            if (meeting) {
              const msgObj = {
                id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                speakerId: emp.id,
                content: `*sends the photo* Here you go! ğŸ“·`,
                imageUrl: imageUrl,
                timestamp: gameState.time?.currentTime || Date.now()
              };
              meeting.messages.push(msgObj);
              addMeetingMessageToUI(msgObj, meeting);
              saveGame(false);
            }
          } else {
            const msg = {
              sender: emp.name,
              content: `*sends the photo* Here you go! ğŸ“·`,
              imageUrl: imageUrl,
              isPlayer: false,
              timestamp: gameState.time?.currentTime || Date.now()
            };
            if (!gameState.chatHistory[emp.id]) gameState.chatHistory[emp.id] = [];
            gameState.chatHistory[emp.id].push(msg);
            if (gameState.activeChat?.id === emp.id) addMessageToChat(msg);
            saveGame(false);
          }
          
          showNotification(`ğŸ“· ${emp.name} sent a photo!`, 'success');
        }
      } catch (error) {
        console.error('[Image Request] Failed to generate image:', error);
        // Send apologetic message
        const apology = `*frowns at phone* Sorry, my camera's acting up! Maybe later? ğŸ˜…`;
        if (isMeetingContext && gameState.activeMeeting) {
          const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
          if (meeting) {
            const msgObj = { id: `msg_${Date.now()}`, speakerId: emp.id, content: apology, timestamp: gameState.time?.currentTime || Date.now() };
            meeting.messages.push(msgObj);
            addMeetingMessageToUI(msgObj, meeting);
            saveGame(false);
          }
        } else {
          const msg = { sender: emp.name, content: apology, isPlayer: false, timestamp: gameState.time?.currentTime || Date.now() };
          if (!gameState.chatHistory[emp.id]) gameState.chatHistory[emp.id] = [];
          gameState.chatHistory[emp.id].push(msg);
          if (gameState.activeChat?.id === emp.id) addMessageToChat(msg);
          saveGame(false);
        }
      }
    }
    
    /**
     * Open Send Image Modal
     * Send an image to an NPC (works in both 1-on-1 and meeting contexts)
     * @param {string} employeeId - Employee to send to
     * @param {boolean} isMeetingContext - Whether this is from a meeting
     */
    function openSendImageModal(employeeId, isMeetingContext = false) {
      const emp = gameState.employees.find(e => e.id === employeeId);
      if (!emp) {
        showNotification('âš ï¸ Employee not found', 'error');
        return;
      }
      
      // Simple prompt-based send for now
      const imageDesc = prompt(`Send an image to ${emp.name}:\n\nDescribe the image you want to send (e.g., "me at my desk", "a funny meme", "what I'm working on")`);
      
      if (!imageDesc || imageDesc.trim() === '') {
        return; // User cancelled
      }
      
      console.log(`[Image Send] Sending to ${emp.name} - "${imageDesc}" (Meeting: ${isMeetingContext})`);
      
      showNotification('ğŸ¨ Generating image...', 'info');
      
      // Generate image
      generateAndSendImage(emp, imageDesc, isMeetingContext);
    }
    
    /**
     * Generate and send image to NPC
     */
    async function generateAndSendImage(emp, imageDesc, isMeetingContext) {
      try {
        // Get player description for context
        const playerDesc = getPlayerPhysicalDescription() || 'person';
        
        // Build prompt
        const prompt = `${playerDesc}, ${imageDesc}`;
        
        // Generate image
        const imageUrl = await queuedGenerateImage(applyImageStyle(prompt), `Custom image request`);
        
        if (!imageUrl) {
          throw new Error('Image generation failed');
        }
        
        // Send message with image
        const message = `ğŸ“¤ Sent you this!`;
        
        if (isMeetingContext && gameState.activeMeeting) {
          // Send in meeting - TODO: Need to add image support to meeting messages
          const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
          if (meeting) {
            const msgObj = {
              id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              speakerId: 'player',
              content: message,
              timestamp: gameState.time?.currentTime || Date.now(),
              imageUrl: imageUrl,
              imagePrompt: prompt
            };
            
            meeting.messages.push(msgObj);
            addMeetingMessageToUI(msgObj, meeting);
            saveGame(false);
          }
        } else {
          // Send in 1-on-1 chat
          if (!gameState.chatHistory[emp.id]) {
            gameState.chatHistory[emp.id] = [];
          }
          
          const msg = {
            sender: 'player',
            content: message,
            isPlayer: true,
            timestamp: gameState.time?.currentTime || Date.now(),
            imageUrl: imageUrl,
            imagePrompt: prompt
          };
          
          gameState.chatHistory[emp.id].push(msg);
          
          if (gameState.activeChat && gameState.activeChat.id === emp.id) {
            addMessageToChat(msg);
          }
          
          saveGame(false);
        }
        
        showNotification(`âœ… Image sent to ${emp.name}!`, 'success');
        
        // Generate NPC reaction
        setTimeout(() => {
          handleNPCImageReaction(emp, imageDesc, isMeetingContext);
        }, 2000 + Math.random() * 3000);
        
      } catch (error) {
        console.error('[Image Send] Error:', error);
        showNotification('âŒ Failed to send image', 'error');
      }
    }
    
    /**
     * Handle NPC reaction to received image - AI-powered, personality-grounded
     */
    async function handleNPCImageReaction(emp, imageDesc, isMeetingContext) {
      ensureEmployeeMemory(emp);
      
      // Get player name
      let playerName = getPlayerName();
      if (!playerName || playerName === 'the boss') playerName = 'Boss';
      
      // Build context for AI reaction
      const affection = emp.stats?.affection ?? 0;
      const comfort = emp.stats?.comfort ?? 0;
      const desire = emp.stats?.desire ?? 0;
      const trust = emp.stats?.trust ?? 0;
      
      // Determine reaction tone based on stats
      const reactionTone = affection > 70 ? 'enthusiastic and warm' :
        affection > 40 ? 'friendly and appreciative' :
        affection > 20 ? 'polite but reserved' : 'professional and brief';
      
      // Check if image is risquÃ© based on description
      const lowerDesc = imageDesc.toLowerCase();
      const isRisque = /sexy|nude|naked|underwear|lingerie|shirtless|provocative|intimate|bedroom|flirt/i.test(lowerDesc);
      
      let contextNote = '';
      if (isRisque) {
        if (desire > 60 && trust > 50) {
          contextNote = 'The image is somewhat intimate. Given your attraction, you\'re pleasantly surprised and maybe a bit flustered.';
        } else if (comfort > 50) {
          contextNote = 'The image is somewhat intimate. You\'re comfortable enough to react with playful surprise.';
        } else {
          contextNote = 'The image is somewhat intimate. React appropriately to your comfort level - maybe surprised or caught off guard.';
        }
      }
      
      // Build meeting context if applicable
      let meetingNote = '';
      if (isMeetingContext && gameState.activeMeeting) {
        const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
        if (meeting) {
          const otherParticipants = meeting.participants
            .map(id => gameState.employees.find(e => e.id === id))
            .filter(e => e && e.id !== emp.id)
            .map(e => e.name);
          if (otherParticipants.length > 0) {
            meetingNote = `\nNOTE: You're in a group meeting with ${otherParticipants.join(', ')}. Others can see your reaction. ${isRisque ? 'Keep your reaction appropriate for the group setting.' : ''}`;
          }
        }
      }
      
      const prompt = `You are ${emp.name}.
Personality: ${emp.personality || 'Professional'}
Gender: ${emp.gender || 'female'}
Relationship with ${playerName}: Affection ${affection}%, Trust ${trust}%, Desire ${desire}%

${playerName} just sent you an image described as: "${imageDesc}"
${contextNote}${meetingNote}

Reaction tone should be: ${reactionTone}

Respond with a BRIEF reaction (1 sentence max). Use *asterisks* for any physical reaction. Include an emoji. Stay in character.

${emp.name}:`;
      
      try {
        const reaction = await queuedGenerateText(prompt, {
          temperature: 0.9,
          max_tokens: 60,
          stop: ['\n\n', `${playerName}:`]
        }, `${emp.name} reacting to image`);
        
        const finalReaction = reaction?.trim() || `*looks at the image* Thanks for sharing! ğŸ˜Š`;
        
        if (isMeetingContext && gameState.activeMeeting) {
          const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
          if (meeting) {
            const msgObj = {
              id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              speakerId: emp.id,
              content: finalReaction,
              timestamp: gameState.time?.currentTime || Date.now()
            };
            
            meeting.messages.push(msgObj);
            addMeetingMessageToUI(msgObj, meeting);
            
            // Store in NPC's meeting memory
            storeMeetingMemoryForNPC(emp, meeting, finalReaction, `sent an image: ${imageDesc}`);
            saveGame(false);
          }
        } else {
          const msg = {
            sender: emp.name,
            content: finalReaction,
            isPlayer: false,
            timestamp: gameState.time?.currentTime || Date.now()
          };
          
          if (!gameState.chatHistory[emp.id]) gameState.chatHistory[emp.id] = [];
          gameState.chatHistory[emp.id].push(msg);
          
          if (gameState.activeChat && gameState.activeChat.id === emp.id) {
            addMessageToChat(msg);
          }
          
          saveGame(false);
        }
        
        // Small stat boost based on reaction
        if (emp.stats) {
          emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 1);
        }
        
      } catch (error) {
        console.error('[Image Reaction] Error generating AI reaction:', error);
        // Fallback to simple reaction
        const fallback = `*looks at the image* Nice! ğŸ‘`;
        if (isMeetingContext && gameState.activeMeeting) {
          const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
          if (meeting) {
            const msgObj = {
              id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              speakerId: emp.id,
              content: fallback,
              timestamp: gameState.time?.currentTime || Date.now()
            };
            meeting.messages.push(msgObj);
            addMeetingMessageToUI(msgObj, meeting);
            saveGame(false);
          }
        } else {
          const msg = { sender: emp.name, content: fallback, isPlayer: false, timestamp: gameState.time?.currentTime || Date.now() };
          if (!gameState.chatHistory[emp.id]) gameState.chatHistory[emp.id] = [];
          gameState.chatHistory[emp.id].push(msg);
          if (gameState.activeChat?.id === emp.id) addMessageToChat(msg);
          saveGame(false);
        }
      }
    }
    
    /**
     * Open Request Post Modal
     * Request a social media post from an NPC
     * @param {string} employeeId - Employee to request from
     * @param {boolean} isMeetingContext - Whether this is from a meeting
     */
    function openRequestPostModal(employeeId, isMeetingContext = false) {
      const emp = gameState.employees.find(e => e.id === employeeId);
      if (!emp) {
        showNotification('âš ï¸ Employee not found', 'error');
        return;
      }
      
      // Simple prompt-based request
      const request = prompt(`Request a social media post from ${emp.name}:\n\nWhat should they post about? (e.g., "their weekend plans", "work progress", "a selfie")`);
      
      if (!request || request.trim() === '') {
        return; // User cancelled
      }
      
      console.log(`[Post Request] ${emp.name} - "${request}" (Meeting: ${isMeetingContext})`);
      
      const requestMessage = `Could you post something about ${request}?`;
      
      if (isMeetingContext && gameState.activeMeeting) {
        // Send in meeting chat
        const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
        if (meeting) {
          sendMeetingMessage(requestMessage);
        }
      } else {
        // Send in 1-on-1 chat
        if (!gameState.chatHistory[emp.id]) {
          gameState.chatHistory[emp.id] = [];
        }
        
        const msg = {
          sender: 'player',
          content: requestMessage,
          isPlayer: true,
          timestamp: gameState.time?.currentTime || Date.now()
        };
        
        gameState.chatHistory[emp.id].push(msg);
        
        if (gameState.activeChat && gameState.activeChat.id === emp.id) {
          addMessageToChat(msg);
        }
      }
      
      showNotification(`ğŸ“± Post requested from ${emp.name}`, 'info');
      
      // Generate AI-powered NPC response and create post
      handlePostRequest(emp, request, isMeetingContext);
    }
    
    /**
     * Handle NPC response to post request - AI-powered
     */
    async function handlePostRequest(emp, request, isMeetingContext) {
      ensureEmployeeMemory(emp);
      
      let playerName = getPlayerName();
      if (!playerName || playerName === 'the boss') playerName = 'Boss';
      
      const affection = emp.stats?.affection ?? 0;
      const comfort = emp.stats?.comfort ?? 0;
      const obedience = emp.stats?.obedience ?? 50;
      
      // Determine willingness
      const willingnessScore = (affection * 0.4) + (comfort * 0.3) + (obedience * 0.3);
      const willingness = willingnessScore > 60 ? 'happy to oblige' :
        willingnessScore > 40 ? 'agreeable' : 'a bit reluctant but willing';
      
      // Meeting context
      let meetingNote = '';
      if (isMeetingContext && gameState.activeMeeting) {
        const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
        if (meeting) {
          meetingNote = `\nNOTE: You're in a group meeting. Others will see your response.`;
        }
      }
      
      const responsePrompt = `You are ${emp.name}.
Personality: ${emp.personality || 'Professional'}
Relationship with ${playerName}: Affection ${affection}%

${playerName} asked you to post on social media about: "${request}"${meetingNote}

Your attitude: ${willingness}

Respond with a BRIEF reply (1-2 sentences) acknowledging the request. Use *asterisks* for actions. Stay in character.

${emp.name}:`;
      
      try {
        const response = await queuedGenerateText(responsePrompt, {
          temperature: 0.85,
          max_tokens: 60,
          stop: ['\n\n', `${playerName}:`]
        }, `${emp.name} responding to post request`);
        
        const finalResponse = response?.trim() || `*pulls out phone* Sure, I'll post something! ğŸ“±`;
        
        if (isMeetingContext && gameState.activeMeeting) {
          const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
          if (meeting) {
            const msgObj = {
              id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              speakerId: emp.id,
              content: finalResponse,
              timestamp: gameState.time?.currentTime || Date.now()
            };
            meeting.messages.push(msgObj);
            addMeetingMessageToUI(msgObj, meeting);
            storeMeetingMemoryForNPC(emp, meeting, finalResponse, `asked to post about: ${request}`);
            saveGame(false);
          }
        } else {
          const msg = {
            sender: emp.name,
            content: finalResponse,
            isPlayer: false,
            timestamp: gameState.time?.currentTime || Date.now()
          };
          if (!gameState.chatHistory[emp.id]) gameState.chatHistory[emp.id] = [];
          gameState.chatHistory[emp.id].push(msg);
          if (gameState.activeChat?.id === emp.id) addMessageToChat(msg);
          saveGame(false);
        }
        
        // Actually create the social media post after a delay
        setTimeout(async () => {
          await generateNPCPost(emp, request, isMeetingContext);
        }, 2000 + Math.random() * 3000);
        
      } catch (error) {
        console.error('[Post Request] Error generating AI response:', error);
        const fallback = `*nods* I'll post something about that! ğŸ“±`;
        if (isMeetingContext && gameState.activeMeeting) {
          const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
          if (meeting) {
            const msgObj = { id: `msg_${Date.now()}`, speakerId: emp.id, content: fallback, timestamp: gameState.time?.currentTime || Date.now() };
            meeting.messages.push(msgObj);
            addMeetingMessageToUI(msgObj, meeting);
            saveGame(false);
          }
        } else {
          const msg = { sender: emp.name, content: fallback, isPlayer: false, timestamp: gameState.time?.currentTime || Date.now() };
          if (!gameState.chatHistory[emp.id]) gameState.chatHistory[emp.id] = [];
          gameState.chatHistory[emp.id].push(msg);
          if (gameState.activeChat?.id === emp.id) addMessageToChat(msg);
          saveGame(false);
        }
      }
    }
    
    /**
     * Generate an actual social media post from NPC
     */
    async function generateNPCPost(emp, topic, isMeetingContext) {
      try {
        // Generate post content
        const postPrompt = `You are ${emp.name}, posting on social media.
Personality: ${emp.personality || 'Professional'}
Your boss asked you to post about: "${topic}"

Write a short, authentic social media post (1-3 sentences) about this topic. Be natural, use emojis if fitting your personality. Don't be overly formal.

Post:`;
        
        const postContent = await queuedGenerateText(postPrompt, {
          temperature: 0.9,
          max_tokens: 100,
          stop: ['\n\n']
        }, `${emp.name} writing social post`);
        
        if (postContent && postContent.trim()) {
          // Create the post
          if (!gameState.socialNetwork) gameState.socialNetwork = { posts: [] };
          if (!gameState.socialNetwork.posts) gameState.socialNetwork.posts = [];
          
          const newPost = {
            id: `post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            authorId: emp.id,
            content: postContent.trim(),
            timestamp: Date.now(),
            likes: Math.floor(Math.random() * 10),
            comments: [],
            isPlayerPost: false
          };
          
          gameState.socialNetwork.posts.unshift(newPost);
          
          // Notify in chat
          const notifyMsg = `*just posted* "${postContent.trim().substring(0, 50)}${postContent.trim().length > 50 ? '...' : ''}" ğŸ“±âœ¨`;
          
          if (isMeetingContext && gameState.activeMeeting) {
            const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
            if (meeting) {
              const msgObj = {
                id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                speakerId: emp.id,
                content: notifyMsg,
                timestamp: gameState.time?.currentTime || Date.now()
              };
              meeting.messages.push(msgObj);
              addMeetingMessageToUI(msgObj, meeting);
              saveGame(false);
            }
          } else {
            const msg = {
              sender: emp.name,
              content: notifyMsg,
              isPlayer: false,
              timestamp: gameState.time?.currentTime || Date.now()
            };
            if (!gameState.chatHistory[emp.id]) gameState.chatHistory[emp.id] = [];
            gameState.chatHistory[emp.id].push(msg);
            if (gameState.activeChat?.id === emp.id) addMessageToChat(msg);
            saveGame(false);
          }
          
          showNotification(`ğŸ“± ${emp.name} posted on social media!`, 'success');
        }
      } catch (error) {
        console.error('[Post Generation] Error:', error);
      }
    }
    
    /**
     * Open Gift Selection Modal
     * Give a gift to an NPC (works in both 1-on-1 and meeting contexts)
     * @param {string} employeeId - Employee to give gift to
     * @param {boolean} isMeetingContext - Whether this is from a meeting
     */
    function openGiftSelectionModal(employeeId, isMeetingContext = false) {
      const emp = gameState.employees.find(e => e.id === employeeId);
      if (!emp) {
        showNotification('âš ï¸ Employee not found', 'error');
        return;
      }
      
      // Store context for when gift is selected
      window.currentGiftContext = {
        employeeId: employeeId,
        isMeeting: isMeetingContext
      };
      
      // Set gameState.activeChat temporarily so existing modal works
      const previousChat = gameState.activeChat;
      gameState.activeChat = emp;
      
      // Call existing gift modal function
      if (typeof window.openGiftSelectionModal === 'function') {
        window.openGiftSelectionModal();
      }
      
      // Restore previous chat after modal opens
      setTimeout(() => {
        if (!isMeetingContext) {
          gameState.activeChat = previousChat;
        }
      }, 100);
    }
    
    // Stop Meeting Replies Button
    const stopMeetingRepliesBtn = $('stopMeetingRepliesBtn');
    if (stopMeetingRepliesBtn) {
      stopMeetingRepliesBtn.addEventListener('click', () => {
        stopMeetingReplies();
      });
    }
    
    // Money Setter
    const cheatMoneyBase = $('cheatMoneyBase');
    const cheatMoneyMagnitude = $('cheatMoneyMagnitude');
    const cheatMoneyPreview = $('cheatMoneyPreview');
    const cheatSetMoneyBtn = $('cheatSetMoneyBtn');
    
    function updateMoneyPreview() {
      if (!cheatMoneyBase || !cheatMoneyMagnitude || !cheatMoneyPreview) return;
      const base = parseInt(cheatMoneyBase.value) || 100;
      const magnitude = parseInt(cheatMoneyMagnitude.value) || 1000000;
      const total = base * magnitude;
      cheatMoneyPreview.textContent = total.toLocaleString();
    }
    
    if (cheatMoneyBase) cheatMoneyBase.addEventListener('input', updateMoneyPreview);
    if (cheatMoneyMagnitude) cheatMoneyMagnitude.addEventListener('change', updateMoneyPreview);
    
    if (cheatSetMoneyBtn && cheatMoneyBase && cheatMoneyMagnitude) {
      cheatSetMoneyBtn.addEventListener('click', () => {
        const base = parseInt(cheatMoneyBase.value) || 100;
        const magnitude = parseInt(cheatMoneyMagnitude.value) || 1000000;
        const total = base * magnitude;
        gameState.cash = total;
        showNotification(`ğŸ’° Money set to $${total.toLocaleString()}!`, 'success');
        updateUI();
      });
    }
    
    // Stat Multiplier Sliders
    const statMultipliers = ['affection', 'trust', 'comfort', 'desire', 'productivity', 'confidence', 'obedience', 'flirtiness', 'professionalism', 'humor'];
    
    statMultipliers.forEach(stat => {
      const slider = $(`${stat}MultSlider`);
      const value = $(`${stat}MultValue`);
      
      if (slider && value) {
        // Map slider value (0-50) to multiplier (0-5x)
        slider.addEventListener('input', (e) => {
          const mult = parseFloat(e.target.value) / 10;
          gameState.cheatMultipliers[stat] = mult;
          value.textContent = `${mult.toFixed(1)}x`;
        });
        
        // Set initial value
        const initialMult = gameState.cheatMultipliers[stat] || 1.0;
        slider.value = initialMult * 10;
        value.textContent = `${initialMult.toFixed(1)}x`;
      }
    });
    
    // Reset Multipliers
    const resetMultipliersBtn = $('resetMultipliersBtn');
    if (resetMultipliersBtn) {
      resetMultipliersBtn.addEventListener('click', () => {
        statMultipliers.forEach(stat => {
          gameState.cheatMultipliers[stat] = 1.0;
          const slider = $(`${stat}MultSlider`);
          const value = $(`${stat}MultValue`);
          if (slider) slider.value = 10;
          if (value) value.textContent = '1.0x';
        });
        showNotification('ğŸ”„ All multipliers reset to 1x', 'info');
      });
    }
    
    // Max Multipliers (5x)
    const maxMultipliersBtn = $('maxMultipliersBtn');
    if (maxMultipliersBtn) {
      maxMultipliersBtn.addEventListener('click', () => {
        statMultipliers.forEach(stat => {
          gameState.cheatMultipliers[stat] = 5.0;
          const slider = $(`${stat}MultSlider`);
          const value = $(`${stat}MultValue`);
          if (slider) slider.value = 50;
          if (value) value.textContent = '5.0x';
        });
        showNotification('âš¡ All multipliers set to 5x!', 'success');
      });
    }
    
    // Set Stats for All NPCs
    const cheatStatType = $('cheatStatType');
    const cheatStatValue = $('cheatStatValue');
    const cheatSetStatBtn = $('cheatSetStatBtn');
    
    if (cheatSetStatBtn && cheatStatType && cheatStatValue) {
      cheatSetStatBtn.addEventListener('click', () => {
        const statType = cheatStatType.value;
        const value = parseInt(cheatStatValue.value);
        
        if (value < 0 || value > 100) {
          showNotification('âš ï¸ Value must be between 0 and 100', 'error');
          return;
        }
        
        let count = 0;
        gameState.employees.forEach(emp => {
          if (emp.employmentStatus === 'active') {
            // Handle different stat locations
            if (['affection', 'trust', 'comfort', 'desire', 'productivity'].includes(statType)) {
              if (!emp.stats) emp.stats = {};
              emp.stats[statType] = value;
              count++;
            } else if (['confidence', 'obedience', 'flirty', 'professional', 'humor'].includes(statType)) {
              if (!emp.personality) emp.personality = {};
              emp.personality[statType] = value;
              count++;
            }
          }
        });
        
        showNotification(`âœ… Set ${statType} to ${value} for ${count} employees!`, 'success');
      });
    }
    
    // Quick Actions
    const cheatMaxAllStatsBtn = $('cheatMaxAllStatsBtn');
    if (cheatMaxAllStatsBtn) {
      cheatMaxAllStatsBtn.addEventListener('click', () => {
        let count = 0;
        gameState.employees.forEach(emp => {
          if (emp.employmentStatus === 'active') {
            if (!emp.stats) emp.stats = {};
            emp.stats.affection = 100;
            emp.stats.trust = 100;
            emp.stats.comfort = 100;
            emp.stats.desire = 100;
            emp.stats.productivity = 100;
            
            if (!emp.personality) emp.personality = {};
            emp.personality.confidence = 100;
            emp.personality.obedience = 100;
            emp.personality.flirty = 100;
            emp.personality.professional = 100;
            emp.personality.humor = 100;
            
            count++;
          }
        });
        showNotification(`ğŸŒŸ Maxed all stats for ${count} employees!`, 'success');
      });
    }
    
    const cheatUnlockAllLocationsBtn = $('cheatUnlockAllLocationsBtn');
    if (cheatUnlockAllLocationsBtn) {
      cheatUnlockAllLocationsBtn.addEventListener('click', () => {
        let count = 0;
        gameState.locations.forEach(loc => {
          if (!loc.owned) {
            loc.owned = true;
            loc.unlocked = true;
            count++;
          }
        });
        showNotification(`ğŸ¢ Unlocked ${count} locations!`, 'success');
        renderLocations();
      });
    }
    
    const cheatUnlockAllProductsBtn = $('cheatUnlockAllProductsBtn');
    if (cheatUnlockAllProductsBtn) {
      cheatUnlockAllProductsBtn.addEventListener('click', () => {
        let count = 0;
        gameState.products.forEach(prod => {
          if (!prod.unlocked) {
            prod.unlocked = true;
            count++;
          }
        });
        showNotification(`ğŸ“¦ Unlocked ${count} products!`, 'success');
        renderProducts();
      });
    }
    
    const cheatHireAllBtn = $('cheatHireAllBtn');
    if (cheatHireAllBtn) {
      cheatHireAllBtn.addEventListener('click', () => {
        if (!gameState.candidates || gameState.candidates.length === 0) {
          showNotification('âš ï¸ No candidates available to hire!', 'error');
          return;
        }
        
        const toHire = gameState.candidates.filter(c => !c.hired);
        toHire.forEach(candidate => {
          candidate.hired = true;
          candidate.employmentStatus = 'active';
          candidate.hireDate = Date.now();
          candidate.bioComplete = true;
          candidate.onboarding = false;
          
          // Initialize social data
          initializeEmployeeSocialData(candidate);
          
          gameState.employees.push(candidate);
          generateRandomRelationships(candidate.id);
        });
        
        gameState.candidates = gameState.candidates.filter(c => c.hired);
        
        showNotification(`ğŸ‘¥ Hired ${toHire.length} candidates!`, 'success');
        updateCompanyAwareness();
      });
    }
    
    const cheatClearPostsBtn = $('cheatClearPostsBtn');
    if (cheatClearPostsBtn) {
      cheatClearPostsBtn.addEventListener('click', () => {
        const count = gameState.socialNetwork.posts.length;
        gameState.socialNetwork.posts = [];
        showNotification(`ğŸ—‘ï¸ Cleared ${count} posts!`, 'info');
        if (gameState.activeTab === 'social') {
          renderSocialFeed(true);
        }
      });
    }
    
    const cheatSpawnPostsBtn = $('cheatSpawnPostsBtn');
    if (cheatSpawnPostsBtn) {
      cheatSpawnPostsBtn.addEventListener('click', async () => {
        const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
        if (activeEmployees.length === 0) {
          showNotification('âš ï¸ No active employees to create posts!', 'error');
          return;
        }
        
        showNotification('ğŸ“± Generating 10 NPC posts...', 'info');
        
        const postTemplates = [
          "Coffee break! â˜•",
          "Busy day at work ğŸ’¼",
          "Finally done with that project! ğŸ‰",
          "Anyone else tired? ğŸ˜´",
          "Looking forward to the weekend! ğŸŒ´",
          "Great teamwork today! ğŸ‘",
          "Just finished a meeting ğŸ“Š",
          "Time flies when you're working hard â°",
          "Loving the office vibes today! ğŸ’¯",
          "Can't believe it's already this late! ğŸ˜…",
          "Productive day! âœ…",
          "Office life be like... ğŸ¤·",
          "Happy to be here! ğŸ˜Š",
          "Made some progress today ğŸ“ˆ",
          "Working on something exciting! ğŸš€",
          "Team lunch was great! ğŸ”",
          "Another milestone reached! ğŸ¯",
          "Feeling accomplished today ğŸ’ª",
          "Good vibes only! âœ¨",
          "Grateful for this team! ğŸ™"
        ];
        
        for (let i = 0; i < 10; i++) {
          const randomEmp = activeEmployees[Math.floor(Math.random() * activeEmployees.length)];
          const randomContent = postTemplates[Math.floor(Math.random() * postTemplates.length)];
          
          createSocialPost({
            authorId: randomEmp.id,
            authorName: randomEmp.name,
            type: 'life_update',
            content: randomContent,
            timestamp: gameState.time.currentTime,
            likes: [],
            comments: [],
            mentions: []
          });
        }
        
        showNotification('âœ… Generated 10 NPC posts!', 'success');
        if (gameState.activeTab === 'social') {
          renderSocialFeed(true);
        }
      });
    }
    
    // ========== TIME CONTROLS ==========
    
    // Time Scale Slider
    const timeScaleSlider = $('timeScaleSlider');
    const timeScaleValue = $('timeScaleValue');
    const timeScaleDescription = $('timeScaleDescription');
    
    if (timeScaleSlider && timeScaleValue && timeScaleDescription) {
      // Update display
      const updateTimeScaleDisplay = (value) => {
        timeScaleValue.textContent = `${value}x`;
        
        // Calculate real-time equivalent
        const gameMinutesPerRealMinute = value;
        const realSecondsPerGameMinute = 60 / value;
        
        let description = '';
        if (value === 1) {
          description = 'Real-time (1:1) - Extremely slow!';
        } else if (value <= 10) {
          description = `${gameMinutesPerRealMinute} game minutes = 1 real minute (Slow)`;
        } else if (value <= 30) {
          description = `${gameMinutesPerRealMinute} game minutes = 1 real minute (Normal)`;
        } else if (value <= 60) {
          description = `${gameMinutesPerRealMinute} game minutes = 1 real minute (Fast)`;
        } else {
          description = `${gameMinutesPerRealMinute} game minutes = 1 real minute (Very Fast!)`;
        }
        
        timeScaleDescription.textContent = description;
      };
      
      // Initialize display
      updateTimeScaleDisplay(gameState.time.timeScale || 20);
      timeScaleSlider.value = gameState.time.timeScale || 20;
      
      // Handle slider change
      timeScaleSlider.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        updateTimeScaleDisplay(value);
        gameState.time.timeScale = value;
        showNotification(`â° Time scale set to ${value}x`, 'info');
      });
    }
    
    // Time Preset Buttons
    document.querySelectorAll('.time-preset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const scale = parseInt(btn.dataset.scale);
        if (timeScaleSlider) {
          timeScaleSlider.value = scale;
          timeScaleSlider.dispatchEvent(new Event('input'));
        }
      });
    });
    
    // Pause Time Button
    const pauseTimeBtn = $('pauseTimeBtn');
    if (pauseTimeBtn) {
      pauseTimeBtn.addEventListener('click', () => {
        gameState.time.paused = !gameState.time.paused;
        
        if (gameState.time.paused) {
          pauseTimeBtn.innerHTML = 'â–¶ï¸ Resume Time';
          pauseTimeBtn.style.background = 'linear-gradient(135deg, #4ecca3 0%, #00d4ff 100%)';
          showNotification('â¸ï¸ Time paused', 'info');
        } else {
          pauseTimeBtn.innerHTML = 'â¸ï¸ Pause Time';
          pauseTimeBtn.style.background = 'linear-gradient(135deg, #e94560 0%, #ff6b9d 100%)';
          showNotification('â–¶ï¸ Time resumed', 'info');
        }
        
        updateCheatTimeDisplay();
      });
    }
    
    // Skip Time Button
    const skipTimeBtn = $('skipTimeBtn');
    if (skipTimeBtn) {
      skipTimeBtn.addEventListener('click', () => {
        // Skip forward 1 game day (24 hours)
        const oneDayMs = 24 * 60 * 60 * 1000;
        gameState.time.currentTime += oneDayMs;
        
        // Trigger daily events
        if (window.onDayChange) {
          window.onDayChange();
        }
        
        showNotification('â­ï¸ Skipped forward 1 day!', 'success');
        updateCheatTimeDisplay();
        updateTimeDisplay();
      });
    }
    
    // Update time display in cheats panel
    function updateCheatTimeDisplay() {
      const cheatGameTime = $('cheatGameTime');
      const cheatTimeStatus = $('cheatTimeStatus');
      
      if (cheatGameTime && gameState.time) {
        const gameDate = new Date(gameState.time.currentTime);
        cheatGameTime.textContent = gameDate.toLocaleString();
      }
      
      if (cheatTimeStatus && gameState.time) {
        if (gameState.time.paused) {
          cheatTimeStatus.textContent = 'Paused';
          cheatTimeStatus.style.color = '#e94560';
        } else {
          cheatTimeStatus.textContent = `Running (${gameState.time.timeScale}x)`;
          cheatTimeStatus.style.color = '#4ecca3';
        }
      }
    }
    
    // Update time display every second when cheats panel is open
    let cheatTimeInterval = null;
    
    // Hook into existing cheats modal open/close
    const existingOpenCheatsBtn = $('openCheatsBtn');
    const existingCloseCheatsBtn = $('closeCheatsBtn');
    
    if (existingOpenCheatsBtn) {
      existingOpenCheatsBtn.addEventListener('click', () => {
        setTimeout(() => {
          updateCheatTimeDisplay();
          cheatTimeInterval = setInterval(updateCheatTimeDisplay, 1000);
        }, 100);
      });
    }
    
    if (existingCloseCheatsBtn) {
      existingCloseCheatsBtn.addEventListener('click', () => {
        if (cheatTimeInterval) {
          clearInterval(cheatTimeInterval);
          cheatTimeInterval = null;
        }
      });
    }
    
    // ========== CONTEXT WINDOWS ==========
    
    // Refresh Company-Wide Context
    const cheatRefreshContextBtn = $('cheatRefreshContextBtn');
    if (cheatRefreshContextBtn) {
      cheatRefreshContextBtn.addEventListener('click', () => {
        refreshContextWindow();
      });
    }
    
    // Clear Company-Wide Context
    const cheatClearContextBtn = $('cheatClearContextBtn');
    if (cheatClearContextBtn) {
      cheatClearContextBtn.addEventListener('click', () => {
        if (confirm('Clear all Company-Wide Context items? NPCs will forget all recent company events.')) {
          gameState.companyWideContext.currentBuzz = [];
          refreshContextWindow();
          showNotification('ğŸ—‘ï¸ Company-Wide Context cleared!', 'info');
        }
      });
    }
    
    // Refresh Gossip Engine
    const cheatRefreshGossipBtn = $('cheatRefreshGossipBtn');
    if (cheatRefreshGossipBtn) {
      cheatRefreshGossipBtn.addEventListener('click', () => {
        refreshGossipWindow();
      });
    }
    
    // Clear Gossip Engine
    const cheatClearGossipBtn = $('cheatClearGossipBtn');
    if (cheatClearGossipBtn) {
      cheatClearGossipBtn.addEventListener('click', () => {
        if (confirm('Clear all gossip from all NPCs? This will reset their knowledge of company drama.')) {
          gameState.employees.forEach(emp => {
            if (emp.gossip) {
              emp.gossip = [];
            }
          });
          refreshGossipWindow();
          showNotification('ğŸ—‘ï¸ All gossip cleared!', 'info');
        }
      });
    }
    
    // Functions to refresh context windows
    function refreshContextWindow() {
      const contextList = $('contextList');
      const contextCountLabel = $('contextCountLabel');
      
      if (!contextList || !contextCountLabel) return;
      
      const items = gameState.companyWideContext?.currentBuzz || [];
      contextCountLabel.textContent = `(${items.length}/${gameState.companyWideContext?.maxItems || 40})`;
      
      if (items.length === 0) {
        contextList.innerHTML = '<p style="color:#aaa; text-align:center; margin:20px 0;">No context items yet</p>';
        return;
      }
      
      // Sort by timestamp (newest first)
      const sortedItems = [...items].sort((a, b) => b.timestamp - a.timestamp);
      
      contextList.innerHTML = sortedItems.map((item, index) => {
        const timeAgo = formatTimeAgo(item.timestamp);
        const juiciness = item.juiciness || 0;
        const juiceColor = juiciness > 70 ? '#e94560' : juiciness > 40 ? '#ffd700' : '#00d4ff';
        
        return `
          <div style="background:#0f3460; border-radius:8px; padding:12px; margin-bottom:8px; border-left:3px solid ${juiceColor};">
            <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:6px;">
              <div style="flex:1;">
                <div style="color:#ddd; font-size:0.95rem; line-height:1.4; margin-bottom:6px;">${item.info}</div>
                <div style="display:flex; gap:12px; font-size:0.8rem; color:#aaa;">
                  <span>ğŸ”¥ ${juiciness}/100</span>
                  <span>â° ${timeAgo}</span>
                  ${item.involvedEmployees ? `<span>ğŸ‘¥ ${item.involvedEmployees.length}</span>` : ''}
                </div>
              </div>
              <button onclick="removeContextItem(${index})" style="background:#e94560; border:none; padding:6px 10px; border-radius:6px; color:white; cursor:pointer; font-size:0.8rem; margin-left:8px;">
                ğŸ—‘ï¸
              </button>
            </div>
          </div>
        `;
      }).join('');
    }
    
    function refreshGossipWindow() {
      const gossipList = $('gossipList');
      const gossipCountLabel = $('gossipCountLabel');
      
      if (!gossipList || !gossipCountLabel) return;
      
      const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
      const employeesWithGossip = activeEmployees.filter(e => 
        e.gossip && e.gossip.knownGossip && e.gossip.knownGossip.length > 0
      );
      
      gossipCountLabel.textContent = `(${employeesWithGossip.length} NPCs)`;
      
      if (employeesWithGossip.length === 0) {
        gossipList.innerHTML = '<p style="color:#aaa; text-align:center; margin:20px 0;">No gossip yet</p>';
        return;
      }
      
      gossipList.innerHTML = employeesWithGossip.map(emp => {
        const gossipItems = emp.gossip?.knownGossip || [];
        const totalGossip = gossipItems.length;
        
        return `
          <div style="background:#0f3460; border-radius:8px; padding:12px; margin-bottom:12px; border:1px solid #ff69b4;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
              <div style="display:flex; align-items:center; gap:10px;">
                <img src="${emp.profileImage || 'https://placehold.co/40x40'}" style="width:40px; height:40px; border-radius:50%; object-fit:cover;">
                <div>
                  <div style="color:#fff; font-weight:600;">${emp.name}</div>
                  <div style="color:#aaa; font-size:0.85rem;">${totalGossip} gossip item${totalGossip !== 1 ? 's' : ''}</div>
                </div>
              </div>
              <button onclick="clearEmployeeGossip('${emp.id}')" style="background:#e94560; border:none; padding:6px 12px; border-radius:6px; color:white; cursor:pointer; font-size:0.8rem;">
                Clear
              </button>
            </div>
            <div style="max-height:150px; overflow-y:auto;">
              ${gossipItems.slice(0, 5).map(g => {
                const timeAgo = formatTimeAgo(g.timestamp || g.heardAt || Date.now());
                const juiceColor = g.juiciness > 70 ? '#e94560' : g.juiciness > 40 ? '#ffd700' : '#00d4ff';
                
                return `
                  <div style="background:#16213e; border-radius:6px; padding:8px; margin-bottom:6px; border-left:2px solid ${juiceColor};">
                    <div style="color:#ddd; font-size:0.9rem; margin-bottom:4px;">${g.content || g.info || g.description || 'Unknown gossip'}</div>
                    <div style="display:flex; gap:8px; font-size:0.75rem; color:#aaa;">
                      <span>ğŸ”¥ ${g.juiciness || 0}</span>
                      <span>â° ${timeAgo}</span>
                      ${g.source ? `<span>ğŸ“¢ ${g.source}</span>` : ''}
                    </div>
                  </div>
                `;
              }).join('')}
              ${totalGossip > 5 ? `<p style="color:#aaa; font-size:0.85rem; text-align:center; margin:8px 0 0 0;">+${totalGossip - 5} more...</p>` : ''}
            </div>
          </div>
        `;
      }).join('');
    }
    
    // Helper functions (global scope for onclick)
    window.removeContextItem = function(index) {
      if (confirm('Remove this context item?')) {
        gameState.companyWideContext.currentBuzz.splice(index, 1);
        refreshContextWindow();
        showNotification('Context item removed', 'info');
      }
    };
    
    window.clearEmployeeGossip = function(employeeId) {
      const emp = gameState.employees.find(e => e.id === employeeId);
      if (emp && emp.gossip && emp.gossip.knownGossip) {
        emp.gossip.knownGossip = [];
        refreshGossipWindow();
        showNotification(`Cleared gossip for ${emp.name}`, 'info');
      }
    };
    
    // Helper function to format time ago
    function formatTimeAgo(timestamp) {
      // CRITICAL FIX: Use in-game time for consistency
      const now = gameState.time?.currentTime || Date.now();
      const seconds = Math.floor((now - timestamp) / 1000);
      if (seconds < 60) return `${seconds}s ago`;
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m ago`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h ago`;
      const days = Math.floor(hours / 24);
      return `${days}d ago`;
    }
    
    if (atmosphereSlider && atmosphereValue) {
      atmosphereSlider.addEventListener('input', (e) => {
        gameState.settings.atmosphere = parseInt(e.target.value);
        const val = parseInt(e.target.value);
        let label = 'Balanced';
        if (val < 33) label = 'Professional';
        else if (val > 66) label = 'Relaxed';
        atmosphereValue.textContent = label;
      });
    }
    
    if (guidelinesSlider && guidelinesValue) {
      guidelinesSlider.addEventListener('input', (e) => {
        gameState.settings.guidelines = parseInt(e.target.value);
        const val = parseInt(e.target.value);
        let label = 'Standard';
        if (val < 33) label = 'Reserved';
        else if (val > 66) label = 'Outgoing';
        guidelinesValue.textContent = label;
      });
    }
    
    // Policy buttons
    document.querySelectorAll('.policy-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        gameState.settings.policy = btn.dataset.policy;
        
        // Update button styles
        document.querySelectorAll('.policy-btn').forEach(b => {
          b.style.background = '#0f3460';
          b.style.borderColor = '#00d4ff';
          b.style.color = 'white';
        });
        btn.style.background = '#e94560';
        btn.style.borderColor = '#e94560';
        btn.style.color = 'white';
        
        // Update policy value label
        const policyValue = document.getElementById('policyValue');
        if (policyValue) {
          const policyLabels = {
            'professional': 'Professional',
            'casual': 'Casual',
            'open': 'Enthusiastic'
          };
          policyValue.textContent = policyLabels[btn.dataset.policy] || 'Professional';
        }
      });
    });
    
    // Stat range controls initialization
    function initializeStatRangeControls() {
      const container = document.getElementById('statRangeControls');
      if (!container) return;
      
      const stats = ['productivity', 'trust', 'friendship', 'desire', 'comfort', 'affection'];
      const statLabels = {
        productivity: 'ğŸ’¼ Productivity',
        trust: 'ğŸ¤ Trust',
        friendship: 'ğŸ’š Friendship',
        desire: 'ğŸ’• Desire',
        comfort: 'ğŸ˜Œ Comfort',
        affection: 'â¤ï¸ Affection'
      };
      
      container.innerHTML = stats.map(stat => {
        const range = gameState.hrSettings.startingStatRanges[stat];
        return `
          <div style="background:#0f3460; padding:15px; border-radius:6px;">
            <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
              <span style="font-weight:600; color:#00d4ff;">${statLabels[stat]}</span>
              <span id="${stat}RangeDisplay" style="color:#e94560; font-weight:600;">${range.min}-${range.max}</span>
            </div>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
              <div>
                <label style="font-size:0.8rem; color:#aaa; display:block; margin-bottom:4px;">Min</label>
                <input type="range" id="${stat}MinSlider" min="0" max="90" value="${range.min}" 
                       style="width:100%;" 
                       oninput="updateStatRange('${stat}', 'min', this.value)">
                <span id="${stat}MinValue" style="font-size:0.85rem; color:#ddd;">${range.min}</span>
              </div>
              <div>
                <label style="font-size:0.8rem; color:#aaa; display:block; margin-bottom:4px;">Max</label>
                <input type="range" id="${stat}MaxSlider" min="10" max="100" value="${range.max}" 
                       style="width:100%;" 
                       oninput="updateStatRange('${stat}', 'max', this.value)">
                <span id="${stat}MaxValue" style="font-size:0.85rem; color:#ddd;">${range.max}</span>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }
    
    // Update stat range
    window.updateStatRange = function(stat, minOrMax, value) {
      value = parseInt(value);
      const range = gameState.hrSettings.startingStatRanges[stat];
      
      if (minOrMax === 'min') {
        // Ensure min doesn't exceed max
        if (value > range.max - 10) value = range.max - 10;
        range.min = value;
        document.getElementById(`${stat}MinValue`).textContent = value;
      } else {
        // Ensure max doesn't go below min
        if (value < range.min + 10) value = range.min + 10;
        range.max = value;
        document.getElementById(`${stat}MaxValue`).textContent = value;
      }
      
      // Update display
      document.getElementById(`${stat}RangeDisplay`).textContent = `${range.min}-${range.max}`;
    };
    
    // Apply preset
    window.applyStatPreset = function(preset) {
      const presets = {
        challenging: { min: 20, max: 50 },
        balanced: { min: 30, max: 60 },
        welcoming: { min: 50, max: 75 }
      };
      
      const values = presets[preset];
      if (!values) return;
      
      const stats = ['productivity', 'trust', 'friendship', 'desire', 'comfort', 'affection'];
      stats.forEach(stat => {
        gameState.hrSettings.startingStatRanges[stat].min = values.min;
        gameState.hrSettings.startingStatRanges[stat].max = values.max;
      });
      
      // Reinitialize the controls to reflect new values
      initializeStatRangeControls();
      
      showNotification(`Applied ${preset} preset: ${values.min}-${values.max} for all stats`);
    };
    
    // Initialize stat controls when HR tab is opened
    const hrTabButton = document.querySelector('[data-tab="hr"]');
    if (hrTabButton) {
      hrTabButton.addEventListener('click', () => {
        setTimeout(initializeStatRangeControls, 100);
      });
    }
    
    // Data management - NEW SAVE MANAGER SYSTEM
    const openSaveManagerBtn = $('openSaveManagerBtn');
    if (openSaveManagerBtn) {
      openSaveManagerBtn.addEventListener('click', () => {
        getSaveManager().show();
      });
      
      // Add hover effect
      openSaveManagerBtn.addEventListener('mouseenter', function() {
        this.style.transform = 'translateY(-2px)';
        this.style.boxShadow = '0 6px 20px rgba(0,212,255,0.5)';
      });
      openSaveManagerBtn.addEventListener('mouseleave', function() {
        this.style.transform = 'translateY(0)';
        this.style.boxShadow = '0 4px 15px rgba(0,212,255,0.3)';
      });
    }
    
    // Keep reset button
    if (resetBtn) resetBtn.addEventListener('click', resetGame);
    
    // Global keyboard shortcuts for Save Manager
    document.addEventListener('keydown', (e) => {
      // F5 - Quick Save
      if (e.key === 'F5') {
        e.preventDefault();
        const slotName = `quick_${Date.now()}`;
        saveGameToSlot(slotName, 'quick', true);
      }
      
      // F9 - Quick Load
      if (e.key === 'F9') {
        e.preventDefault();
        listAllSaves().then(allSaves => {
          const quickSaves = allSaves.filter(s => s.saveType === 'quick');
          if (quickSaves.length === 0) {
            showNotification('âŒ No quick saves found!', 'error');
            return;
          }
          loadGameFromSlot(quickSaves[0].slotName);
        });
      }
    });
    
    // Legacy import support (hidden file input for old import system)
    const importFileInput = $('importFileInput');
    if (importFileInput) {
      importFileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (ev) => {
          try {
            const saveData = JSON.parse(ev.target.result);
            if (!saveData.gameState) {
              showNotification('âŒ Invalid save file!', 'error');
              return;
            }
            importSaveToSlot(saveData);
          } catch (error) {
            console.error('[Import] Error:', error);
            showNotification('âŒ Failed to import save!', 'error');
          }
        };
        reader.readAsText(file);
        e.target.value = '';
      });
    }
    
    // Chat modal
    if (closeChatBtn) {
      closeChatBtn.addEventListener('click', () => {
        if (chatModal) {
          chatModal.hidden = true;
          chatModal.style.display = 'none';
          chatModal.style.pointerEvents = 'none';
          
          // CRITICAL FIX: Save game before closing chat to prevent message loss
          if (gameState.activeChat) {
            saveGame(false); // false = no toast notification
          }
          
          gameState.activeChat = null;
        }
      });
    }
    
    // Clear chat button
    const clearChatBtn = $('clearChatBtn');
    if (clearChatBtn) {
      clearChatBtn.addEventListener('click', () => {
        // PLAYER FEEDBACK FIX: Properly handle activeChat as ID or object
        const activeChatId = gameState.activeChat?.id || gameState.activeChat;
        if (!activeChatId) {
          console.warn('[Clear Chat] No active chat');
          return;
        }
        
        const employee = gameState.employees.find(e => e.id === activeChatId);
        if (!employee) {
          console.warn('[Clear Chat] Employee not found:', activeChatId);
          return;
        }
        
        // Confirm before clearing
        if (!confirm(`Clear chat history with ${employee.name}?\n\nThis will archive the conversation but remove it from view. Context will be preserved for AI.`)) {
          return;
        }
        
        // Archive current chat history
        const currentHistory = gameState.chatHistory[activeChatId] || [];
        if (currentHistory.length > 0) {
          // Initialize archive if it doesn't exist
          if (!employee.conversationArchive) {
            employee.conversationArchive = [];
          }
          
          // Add current chat to archive with timestamp
          employee.conversationArchive.push({
            timestamp: gameState.time?.currentTime || Date.now(),
            messages: [...currentHistory],
            messageCount: currentHistory.length
          });
          
          // Keep only last 5 archived conversations to prevent bloat
          if (employee.conversationArchive.length > 5) {
            employee.conversationArchive = employee.conversationArchive.slice(-5);
          }
          
          // Clear visible chat
          gameState.chatHistory[activeChatId] = [];
          
          // Update display
          renderChatMessages();
          
          console.log(`[Clear Chat] Cleared and archived chat with ${employee.name}`);
          showNotification(`Chat with ${employee.name} cleared and archived.`);
        } else {
          showNotification(`No messages to clear with ${employee.name}.`);
        }
      });
    }
    
    // Function to refresh chat display
    window.refreshChatDisplay = function() {
      if (gameState.activeChat && gameState.activeChat.id) {
        // Trigger chat open to refresh
        const employee = gameState.employees.find(e => e.id === gameState.activeChat.id);
        if (employee) {
          openChat(employee);
        }
      }
    };
    
    // Typing indicator functions
    window.showTypingIndicator = function(employee) {
      const chatTypingIndicator = $('chatTypingIndicator');
      const chatTypingName = $('chatTypingName');
      if (chatTypingIndicator && chatTypingName) {
        chatTypingName.textContent = employee.name;
        chatTypingIndicator.style.display = 'block';
        
        // Scroll to bottom
        const chatMessages = $('chatMessages');
        if (chatMessages) {
          setTimeout(() => chatMessages.scrollTop = chatMessages.scrollHeight, 100);
        }
      }
    };
    
    window.hideTypingIndicator = function() {
      const chatTypingIndicator = $('chatTypingIndicator');
      if (chatTypingIndicator) {
        chatTypingIndicator.style.display = 'none';
      }
    };
    
    if (chatSendBtn) {
      chatSendBtn.addEventListener('click', sendOrUpdateChatMessage);
    }
    
    if (chatInput) {
      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendOrUpdateChatMessage();
      });
    }
    
    // Emoji picker for chat
    const chatEmojiBtn = $('chatEmojiBtn');
    console.log('Chat emoji button:', chatEmojiBtn, 'Chat input:', chatInput);
    if (chatEmojiBtn && chatInput) {
      chatEmojiBtn.addEventListener('click', (e) => {
        console.log('Chat emoji button clicked!');
        e.stopPropagation();
        emojiPicker.show(chatInput, chatEmojiBtn);
      });
    }
    
    // Emoji picker for post caption
    const postCaptionEmojiBtn = $('postCaptionEmojiBtn');
    const playerPostCaption = $('playerPostCaption');
    if (postCaptionEmojiBtn && playerPostCaption) {
      postCaptionEmojiBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        emojiPicker.show(playerPostCaption, postCaptionEmojiBtn);
      });
    }
    
    // Emoji picker for comments (delegated event)
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('comment-emoji-btn')) {
        e.stopPropagation();
        const postId = e.target.dataset.postId;
        const commentInput = document.querySelector(`.comment-input[data-post-id="${postId}"]`);
        if (commentInput) {
          emojiPicker.show(commentInput, e.target);
        }
      }
    });
    
    // Initialize emoji picker
    emojiPicker.init();
    
    // Player Profile Modal
    const openPlayerProfileBtn = $('openPlayerProfileBtn');
    const playerProfileModal = $('playerProfileModal');
    const closePlayerProfileModal = $('closePlayerProfileModal');
    const cancelPlayerProfile = $('cancelPlayerProfile');
    const savePlayerProfile = $('savePlayerProfile');
    
    if (openPlayerProfileBtn && playerProfileModal) {
      openPlayerProfileBtn.addEventListener('click', () => {
        // Load current profile data into form
        $('playerCompanyName').value = gameState.playerProfile.companyName || '';
        $('playerFirstName').value = gameState.playerProfile.firstName || '';
        $('playerLastName').value = gameState.playerProfile.lastName || '';
        $('playerAge').value = gameState.playerProfile.age || '';
        $('playerGender').value = gameState.playerProfile.gender || '';
        $('playerEthnicity').value = gameState.playerProfile.ethnicity || '';
        $('playerSkinTone').value = gameState.playerProfile.skinTone || '';
        $('playerHeight').value = gameState.playerProfile.height || '';
        $('playerBodyType').value = gameState.playerProfile.bodyType || '';
        $('playerHairColor').value = gameState.playerProfile.hairColor || '';
        $('playerHairStyle').value = gameState.playerProfile.hairStyle || '';
        $('playerEyeColor').value = gameState.playerProfile.eyeColor || '';
        $('playerFacialHair').value = gameState.playerProfile.facialHair || '';
        $('playerGenitalType').value = gameState.playerProfile.genitalType || '';
        $('playerGenitalDetails').value = gameState.playerProfile.genitalDetails || '';
        $('playerChestSize').value = gameState.playerProfile.chestSize || '';
        $('playerBuildDetails').value = gameState.playerProfile.buildDetails || '';
        $('playerAdditionalDetails').value = gameState.playerProfile.additionalDetails || '';
        $('playerPersonality').value = gameState.playerProfile.personality || '';
        
        playerProfileModal.style.display = 'flex';
      });
      
      const closeModal = () => {
        playerProfileModal.style.display = 'none';
      };
      
      if (closePlayerProfileModal) closePlayerProfileModal.addEventListener('click', closeModal);
      if (cancelPlayerProfile) cancelPlayerProfile.addEventListener('click', closeModal);
      
      if (savePlayerProfile) {
        savePlayerProfile.addEventListener('click', () => {
          // Save all fields
          gameState.playerProfile.companyName = $('playerCompanyName').value.trim();
          gameState.playerProfile.firstName = $('playerFirstName').value.trim();
          gameState.playerProfile.lastName = $('playerLastName').value.trim();
          gameState.playerProfile.age = parseInt($('playerAge').value) || null;
          gameState.playerProfile.gender = $('playerGender').value;
          gameState.playerProfile.ethnicity = $('playerEthnicity').value.trim();
          gameState.playerProfile.skinTone = $('playerSkinTone').value.trim();
          gameState.playerProfile.height = $('playerHeight').value.trim();
          gameState.playerProfile.bodyType = $('playerBodyType').value.trim();
          gameState.playerProfile.hairColor = $('playerHairColor').value.trim();
          gameState.playerProfile.hairStyle = $('playerHairStyle').value.trim();
          gameState.playerProfile.eyeColor = $('playerEyeColor').value.trim();
          gameState.playerProfile.facialHair = $('playerFacialHair').value.trim();
          gameState.playerProfile.genitalType = $('playerGenitalType').value;
          gameState.playerProfile.genitalDetails = $('playerGenitalDetails').value.trim();
          gameState.playerProfile.chestSize = $('playerChestSize').value.trim();
          gameState.playerProfile.buildDetails = $('playerBuildDetails').value.trim();
          gameState.playerProfile.additionalDetails = $('playerAdditionalDetails').value.trim();
          gameState.playerProfile.personality = $('playerPersonality').value.trim();
          
          showNotification('Player profile saved!');
          playerProfileModal.style.display = 'none';
          saveGame(); // Auto-save after profile update
        });
      }
    }
    
    // Gender Options Modal
    const genderOptionsBtn = $('genderOptionsBtn');
    const genderOptionsModal = $('genderOptionsModal');
    const closeGenderOptionsModal = $('closeGenderOptionsModal');
    const cancelGenderOptions = $('cancelGenderOptions');
    const saveGenderOptions = $('saveGenderOptions');
    
    // Get all slider elements
    const femaleSlider = $('femaleSlider');
    const maleSlider = $('maleSlider');
    const femaleFutaSlider = $('femaleFutaSlider');
    const transManSlider = $('transManSlider');
    const transWomanSlider = $('transWomanSlider');
    
    // Get percentage display elements
    const femalePercentage = $('femalePercentage');
    const malePercentage = $('malePercentage');
    const femaleFutaPercentage = $('femaleFutaPercentage');
    const transManPercentage = $('transManPercentage');
    const transWomanPercentage = $('transWomanPercentage');
    const genderTotalValue = $('genderTotalValue');
    const genderWarning = $('genderWarning');
    
    // Function to update gender distribution display
    function updateGenderDistributionDisplay() {
      const genderSettings = gameState.genderSettings;
      const raceSettings = gameState.raceSettings || {}; // Safe fallback
      const displayEl = $('genderDistributionDisplay');
      if (!displayEl) return;
      
      const genderColors = {
        female: '#ff6b9d',
        male: '#00d4ff',
        femaleFuta: '#c77dff',
        transMan: '#4ecca3',
        transWoman: '#ffd700'
      };
      
      const genderLabels = {
        female: 'Female',
        male: 'Male',
        femaleFuta: 'Female Futa',
        transMan: 'Trans Man',
        transWoman: 'Trans Woman'
      };
      
      const raceColors = {
        human: '#00d4ff',
        elf: '#90ee90',
        orc: '#7ccd7c',
        demon: '#b83b5e',
        fox: '#ff6b35',
        wolf: '#a8dadc',
        cat: '#ff9ff3',
        rabbit: '#ffc2d1'
      };
      
      const raceLabels = {
        human: 'ğŸ‘¤ Human',
        elf: 'ğŸ§ Elf',
        orc: 'ğŸ’ª Orc',
        demon: 'ğŸ˜ˆ Demon',
        fox: 'ğŸ¦Š Foxkin',
        wolf: 'ğŸº Wolfkin',
        cat: 'ğŸ˜º Catkin',
        rabbit: 'ğŸ° Rabbitkin'
      };
      
      // Build HTML with gender distribution
      let html = '<div style="margin-bottom:15px;"><div style="color:#aaa; font-size:0.85rem; font-weight:600; margin-bottom:8px;">Gender Distribution:</div><div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(100px, 1fr)); gap:8px;">';
      
      html += Object.entries(genderSettings)
        .filter(([key, value]) => value > 0)
        .map(([key, value]) => `
          <div style="text-align:center; padding:8px; background:#16213e; border-radius:6px; border-left:3px solid ${genderColors[key]};">
            <div style="color:${genderColors[key]}; font-weight:700; font-size:1.3rem;">${value}%</div>
            <div style="color:#aaa; font-size:0.7rem;">${genderLabels[key]}</div>
          </div>
        `).join('');
      
      if (Object.values(genderSettings).every(v => v === 0)) {
        html += '<div style="grid-column:1/-1; text-align:center; color:#666; padding:15px;">No gender settings configured</div>';
      }
      
      html += '</div></div>';
      
      // Add race distribution (only if raceSettings exists and has entries)
      if (raceSettings && Object.keys(raceSettings).length > 0) {
        html += '<div><div style="color:#aaa; font-size:0.85rem; font-weight:600; margin-bottom:8px;">Race Distribution:</div><div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(100px, 1fr)); gap:8px;">';
        
        html += Object.entries(raceSettings)
          .filter(([key, value]) => value > 0)
          .map(([key, value]) => `
            <div style="text-align:center; padding:8px; background:#16213e; border-radius:6px; border-left:3px solid ${raceColors[key]};">
              <div style="color:${raceColors[key]}; font-weight:700; font-size:1.3rem;">${value}%</div>
              <div style="color:#aaa; font-size:0.7rem;">${raceLabels[key]}</div>
            </div>
          `).join('');
        
        if (Object.values(raceSettings).every(v => v === 0)) {
          html += '<div style="grid-column:1/-1; text-align:center; color:#666; padding:15px;">No race settings configured</div>';
        }
        
        html += '</div></div>';
      }
      
      displayEl.innerHTML = html;
    }
    
    // Function to normalize sliders (make them proportional to 100%)
    function normalizeGenderSliders(changedSlider) {
      const sliders = [femaleSlider, maleSlider, femaleFutaSlider, transManSlider, transWomanSlider];
      const values = sliders.map(s => parseInt(s.value));
      const total = values.reduce((sum, v) => sum + v, 0);
      
      if (total === 0) {
        // If everything is 0, reset to default (100% female)
        femaleSlider.value = 100;
        updateSliderDisplays();
        return;
      }
      
      if (total === 100) {
        // Perfect total, just update displays
        updateSliderDisplays();
        return;
      }
      
      // Normalize all sliders except the one that just changed
      const changedIndex = sliders.indexOf(changedSlider);
      const changedValue = parseInt(changedSlider.value);
      const otherTotal = total - changedValue;
      const remaining = 100 - changedValue;
      
      if (remaining < 0) {
        // Changed slider exceeds 100%, cap it at 100 and zero others
        changedSlider.value = 100;
        sliders.forEach((s, i) => {
          if (i !== changedIndex) s.value = 0;
        });
      } else if (otherTotal > 0) {
        // Proportionally adjust other sliders
        sliders.forEach((s, i) => {
          if (i !== changedIndex) {
            const currentVal = parseInt(s.value);
            const proportion = currentVal / otherTotal;
            s.value = Math.round(proportion * remaining);
          }
        });
        
        // Fix rounding errors - adjust largest other slider
        const newTotal = sliders.reduce((sum, s) => sum + parseInt(s.value), 0);
        if (newTotal !== 100) {
          const diff = 100 - newTotal;
          let largestOtherIndex = -1;
          let largestOtherValue = -1;
          sliders.forEach((s, i) => {
            if (i !== changedIndex) {
              const val = parseInt(s.value);
              if (val > largestOtherValue) {
                largestOtherValue = val;
                largestOtherIndex = i;
              }
            }
          });
          if (largestOtherIndex >= 0) {
            sliders[largestOtherIndex].value = parseInt(sliders[largestOtherIndex].value) + diff;
          }
        }
      }
      
      updateSliderDisplays();
    }
    
    // Function to update slider percentage displays
    function updateSliderDisplays() {
      femalePercentage.textContent = femaleSlider.value;
      malePercentage.textContent = maleSlider.value;
      femaleFutaPercentage.textContent = femaleFutaSlider.value;
      transManPercentage.textContent = transManSlider.value;
      transWomanPercentage.textContent = transWomanSlider.value;
      
      const total = parseInt(femaleSlider.value) + parseInt(maleSlider.value) + 
                    parseInt(femaleFutaSlider.value) + parseInt(transManSlider.value) + 
                    parseInt(transWomanSlider.value);
      
      genderTotalValue.textContent = total;
      
      if (total === 100) {
        genderTotalValue.style.color = '#00d4ff';
        genderWarning.style.display = 'none';
      } else {
        genderTotalValue.style.color = '#e94560';
        genderWarning.style.display = 'block';
      }
    }
    
    // Open gender options modal
    if (genderOptionsBtn && genderOptionsModal) {
      genderOptionsBtn.addEventListener('click', () => {
        // Load current settings
        femaleSlider.value = gameState.genderSettings.female;
        maleSlider.value = gameState.genderSettings.male;
        femaleFutaSlider.value = gameState.genderSettings.femaleFuta;
        transManSlider.value = gameState.genderSettings.transMan;
        transWomanSlider.value = gameState.genderSettings.transWoman;
        
        updateSliderDisplays();
        genderOptionsModal.style.display = 'flex';
      });
      
      const closeModal = () => {
        genderOptionsModal.style.display = 'none';
      };
      
      if (closeGenderOptionsModal) closeGenderOptionsModal.addEventListener('click', closeModal);
      if (cancelGenderOptions) cancelGenderOptions.addEventListener('click', closeModal);
      
      // Add slider listeners
      [femaleSlider, maleSlider, femaleFutaSlider, transManSlider, transWomanSlider].forEach(slider => {
        if (slider) {
          slider.addEventListener('input', () => normalizeGenderSliders(slider));
        }
      });
      
      // Save gender settings
      if (saveGenderOptions) {
        saveGenderOptions.addEventListener('click', () => {
          const total = parseInt(femaleSlider.value) + parseInt(maleSlider.value) + 
                        parseInt(femaleFutaSlider.value) + parseInt(transManSlider.value) + 
                        parseInt(transWomanSlider.value);
          
          if (total !== 100) {
            showNotification('Total must equal 100%!');
            return;
          }
          
          // Save settings
          gameState.genderSettings.female = parseInt(femaleSlider.value);
          gameState.genderSettings.male = parseInt(maleSlider.value);
          gameState.genderSettings.femaleFuta = parseInt(femaleFutaSlider.value);
          gameState.genderSettings.transMan = parseInt(transManSlider.value);
          gameState.genderSettings.transWoman = parseInt(transWomanSlider.value);
          
          showNotification('Gender settings saved! New hires will reflect these percentages.');
          updateGenderDistributionDisplay();
          genderOptionsModal.style.display = 'none';
          saveGame(); // Auto-save after settings update
        });
      }
    }
    
    // Initialize gender distribution display
    updateGenderDistributionDisplay();
    
    // ========== RACE/SPECIES OPTIONS (PLAYER FEATURE REQUEST) ==========
    const raceHumanSlider = $('raceHumanSlider');
    const raceElfSlider = $('raceElfSlider');
    const raceOrcSlider = $('raceOrcSlider');
    const raceDemonSlider = $('raceDemonSlider');
    const raceFoxSlider = $('raceFoxSlider');
    const raceWolfSlider = $('raceWolfSlider');
    const raceCatSlider = $('raceCatSlider');
    const raceRabbitSlider = $('raceRabbitSlider');
    
    const raceHumanPercentage = $('raceHumanPercentage');
    const raceElfPercentage = $('raceElfPercentage');
    const raceOrcPercentage = $('raceOrcPercentage');
    const raceDemonPercentage = $('raceDemonPercentage');
    const raceFoxPercentage = $('raceFoxPercentage');
    const raceWolfPercentage = $('raceWolfPercentage');
    const raceCatPercentage = $('raceCatPercentage');
    const raceRabbitPercentage = $('raceRabbitPercentage');
    const raceTotalValue = $('raceTotalValue');
    const raceWarning = $('raceWarning');
    
    // Initialize race settings in gameState if not present
    if (!gameState.raceSettings) {
      gameState.raceSettings = {
        human: 100,
        elf: 0,
        orc: 0,
        demon: 0,
        fox: 0,
        wolf: 0,
        cat: 0,
        rabbit: 0
      };
    }
    
    // Function to normalize race sliders (make them proportional to 100%)
    function normalizeRaceSliders(changedSlider) {
      const sliders = [raceHumanSlider, raceElfSlider, raceOrcSlider, raceDemonSlider, raceFoxSlider, raceWolfSlider, raceCatSlider, raceRabbitSlider];
      const values = sliders.map(s => parseInt(s.value));
      const total = values.reduce((sum, v) => sum + v, 0);
      
      if (total === 0) {
        // If everything is 0, reset to default (100% human)
        raceHumanSlider.value = 100;
        updateRaceSliderDisplays();
        return;
      }
      
      if (total === 100) {
        // Perfect total, just update displays
        updateRaceSliderDisplays();
        return;
      }
      
      // Normalize all sliders except the one that just changed
      const changedIndex = sliders.indexOf(changedSlider);
      const changedValue = parseInt(changedSlider.value);
      const otherTotal = total - changedValue;
      const remaining = 100 - changedValue;
      
      if (remaining < 0) {
        // Changed slider exceeds 100%, cap it at 100 and zero others
        changedSlider.value = 100;
        sliders.forEach((s, i) => {
          if (i !== changedIndex) s.value = 0;
        });
        updateRaceSliderDisplays();
        return;
      }
      
      if (remaining === 0) {
        // Changed slider is 100%, zero all others
        sliders.forEach((s, i) => {
          if (i !== changedIndex) s.value = 0;
        });
        updateRaceSliderDisplays();
        return;
      }
      
      // Proportionally adjust other sliders
      if (otherTotal > 0) {
        sliders.forEach((s, i) => {
          if (i !== changedIndex) {
            const oldValue = parseInt(s.value);
            const proportion = oldValue / otherTotal;
            const newValue = Math.round(proportion * remaining);
            s.value = newValue;
          }
        });
      } else {
        // All others are 0, distribute remaining evenly
        const perSlider = Math.floor(remaining / (sliders.length - 1));
        let distributed = 0;
        sliders.forEach((s, i) => {
          if (i !== changedIndex) {
            s.value = perSlider;
            distributed += perSlider;
          }
        });
        // Add any remainder to first non-changed slider
        const remainder = remaining - distributed;
        if (remainder > 0) {
          for (let i = 0; i < sliders.length; i++) {
            if (i !== changedIndex) {
              sliders[i].value = parseInt(sliders[i].value) + remainder;
              break;
            }
          }
        }
      }
      
      updateRaceSliderDisplays();
    }
    
    // Update race slider displays
    function updateRaceSliderDisplays() {
      if (raceHumanPercentage) raceHumanPercentage.textContent = raceHumanSlider.value;
      if (raceElfPercentage) raceElfPercentage.textContent = raceElfSlider.value;
      if (raceOrcPercentage) raceOrcPercentage.textContent = raceOrcSlider.value;
      if (raceDemonPercentage) raceDemonPercentage.textContent = raceDemonSlider.value;
      if (raceFoxPercentage) raceFoxPercentage.textContent = raceFoxSlider.value;
      if (raceWolfPercentage) raceWolfPercentage.textContent = raceWolfSlider.value;
      if (raceCatPercentage) raceCatPercentage.textContent = raceCatSlider.value;
      if (raceRabbitPercentage) raceRabbitPercentage.textContent = raceRabbitSlider.value;
      
      const total = parseInt(raceHumanSlider.value) + parseInt(raceElfSlider.value) + 
                    parseInt(raceOrcSlider.value) + parseInt(raceDemonSlider.value) +
                    parseInt(raceFoxSlider.value) + parseInt(raceWolfSlider.value) +
                    parseInt(raceCatSlider.value) + parseInt(raceRabbitSlider.value);
      
      if (raceTotalValue) raceTotalValue.textContent = total;
      
      if (total === 100) {
        if (raceTotalValue) raceTotalValue.style.color = '#00d4ff';
        if (raceWarning) raceWarning.style.display = 'none';
      } else {
        if (raceTotalValue) raceTotalValue.style.color = '#e94560';
        if (raceWarning) raceWarning.style.display = 'block';
      }
    }
    
    // Add race slider listeners
    [raceHumanSlider, raceElfSlider, raceOrcSlider, raceDemonSlider, raceFoxSlider, raceWolfSlider, raceCatSlider, raceRabbitSlider].forEach(slider => {
      if (slider) {
        slider.addEventListener('input', () => normalizeRaceSliders(slider));
      }
    });
    
    // Load race settings when opening modal
    if (genderOptionsBtn && genderOptionsModal) {
      const originalOpenListener = genderOptionsBtn.onclick;
      genderOptionsBtn.addEventListener('click', () => {
        // Load race settings
        if (raceHumanSlider) raceHumanSlider.value = gameState.raceSettings.human || 100;
        if (raceElfSlider) raceElfSlider.value = gameState.raceSettings.elf || 0;
        if (raceOrcSlider) raceOrcSlider.value = gameState.raceSettings.orc || 0;
        if (raceDemonSlider) raceDemonSlider.value = gameState.raceSettings.demon || 0;
        if (raceFoxSlider) raceFoxSlider.value = gameState.raceSettings.fox || 0;
        if (raceWolfSlider) raceWolfSlider.value = gameState.raceSettings.wolf || 0;
        if (raceCatSlider) raceCatSlider.value = gameState.raceSettings.cat || 0;
        if (raceRabbitSlider) raceRabbitSlider.value = gameState.raceSettings.rabbit || 0;
        
        updateRaceSliderDisplays();
      });
    }
    
    // Update save button to include race settings
    if (saveGenderOptions) {
      const originalSaveHandler = saveGenderOptions.onclick;
      saveGenderOptions.addEventListener('click', () => {
        // Verify race total is 100%
        const raceTotal = parseInt(raceHumanSlider.value) + parseInt(raceElfSlider.value) + 
                         parseInt(raceOrcSlider.value) + parseInt(raceDemonSlider.value) +
                         parseInt(raceFoxSlider.value) + parseInt(raceWolfSlider.value) +
                         parseInt(raceCatSlider.value) + parseInt(raceRabbitSlider.value);
        
        if (raceTotal !== 100) {
          showNotification('Race distribution must total 100%!', 'error');
          return;
        }
        
        // Save race settings
        gameState.raceSettings.human = parseInt(raceHumanSlider.value);
        gameState.raceSettings.elf = parseInt(raceElfSlider.value);
        gameState.raceSettings.orc = parseInt(raceOrcSlider.value);
        gameState.raceSettings.demon = parseInt(raceDemonSlider.value);
        gameState.raceSettings.fox = parseInt(raceFoxSlider.value);
        gameState.raceSettings.wolf = parseInt(raceWolfSlider.value);
        gameState.raceSettings.cat = parseInt(raceCatSlider.value);
        gameState.raceSettings.rabbit = parseInt(raceRabbitSlider.value);
        
        // Update the HR page display
        updateGenderDistributionDisplay();
        
        // Check if non-human races are being used
        const nonHumanTotal = raceTotal - parseInt(raceHumanSlider.value);
        if (nonHumanTotal > 0) {
          showNotification('ğŸ§¬ Race & Gender settings saved!', 'success');
        }
      });
    }
    
    // Attachment menu
    const chatAttachBtn = $('chatAttachBtn');
    const attachmentMenu = $('attachmentMenu');
    if (chatAttachBtn && attachmentMenu) {
      chatAttachBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const isVisible = attachmentMenu.style.display === 'block';
        attachmentMenu.style.display = isVisible ? 'none' : 'block';
      });
      
      // Close menu when clicking outside
      document.addEventListener('click', (e) => {
        if (!chatAttachBtn.contains(e.target) && !attachmentMenu.contains(e.target)) {
          attachmentMenu.style.display = 'none';
        }
      });
      
      // Attachment menu items
      document.querySelectorAll('.attach-menu-item').forEach(item => {
        item.addEventListener('click', () => {
          const action = item.dataset.action;
          attachmentMenu.style.display = 'none';
          
          if (action === 'send-money') {
            openSendMoneyModal();
          } else if (action === 'give-gift') {
            // Use window.openGiftSelectionModal directly to avoid shadowing issues
            if (typeof window.openGiftSelectionModal === 'function') {
              window.openGiftSelectionModal();
            }
          } else if (action === 'request') {
            $('requestImageModal').style.display = 'flex';
          } else if (action === 'send') {
            $('sendImageModal').style.display = 'flex';
          } else if (action === 'request-post') {
            $('requestPostModal').style.display = 'flex';
          } else if (action === 'visualize') {
            visualizeCurrentScene();
          }
        });
      });
    }
    
    // Send Image Modal
    const sendImageModal = $('sendImageModal');
    const closeSendImageModal = $('closeSendImageModal');
    const cancelSendImage = $('cancelSendImage');
    const confirmSendImage = $('confirmSendImage');
    const sendImagePrompt = $('sendImagePrompt');
    
    // Setup @mention autocomplete for send image prompt
    if (sendImagePrompt) {
      setupMentionAutocomplete(sendImagePrompt, 'sendImageMentionSuggestions');
    }
    
    if (closeSendImageModal) {
      closeSendImageModal.addEventListener('click', () => {
        sendImageModal.style.display = 'none';
        sendImagePrompt.value = '';
      });
    }
    
    if (cancelSendImage) {
      cancelSendImage.addEventListener('click', () => {
        sendImageModal.style.display = 'none';
        sendImagePrompt.value = '';
      });
    }
    
    if (confirmSendImage) {
      confirmSendImage.addEventListener('click', async () => {
        const prompt = sendImagePrompt.value.trim();
        if (prompt) {
          sendImageModal.style.display = 'none';
          sendImagePrompt.value = '';
          await sendImageToNPC(prompt);
        }
      });
    }
    
    // Send Money Modal
    const sendMoneyModal = $('sendMoneyModal');
    const closeSendMoneyModal = $('closeSendMoneyModal');
    const cancelSendMoney = $('cancelSendMoney');
    const confirmSendMoney = $('confirmSendMoney');
    const customMoneyAmount = $('customMoneyAmount');
    
    /**
     * Open Send Money Modal
     * Send money to an employee (works in both 1-on-1 and meeting contexts)
     * @param {string} employeeId - Employee to send money to (optional for legacy compatibility)
     * @param {boolean} isMeetingContext - Whether this is from a meeting (optional)
     */
    function openSendMoneyModal(employeeId = null, isMeetingContext = false) {
      // Legacy compatibility: if no employeeId, use activeChat
      if (!employeeId && gameState.activeChat) {
        employeeId = gameState.activeChat.id;
        isMeetingContext = false;
      }
      
      // Store context for when send is confirmed
      window.currentMoneyContext = {
        employeeId: employeeId,
        isMeeting: isMeetingContext
      };
      
      const balance = gameState.cash || 0;
      $('sendMoneyBalance').textContent = '$' + formatCash(balance);
      
      // Calculate preset amounts (1%, 5%, 10% of balance)
      const small = Math.max(100, Math.floor(balance * 0.01));
      const medium = Math.max(1000, Math.floor(balance * 0.05));
      const large = Math.max(10000, Math.floor(balance * 0.10));
      
      $('moneySmall').textContent = '$' + formatCash(small);
      $('moneyMedium').textContent = '$' + formatCash(medium);
      $('moneyLarge').textContent = '$' + formatCash(large);
      
      customMoneyAmount.value = '';
      $('moneyMessage').value = '';
      sendMoneyModal.style.display = 'flex';
    }
    
    if (closeSendMoneyModal) {
      closeSendMoneyModal.addEventListener('click', () => {
        sendMoneyModal.style.display = 'none';
        customMoneyAmount.value = '';
        $('moneyMessage').value = '';
      });
    }
    
    if (cancelSendMoney) {
      cancelSendMoney.addEventListener('click', () => {
        sendMoneyModal.style.display = 'none';
        customMoneyAmount.value = '';
        $('moneyMessage').value = '';
      });
    }
    
    // Money preset buttons - populate custom amount field instead of immediately sending
    document.querySelectorAll('.money-preset').forEach(btn => {
      btn.addEventListener('click', () => {
        const preset = btn.dataset.preset;
        const balance = gameState.cash || 0;
        
        let amount = 0;
        if (preset === 'small') amount = Math.max(100, Math.floor(balance * 0.01));
        else if (preset === 'medium') amount = Math.max(1000, Math.floor(balance * 0.05));
        else if (preset === 'large') amount = Math.max(10000, Math.floor(balance * 0.10));
        
        // Populate the custom amount field with the preset value
        if (customMoneyAmount) {
          customMoneyAmount.value = amount;
          customMoneyAmount.focus();
        }
      });
      
      // Hover effects
      btn.addEventListener('mouseenter', () => {
        btn.style.background = '#4ecca3';
        btn.style.borderColor = '#4ecca3';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.background = '#0f3460';
        btn.style.borderColor = '#4ecca3';
      });
    });
    
    if (confirmSendMoney) {
      confirmSendMoney.addEventListener('click', async () => {
        const amount = parseInt(customMoneyAmount.value) || 0;
        const balance = gameState.cash || 0;
        const message = $('moneyMessage').value.trim();
        
        if (amount <= 0) {
          showNotification('âŒ Please enter a valid amount', 'error');
          return;
        }
        
        if (amount > balance) {
          showNotification('âŒ Insufficient funds!', 'error');
          return;
        }
        
        sendMoneyModal.style.display = 'none';
        customMoneyAmount.value = '';
        $('moneyMessage').value = '';
        
        // Use context if available, otherwise fall back to activeChat
        const context = window.currentMoneyContext || {};
        const employeeId = context.employeeId || (gameState.activeChat ? gameState.activeChat.id : null);
        const isMeeting = context.isMeeting || false;
        
        if (!employeeId) {
          showNotification('âŒ No recipient selected', 'error');
          return;
        }
        
        await sendMoneyToNPC(amount, message, employeeId, isMeeting);
        
        // Clear context
        window.currentMoneyContext = null;
      });
    }
    
    // Gift Selection Modal
    const giftSelectionModal = $('giftSelectionModal');
    const closeGiftSelectionModal = $('closeGiftSelectionModal');
    const cancelGiftSelection = $('cancelGiftSelection');
    const giftSelectionGrid = $('giftSelectionGrid');
    const giftSelectionEmpty = $('giftSelectionEmpty');
    let currentGiftRecipient = null;
    
    window.openGiftSelectionModal = function() {
      if (!gameState.activeChat) {
        console.error('[Gift Modal] No active chat');
        return;
      }
      
      // activeChat is the employee object itself, not just the ID
      const employee = gameState.activeChat;
      currentGiftRecipient = employee.id;
      
      if (!giftSelectionModal) {
        console.error('[Gift Modal] Modal element not found');
        return;
      }
      
      // Set recipient name
      const recipientNameEl = $('giftRecipientName');
      if (recipientNameEl) {
        recipientNameEl.textContent = `Giving a gift to ${employee.name}`;
      }
      
      // Show preferences (hidden until learned)
      const prefs = employee.giftPreferences || { loves: [], hates: [], learnedLoves: [], learnedHates: [] };
      
      // Ensure learned arrays exist (for save compatibility)
      if (!prefs.learnedLoves) prefs.learnedLoves = [];
      if (!prefs.learnedHates) prefs.learnedHates = [];
      
      // Show learned loves, hide unknown ones
      const lovesDisplay = prefs.loves.map(cat => {
        if (prefs.learnedLoves.includes(cat)) {
          const category = GIFT_CATEGORIES[cat];
          return category ? `${category.emoji} ${category.name}` : cat;
        } else {
          return 'â“ ?????';
        }
      });
      const lovesText = lovesDisplay.join(', ') || 'Unknown';
      
      // Show learned hates, hide unknown ones
      const hatesDisplay = prefs.hates.map(cat => {
        if (prefs.learnedHates.includes(cat)) {
          const category = GIFT_CATEGORIES[cat];
          return category ? `${category.emoji} ${category.name}` : cat;
        } else {
          return 'â“ ?????';
        }
      });
      const hatesText = hatesDisplay.join(', ') || 'Unknown';
      
      const lovesEl = $('giftLovesHint');
      const hatesEl = $('giftHatesHint');
      if (lovesEl) lovesEl.textContent = lovesText;
      if (hatesEl) hatesEl.textContent = hatesText;
      
      // Populate gift grid
      populateGiftSelectionGrid(employee);
      
      console.log('[Gift Modal] Opening modal for', employee.name);
      giftSelectionModal.style.display = 'flex';
    }
    
    function populateGiftSelectionGrid(employee) {
      const inventory = gameState.giftInventory?.items || [];
      
      if (inventory.length === 0) {
        giftSelectionGrid.style.display = 'none';
        giftSelectionEmpty.style.display = 'block';
        return;
      }
      
      giftSelectionGrid.style.display = 'grid';
      giftSelectionEmpty.style.display = 'none';
      giftSelectionGrid.innerHTML = '';
      
      const prefs = employee.giftPreferences || { loves: [], neutral: [], hates: [] };
      
      inventory.forEach(gift => {
        const category = GIFT_CATEGORIES[gift.category];
        const categoryEmoji = category ? category.emoji : 'ğŸ';
        const categoryName = category ? category.name : gift.category;
        
        // Determine preference match
        let matchType = 'neutral';
        let matchColor = '#aaa';
        let matchText = '';
        
        if (prefs.loves?.includes(gift.category)) {
          matchType = 'loves';
          matchColor = '#4ecca3';
          matchText = "They'll LOVE this! ğŸ’•";
        } else if (prefs.hates?.includes(gift.category)) {
          matchType = 'hates';
          matchColor = '#e94560';
          matchText = "They might hate this... ğŸ’”";
        } else {
          matchText = "They'll appreciate this ğŸ‘";
        }
        
        const card = document.createElement('div');
        card.style.cssText = `
          background: #0f3460;
          border-radius: 10px;
          padding: 15px;
          cursor: pointer;
          transition: all 0.2s;
          border: 2px solid ${matchType === 'loves' ? '#4ecca3' : matchType === 'hates' ? '#e94560' : '#0f3460'};
          position: relative;
        `;
        
        card.innerHTML = `
          <div style="font-size: 2.5rem; text-align: center; margin-bottom: 8px;">${categoryEmoji}</div>
          <h4 style="margin: 0 0 5px 0; font-size: 0.95rem; color: white; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${gift.name}">${gift.name}</h4>
          <p style="margin: 0 0 8px 0; font-size: 0.75rem; color: #aaa; text-align: center;">${categoryName}</p>
          <p style="margin: 0 0 8px 0; font-size: 0.9rem; color: #4ecca3; text-align: center; font-weight: 600;">$${formatCash(gift.price)}</p>
          <p style="margin: 0; font-size: 0.75rem; color: ${matchColor}; text-align: center; font-weight: 600;">${matchText}</p>
        `;
        
        // Hover effect
        card.addEventListener('mouseenter', () => {
          card.style.transform = 'translateY(-5px)';
          card.style.boxShadow = `0 8px 20px ${matchType === 'loves' ? 'rgba(78,204,163,0.3)' : matchType === 'hates' ? 'rgba(233,69,96,0.3)' : 'rgba(102,126,234,0.3)'}`;
        });
        
        card.addEventListener('mouseleave', () => {
          card.style.transform = 'translateY(0)';
          card.style.boxShadow = 'none';
        });
        
        // Click to select gift (not send yet)
        card.addEventListener('click', () => {
          // Deselect all other cards
          giftSelectionGrid.querySelectorAll('div').forEach(c => {
            c.style.borderColor = c.dataset.matchType === 'loves' ? '#4ecca3' : c.dataset.matchType === 'hates' ? '#e94560' : '#0f3460';
            c.style.borderWidth = '2px';
          });
          
          // Select this card
          card.style.borderColor = '#00d4ff';
          card.style.borderWidth = '3px';
          
          // Store selected gift
          window.selectedGift = gift;
          
          // Enable send button
          const sendBtn = $('sendGiftBtn');
          if (sendBtn) {
            sendBtn.disabled = false;
            sendBtn.style.opacity = '1';
            sendBtn.style.cursor = 'pointer';
          }
        });
        
        // Store match type for border reset
        card.dataset.matchType = matchType;
        
        giftSelectionGrid.appendChild(card);
      });
    }
    
    // Send gift button handler
    const sendGiftBtn = $('sendGiftBtn');
    if (sendGiftBtn) {
      sendGiftBtn.addEventListener('click', async () => {
        if (!window.selectedGift || !currentGiftRecipient) return;
        
        const gift = window.selectedGift;
        const employeeId = currentGiftRecipient;
        const employee = gameState.employees.find(e => e.id === employeeId);
        
        if (!employee) {
          showNotification('Employee not found!', 'error');
          return;
        }
        
        // Get personal message
        const messageInput = $('giftPersonalMessage');
        const personalMessage = messageInput ? messageInput.value.trim() : '';
        
        giftSelectionModal.style.display = 'none';
        
        // Clear selection and message for next time
        window.selectedGift = null;
        if (messageInput) messageInput.value = '';
        sendGiftBtn.disabled = true;
        sendGiftBtn.style.opacity = '0.5';
        
        // Remove ONE gift from inventory (decrement quantity)
        const giftItem = gameState.giftInventory.items.find(g => g.id === gift.id);
        if (giftItem) {
          giftItem.quantity = (giftItem.quantity || 1) - 1;
          
          // Only remove the item entirely if quantity is 0
          if (giftItem.quantity <= 0) {
            gameState.giftInventory.items = gameState.giftInventory.items.filter(g => g.id !== gift.id);
          }
        }
        
        // Add gift message to chat immediately
        const chatHistory = gameState.chatHistory[employee.id] || [];
        const categoryInfo = GIFT_CATEGORIES[gift.category];
        
        chatHistory.push({
          sender: 'player',
          content: personalMessage || `ğŸ Gave a gift`,
          timestamp: gameState.time?.currentTime || Date.now(),
          isPlayer: true,
          giftData: {
            name: gift.name,
            price: gift.price,
            category: gift.category,
            categoryName: categoryInfo?.name || gift.category,
            categoryEmoji: categoryInfo?.emoji || 'ğŸ',
            description: gift.description,
            imageUrl: gift.imageUrl
          }
        });
        
        gameState.chatHistory[employee.id] = chatHistory;
        
        // Refresh chat to show gift immediately
        if (gameState.activeChat && gameState.activeChat.id === employee.id) {
          refreshChatDisplay();
        }
        
        // Show typing indicator
        if (gameState.activeChat && gameState.activeChat.id === employee.id) {
          showTypingIndicator(employee);
        }
        
        // Give the gift with personal message (this will generate AI reaction and add it to chat)
        const result = await giveGiftToEmployee(employee.id, gift, personalMessage);
        
        // Hide typing indicator and refresh chat
        if (gameState.activeChat && gameState.activeChat.id === employee.id) {
          hideTypingIndicator();
          refreshChatDisplay();
        }
        
        // Update UI
        updateUI();
      });
    }
    
    if (closeGiftSelectionModal) {
      closeGiftSelectionModal.addEventListener('click', () => {
        giftSelectionModal.style.display = 'none';
        currentGiftRecipient = null;
        window.selectedGift = null;
        
        // Reset send button
        const sendBtn = $('sendGiftBtn');
        if (sendBtn) {
          sendBtn.disabled = true;
          sendBtn.style.opacity = '0.5';
        }
        
        // Clear message
        const messageInput = $('giftPersonalMessage');
        if (messageInput) messageInput.value = '';
      });
    }
    
    if (cancelGiftSelection) {
      cancelGiftSelection.addEventListener('click', () => {
        giftSelectionModal.style.display = 'none';
        currentGiftRecipient = null;
        window.selectedGift = null;
        
        // Reset send button
        const sendBtn = $('sendGiftBtn');
        if (sendBtn) {
          sendBtn.disabled = true;
          sendBtn.style.opacity = '0.5';
        }
        
        // Clear message
        const messageInput = $('giftPersonalMessage');
        if (messageInput) messageInput.value = '';
      });
    }
    
    // Gift personal message character counter
    const giftPersonalMessage = $('giftPersonalMessage');
    const giftMessageCharCount = $('giftMessageCharCount');
    if (giftPersonalMessage && giftMessageCharCount) {
      giftPersonalMessage.addEventListener('input', () => {
        const count = giftPersonalMessage.value.length;
        giftMessageCharCount.textContent = count;
        
        // Change color as approaching limit
        if (count > 450) {
          giftMessageCharCount.style.color = '#e94560';
        } else if (count > 400) {
          giftMessageCharCount.style.color = '#ff9800';
        } else {
          giftMessageCharCount.style.color = '#666';
        }
      });
    }
    
    // Counter Offer Modal
    const counterOfferModal = $('counterOfferModal');
    const closeCounterOfferModal = $('closeCounterOfferModal');
    const cancelCounterOffer = $('cancelCounterOffer');
    const confirmCounterOffer = $('confirmCounterOffer');
    const counterAmount = $('counterAmount');
    const counterJustification = $('counterJustification');
    
    if (closeCounterOfferModal) {
      closeCounterOfferModal.addEventListener('click', () => {
        counterOfferModal.style.display = 'none';
        counterAmount.value = '';
        counterJustification.value = '';
      });
    }
    
    if (cancelCounterOffer) {
      cancelCounterOffer.addEventListener('click', () => {
        counterOfferModal.style.display = 'none';
        counterAmount.value = '';
        counterJustification.value = '';
      });
    }
    
    if (confirmCounterOffer) {
      confirmCounterOffer.addEventListener('click', async () => {
        await submitCounterOffer();
      });
    }
    
    // Request Image Modal
    const requestImageModal = $('requestImageModal');
    const closeRequestImageModal = $('closeRequestImageModal');
    const requestManualBtn = $('requestManualBtn');
    const requestManualInput = $('requestManualInput');
    const requestImageMode = $('requestImageMode');
    const cancelRequestManual = $('cancelRequestManual');
    const confirmRequestManual = $('confirmRequestManual');
    const requestImagePrompt = $('requestImagePrompt');
    
    // Setup @mention autocomplete for request image prompt
    if (requestImagePrompt) {
      setupMentionAutocomplete(requestImagePrompt, 'requestImageMentionSuggestions');
    }
    
    if (closeRequestImageModal) {
      closeRequestImageModal.addEventListener('click', () => {
        requestImageModal.style.display = 'none';
        requestManualInput.style.display = 'none';
        requestImageMode.querySelector('div').style.display = 'grid';
        requestManualBtn.style.display = 'block';
        requestImagePrompt.value = '';
      });
    }
    
    // Preset buttons
    document.querySelectorAll('.request-preset').forEach(btn => {
      btn.addEventListener('click', async () => {
        const preset = btn.dataset.preset;
        requestImageModal.style.display = 'none';
        await requestImageFromNPC(preset);
      });
      
      // Hover effects
      btn.addEventListener('mouseenter', () => {
        btn.style.background = '#00d4ff';
        btn.style.color = '#0f1419';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.background = '#0f3460';
        btn.style.color = 'white';
      });
    });
    
    // Manual request button
    if (requestManualBtn) {
      requestManualBtn.addEventListener('click', () => {
        requestImageMode.querySelector('div').style.display = 'none';
        requestManualBtn.style.display = 'none';
        requestManualInput.style.display = 'block';
      });
    }
    
    if (cancelRequestManual) {
      cancelRequestManual.addEventListener('click', () => {
        requestManualInput.style.display = 'none';
        requestImageMode.querySelector('div').style.display = 'grid';
        requestManualBtn.style.display = 'block';
        requestImagePrompt.value = '';
      });
    }
    
    if (confirmRequestManual) {
      confirmRequestManual.addEventListener('click', async () => {
        const prompt = requestImagePrompt.value.trim();
        if (prompt) {
          requestImageModal.style.display = 'none';
          requestManualInput.style.display = 'none';
          requestImageMode.querySelector('div').style.display = 'grid';
          requestManualBtn.style.display = 'block';
          requestImagePrompt.value = '';
          await requestImageFromNPC(null, prompt);
        }
      });
    }
    
    // ========== REQUEST POST MODAL HANDLERS ==========
    
    const requestPostModal = $('requestPostModal');
    const closeRequestPostModal = $('closeRequestPostModal');
    const requestPostCustomBtn = $('requestPostCustomBtn');
    const requestPostCustomInput = $('requestPostCustomInput');
    const requestPostMode = $('requestPostMode');
    const cancelRequestPostCustom = $('cancelRequestPostCustom');
    const confirmRequestPostCustom = $('confirmRequestPostCustom');
    const requestPostPrompt = $('requestPostPrompt');
    
    if (closeRequestPostModal) {
      closeRequestPostModal.addEventListener('click', () => {
        requestPostModal.style.display = 'none';
        requestPostCustomInput.style.display = 'none';
        requestPostMode.querySelector('div').style.display = 'grid';
        requestPostCustomBtn.style.display = 'block';
        requestPostPrompt.value = '';
      });
    }
    
    // Post type preset buttons
    document.querySelectorAll('.request-post-preset').forEach(btn => {
      btn.addEventListener('mouseenter', () => {
        btn.style.background = '#00d4ff';
        btn.style.color = '#0f1419';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.background = '#0f3460';
        btn.style.color = 'white';
      });
      btn.addEventListener('click', async () => {
        const preset = btn.dataset.preset;
        requestPostModal.style.display = 'none';
        await requestPostFromNPC(preset);
      });
    });
    
    // Custom post request button
    if (requestPostCustomBtn) {
      requestPostCustomBtn.addEventListener('click', () => {
        requestPostMode.querySelector('div').style.display = 'none';
        requestPostCustomBtn.style.display = 'none';
        requestPostCustomInput.style.display = 'block';
      });
    }
    
    if (cancelRequestPostCustom) {
      cancelRequestPostCustom.addEventListener('click', () => {
        requestPostCustomInput.style.display = 'none';
        requestPostMode.querySelector('div').style.display = 'grid';
        requestPostCustomBtn.style.display = 'block';
        requestPostPrompt.value = '';
      });
    }
    
    if (confirmRequestPostCustom) {
      confirmRequestPostCustom.addEventListener('click', async () => {
        const prompt = requestPostPrompt.value.trim();
        if (prompt) {
          requestPostModal.style.display = 'none';
          requestPostCustomInput.style.display = 'none';
          requestPostMode.querySelector('div').style.display = 'grid';
          requestPostCustomBtn.style.display = 'block';
          requestPostPrompt.value = '';
          await requestPostFromNPC(null, prompt);
        }
      });
    }
    
    // ========== SOCIAL FEED EVENT HANDLERS ==========
    
    // Player post button
    const playerPostBtn = $('playerPostBtn');
    if (playerPostBtn) {
      playerPostBtn.addEventListener('click', () => {
        openPlayerPostComposer();
      });
    }
    
    // ========== THE ALGORITHMâ„¢ - EVENT LISTENERS ==========
    
    // Algorithm Sort Buttons
    document.querySelectorAll('.algo-sort-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        // Update active state
        document.querySelectorAll('.algo-sort-btn').forEach(b => {
          b.classList.remove('active');
          b.style.background = '#0f3460';
          b.style.color = '#aaa';
        });
        
        btn.classList.add('active');
        btn.style.background = '#0f3460';
        btn.style.color = 'white';
        
        // Update algorithm sort
        const sort = btn.dataset.sort;
        gameState.socialNetwork.algorithm.sort = sort;
        
        // Show/hide Best time frame selector
        const timeFrameSelector = $('bestTimeFrameSelector');
        if (timeFrameSelector) {
          timeFrameSelector.style.display = sort === 'best' ? 'block' : 'none';
        }
        
        renderSocialFeed(true); // Force full render
      });
    });
    
    // Best Time Frame Selector
    const bestTimeFrameSelect = $('bestTimeFrameSelect');
    if (bestTimeFrameSelect) {
      bestTimeFrameSelect.addEventListener('change', (e) => {
        gameState.socialNetwork.algorithm.bestTimeFrame = e.target.value;
        
        // Update the label
        const timeFrameLabel = $('bestTimeFrame');
        if (timeFrameLabel) {
          const labels = {
            'hour': 'Past Hour',
            'day': 'Past 24h',
            'week': 'Past Week',
            'month': 'Past Month',
            'all': 'All Time'
          };
          timeFrameLabel.textContent = labels[e.target.value] || 'All Time';
        }
        
        renderSocialFeed(true);
      });
    }
    
    // Content Rating Filter Buttons
    document.querySelectorAll('.content-filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        // Update active state
        document.querySelectorAll('.content-filter-btn').forEach(b => {
          b.classList.remove('active');
          b.style.background = '#0f3460';
          b.style.color = '#aaa';
        });
        
        btn.classList.add('active');
        btn.style.background = '#0f3460';
        btn.style.color = 'white';
        
        // Update content rating filter
        gameState.socialNetwork.algorithm.contentRating = btn.dataset.rating;
        renderSocialFeed(true);
      });
    });
    
    // Post Type Filter
    const postTypeFilter = $('postTypeFilter');
    if (postTypeFilter) {
      postTypeFilter.addEventListener('change', (e) => {
        gameState.socialNetwork.algorithm.postType = e.target.value;
        renderSocialFeed(true);
      });
    }
    
    // Author Filter
    const authorFilter = $('authorFilter');
    if (authorFilter) {
      // Populate with employee names
      const populateAuthorFilter = () => {
        const currentValue = authorFilter.value;
        authorFilter.innerHTML = `
          <option value="all">Everyone</option>
          <option value="player">My Posts</option>
          <option value="following">Following</option>
        `;
        
        // Add all active employees
        gameState.employees
          .filter(e => e.employmentStatus === 'active')
          .sort((a, b) => a.name.localeCompare(b.name))
          .forEach(emp => {
            const option = document.createElement('option');
            option.value = emp.id;
            option.textContent = emp.name;
            authorFilter.appendChild(option);
          });
        
        // Restore previous value if it still exists
        if (currentValue && Array.from(authorFilter.options).some(o => o.value === currentValue)) {
          authorFilter.value = currentValue;
        }
      };
      
      populateAuthorFilter();
      
      authorFilter.addEventListener('change', (e) => {
        gameState.socialNetwork.algorithm.author = e.target.value;
        renderSocialFeed(true);
      });
      
      // Repopulate when employees change
      window.addEventListener('employeesUpdated', populateAuthorFilter);
    }
    
    // Engagement Filter
    const engagementFilter = $('engagementFilter');
    if (engagementFilter) {
      engagementFilter.addEventListener('change', (e) => {
        gameState.socialNetwork.algorithm.engagement = e.target.value;
        renderSocialFeed(true);
      });
    }
    
    // Search Input
    const feedSearchInput = $('feedSearchInput');
    const clearSearchBtn = $('clearSearchBtn');
    const searchResultsCount = $('searchResultsCount');
    
    if (feedSearchInput) {
      // Real-time search with debounce
      let searchTimeout;
      feedSearchInput.addEventListener('input', (e) => {
        const query = e.target.value;
        
        // Show/hide clear button
        if (clearSearchBtn) {
          clearSearchBtn.style.display = query ? 'block' : 'none';
        }
        
        // Debounce search
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          gameState.socialNetwork.algorithm.searchQuery = query;
          renderSocialFeed(true);
          
          // Show search results count
          if (searchResultsCount && query) {
            const posts = filterAndSortPosts();
            searchResultsCount.style.display = 'block';
            searchResultsCount.textContent = `Found ${posts.length} post${posts.length !== 1 ? 's' : ''}`;
          } else if (searchResultsCount) {
            searchResultsCount.style.display = 'none';
          }
        }, 300); // 300ms debounce
      });
    }
    
    // Clear Search Button
    if (clearSearchBtn && feedSearchInput) {
      clearSearchBtn.addEventListener('click', () => {
        feedSearchInput.value = '';
        gameState.socialNetwork.algorithm.searchQuery = '';
        clearSearchBtn.style.display = 'none';
        if (searchResultsCount) searchResultsCount.style.display = 'none';
        renderSocialFeed(true);
      });
    }
    
    // Test generate post button
    const testGeneratePostBtn = $('testGeneratePostBtn');
    if (testGeneratePostBtn) {
      testGeneratePostBtn.addEventListener('click', () => {
        generateTestPost();
      });
    }
    
    // Post composer modal close button (X button)
    const closePlayerPostModalBtn = $('closePlayerPostModal');
    if (closePlayerPostModalBtn) {
      closePlayerPostModalBtn.addEventListener('click', () => {
        closePlayerPostModal();
      });
    }
    
    // Post composer cancel button
    const cancelPlayerPost = $('cancelPlayerPost');
    if (cancelPlayerPost) {
      cancelPlayerPost.addEventListener('click', () => {
        closePlayerPostModal();
      });
    }
    
    // Post type buttons
    document.querySelectorAll('.post-type-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        // Update active state
        document.querySelectorAll('.post-type-btn').forEach(b => {
          b.classList.remove('active');
          b.style.borderColor = '#0f3460';
          b.style.color = '#aaa';
        });
        
        btn.classList.add('active');
        btn.style.borderColor = '#00d4ff';
        btn.style.color = 'white';
        
        // Show/hide image sections
        const type = btn.dataset.type;
        const imageSection = $('playerPostImageSection');
        const generateImageBtn = $('generatePlayerPostImage');
        const imagePromptInput = $('playerPostImagePrompt');
        const imageAltInput = $('playerPostAltText');
        
        if (type === 'text') {
          if (imageSection) imageSection.style.display = 'none';
          if (generateImageBtn) generateImageBtn.style.display = 'none';
        } else {
          if (imageSection) imageSection.style.display = 'block';
          if (generateImageBtn) generateImageBtn.style.display = 'inline-block';
          
          // Set default prompt based on type
          if (type === 'image' && imagePromptInput) {
            imagePromptInput.placeholder = 'Describe the image (e.g., "@TheBoss at a party"). Type @ to autocomplete!';
          } else if (type === 'selfie' && imagePromptInput) {
            imagePromptInput.placeholder = 'Describe your selfie (e.g., "@player in workout clothes"). Type @ to autocomplete!';
          }
        }
      });
    });
    
    // Setup @mention autocomplete for player post image prompt
    const playerPostImagePromptField = $('playerPostImagePrompt');
    if (playerPostImagePromptField) {
      setupMentionAutocomplete(playerPostImagePromptField, 'postImageMentionSuggestions');
    }
    
    // Generate image button
    const generatePlayerPostImage = $('generatePlayerPostImage');
    if (generatePlayerPostImage) {
      generatePlayerPostImage.addEventListener('click', async () => {
        await generatePlayerPostImage_handler();
      });
    }
    
    // Regenerate image button
    const playerPostRegenerateImg = $('playerPostRegenerateImg');
    if (playerPostRegenerateImg) {
      playerPostRegenerateImg.addEventListener('click', async () => {
        await generatePlayerPostImage_handler();
      });
    }
    
    // Submit player post
    const submitPlayerPost = $('submitPlayerPost');
    if (submitPlayerPost) {
      submitPlayerPost.addEventListener('click', () => {
        submitPlayerPostToFeed();
      });
    }
    
    // Character counter for caption
    const captionCharCount = $('captionCharCount');
    if (playerPostCaption && captionCharCount) {
      playerPostCaption.addEventListener('input', () => {
        const length = playerPostCaption.value.length;
        captionCharCount.textContent = length;
        
        if (length > 500) {
          captionCharCount.style.color = '#e94560';
        } else {
          captionCharCount.style.color = '#666';
        }
      });
    }
    
    // Event delegation for dynamically created post elements
    document.addEventListener('click', (e) => {
      // Like button
      if (e.target.closest('.like-btn')) {
        const btn = e.target.closest('.like-btn');
        const postId = btn.dataset.postId;
        handleLikePost(postId);
      }
      
      // Comment button - open post modal
      if (e.target.closest('.comment-btn')) {
        const btn = e.target.closest('.comment-btn');
        const postId = btn.dataset.postId;
        openPostModal(postId);
      }
      
      // Submit comment button (legacy support - modal has its own)
      if (e.target.closest('.submit-comment-btn')) {
        const btn = e.target.closest('.submit-comment-btn');
        const postId = btn.dataset.postId;
        const input = document.querySelector(`.comment-input[data-post-id="${postId}"]`);
        const replyIndicator = document.querySelector(`.reply-indicator[data-post-id="${postId}"]`);
        const replyToId = replyIndicator && replyIndicator.style.display !== 'none' ? 
                         replyIndicator.getAttribute('data-reply-to-id') : null;
        
        if (input) {
          addCommentToPost(postId, input.value, replyToId);
        }
      }
    });
    
    // Handle Enter key in comment inputs
    document.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && e.target.classList.contains('comment-input')) {
        const postId = e.target.dataset.postId;
        const replyIndicator = document.querySelector(`.reply-indicator[data-post-id="${postId}"]`);
        const replyToId = replyIndicator && replyIndicator.style.display !== 'none' ? 
                         replyIndicator.getAttribute('data-reply-to-id') : null;
        addCommentToPost(postId, e.target.value, replyToId);
      }
    });
    
    // Handle Reply button clicks
    document.addEventListener('click', (e) => {
      if (e.target.closest('.reply-to-comment-btn')) {
        const btn = e.target.closest('.reply-to-comment-btn');
        const postId = btn.dataset.postId;
        const commentId = btn.dataset.commentId;
        const authorName = btn.dataset.authorName;
        const authorId = btn.dataset.authorId;
        const authorUsername = btn.dataset.authorUsername; // CRITICAL FIX: Get actual username
        
        const input = document.querySelector(`.comment-input[data-post-id="${postId}"]`);
        const replyIndicator = document.querySelector(`.reply-indicator[data-post-id="${postId}"]`);
        
        if (input && replyIndicator) {
          // Show reply indicator
          replyIndicator.querySelector('.reply-text').textContent = `Replying to ${authorName}`;
          replyIndicator.style.display = 'block';
          replyIndicator.setAttribute('data-reply-to-id', commentId);
          
          // CRITICAL FIX: Use username, not display name for @mentions
          if (authorId !== 'player' && authorUsername) {
            // Pre-fill with proper @username
            if (!input.value.includes(`@${authorUsername}`)) {
              input.value = `@${authorUsername} `;
            }
          }
          
          // Focus input
          input.focus();
        }
      }
    });
    
    // Handle Cancel Reply button clicks
    document.addEventListener('click', (e) => {
      if (e.target.closest('.cancel-reply-btn')) {
        const btn = e.target.closest('.cancel-reply-btn');
        const postId = btn.dataset.postId;
        
        const replyIndicator = document.querySelector(`.reply-indicator[data-post-id="${postId}"]`);
        if (replyIndicator) {
          replyIndicator.style.display = 'none';
          replyIndicator.removeAttribute('data-reply-to-id');
        }
      }
    });
    
    // Global Upgrades - Click Power Button
    const buyClickPowerBtn = $('buyClickPowerBtn');
    if (buyClickPowerBtn) {
      buyClickPowerBtn.addEventListener('click', buyClickPower);
    }
    
    // Elite upgrade buttons
    const buyGoldenTouchBtn = $('buyGoldenTouchBtn');
    if (buyGoldenTouchBtn) {
      buyGoldenTouchBtn.addEventListener('click', buyGoldenTouch);
    }
    
    const buyTimeDilationBtn = $('buyTimeDilationBtn');
    if (buyTimeDilationBtn) {
      buyTimeDilationBtn.addEventListener('click', buyTimeDilation);
    }
    
    const buyEmpireBuilderBtn = $('buyEmpireBuilderBtn');
    if (buyEmpireBuilderBtn) {
      buyEmpireBuilderBtn.addEventListener('click', buyEmpireBuilder);
    }
    
    // ========== PRESTIGE SYSTEM EVENT HANDLERS ==========
    
    // Prestige button - opens confirmation modal
    const prestigeBtn = $('prestigeBtn');
    if (prestigeBtn) {
      prestigeBtn.addEventListener('click', showPrestigeModal);
    }
    
    // Prestige modal - close button
    const closePrestigeModal = $('closePrestigeModal');
    if (closePrestigeModal) {
      closePrestigeModal.addEventListener('click', () => {
        const modal = $('prestigeModal');
        if (modal) modal.style.display = 'none';
      });
    }
    
    // Prestige modal - cancel button
    const cancelPrestige = $('cancelPrestige');
    if (cancelPrestige) {
      cancelPrestige.addEventListener('click', () => {
        const modal = $('prestigeModal');
        if (modal) modal.style.display = 'none';
      });
    }
    
    // Prestige modal - confirm button
    const confirmPrestige = $('confirmPrestige');
    if (confirmPrestige) {
      confirmPrestige.addEventListener('click', executePrestige);
    }
    
    // ========== PAGE VISIBILITY & AFK DETECTION ==========
    
    // Track user interactions to detect AFK state
    const updateInteractionTime = () => {
      gameState.lastInteractionTime = Date.now();
    };
    
    // Listen for actual user interactions
    document.addEventListener('click', updateInteractionTime);
    document.addEventListener('keydown', updateInteractionTime);
    document.addEventListener('touchstart', updateInteractionTime);
    document.addEventListener('scroll', updateInteractionTime);
    
    // Page Visibility API - detect when tab/app goes to background
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Page is now hidden (tab switched, phone locked, etc.)
        const now = Date.now();
        gameState.pageHiddenTime = now;
        gameState.lastPlayTime = now;
        // Save immediately when page goes hidden
        saveGame(false);
      } else {
        // Page is now visible again
        // Check for AFK earnings based on time hidden
        checkAfkIncome();
        // Update interaction time since user is back
        gameState.lastInteractionTime = Date.now();
      }
    });
    
    // Also handle beforeunload to save last active time
    window.addEventListener('beforeunload', () => {
      gameState.lastPlayTime = Date.now();
      // Note: We can't reliably save here in some browsers, but we try
      navigator.sendBeacon && navigator.sendBeacon('/save', JSON.stringify(gameState));
    });
    
    // Additional fallback: If user hasn't interacted in 10 minutes while page is visible,
    // automatically trigger AFK mode
    setInterval(() => {
      if (!document.hidden) {
        const now = Date.now();
        const timeSinceInteraction = now - (gameState.lastInteractionTime || now);
        const TEN_MINUTES = 10 * 60 * 1000;
        
        // If no interaction for 10+ minutes, update lastPlayTime
        if (timeSinceInteraction >= TEN_MINUTES) {
          // Update lastPlayTime to when they last interacted
          if (gameState.lastPlayTime > gameState.lastInteractionTime) {
            gameState.lastPlayTime = gameState.lastInteractionTime;
          }
        }
      }
    }, 60000); // Check every minute
  }
  
  // Switch active tab
  function switchTab(tabName) {
    gameState.activeTab = tabName;
    
    // Update tab buttons
    document.querySelectorAll('.tab-btn').forEach(btn => {
      if (btn.dataset.tab === tabName) {
        btn.classList.add('active');
        btn.style.color = '#e94560';
      } else {
        btn.classList.remove('active');
        btn.style.color = 'white';
      }
    });
    
    // Update tab content
    document.querySelectorAll('.tab-content').forEach(content => {
      content.hidden = true;
    });
    
    const activeTab = $(`${tabName}Tab`);
    if (activeTab) {
      activeTab.hidden = false;
      updateTabContent(tabName);
    }
  }
  
  // ========== GIFT SYSTEM UI INITIALIZATION ==========
  
  // Initialize gift genie cycling suggestions
  let currentSuggestionIndex = 0;
  let suggestionIntervalId = null; // Store interval ID to prevent duplicates
  const giftGenieInput = $('giftGenieInput');
  const giftGenieSuggestion = $('giftGenieSuggestion');
  
  function cycleSuggestions() {
    if (!giftGenieInput || !giftGenieSuggestion) return;
    
    // Only show suggestion if input is empty
    if (giftGenieInput.value.length === 0) {
      giftGenieSuggestion.style.opacity = '1';
      giftGenieSuggestion.textContent = GIFT_SUGGESTIONS[currentSuggestionIndex];
      
      // Move to next suggestion
      currentSuggestionIndex = (currentSuggestionIndex + 1) % GIFT_SUGGESTIONS.length;
    } else {
      giftGenieSuggestion.style.opacity = '0';
    }
  }
  
  // Start cycling (with duplicate prevention)
  if (giftGenieInput && !suggestionIntervalId) {
    suggestionIntervalId = setInterval(cycleSuggestions, 1500);
    cycleSuggestions(); // Initial call
    
    // Hide suggestion when typing
    giftGenieInput.addEventListener('input', () => {
      if (giftGenieInput.value.length > 0) {
        giftGenieSuggestion.style.opacity = '0';
      } else {
        cycleSuggestions();
      }
    });
  }
  
  // Generate gift button
  const generateGiftBtn = $('generateGiftBtn');
  let currentGenerationController = null; // Track current generation
  
  if (generateGiftBtn) {
    generateGiftBtn.addEventListener('click', async () => {
      const input = giftGenieInput?.value.trim();
      if (!input) {
        showNotification('Please describe a gift!', 'warning');
        return;
      }
      
      const budget = parseFloat($('giftBudgetLimit')?.value || 'Infinity');
      
      // Create cancellation controller
      currentGenerationController = { cancelled: false };
      const thisController = currentGenerationController;
      
      // Show loading with visual feedback
      generateGiftBtn.disabled = true;
      generateGiftBtn.style.opacity = '0.6';
      generateGiftBtn.style.cursor = 'not-allowed';
      generateGiftBtn.innerHTML = 'â³ Creating gift...';
      
      // Show cancel button
      const cancelBtn = document.createElement('button');
      cancelBtn.id = 'cancelGenerationBtn';
      cancelBtn.innerHTML = 'ğŸš« Cancel';
      cancelBtn.style.cssText = 'margin-left:10px; padding:8px 15px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600;';
      cancelBtn.onclick = () => {
        thisController.cancelled = true;
        showNotification('ğŸš« Generation cancelled', 'info');
      };
      generateGiftBtn.parentElement.appendChild(cancelBtn);
      
      // Show notification
      showNotification('ğŸ§â€â™‚ï¸ Gift Genie is working...', 'info');
      
      try {
        const gift = await generateCustomGift(input, budget, thisController);
        
        // Check if cancelled
        if (thisController.cancelled) {
          console.log('[Gift] Generation cancelled by user');
          return;
        }
        
        // Store generation params for redo functionality
        window.lastGiftGenerationParams = {
          userDescription: input,
          maxBudget: budget
        };
        
        showGiftPreview(gift);
        giftGenieInput.value = ''; // Clear input
        cycleSuggestions(); // Restart cycling
        showNotification('âœ¨ Gift created successfully!', 'success');
      } catch (error) {
        // Ignore errors if cancelled
        if (thisController.cancelled) return;
        
        console.error('[Gift] Generation failed:', error);
        // Only show generic error if it wasn't a genie refusal
        if (error.message !== 'Genie refused this request') {
          showNotification('âŒ Failed to create gift. Please try again.', 'error');
        }
      } finally {
        // Remove cancel button
        const cancelBtn = $('cancelGenerationBtn');
        if (cancelBtn) cancelBtn.remove();
        
        // Only reset if this generation is still current
        if (currentGenerationController === thisController) {
          generateGiftBtn.disabled = false;
          generateGiftBtn.style.opacity = '1';
          generateGiftBtn.style.cursor = 'pointer';
          generateGiftBtn.innerHTML = 'âœ¨ Create Gift';
          currentGenerationController = null;
        }
      }
    });
  }
  
  // Show gift preview after generation
  function showGiftPreview(gift) {
    const modal = $('giftPreviewModal');
    const nameEl = $('giftPreviewName');
    const priceEl = $('giftPreviewPrice');
    const categoryEl = $('giftPreviewCategory');
    const descEl = $('giftPreviewDescription');
    const uniqueWarning = $('giftPreviewUnique');
    
    if (!modal) return;
    
    // Populate preview
    if (nameEl) nameEl.textContent = gift.name;
    if (priceEl) priceEl.textContent = '$' + gift.price.toLocaleString();
    if (categoryEl) {
      const cat = GIFT_CATEGORIES[gift.category];
      categoryEl.textContent = (cat?.emoji || '') + ' ' + (cat?.name || gift.category);
    }
    if (descEl) descEl.textContent = gift.description;
    
    // Show unique warning if applicable
    if (uniqueWarning) {
      uniqueWarning.style.display = gift.category === 'UNIQUE' ? 'block' : 'none';
    }
    
    // Store gift for purchase
    window.currentPreviewGift = gift;
    
    modal.style.display = 'block';
  }
  
  // Generate gift image
  const generateGiftImageBtn = $('generateGiftImageBtn');
  if (generateGiftImageBtn) {
    generateGiftImageBtn.addEventListener('click', async () => {
      if (!window.currentPreviewGift) return;
      
      const gift = window.currentPreviewGift;
      const imageEl = $('giftPreviewImage');
      
      generateGiftImageBtn.disabled = true;
      generateGiftImageBtn.textContent = 'ğŸ¨ Generating...';
      
      try {
        const imageUrl = await queuedGenerateImage(applyImageStyle(gift.imagePrompt), `Gift image: ${gift.name}`);
        if (imageEl) {
          imageEl.innerHTML = `<img src="${imageUrl}" style="width:100%; height:100%; object-fit:cover; border-radius:10px;">`;
        }
        gift.imageUrl = imageUrl;
      } catch (error) {
        console.error('[Gift] Image generation failed:', error);
        showNotification('Failed to generate image', 'error');
      } finally {
        generateGiftImageBtn.disabled = false;
        generateGiftImageBtn.textContent = 'ğŸ“¸ Generate Image';
      }
    });
  }
  
  // Approve gift button (add to store)
  const approveGiftBtn = $('approveGiftBtn');
  if (approveGiftBtn) {
    approveGiftBtn.addEventListener('click', () => {
      if (!window.currentPreviewGift) return;
      
      const gift = window.currentPreviewGift;
      
      // Add to store
      const result = addGiftToStore(gift);
      
      if (result) {
        // Close preview
        $('giftPreviewModal').style.display = 'none';
        window.currentPreviewGift = null;
        
        // Reset image
        const imageEl = $('giftPreviewImage');
        if (imageEl) imageEl.innerHTML = 'ğŸ';
        
        // Refresh displays
        updateGiftStore();
        updateGiftInventory();
      }
    });
  }
  
  // Deny gift button (delete)
  const denyGiftBtn = $('denyGiftBtn');
  if (denyGiftBtn) {
    denyGiftBtn.addEventListener('click', () => {
      if (!window.currentPreviewGift) return;
      
      const giftName = window.currentPreviewGift.name;
      
      // Close preview
      $('giftPreviewModal').style.display = 'none';
      window.currentPreviewGift = null;
      
      // Reset image
      const imageEl = $('giftPreviewImage');
      if (imageEl) imageEl.innerHTML = 'ğŸ';
      
      showNotification(`ğŸ—‘ï¸ Deleted "${giftName}"`, 'info');
    });
  }
  
  // Redo gift button (regenerate with same prompt)
  const redoGiftBtn = $('redoGiftBtn');
  if (redoGiftBtn) {
    redoGiftBtn.addEventListener('click', async () => {
      if (!window.lastGiftGenerationParams) {
        showNotification('No previous generation to redo', 'warning');
        return;
      }
      
      const { userDescription, maxBudget } = window.lastGiftGenerationParams;
      
      // Close preview modal
      $('giftPreviewModal').style.display = 'none';
      
      // Reset image
      const imageEl = $('giftPreviewImage');
      if (imageEl) imageEl.innerHTML = 'ğŸ';
      
      // Disable button
      redoGiftBtn.disabled = true;
      redoGiftBtn.style.opacity = '0.6';
      
      // Show notification
      showNotification('ğŸ”„ Regenerating gift with same prompt...', 'info');
      
      // Create cancellation controller
      const controller = { cancelled: false };
      
      try {
        const gift = await generateCustomGift(userDescription, maxBudget, controller);
        
        if (controller.cancelled) {
          console.log('[Gift] Regeneration cancelled by user');
          return;
        }
        
        showGiftPreview(gift);
        showNotification('âœ¨ New gift generated!', 'success');
      } catch (error) {
        console.error('[Gift] Regeneration failed:', error);
        if (error.message !== 'Genie refused this request') {
          showNotification('âŒ Failed to regenerate gift. Please try again.', 'error');
        }
      } finally {
        redoGiftBtn.disabled = false;
        redoGiftBtn.style.opacity = '1';
      }
    });
  }
  
  // Cache to prevent unnecessary re-renders
  let lastStoreRenderHash = null;
  let lastInventoryRenderHash = null;
  
  // Update gift store display
  function updateGiftStore() {
    const grid = $('giftStoreGrid');
    const countEl = $('giftStoreCount');
    
    if (!grid) return;
    
    // Ensure store exists (migration safety)
    if (!gameState.giftStore) {
      gameState.giftStore = { items: [] };
    }
    
    // Create a hash of the current state to detect changes
    const currentHash = JSON.stringify(gameState.giftStore.items.map(g => g.id));
    if (currentHash === lastStoreRenderHash) {
      // No changes, skip re-render
      return;
    }
    lastStoreRenderHash = currentHash;
    
    // Update count
    if (countEl) {
      countEl.textContent = gameState.giftStore.items.length;
    }
    
    // Render store
    if (gameState.giftStore.items.length === 0) {
      grid.innerHTML = `
        <div style="
          grid-column:1/-1;
          text-align:center;
          padding:40px;
          color:#aaa;
        ">
          <div style="font-size:3rem; margin-bottom:10px;">ğŸª</div>
          <p>No gifts in store yet!</p>
          <p style="font-size:0.9rem;">Use the Gift Genie above to create and approve gifts.</p>
        </div>
      `;
      return;
    }
    
    grid.innerHTML = '';
    
    gameState.giftStore.items.forEach(gift => {
      const category = GIFT_CATEGORIES[gift.category];
      const card = document.createElement('div');
      
      card.style.cssText = `
        background:#16213e;
        border-radius:10px;
        padding:15px;
        transition:all 0.2s;
        border:2px solid ${gift.category === 'UNIQUE' ? 'gold' : '#0f3460'};
        cursor:pointer;
      `;
      
      // Display image if available, otherwise show emoji
      const displayImage = gift.imageUrl 
        ? `<img src="${gift.imageUrl}" style="width:100%; aspect-ratio:1; object-fit:cover; border-radius:8px; margin-bottom:8px;">`
        : `<div style="font-size:2.5rem; text-align:center; margin-bottom:8px;">${category?.emoji || 'ğŸ'}</div>`;
      
      card.innerHTML = `
        ${displayImage}
        <h4 style="margin:0 0 5px 0; color:white; font-size:0.95rem; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;" title="${gift.name}">${gift.name}</h4>
        <p style="margin:0 0 8px 0; font-size:0.75rem; color:#aaa;">${category?.name || gift.category}</p>
        <p style="margin:0 0 10px 0; font-size:1rem; color:#4ecca3; font-weight:600;">$${formatCash(gift.price)}</p>
        ${gift.category === 'UNIQUE' ? '<p style="margin:0 0 10px 0; font-size:0.75rem; color:gold;">â­ One-time only!</p>' : ''}
        <button 
          onclick="purchaseGiftFromStore('${gift.id}')" 
          style="
            width:100%;
            padding:8px;
            background:#4ecca3;
            border:none;
            border-radius:6px;
            color:#0f1419;
            font-weight:600;
            cursor:pointer;
          "
        >ğŸ’° Purchase</button>
      `;
      
      card.addEventListener('mouseenter', () => {
        card.style.transform = 'translateY(-5px)';
        card.style.boxShadow = '0 8px 20px rgba(78,204,163,0.3)';
      });
      
      card.addEventListener('mouseleave', () => {
        card.style.transform = 'translateY(0)';
        card.style.boxShadow = 'none';
      });
      
      grid.appendChild(card);
    });
  }
  
  // Update gift inventory display
  function updateGiftInventory() {
    const grid = $('giftInventoryGrid');
    const countEl = $('giftInventoryCount');
    const scaleInfo = $('giftScaleInfo');
    const rangeEl = $('recommendedGiftRange');
    
    if (!grid) return;
    
    // Ensure inventory exists (migration safety)
    if (!gameState.giftInventory) {
      gameState.giftInventory = { items: [], capacity: Infinity };
    }
    
    // Create a hash of the current state to detect changes
    const currentHash = JSON.stringify(gameState.giftInventory.items.map(g => `${g.id}:${g.quantity || 1}`));
    if (currentHash === lastInventoryRenderHash) {
      // No changes, skip re-render
      return;
    }
    lastInventoryRenderHash = currentHash;
    
    // Update count
    if (countEl) {
      countEl.textContent = gameState.giftInventory.items.length;
    }
    
    // Update scale info
    if (scaleInfo && rangeEl) {
      const scale = calculateGiftPriceScale();
      rangeEl.textContent = `$${Math.round(scale.minRecommended).toLocaleString()} - $${Math.round(scale.maxRecommended).toLocaleString()}`;
    }
    
    // Render inventory
    if (gameState.giftInventory.items.length === 0) {
      grid.innerHTML = `
        <div style="
          grid-column:1/-1;
          text-align:center;
          padding:60px 20px;
          color:#666;
          font-size:1.1rem;
        ">
          Your inventory is empty. Create gifts above to get started! âœ¨
        </div>
      `;
      return;
    }
    
    grid.innerHTML = gameState.giftInventory.items.map(gift => {
      const cat = GIFT_CATEGORIES[gift.category];
      return `
        <div style="
          background:#0f3460;
          border:2px solid #667eea;
          border-radius:12px;
          padding:15px;
          transition:all 0.3s;
        " onmouseover="this.style.transform='translateY(-4px)'; this.style.borderColor='#00d4ff'"
           onmouseout="this.style.transform='translateY(0)'; this.style.borderColor='#667eea'">
          ${gift.imageUrl ? `
            <img src="${gift.imageUrl}" style="width:100%; aspect-ratio:1; object-fit:cover; border-radius:8px; margin-bottom:10px;">
          ` : `
            <div style="
              width:100%;
              aspect-ratio:1;
              background:#16213e;
              border-radius:8px;
              display:flex;
              align-items:center;
              justify-content:center;
              font-size:3rem;
              margin-bottom:10px;
            ">${cat?.emoji || 'ğŸ'}</div>
          `}
          
          <div style="font-size:1.05rem; font-weight:bold; margin-bottom:6px; color:#fff;">
            ${gift.name}
          </div>
          
          <div style="font-size:0.85rem; color:#aaa; margin-bottom:10px; line-height:1.4;">
            ${gift.description.length > 80 ? gift.description.substring(0, 80) + '...' : gift.description}
          </div>
          
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
            <span style="color:#4caf50; font-weight:bold;">$${gift.price.toLocaleString()}</span>
            <span style="color:#888;">x${gift.quantity || 1}</span>
          </div>
          
          <div style="font-size:0.8rem; color:#667eea; margin-bottom:10px;">
            ${cat?.emoji || ''} ${cat?.name || gift.category}
            ${gift.category === 'UNIQUE' ? '<span style="color:gold; margin-left:5px;">â­ UNIQUE</span>' : ''}
          </div>
          
          <button onclick="deleteGiftFromInventory('${gift.id}')" style="
            width:100%;
            padding:8px;
            background:#e94560;
            border:none;
            border-radius:6px;
            color:white;
            cursor:pointer;
            font-size:0.9rem;
          ">
            ğŸ—‘ï¸ Delete
          </button>
        </div>
      `;
    }).join('');
  }
  
  // Delete gift from inventory
  window.deleteGiftFromInventory = function(giftId) {
    if (!confirm('Delete this gift from your inventory?')) return;
    
    gameState.giftInventory.items = gameState.giftInventory.items.filter(g => g.id !== giftId);
    updateGiftInventory();
    showNotification('Gift deleted from inventory', 'info');
  };
  
  // Expose functions globally
  window.updateGiftInventory = updateGiftInventory;
  window.updateGiftStore = updateGiftStore;
  window.showGiftPreview = showGiftPreview;
  window.purchaseGiftFromStore = purchaseGiftFromStore;
  
  // ========== END GIFT SYSTEM UI ==========
  
  // Update content for specific tab
  function updateTabContent(tabName) {
    switch (tabName) {
      case 'dashboard':
        updateDashboard();
        refreshDashboardSections(); // Force initial render of interactive sections
        break;
      case 'business':
        updateBusinessTab();
        break;
      case 'upgrades':
        updateUpgradesTab();
        break;
      case 'people':
        updatePeopleTab();
        break;
      case 'meetings':
        updateMeetingsList();
        break;
      case 'gifts':
        updateGiftsTab();
        break;
      case 'hr':
        updateHRTab();
        break;
      case 'social':
        updateSocialTab();
        break;
      case 'invest':
        updatePrestigeUI();
        renderInfluenceUpgrades();
        break;
      case 'ceocorner':
        // CEO Corner doesn't need updates, just display the chat
        break;
    }
  }
    // Update Dashboard Tab
    function updateDashboard() {
    // ===== TOP STATS CARDS =====
    
    // Cash & Cash/sec
    const dashCash = $('dashCash');
    const dashCashPerSec = $('dashCashPerSec');
    if (dashCash) dashCash.textContent = formatNumber(Math.floor(gameState.cash));
    if (dashCashPerSec) dashCashPerSec.textContent = formatNumber(calculateCashPerSecond());
    
    // Lifetime Earnings & Prestige Level
    const dashLifetimeEarnings = $('dashLifetimeEarnings');
    const dashPrestigeLevel = $('dashPrestigeLevel');
    if (dashLifetimeEarnings) dashLifetimeEarnings.textContent = formatNumber(Math.floor(gameState.lifetimeEarnings || 0));
    if (dashPrestigeLevel) dashPrestigeLevel.textContent = gameState.prestigeLevel || 0;
    
    // Employees & Managers
    const dashEmployeeCount = $('dashEmployeeCount');
    const dashManagerCount = $('dashManagerCount');
    if (dashEmployeeCount) dashEmployeeCount.textContent = gameState.employees.length;
    const managerCount = gameState.products.filter(p => p.managerHired).length;
    if (dashManagerCount) dashManagerCount.textContent = managerCount;
    
    // Products & Running Products
    const dashProductCount = $('dashProductCount');
    const dashRunningProducts = $('dashRunningProducts');
    const unlockedProducts = gameState.products.filter(p => p.unlocked).length;
    const runningProducts = gameState.products.filter(p => p.running || p.managerHired).length;
    if (dashProductCount) dashProductCount.textContent = unlockedProducts;
    if (dashRunningProducts) dashRunningProducts.textContent = runningProducts;
    
    // ===== RECENT MESSAGES ===== 
    // Only rebuild if the container is empty or data has actually changed
    const dashRecentMessages = $('dashRecentMessages');
    if (dashRecentMessages && !dashRecentMessages.dataset.initialized) {
      renderDashboardMessages();
      dashRecentMessages.dataset.initialized = 'true';
    }
    
    // ===== BOSS FIGHTS PROGRESS =====
    const dashBossProgress = $('dashBossProgress');
    if (dashBossProgress) {
      const totalBosses = Object.keys(bossFightConfig || {}).length;
      const defeatedBosses = (gameState.bossFights?.defeated || []).length;
      
      // Only update if values changed
      const currentProgress = dashBossProgress.dataset.progress;
      const newProgress = `${defeatedBosses}/${totalBosses}`;
      if (currentProgress !== newProgress) {
        dashBossProgress.dataset.progress = newProgress;
        
        if (totalBosses === 0) {
          dashBossProgress.innerHTML = '<div style="text-align:center; color:#666; padding:10px; font-style:italic;">No bosses available</div>';
        } else {
          const percentage = Math.floor((defeatedBosses / totalBosses) * 100);
          dashBossProgress.innerHTML = `
            <div style="margin-bottom:15px;">
              <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                <span style="color:#aaa; font-size:0.9rem;">Progress</span>
                <span style="color:#e94560; font-weight:600;">${defeatedBosses}/${totalBosses}</span>
              </div>
              <div style="background:#0f3460; height:12px; border-radius:6px; overflow:hidden;">
                <div style="background:linear-gradient(90deg, #e94560, #ff6b9d); height:100%; width:${percentage}%; transition:width 0.3s;"></div>
              </div>
            </div>
            ${defeatedBosses < totalBosses ? '<div style="color:#aaa; font-size:0.85rem; text-align:center;">ğŸ’ª Keep growing to challenge the next boss!</div>' : '<div style="color:#4ecca3; font-size:0.85rem; text-align:center;">ğŸ‰ All bosses defeated!</div>'}
          `;
        }
      }
    }
    
    // ===== QUICK STATS =====
    const dashLocationCount = $('dashLocationCount');
    const dashTotalLocations = $('dashTotalLocations');
    const dashEfficiency = $('dashEfficiency');
    const dashInfluencePoints = $('dashInfluencePoints');
    const dashIncomeMultiplier = $('dashIncomeMultiplier');
    
    const unlockedLocations = gameState.locations.filter(loc => loc.unlocked).length;
    const totalLocations = gameState.locations.length;
    if (dashLocationCount) dashLocationCount.textContent = unlockedLocations;
    if (dashTotalLocations) dashTotalLocations.textContent = totalLocations;
    
    const totalEff = gameState.employees.reduce((sum, emp) => sum + (emp.stats?.efficiency ?? 0), 0);
    const maxEff = gameState.employees.length * 100;
    const effPct = maxEff > 0 ? Math.max(0, Math.min(100, Math.floor((totalEff / maxEff) * 100))) : 100;
    if (dashEfficiency) dashEfficiency.textContent = effPct;
    
    if (dashInfluencePoints) dashInfluencePoints.textContent = gameState.influencePoints || 0;
    
    const incomeUpgradeLevel = gameState.influenceUpgrades?.incomeMultiplier || 0;
    const multiplier = influenceUpgrades.incomeMultiplier.effect(incomeUpgradeLevel);
    if (dashIncomeMultiplier) dashIncomeMultiplier.textContent = multiplier.toFixed(1);
    
    // ===== SOCIAL MENTIONS =====
    // Only rebuild if not initialized
    const dashSocialMentions = $('dashSocialMentions');
    if (dashSocialMentions && !dashSocialMentions.dataset.initialized) {
      renderDashboardMentions();
      dashSocialMentions.dataset.initialized = 'true';
    }
    
    // ===== AI QUALITY TRAINING STATS =====
    const stats = gameState.aiQuality?.stats || {};
    const totalVotes = stats.totalVotes || 0;
    const upvotes = stats.upvotes || 0;
    const downvotes = stats.downvotes || 0;
    const postsVoted = stats.postsVoted || 0;
    const commentsVoted = stats.commentsVoted || 0;
    const chatsVoted = stats.chatsVoted || 0;
    
    // Update total votes
    const dashTotalVotes = $('dashTotalVotes');
    if (dashTotalVotes) dashTotalVotes.textContent = totalVotes;
    
    // Update quality score (upvote percentage)
    const dashQualityScore = $('dashQualityScore');
    if (dashQualityScore) {
      if (totalVotes === 0) {
        dashQualityScore.textContent = '--%';
        dashQualityScore.style.color = '#aaa';
      } else {
        const qualityPercent = Math.round((upvotes / totalVotes) * 100);
        dashQualityScore.textContent = qualityPercent + '%';
        // Color based on quality: red < 40%, yellow 40-60%, green > 60%
        if (qualityPercent < 40) dashQualityScore.style.color = '#ff6b6b';
        else if (qualityPercent < 60) dashQualityScore.style.color = '#ffd700';
        else dashQualityScore.style.color = '#4ecca3';
      }
    }
    
    // Update upvotes/downvotes
    const dashUpvotes = $('dashUpvotes');
    const dashDownvotes = $('dashDownvotes');
    if (dashUpvotes) dashUpvotes.textContent = upvotes;
    if (dashDownvotes) dashDownvotes.textContent = downvotes;
    
    // Update content type breakdown
    const dashPostsVoted = $('dashPostsVoted');
    const dashCommentsVoted = $('dashCommentsVoted');
    const dashChatsVoted = $('dashChatsVoted');
    if (dashPostsVoted) dashPostsVoted.textContent = postsVoted;
    if (dashCommentsVoted) dashCommentsVoted.textContent = commentsVoted;
    if (dashChatsVoted) dashChatsVoted.textContent = chatsVoted;
    
    // ===== TOP PERFORMERS =====
    // Only rebuild if not initialized
    const dashTopPerformers = $('dashTopPerformers');
    if (dashTopPerformers && !dashTopPerformers.dataset.initialized) {
      renderDashboardTopPerformers();
      dashTopPerformers.dataset.initialized = 'true';
    }
    
    // ===== COMPANY NEWS =====
    updateNewsFeed();
    }

  // Separate render functions that only run once or on demand
  function renderDashboardMessages() {
    const dashRecentMessages = $('dashRecentMessages');
    if (!dashRecentMessages) return;
    
    // Get all chat histories and find unread messages
    const recentMessages = [];
    gameState.employees.forEach(emp => {
      const history = gameState.chatHistory[emp.id] || [];
      // Use the employee's unreadMessages counter instead of filtering history
      const unreadCount = emp.unreadMessages || 0;
      if (history.length > 0) {
        const lastMessage = history[history.length - 1];
        recentMessages.push({
          employee: emp,
          message: lastMessage,
          unreadCount: unreadCount,
          timestamp: lastMessage.timestamp || Date.now()
        });
      }
    });
    
    // Sort by timestamp (most recent first)
    recentMessages.sort((a, b) => b.timestamp - a.timestamp);
    
    if (recentMessages.length === 0) {
      dashRecentMessages.innerHTML = '<div style="text-align:center; color:#666; padding:20px; font-style:italic;">No messages yet. Start chatting with employees!</div>';
    } else {
      dashRecentMessages.innerHTML = recentMessages.slice(0, 5).map(item => {
        const timeAgo = getTimeAgo(item.timestamp);
        const preview = item.message.content.substring(0, 80) + (item.message.content.length > 80 ? '...' : '');
        const unreadBadge = item.unreadCount > 0 ? `<span style="background:#e94560; color:white; padding:2px 8px; border-radius:10px; font-size:0.75rem; font-weight:600;">${item.unreadCount}</span>` : '';
        
        return `
          <div onclick="openChat('${item.employee.id}')" style="background:#0f3460; padding:12px; border-radius:8px; margin-bottom:10px; cursor:pointer; transition:all 0.2s;" onmouseenter="this.style.background='#16213e'" onmouseleave="this.style.background='#0f3460'">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
              <div style="font-weight:600; color:#00d4ff;">${item.employee.name}</div>
              <div style="display:flex; align-items:center; gap:8px;">
                ${unreadBadge}
                <div style="font-size:0.75rem; color:#666;">${timeAgo}</div>
              </div>
            </div>
            <div style="color:#aaa; font-size:0.85rem;">${preview}</div>
          </div>
        `;
      }).join('');
    }
  }
  
  function renderDashboardMentions() {
    const dashSocialMentions = $('dashSocialMentions');
    if (!dashSocialMentions) return;
    
    const allPosts = gameState.socialFeed || [];
    const mentions = allPosts.filter(post => 
      post.content && post.content.toLowerCase().includes('@theboss')
    ).sort((a, b) => b.timestamp - a.timestamp);
    
    if (mentions.length === 0) {
      dashSocialMentions.innerHTML = '<div style="text-align:center; color:#666; padding:20px; font-style:italic;">No mentions yet. Engage with employees!</div>';
    } else {
      dashSocialMentions.innerHTML = mentions.slice(0, 3).map(post => {
        const author = gameState.employees.find(e => e.id === post.authorId);
        if (!author) return '';
        
        const timeAgo = getTimeAgo(post.timestamp);
        const content = post.content.substring(0, 100) + (post.content.length > 100 ? '...' : '');
        
        return `
          <div onclick="switchTab('social')" style="background:#0f3460; padding:12px; border-radius:8px; margin-bottom:10px; cursor:pointer; transition:all 0.2s;" onmouseenter="this.style.background='#16213e'" onmouseleave="this.style.background='#0f3460'">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
              <div style="font-weight:600; color:#ff6b9d;">${author.name}</div>
              <div style="font-size:0.75rem; color:#666;">${timeAgo}</div>
            </div>
            <div style="color:#aaa; font-size:0.85rem;">${content}</div>
            <div style="color:#e94560; font-size:0.75rem; margin-top:5px;">ğŸ’• ${post.likes?.length || 0} likes â€¢ ğŸ’¬ ${post.comments?.length || 0} comments</div>
          </div>
        `;
      }).filter(html => html).join('');
    }
  }
  
  function renderDashboardTopPerformers() {
    const dashTopPerformers = $('dashTopPerformers');
    if (!dashTopPerformers) return;
    
    if (gameState.employees.length === 0) {
      dashTopPerformers.innerHTML = '<div style="text-align:center; color:#666; padding:20px; font-style:italic;">No employees yet</div>';
    } else {
      // Sort employees by a combination of stats
      const scoredEmployees = gameState.employees.map(emp => ({
        employee: emp,
        score: (emp.stats?.productivity || 0) + (emp.stats?.efficiency || 0) + (emp.stats?.affection || 0) * 0.5
      })).sort((a, b) => b.score - a.score);
      
      dashTopPerformers.innerHTML = scoredEmployees.slice(0, 3).map((item, index) => {
        const emp = item.employee;
        const medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'];
        const medal = medals[index] || 'ğŸ…';
        
        return `
          <div onclick="showEmployeeProfile('${emp.id}')" style="background:#0f3460; padding:12px; border-radius:8px; margin-bottom:8px; cursor:pointer; transition:all 0.2s;" onmouseenter="this.style.background='#16213e'" onmouseleave="this.style.background='#0f3460'">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <div style="display:flex; align-items:center; gap:10px;">
                <div style="font-size:1.5rem;">${medal}</div>
                <div>
                  <div style="font-weight:600;">${getColoredName(emp)}</div>
                  <div style="color:#666; font-size:0.8rem;">${emp.position || 'Employee'}</div>
                </div>
              </div>
              <div style="text-align:right;">
                <div style="color:#ffd700; font-weight:600; font-size:0.9rem;">${Math.floor(item.score)} pts</div>
                <div style="color:#666; font-size:0.75rem;">Productivity: ${Math.floor(emp.stats?.productivity || 0)}%</div>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }
  }
  
  // Function to refresh dashboard sections on demand (call when data changes)
  function refreshDashboardSections() {
    const dashRecentMessages = $('dashRecentMessages');
    const dashSocialMentions = $('dashSocialMentions');
    const dashTopPerformers = $('dashTopPerformers');
    
    if (dashRecentMessages) {
      dashRecentMessages.dataset.initialized = '';
      renderDashboardMessages();
      dashRecentMessages.dataset.initialized = 'true';
    }
    
    if (dashSocialMentions) {
      dashSocialMentions.dataset.initialized = '';
      renderDashboardMentions();
      dashSocialMentions.dataset.initialized = 'true';
    }
    
    if (dashTopPerformers) {
      dashTopPerformers.dataset.initialized = '';
      renderDashboardTopPerformers();
      dashTopPerformers.dataset.initialized = 'true';
    }
  }

  
  // Helper function to format time ago
  function getTimeAgo(timestamp) {
    // CRITICAL FIX: Use in-game time for social posts, not real-world time
    const now = gameState.time?.currentTime || Date.now();
    const diff = now - timestamp;
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (days > 0) return `${days}d ago`;
    if (hours > 0) return `${hours}h ago`;
    if (minutes > 0) return `${minutes}m ago`;
    return 'Just now';
  }

  
  // Update Business Tab
  function updateBusinessTab() {
    // Update location subtabs
    const locationSubtabs = $('locationSubtabs');
    if (locationSubtabs) {
      locationSubtabs.innerHTML = '';
      
      gameState.locations.forEach((location, index) => {
        const canUnlock = checkLocationUnlockable(location.id);
        const isLocked = !location.unlocked;
        const isActive = gameState.activeLocationId === location.id;
        const canAfford = gameState.cash >= location.cost;
        const prevLoc = index > 0 ? gameState.locations[index - 1] : null;
        const prevUnlocked = !prevLoc || prevLoc.unlocked;
        const hasPrestigeReq = location.requiresPrestiges && gameState.prestigeLevel < location.requiresPrestiges;
        
        const subtab = document.createElement('button');
        subtab.className = 'location-subtab';
        subtab.dataset.locationId = location.id;
        
        if (isLocked) {
          if (hasPrestigeReq) {
            // Requires prestige
            subtab.style.cssText = 'padding:10px 16px; background:#1a1a2e; border:none; border-bottom:3px solid transparent; color:#666; cursor:not-allowed; white-space:nowrap; opacity:0.5;';
            subtab.innerHTML = `ï¿½ï¸ ${location.name}<br><span style="font-size:0.8em;">Requires ${location.requiresPrestiges} Prestige</span>`;
            subtab.disabled = true;
          } else if (!prevUnlocked) {
            // Previous location not unlocked
            subtab.style.cssText = 'padding:10px 16px; background:#1a1a2e; border:none; border-bottom:3px solid transparent; color:#666; cursor:not-allowed; white-space:nowrap; opacity:0.5;';
            subtab.innerHTML = `ğŸ”’ ${location.name}`;
            subtab.disabled = true;
          } else if (canAfford) {
            // Can unlock now - check if it requires boss fight (all locations except garage)
            if (index > 0) {
              // Check if boss already defeated - if so, should already be unlocked
              // This is a safety check - normally defeated bosses have unlocked locations
              const boss = bossFightConfig[location.id];
              const alreadyDefeated = boss && gameState.bossFights.defeated.includes(boss.id);
              
              if (alreadyDefeated) {
                // Boss defeated but location not unlocked (shouldn't happen, but handle it)
                subtab.style.cssText = 'padding:10px 16px; background:#0f3460; border:none; border-bottom:3px solid #e94560; color:#4caf50; cursor:pointer; white-space:nowrap; font-weight:bold; animation: pulse 2s infinite;';
                subtab.innerHTML = `ğŸ”“ ${location.name}<br><span style="font-size:0.8em;">Claim Victory</span>`;
                subtab.onclick = () => unlockLocation(location.id);
              } else {
                // Boss fight required
                const bossCheck = checkBossFightRequirements(location.id);
                subtab.style.cssText = 'padding:10px 16px; background:#0f3460; border:none; border-bottom:3px solid #e94560; color:#ff6b9d; cursor:pointer; white-space:nowrap; font-weight:bold; animation: pulse 2s infinite;';
                if (bossCheck.reasons.length > 0) {
                  // Show warning about recommendations
                  subtab.innerHTML = `âš”ï¸ ${location.name}<br><span style="font-size:0.7em; color:#ffaa00;">${bossCheck.reasons[0]}</span>`;
                } else {
                  // Ready to fight
                  subtab.innerHTML = `âš”ï¸ ${location.name}<br><span style="font-size:0.8em;">Boss Fight!</span>`;
                }
                subtab.onclick = () => {
                  if (bossCheck.reasons.length > 0) {
                    // Show warning before starting
                    if (confirm(`Warning: This boss may be difficult!\n\n${bossCheck.reasons.join('\n')}\n\nAttempt anyway?`)) {
                      startBossFight(location.id);
                    }
                  } else {
                    startBossFight(location.id);
                  }
                };
              }
            } else {
              // First location (garage) - direct unlock
              subtab.style.cssText = 'padding:10px 16px; background:#0f3460; border:none; border-bottom:3px solid #e94560; color:#4caf50; cursor:pointer; white-space:nowrap; font-weight:bold; animation: pulse 2s infinite;';
              subtab.innerHTML = `ğŸ”“ ${location.name}<br><span style="font-size:0.8em;">Unlock: ${formatNumber(location.cost)}</span>`;
              subtab.onclick = () => unlockLocation(location.id);
            }
          } else {
            // Can't afford yet
            subtab.style.cssText = 'padding:10px 16px; background:#1a1a2e; border:none; border-bottom:3px solid transparent; color:#888; cursor:not-allowed; white-space:nowrap; opacity:0.7;';
            subtab.innerHTML = `ğŸ”’ ${location.name}<br><span style="font-size:0.8em;">Need: ${formatNumber(location.cost)}</span>`;
            subtab.disabled = true;
          }
        } else {
          // Unlocked - show NSFW level indicator if applicable
          const nsfwIndicator = location.nsfwLevel ? 'ğŸ”'.repeat(location.nsfwLevel) : '';
          subtab.style.cssText = `padding:10px 16px; background:${isActive ? '#0f3460' : 'transparent'}; border:none; border-bottom:3px solid ${isActive ? '#e94560' : 'transparent'}; color:${isActive ? '#e94560' : 'white'}; cursor:pointer; white-space:nowrap; font-weight:${isActive ? 'bold' : 'normal'}; transition:all 0.2s;`;
          subtab.innerHTML = `${location.name}${nsfwIndicator ? ' ' + nsfwIndicator : ''}`;
          subtab.onclick = () => {
            gameState.activeLocationId = location.id;
            applyLocationTheme(location);
            updateBusinessTab();
          };
          
          // Hover effect for unlocked tabs
          subtab.addEventListener('mouseenter', () => {
            if (!isActive) {
              subtab.style.borderBottomColor = '#e94560';
              subtab.style.color = '#e94560';
            }
          });
          subtab.addEventListener('mouseleave', () => {
            if (!isActive) {
              subtab.style.borderBottomColor = 'transparent';
              subtab.style.color = 'white';
            }
          });
        }
        
        locationSubtabs.appendChild(subtab);
      });
    }
    
    // Update location info banner
    const locationInfo = document.getElementById('locationInfo');
    if (locationInfo) {
      const activeLocation = gameState.locations.find(loc => loc.id === gameState.activeLocationId);
      if (activeLocation && activeLocation.unlocked && activeLocation.theme) {
        const nsfwWarning = activeLocation.nsfwLevel ? `<span style="color:#ff6b6b; font-weight:bold;">âš ï¸ NSFW Level ${activeLocation.nsfwLevel}</span> â€¢ ` : '';
        locationInfo.style.display = 'block';
        locationInfo.innerHTML = `
          <div style="display:flex; align-items:center; gap:15px;">
            <div style="font-size:2rem;">${activeLocation.name.split(' ')[0]}</div>
            <div style="flex:1;">
              <div style="font-size:1.1rem; font-weight:bold; margin-bottom:5px;">${activeLocation.name}</div>
              <div style="color:#aaa; font-size:0.9rem;">${nsfwWarning}${activeLocation.theme.description}</div>
            </div>
          </div>
        `;
      } else {
        locationInfo.style.display = 'none';
      }
    }
    
    // Update products (only show products from active location)
    updateProductsList();
  }
  
  // Check if a location can be unlocked
  function checkLocationUnlockable(locationId) {
    const location = gameState.locations.find(loc => loc.id === locationId);
    if (!location) return false;
    
    // Already unlocked
    if (location.unlocked) return false;
    
    // Check cash requirement
    if (gameState.cash < location.cost) return false;
    
    // Check prestige requirement
    if (location.requiresPrestiges && gameState.prestigeLevel < location.requiresPrestiges) {
      return false;
    }
    
    // First location is always unlockable (but should start unlocked anyway)
    const locationIndex = gameState.locations.findIndex(loc => loc.id === locationId);
    if (locationIndex === 0) return true;
    
    // Check if previous location is unlocked
    if (locationIndex > 0) {
      const prevLocation = gameState.locations[locationIndex - 1];
      if (!prevLocation.unlocked) return false;
    }
    
    return true;
  }
  
  // Unlock a location
  function unlockLocation(locationId) {
    const location = gameState.locations.find(loc => loc.id === locationId);
    if (!location || location.unlocked) return;
    
    if (!checkLocationUnlockable(locationId)) {
      showNotification('Cannot unlock this location yet!', 'error');
      return;
    }
    
    if (gameState.cash < location.cost) {
      showNotification('Not enough cash to unlock this location!', 'error');
      return;
    }
    
    // Deduct cost and unlock
    gameState.cash -= location.cost;
    location.unlocked = true;
    location.owned = true;
    
    // Unlock the first product in this location automatically
    const firstProduct = gameState.products.find(p => p.locationId === locationId && p.unlockCost === 0);
    if (firstProduct) {
      firstProduct.unlocked = true;
    }
    
    // Switch to newly unlocked location
    gameState.activeLocationId = locationId;
    
    // Apply location theme
    applyLocationTheme(location);
    
    showNotification(`${location.name} unlocked!`, 'success');
    updateUI();
    saveGame();
  }
  
  // Apply visual theme when switching locations
  function applyLocationTheme(location) {
    if (!location || !location.theme) return;
    
    const body = document.body;
    const theme = location.theme;
    
    // Apply background gradient
    if (theme.background) {
      body.style.background = theme.background;
    }
    
    // Store current theme for other UI elements to reference
    gameState.currentTheme = theme;
    
    // Update any dynamic UI elements based on theme
    // This can be expanded later with particle effects, etc.
  }
  
  // Update products list (renders cards only; click handling is delegated elsewhere)
  function updateProductsList() {
    if (!productsList) return;
    
    // Clear cache when re-rendering products
    clearUpgradeButtonCache();
    
    productsList.innerHTML = '';
    
    // Only show products from the active location
    const activeLocation = gameState.locations.find(loc => loc.id === gameState.activeLocationId);
    if (!activeLocation || !activeLocation.unlocked) {
      productsList.innerHTML = '<p style="color:#aaa; text-align:center; padding:40px;">Select an unlocked location to view products.</p>';
      return;
    }
    
    const visibleProducts = gameState.products.filter(p => p.locationId === gameState.activeLocationId);
    
    if (visibleProducts.length === 0) {
      productsList.innerHTML = '<p style="color:#aaa; text-align:center; padding:40px;">No products available in this location.</p>';
      return;
    }
    
    visibleProducts.forEach(p => {
      const card = document.createElement('div');
      card.className = 'product-card';
      card.style.cssText = 'background:#16213e; border-radius:10px; padding:15px; box-shadow:0 4px 10px rgba(0,0,0,0.2);';

      // Check if product is unlocked
      if (!p.unlocked) {
        // Calculate what the actual earnings will be with current multipliers
        const actualEarnings = currentValue(p);
        
        // Apply product discount from influence upgrades to unlock cost
        const productDiscountLevel = gameState.influenceUpgrades?.productDiscount || 0;
        const discountMultiplier = influenceUpgrades.productDiscount.effect(productDiscountLevel);
        const discountedUnlockCost = Math.floor(p.unlockCost * discountMultiplier);
        
        // Calculate discount percentage for display
        const discountPercent = Math.round((1 - discountMultiplier) * 100);
        const hasDiscount = discountPercent > 0;
        
        // Render locked product card
        card.innerHTML = `
          <h3 style="margin:0 0 6px 0;">${p.name}</h3>
          <p style="margin:0; color:#aaa;">ğŸ”’ Locked</p>
          <p style="margin:6px 0 8px 0; font-size:.9rem; color:#888;">
            Unlock this product to start earning $${formatNumber(actualEarnings)} per unit.
          </p>
          <div style="margin-top:12px;">
            <button class="unlock-product-btn" data-id="${p.id}" style="width:100%; padding:12px; background:#0f3460; border:none; border-radius:6px; color:#fff; cursor:pointer; font-weight:bold;">
              ğŸ”“ Unlock ${hasDiscount ? `<span style="color:#4ecca3;">$${formatNumber(discountedUnlockCost)}</span> <span style="color:#888; text-decoration:line-through; font-size:0.85rem;">$${formatNumber(p.unlockCost)}</span> <span style="color:#ffd700; font-size:0.85rem;">(-${discountPercent}%)</span>` : `($${formatNumber(p.unlockCost)})`}
            </button>
          </div>
        `;
        productsList.appendChild(card);
        return;
      }

      // Calculate bulk upgrade cost
      const multiplier = gameState.upgradeMultiplier;
      const MAX_LEVEL = 999;
      const isMaxLevel = p.level >= MAX_LEVEL;
      let upgradeCost, upgradeCount, upgradeText;
      
      if (isMaxLevel) {
        // At max level
        upgradeCost = 0;
        upgradeCount = 0;
        upgradeText = `MAX LEVEL (${MAX_LEVEL})`;
      } else if (multiplier === 'max') {
        // Calculate max affordable upgrades (but cap at MAX_LEVEL)
        const result = calculateMaxAffordableUpgrades(p, gameState.cash);
        upgradeCost = result.totalCost;
        upgradeCount = Math.min(result.count, MAX_LEVEL - p.level);
        upgradeText = `Upgrade x${upgradeCount} (${formatNumber(upgradeCost)})`;
      } else if (multiplier === 1) {
        upgradeCost = p.upgradeCost;
        upgradeCount = 1;
        upgradeText = `Upgrade (${formatNumber(upgradeCost)})`;
      } else {
        upgradeCost = calculateBulkUpgradeCost(p, Math.min(multiplier, MAX_LEVEL - p.level));
        upgradeCount = Math.min(multiplier, MAX_LEVEL - p.level);
        upgradeText = `Upgrade x${upgradeCount} (${formatNumber(upgradeCost)})`;
      }

      // Render unlocked product card
      const cycleTime = currentCycleTimeMs(p);
      const isConstantStream = cycleTime < 1000 && p.managerHired;
      const pct = p.running ? Math.min(100, (1 - (p.timeRemainingMs / cycleTime)) * 100) : 0;
      const onboarding = !!p.managerOnboarding;
      
      // Manager button logic
      let managerCta, managerDisabledAttr, managerCursor, managerOpacity, managerBgColor;
      
      // Check if manager actually exists (in employees OR onboarding)
      const managerExists = p.managerId && (
        gameState.employees.find(e => e.id === p.managerId) ||
        (gameState.onboarding && gameState.onboarding.find(e => e.id === p.managerId))
      );
      
      // If marked as hired but manager doesn't exist, fix the state
      if (p.managerHired && !managerExists) {
        p.managerHired = false;
        p.managerId = null;
        p.managerLevel = 0;
        p.managerOnboarding = false;
      }
      
      if (isConstantStream) {
        // Constant stream - lock position upgrades
        managerCta = 'ğŸ”’ Optimized (Constant)';
        managerDisabledAttr = 'disabled';
        managerCursor = 'not-allowed';
        managerOpacity = '0.6';
        managerBgColor = '#2a2a2a';
      } else if (onboarding) {
        managerCta = 'Onboarding in Progress';
        managerDisabledAttr = 'disabled';
        managerCursor = 'not-allowed';
        managerOpacity = '0.7';
        managerBgColor = '#533483';
      } else if (p.managerHired) {
        managerCta = `Upgrade Position ($${formatNumber(p.managerUpgradeCost)})`;
        managerDisabledAttr = '';
        managerCursor = 'pointer';
        managerOpacity = '1';
        managerBgColor = '#533483';
      } else {
        managerCta = `Hire Staff ($${formatNumber(p.managerHireCost)})`;
        managerDisabledAttr = '';
        managerCursor = 'pointer';
        managerOpacity = '1';
        managerBgColor = '#533483';
      }
      
      // Value display - show per second for constant streams
      const currentVal = currentValue(p);
      const valueDisplay = isConstantStream 
        ? `$<span id="val-${p.id}">${formatNumber(currentVal / (cycleTime / 1000))}</span> / sec`
        : `$<span id="val-${p.id}">${formatNumber(currentVal)}</span> / unit`;

      card.innerHTML = `
        <h3 style="margin:0 0 6px 0;">${p.name}${isConstantStream ? ' âš¡' : ''}</h3>
        <p style="margin:0; color:#aaa;">${valueDisplay}</p>
        <p style="margin:6px 0 8px 0; font-size:.9rem;">
          Cycle: <span id="cyc-${p.id}">${(cycleTime/1000).toFixed(1)}</span>s â€¢ Level ${p.level}${isMaxLevel ? ' ğŸ†' : ''}
        </p>

        <div style="width:100%; background:#0f3460; height:8px; border-radius:4px; margin:8px 0 12px 0;">
          <div id="prog-${p.id}" style="width:${pct}%; background:#e94560; height:100%; border-radius:4px;"></div>
        </div>

        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          ${!isConstantStream ? `
            <button class="sell-btn" data-id="${p.id}" style="flex:1; padding:10px; background:#e94560; border:none; border-radius:6px; color:#fff; cursor:pointer;">
              <span id="selltxt-${p.id}">${p.running ? 'Click: -1s' : 'Sell'}</span>
            </button>
          ` : `
            <div style="flex:1; padding:10px; background:#1a4d2e; border:none; border-radius:6px; color:#4caf50; text-align:center; font-weight:bold;">
              âš¡ Constant Stream
            </div>
          `}
          <button class="upgrade-product-btn" data-id="${p.id}" data-count="${upgradeCount}" data-cost="${upgradeCost}" ${isMaxLevel ? 'disabled' : ''} style="padding:10px; background:${isMaxLevel ? '#333' : '#0f3460'}; border:none; border-radius:6px; color:${isMaxLevel ? '#888' : '#fff'}; cursor:${isMaxLevel ? 'not-allowed' : 'pointer'}; opacity:${isMaxLevel ? '0.7' : '1'};">
            ${upgradeText}
          </button>
          <button class="manager-btn" data-id="${p.id}" ${managerDisabledAttr} style="padding:10px; background:${managerBgColor}; border:none; border-radius:6px; color:#fff; cursor:${managerCursor}; opacity:${managerOpacity};">
            ${managerCta}
          </button>
        </div>

        ${p.managerHired ? (() => {
          const manager = gameState.employees.find(e => e.id === p.managerId);
          
          // If manager not found, show error state
          if (!manager) {
            return `<p style="margin:10px 0 0 0; color:#e94560; font-size:0.9rem;">âš ï¸ Staff assignment lost - click "Hire Staff" to reassign</p>`;
          }
          
          const managerName = manager.name;
          const managerLevel = p.managerLevel || 1;
          
          // Calculate manager bonuses for display
          const bonuses = getManagerialBonuses(p);
          const hasManagerBonuses = bonuses.managerChain && bonuses.managerChain.length > 0;
          
          let bonusDisplay = '';
          if (hasManagerBonuses) {
            const speedBonus = ((bonuses.speedMultiplier - 1) * 100).toFixed(0);
            const incomeBonus = ((bonuses.incomeMultiplier - 1) * 100).toFixed(0);
            bonusDisplay = `<div style="margin-top:4px; font-size:0.8rem; color:#ffd700;">
              ğŸ“Š Manager Bonuses: +${speedBonus}% speed, +${incomeBonus}% income
              <br/><span style="font-size:0.75rem; color:#aaa;">${bonuses.managerChain.map(m => m.title).join(' â†’ ')}</span>
            </div>`;
          }
          
          return `<p style="margin:10px 0 0 0; color:${isConstantStream ? '#4caf50' : (onboarding ? '#ffa726' : '#4caf50')};">${isConstantStream ? `âš¡ Staffed by ${managerName} - Operating at peak efficiency` : (onboarding ? `â³ ${managerName} onboardingâ€¦ (auto running)` : `âœ“ Staffed by ${managerName} (Lv.${managerLevel})`)}</p>${bonusDisplay}`;
        })() : `<p style="margin:10px 0 0 0; color:#e94560; font-size:0.9rem;">âš ï¸ No staff assigned - automation disabled</p>`}
      `;
      
      // IMPORTANT: Clear the constant stream flag so updateProductProgressBars() will re-apply the animation
      delete p._wasConstantStream;

      productsList.appendChild(card);
    });
  }

  // Cache for upgrade button elements to avoid repeated querySelector calls
  let upgradeButtonCache = new Map();
  
  function updateProductProgressBars() {
    for (const p of gameState.products) {
      // Skip locked products as they don't have progress bars
      if (!p.unlocked) continue;
      
      const bar = $(`prog-${p.id}`);
      const sellTx = $(`selltxt-${p.id}`);
      const valEl = $(`val-${p.id}`);
      const cycEl = $(`cyc-${p.id}`);
      if (!bar) continue;

      const cycleTime = currentCycleTimeMs(p);
      const isConstantStream = cycleTime < 1000 && p.managerHired; // Sub-1-second with manager
      
      // Only update if state changed (prevent unnecessary DOM updates)
      const wasConstantStream = p._wasConstantStream || false;
      
      if (isConstantStream !== wasConstantStream) {
        p._wasConstantStream = isConstantStream;
        
        if (isConstantStream) {
          // Replace progress bar with "Constant Stream" animation
          bar.style.width = '100%';
          bar.style.background = 'linear-gradient(90deg, #4caf50, #00d4ff, #4caf50)';
          bar.style.backgroundSize = '200% 100%';
          bar.style.animation = 'constantStream 1.5s linear infinite';
          
          // Mark as optimized - update display once
          if (valEl) {
            const earningsPerSec = currentValue(p) / (cycleTime / 1000);
            valEl.textContent = formatNumber(earningsPerSec);
          }
          if (cycEl) cycEl.textContent = 'âš¡ Constant';
        } else {
          // Normal progress bar - reset styles
          bar.style.background = '#e94560';
          bar.style.backgroundSize = '100% 100%';
          bar.style.animation = 'none';
          bar.style.width = '0%'; // Reset width for normal animation
        }
      }
      
      // For constant streams, ensure animation persists (fix for broken bars)
      if (isConstantStream) {
        // Re-apply animation if it was somehow removed
        if (!bar.style.animation || bar.style.animation === 'none' || bar.style.animation === '') {
          bar.style.width = '100%';
          bar.style.background = 'linear-gradient(90deg, #4caf50, #00d4ff, #4caf50)';
          bar.style.backgroundSize = '200% 100%';
          bar.style.animation = 'constantStream 1.5s linear infinite';
        }
        // Skip progress bar, sell text, and frequent value updates
        // Only update upgrade buttons on the throttled schedule
      } else {
        // Normal product - update progress bar and values
        const pct = p.running ? Math.min(100, (1 - (p.timeRemainingMs / cycleTime)) * 100) : 0;
        bar.style.width = `${pct}%`;
        
        if (sellTx) sellTx.textContent = p.running ? 'Click: -1s' : 'Sell';
        if (valEl) valEl.textContent = formatNumber(currentValue(p));
        if (cycEl) {
          const cycleText = (cycleTime/1000).toFixed(1);
          if (cycEl.textContent !== cycleText) {
            cycEl.textContent = cycleText;
          }
        }
      }
      
      // Update upgrade button cost and count in real-time (throttled)
      // Only update every 10 ticks (~1 second) to reduce DOM manipulation
      if (!p._upgradeTickCount) p._upgradeTickCount = 0;
      p._upgradeTickCount++;
      
      if (p._upgradeTickCount >= 10) {
        p._upgradeTickCount = 0;
        
        // Get cached button or query once
        let upgradeBtn = upgradeButtonCache.get(p.id);
        if (!upgradeBtn || !document.contains(upgradeBtn)) {
          upgradeBtn = document.querySelector(`.upgrade-product-btn[data-id="${p.id}"]`);
          if (upgradeBtn) {
            upgradeButtonCache.set(p.id, upgradeBtn);
          }
        }
        
        if (upgradeBtn) {
          const multiplier = gameState.upgradeMultiplier;
          const MAX_LEVEL = 999;
          const isMaxLevel = p.level >= MAX_LEVEL;
          let upgradeCost, upgradeCount, upgradeText;
          
          if (isMaxLevel) {
            upgradeCount = 0;
            upgradeCost = 0;
            upgradeText = `MAX LEVEL (${MAX_LEVEL})`;
          } else if (multiplier === 'max') {
            const result = calculateMaxAffordableUpgrades(p, gameState.cash);
            upgradeCount = Math.min(result.count, MAX_LEVEL - p.level);
            upgradeCost = result.totalCost;
            upgradeText = `Upgrade x${upgradeCount} (${formatNumber(upgradeCost)})`;
          } else if (multiplier === 1) {
            upgradeCount = 1;
            upgradeCost = p.upgradeCost;
            upgradeText = `Upgrade (${formatNumber(upgradeCost)})`;
          } else {
            upgradeCount = Math.min(multiplier, MAX_LEVEL - p.level);
            upgradeCost = calculateBulkUpgradeCost(p, upgradeCount);
            upgradeText = `Upgrade x${upgradeCount} (${formatNumber(upgradeCost)})`;
          }
          
          // Only update if changed
          if (upgradeBtn.textContent !== upgradeText) {
            upgradeBtn.textContent = upgradeText;
          }
          upgradeBtn.dataset.count = upgradeCount;
          upgradeBtn.dataset.cost = upgradeCost;
          
          // Update button state (enabled/disabled) based on affordability
          const shouldBeDisabled = isMaxLevel || gameState.cash < upgradeCost || upgradeCount === 0;
          if (upgradeBtn.disabled !== shouldBeDisabled) {
            upgradeBtn.disabled = shouldBeDisabled;
            
            if (isMaxLevel) {
              upgradeBtn.style.opacity = '0.7';
              upgradeBtn.style.cursor = 'not-allowed';
              upgradeBtn.style.background = '#333';
              upgradeBtn.style.color = '#888';
            } else if (!shouldBeDisabled) {
              upgradeBtn.style.opacity = '1';
              upgradeBtn.style.cursor = 'pointer';
              upgradeBtn.style.background = '#0f3460';
              upgradeBtn.style.color = '#fff';
            } else {
              upgradeBtn.style.opacity = '0.5';
              upgradeBtn.style.cursor = 'not-allowed';
            }
          }
        }
      }
    }
  }
  
  // Clear upgrade button cache when products list is re-rendered
  function clearUpgradeButtonCache() {
    upgradeButtonCache.clear();
  }
  
  // Initialize people sorting settings if not exists
  if (!gameState.peopleSorting) {
    gameState.peopleSorting = {
      sortBy: 'recentMessages',
      showFavoritesOnly: false
    };
  }

  // Toggle favorite/star on employee
  function toggleEmployeeFavorite(employeeId) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (employee) {
      employee.isFavorite = !employee.isFavorite;
      updatePeopleTab();
      saveGame();
    }
  }

  // Calculate average relationship strength for an employee
  /**
   * Calculate the overall relationship score between the player and an employee.
   * This averages the 5 core stats (affection, comfort, trust, desire, obedience)
   * and optionally factors in the intimacy level.
   * @param {Object} employee - The employee object
   * @returns {number} Average relationship score (0-100)
   */
  function calculateAverageRelationship(employee) {
    if (!employee.stats) {
      return 0;
    }
    
    // Get the 5 core relationship stats
    const affection = employee.stats.affection || 0;
    const comfort = employee.stats.comfort || 0;
    const trust = employee.stats.trust || 0;
    const desire = employee.stats.desire || 0;
    const obedience = employee.stats.obedience || 0;
    
    // Calculate the average of the 5 core stats
    const coreAverage = (affection + comfort + trust + desire + obedience) / 5;
    
    // Optionally include intimacy level as a bonus factor (stored in memory)
    // Intimacy is already calculated from these stats, so we give it less weight
    const intimacyLevel = employee.memory?.intimacyLevel || 0;
    
    // Final score: 80% core stats average, 20% intimacy level
    // This gives slight bonus to employees with established intimate relationships
    const finalScore = (coreAverage * 0.8) + (intimacyLevel * 0.2);
    
    return finalScore;
  }

  // ========== CORPORATE HIERARCHY & PROMOTION SYSTEM ==========
  
  /**
   * Get promotion requirements for a given level
   * @param {number} level - Target promotion level (2-7)
   * @param {object} employee - Employee object (optional, for fast-track calculation)
   * @returns {object} Requirements object or null
   */
  function getPromotionRequirements(level, employee = null) {
    const baseRequirements = {
      2: { minProductivity: 60, minManagement: 1 },                  // Staff â†’ Local Manager
      3: { minProductivity: 70, minManagement: 2 },                  // Local Manager â†’ Regional Manager
      4: { minProductivity: 75, minManagement: 4 },                  // Regional Manager â†’ Branch Manager
      5: { minProductivity: 80, minManagement: 6 },                  // Branch Manager â†’ CFO/COO
      6: { minProductivity: 85, minManagement: 8 },                  // CFO/COO â†’ Senior Executive
      7: { minProductivity: 90, minManagement: 10 }                  // Senior Executive â†’ CEO
    };
    
    return baseRequirements[level] || null;
  }

  /**
   * Check if employee can be promoted to next level
   * @param {object} employee - Employee object
   * @returns {boolean} True if eligible for promotion
   */
  function canPromote(employee) {
    if (!employee || !employee.career) return false;
    
    const currentLevel = employee.career.level;
    const nextLevel = currentLevel + 1;
    
    // Cap at Executive level
    if (nextLevel > 7) return false;
    
    const requirements = getPromotionRequirements(nextLevel, employee);
    if (!requirements) return false;
    
    // Check productivity requirement
    if ((employee.stats.productivity || 0) < requirements.minProductivity) return false;
    
    // Check management skill requirement (if applicable)
    if (requirements.minManagement) {
      const managementLevel = employee.skills?.management?.level || 0;
      if (managementLevel < requirements.minManagement) return false;
    }
    
    return true;
  }

  /**
   * Promote employee to next level
   * @param {object} employee - Employee object
   * @returns {boolean} True if promotion successful
   */
  function promoteEmployee(employee) {
    if (!canPromote(employee)) return false;
    
    const oldLevel = employee.career.level;
    const newLevel = oldLevel + 1;
    const levelData = gameState.hierarchyLevels[newLevel];
    
    if (!levelData) return false;
    
    // Update career data
    employee.career.level = newLevel;
    employee.career.title = levelData.title;
    employee.career.salary = levelData.baseSalary;
    const previousStartDate = employee.career.startDate;
    employee.career.startDate = Date.now();
    
    // Track history
    employee.career.promotionHistory.push({
      date: Date.now(),
      fromLevel: oldLevel,
      toLevel: newLevel,
      timeInRole: (Date.now() - previousStartDate) / (1000 * 60 * 60 * 24), // days
      reason: "Performance milestone reached"
    });
    
    // Update hierarchy tracking
    updateCorporateHierarchy();
    
    // Generate social post about promotion
    generatePromotionPost(employee, newLevel);
    
    // Update UI
    updatePeopleTab();
    
    // Show notification
    showNotification(`ğŸ‰ ${employee.name} promoted to ${employee.career.title}!`, 'success');
    
    console.log(`[Promotion] ${employee.name} promoted from Level ${oldLevel} to Level ${newLevel} (${levelData.title})`);
    
    return true;
  }

  /**
   * Check all employees for promotion eligibility and auto-promote
   * Should be called periodically (e.g., every game tick or time update)
   */
  function checkForPromotions() {
    if (!gameState.employees || gameState.employees.length === 0) return;
    
    let promotionCount = 0;
    
    gameState.employees.forEach(employee => {
      if (employee.employmentStatus !== 'active') return;
      if (!employee.career) return;
      
      if (canPromote(employee)) {
        if (promoteEmployee(employee)) {
          promotionCount++;
        }
      }
    });
    
    if (promotionCount > 0) {
      console.log(`[Promotion] Auto-promoted ${promotionCount} employee(s)`);
    }
  }

  /**
   * Check if an employee can be promoted (has eligible positions available)
   * @param {object} employee - Employee object
   * @returns {boolean} True if employee has positions they can be promoted to
   */
  function canPromoteEmployee(employee) {
    if (!employee || employee.employmentStatus !== 'active') return false;
    if (!employee.career) return false;
    
    // Get current position
    const currentPosition = getEmployeePosition(employee.id);
    if (!currentPosition) return false;
    
    // Check if there are any positions they can fill at a higher level
    const currentLevel = currentPosition.level;
    
    // Check levels above current (up to level 6, since 7 is CEO)
    for (let level = Math.floor(currentLevel) + 1; level <= 6; level++) {
      const positions = gameState.corporatePyramid.positions[level];
      if (!positions) continue;
      
      for (const position of positions) {
        const check = canFillPosition(employee, position);
        if (check.canFill) {
          return true; // Found at least one eligible position
        }
      }
    }
    
    // Check secretary position if they're level 1-3 and not already secretary
    if (currentPosition.positionId !== 'secretary' && employee.career.level >= 1 && employee.career.level <= 3) {
      const secretaryPos = gameState.corporatePyramid.secretaryPosition;
      if (secretaryPos && !secretaryPos.employeeId) {
        return true;
      }
    }
    
    return false;
  }

  /**
   * Start the promotion flow for an employee
   * Closes the employee modal and opens the pyramid with eligible positions highlighted
   * @param {string} employeeId - Employee ID
   */
  function startPromotionFlow(employeeId) {
    // Close the employee profile modal
    if (typeof ModalManager !== 'undefined' && ModalManager.close) {
      ModalManager.close('profileModal');
    }
    
    // Wait a moment for the modal to close, then open pyramid
    setTimeout(() => {
      openCorporatePyramidModal(employeeId);
    }, 150);
  }

  // Make functions available globally
  window.canPromoteEmployee = canPromoteEmployee;
  window.startPromotionFlow = startPromotionFlow;

  // ========== PRODUCTIVITY IMPROVEMENT SYSTEMS ==========
  
  /**
   * Training Workshop System
   * Costs money to conduct, boosts productivity for all attendees
   */
  function conductTrainingWorkshop() {
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    if (activeEmployees.length === 0) {
      showNotification('No active employees to train!', 'error');
      return;
    }
    
    // Cost scales with number of employees
    const costPerEmployee = 500;
    const totalCost = activeEmployees.length * costPerEmployee;
    
    if (gameState.cash < totalCost) {
      showNotification(`Not enough cash! Training costs $${formatNumber(totalCost)} ($${formatNumber(costPerEmployee)} per employee)`, 'error');
      return;
    }
    
    // Deduct cost
    gameState.cash -= totalCost;
    
    // Apply productivity boost to all active employees
    // BATCH OPERATION - Process all employees before triggering any UI updates
    let boostedCount = 0;
    activeEmployees.forEach(emp => {
      if (!emp.stats) emp.stats = {};
      const oldProductivity = emp.stats.productivity || 50;
      
      // +5 to +10 productivity boost (random within range)
      const boost = 5 + Math.floor(Math.random() * 6);
      emp.stats.productivity = Math.min(100, oldProductivity + boost);
      
      // Also give some management skill XP
      gainSkillXP(emp, 'management', 20, 'training_workshop');
      
      boostedCount++;
    });
    
    // Track when last workshop was held
    if (!gameState.productivitySystems) gameState.productivitySystems = {};
    gameState.productivitySystems.lastWorkshop = Date.now();
    
    showNotification(`ğŸ“ Training Workshop completed! ${boostedCount} employees gained +5-10 productivity!`, 'success');
    logCompanyEvent({
      type: 'training',
      description: `Company-wide training workshop conducted`,
      sentiment: 'positive',
      importance: 6
    });
    
    // Flush any pending debounced saves, then do final save
    flushPendingSave();
    saveGame(false); // Pass false to suppress "game saved" notification
    updatePeopleTab();
    updateUI();
  }
  
  /**
   * Performance Review System
   * Review individual employee, provide focused feedback
   */
  function conductPerformanceReview(employeeId) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee || employee.employmentStatus !== 'active') {
      showNotification('Employee not found or inactive!', 'error');
      return;
    }
    
    // Check cooldown (can't review same employee within 7 days)
    if (!gameState.productivitySystems) gameState.productivitySystems = {};
    if (!gameState.productivitySystems.reviewCooldowns) gameState.productivitySystems.reviewCooldowns = {};
    
    const lastReview = gameState.productivitySystems.reviewCooldowns[employeeId] || 0;
    const daysSinceReview = (Date.now() - lastReview) / (1000 * 60 * 60 * 24);
    
    if (daysSinceReview < 7) {
      const daysRemaining = Math.ceil(7 - daysSinceReview);
      showNotification(`${employee.name} was recently reviewed. Wait ${daysRemaining} more day(s).`, 'error');
      return;
    }
    
    // Cost for one-on-one review
    const reviewCost = 200;
    if (gameState.cash < reviewCost) {
      showNotification(`Not enough cash! Performance review costs $${formatNumber(reviewCost)}`, 'error');
      return;
    }
    
    gameState.cash -= reviewCost;
    
    // Apply boost based on current performance
    if (!employee.stats) employee.stats = {};
    const oldProductivity = employee.stats.productivity || 50;
    
    let boost;
    let message;
    
    if (oldProductivity < 50) {
      // Low performers get big boost
      boost = 15 + Math.floor(Math.random() * 6); // +15-20
      message = `${employee.name} appreciated the feedback and showed significant improvement!`;
    } else if (oldProductivity < 75) {
      // Average performers get medium boost
      boost = 10 + Math.floor(Math.random() * 6); // +10-15
      message = `${employee.name} took the feedback well and improved their productivity!`;
    } else {
      // High performers get small boost
      boost = 5 + Math.floor(Math.random() * 6); // +5-10
      message = `${employee.name} is already performing well, but found ways to optimize further!`;
    }
    
    employee.stats.productivity = Math.min(100, oldProductivity + boost);
    
    // Also boost affection slightly (positive interaction)
    if (employee.stats.affection !== undefined) {
      employee.stats.affection = Math.min(100, (employee.stats.affection || 50) + 5);
    }
    
    // Set cooldown
    gameState.productivitySystems.reviewCooldowns[employeeId] = Date.now();
    
    showNotification(`ğŸ“Š ${message} (+${boost} productivity)`, 'success');
    
    // Track in employee history
    if (!employee.career) employee.career = {};
    if (!employee.career.reviewHistory) employee.career.reviewHistory = [];
    employee.career.reviewHistory.push({
      date: Date.now(),
      productivityBefore: oldProductivity,
      productivityAfter: employee.stats.productivity,
      boost: boost
    });
    
    saveGame();
    updatePeopleTab();
    updateUI();
  }
  
  /**
   * Team Building Activity
   * Costs money, boosts productivity + morale for all employees
   */
  function conductTeamBuilding() {
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    if (activeEmployees.length === 0) {
      showNotification('No active employees for team building!', 'error');
      return;
    }
    
    // Check cooldown (can't do team building too often)
    if (!gameState.productivitySystems) gameState.productivitySystems = {};
    const lastTeamBuilding = gameState.productivitySystems.lastTeamBuilding || 0;
    const daysSince = (Date.now() - lastTeamBuilding) / (1000 * 60 * 60 * 24);
    
    if (daysSince < 14) {
      const daysRemaining = Math.ceil(14 - daysSince);
      showNotification(`Team building activities need time to be effective. Wait ${daysRemaining} more day(s).`, 'error');
      return;
    }
    
    // Cost scales with employees but is more expensive than training
    const costPerEmployee = 800;
    const totalCost = activeEmployees.length * costPerEmployee;
    
    if (gameState.cash < totalCost) {
      showNotification(`Not enough cash! Team building costs $${formatNumber(totalCost)} ($${formatNumber(costPerEmployee)} per employee)`, 'error');
      return;
    }
    
    gameState.cash -= totalCost;
    
    // Apply benefits
    let boostedCount = 0;
    activeEmployees.forEach(emp => {
      if (!emp.stats) emp.stats = {};
      
      // Moderate productivity boost
      const oldProductivity = emp.stats.productivity || 50;
      const productivityBoost = 3 + Math.floor(Math.random() * 5); // +3-7
      emp.stats.productivity = Math.min(100, oldProductivity + productivityBoost);
      
      // Significant morale boosts
      if (emp.stats.affection !== undefined) {
        emp.stats.affection = Math.min(100, (emp.stats.affection || 50) + 8);
      }
      if (emp.stats.comfort !== undefined) {
        emp.stats.comfort = Math.min(100, (emp.stats.comfort || 50) + 8);
      }
      
      // Social skill boost
      gainSkillXP(emp, 'social', 30, 'team_building');
      
      boostedCount++;
    });
    
    gameState.productivitySystems.lastTeamBuilding = Date.now();
    
    showNotification(`ğŸ‰ Team Building Activity completed! ${boostedCount} employees bonded and improved! (+3-7 productivity, +8 morale)`, 'success');
    
    logCompanyEvent({
      type: 'team_building',
      description: `Company team building event held`,
      sentiment: 'positive',
      importance: 7
    });
    
    // Flush any pending debounced saves, then do final save
    flushPendingSave();
    saveGame(false);
    updatePeopleTab();
    updateUI();
  }

  /**
   * Update corporate hierarchy tracking
   * Organizes employees by level
   */
  function updateCorporateHierarchy() {
    // Reset levels
    Object.keys(gameState.corporateHierarchy.levels).forEach(level => {
      gameState.corporateHierarchy.levels[level] = [];
    });
    
    // Organize employees by level
    gameState.employees.forEach(employee => {
      if (employee.employmentStatus !== 'active') return;
      if (!employee.career) return;
      
      const level = employee.career.level;
      if (gameState.corporateHierarchy.levels[level]) {
        gameState.corporateHierarchy.levels[level].push(employee.id);
      }
    });
  }

  // ========== CORPORATE PYRAMID MANAGEMENT (HIERARCHICAL ORG CHART) ==========
  
  /**
   * Initialize hierarchical pyramid structure
   * Creates positions dynamically as locations/products unlock
   */
  function initializeHierarchicalPyramid() {
    // Ensure corporatePyramid structure exists
    if (!gameState.corporatePyramid) {
      console.error('[Pyramid] corporatePyramid not found in gameState!');
      return;
    }
    
    // Initialize secretary position if it doesn't exist
    if (!gameState.corporatePyramid.secretaryPosition) {
      gameState.corporatePyramid.secretaryPosition = {
        positionId: 'secretary',
        title: 'Executive Secretary',
        level: 6.5,
        employeeId: null,
        reportsTo: 'ceo',
        subordinates: []
      };
    }
    
    // Migrate old structure to new hierarchical structure if needed
    if (!gameState.corporatePyramid.positions || typeof gameState.corporatePyramid.positions !== 'object') {
      console.log('[Pyramid] Migrating to hierarchical structure...');
      gameState.corporatePyramid.positions = {
        6: [{
          positionId: 'senior_exec',
          title: 'Senior Executive',
          level: 6,
          employeeId: null,
          reportsTo: 'ceo',
          subordinates: [],
          span: 2
        }],
        5: [
          {
            positionId: 'cfo',
            title: 'Chief Financial Officer',
            level: 5,
            employeeId: null,
            reportsTo: 'senior_exec',
            subordinates: [],
            span: 2
          },
          {
            positionId: 'coo',
            title: 'Chief Operating Officer',
            level: 5,
            employeeId: null,
            reportsTo: 'senior_exec',
            subordinates: [],
            span: 2
          }
        ],
        4: [
          { positionId: 'branch_mgr_1', title: 'Branch Manager 1', level: 4, employeeId: null, reportsTo: 'cfo', subordinates: [], locationsManaged: [], span: 3 },
          { positionId: 'branch_mgr_2', title: 'Branch Manager 2', level: 4, employeeId: null, reportsTo: 'cfo', subordinates: [], locationsManaged: [], span: 3 },
          { positionId: 'branch_mgr_3', title: 'Branch Manager 3', level: 4, employeeId: null, reportsTo: 'coo', subordinates: [], locationsManaged: [], span: 2 },
          { positionId: 'branch_mgr_4', title: 'Branch Manager 4', level: 4, employeeId: null, reportsTo: 'coo', subordinates: [], locationsManaged: [], span: 1 }
        ],
        3: [],
        2: [],
        1: []
      };
      
      // Migrate promotion costs if they're using old structure
      if (!gameState.corporatePyramid.promotionCosts) {
        gameState.corporatePyramid.promotionCosts = {
          1: 500,
          2: 2000,
          3: 10000,
          4: 50000,
          5: 150000,
          6: 500000,
          7: 0
        };
      }
    }
    
    // Ensure each level is an array
    for (let i = 1; i <= 6; i++) {
      if (!Array.isArray(gameState.corporatePyramid.positions[i])) {
        gameState.corporatePyramid.positions[i] = [];
      }
    }
    
    // Count unlocked locations
    const unlockedLocations = gameState.locations.filter(l => l.unlocked);
    const locationCount = unlockedLocations.length;
    
    // Level 3: Regional Managers (1 per location)
    unlockedLocations.forEach((location, index) => {
      const existingPos = gameState.corporatePyramid.positions[3].find(p => p.locationId === location.id);
      if (!existingPos) {
        // Determine which branch manager this reports to
        const branchManagerIndex = Math.floor(index / 2.25); // Distribute among 4 branch managers
        const branchMgrId = `branch_mgr_${Math.min(branchManagerIndex + 1, 4)}`;
        
        gameState.corporatePyramid.positions[3].push({
          positionId: `regional_mgr_${location.id}`,
          title: `Regional Manager - ${location.name}`,
          level: 3,
          employeeId: null,
          reportsTo: branchMgrId,
          subordinates: [],
          locationId: location.id,
          span: 3 // Manages 2-3 local managers
        });
      }
    });
    
    // Level 2: Local Managers (2-3 per location, manages 4-6 products each)
    unlockedLocations.forEach(location => {
      const products = gameState.products.filter(p => p.locationId === location.id && p.unlocked);
      const productCount = products.length;
      
      // Determine how many local managers needed (1 per 4-6 products)
      const managersNeeded = Math.max(1, Math.ceil(productCount / 5));
      
      for (let i = 0; i < managersNeeded; i++) {
        const existingPos = gameState.corporatePyramid.positions[2].find(
          p => p.locationId === location.id && p.managerId === i
        );
        
        if (!existingPos) {
          gameState.corporatePyramid.positions[2].push({
            positionId: `local_mgr_${location.id}_${i}`,
            title: `Local Manager ${i + 1} - ${location.name}`,
            level: 2,
            employeeId: null,
            reportsTo: `regional_mgr_${location.id}`,
            subordinates: [],
            locationId: location.id,
            managerId: i,
            span: 5 // Manages ~5 staff
          });
        }
      }
    });
    
    // Level 1: Staff (1 per product)
    unlockedLocations.forEach(location => {
      const products = gameState.products.filter(p => p.locationId === location.id && p.unlocked);
      
      products.forEach((product, index) => {
        const existingPos = gameState.corporatePyramid.positions[1].find(
          p => p.productId === product.id
        );
        
        if (!existingPos) {
          // Assign to local manager based on index
          const localManagers = gameState.corporatePyramid.positions[2].filter(p => p.locationId === location.id);
          const managerIndex = Math.floor(index / 5) % localManagers.length;
          const assignedManager = localManagers[managerIndex];
          
          gameState.corporatePyramid.positions[1].push({
            positionId: `staff_${product.id}`,
            title: `${product.name} Staff`,
            level: 1,
            employeeId: null,
            reportsTo: assignedManager ? assignedManager.positionId : null,
            locationId: location.id,
            productId: product.id
          });
        }
      });
    });
    
    console.log(`[Pyramid] Initialized: ${gameState.corporatePyramid.positions[1].length} Staff, ${gameState.corporatePyramid.positions[2].length} Local Managers, ${gameState.corporatePyramid.positions[3].length} Regional Managers`);
  }
  
  /**
   * Get position by ID (searches all levels)
   * @param {string} positionId - Position ID
   * @returns {object|null} Position object
   */
  function getPosition(positionId) {
    if (positionId === 'ceo') return gameState.corporatePyramid.ceo;
    if (positionId === 'secretary') return gameState.corporatePyramid.secretaryPosition;
    
    // Search through all levels
    for (let level = 1; level <= 6; level++) {
      const positions = gameState.corporatePyramid.positions[level];
      if (Array.isArray(positions)) {
        const position = positions.find(p => p.positionId === positionId);
        if (position) return position;
      }
    }
    
    return null;
  }
  
  /**
   * Get employee's current position in hierarchy
   * @param {string} employeeId - Employee ID
   * @returns {object|null} Position object
   */
  function getEmployeePosition(employeeId) {
    // Check secretary position first
    if (gameState.corporatePyramid.secretaryPosition?.employeeId === employeeId) {
      return gameState.corporatePyramid.secretaryPosition;
    }
    
    for (let level = 1; level <= 6; level++) {
      const positions = gameState.corporatePyramid.positions[level];
      if (Array.isArray(positions)) {
        const position = positions.find(p => p.employeeId === employeeId);
        if (position) return position;
      }
    }
    return null;
  }
  
  /**
   * Get all subordinates of a position (direct reports)
   * @param {string} positionId - Position ID
   * @returns {array} Array of employee objects who report to this position
   */
  function getSubordinates(positionId) {
    const subordinates = [];
    
    for (let level = 1; level <= 6; level++) {
      const positions = gameState.corporatePyramid.positions[level];
      if (Array.isArray(positions)) {
        positions.forEach(pos => {
          if (pos.reportsTo === positionId && pos.employeeId) {
            const employee = gameState.employees.find(e => e.id === pos.employeeId);
            if (employee) {
              subordinates.push({ employee, position: pos });
            }
          }
        });
      }
    }
    
    return subordinates;
  }
  
  /**
   * Check if employee meets position requirements
   * @param {object} employee - Employee object
   * @param {object} position - Position object
   * @returns {object} { canFill: boolean, reason: string }
   */
  function canFillPosition(employee, position) {
    console.log(`\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
    console.log(`[PROMOTION CHECK] Evaluating ${employee.name} for ${position.title}`);
    console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
    
    if (!employee || !position) {
      console.log(`âŒ FAILED: Invalid employee or position`);
      console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`);
      return { canFill: false, reason: 'Invalid employee or position' };
    }
    
    // CRITICAL: Check if position is already occupied by someone else
    if (position.employeeId && position.employeeId !== employee.id) {
      const occupant = gameState.employees.find(e => e.id === position.employeeId);
      const occupantName = occupant ? occupant.name : 'someone';
      console.log(`âŒ FAILED: Position already occupied by ${occupantName}`);
      console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`);
      return { canFill: false, reason: `Position already occupied by ${occupantName}` };
    }
    
    if (!employee.career) {
      console.log(`âŒ FAILED: Employee has no career data`);
      console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`);
      return { canFill: false, reason: 'Employee has no career data' };
    }
    
    console.log(`ğŸ“Š Employee Stats:`);
    console.log(`   â€¢ Current Level: ${employee.career.level} (${employee.career.title})`);
    console.log(`   â€¢ Productivity: ${Math.round(employee.stats.productivity)}%`);
    console.log(`   â€¢ Management Skill: Lv.${employee.skills?.management?.level || 0}`);
    console.log(`   â€¢ Other Skills:`, {
      technical: employee.skills?.technical?.level || 0,
      social: employee.skills?.social?.level || 0,
      creativity: employee.skills?.creativity?.level || 0
    });
    
    console.log(`\nğŸ¯ Position Requirements:`);
    console.log(`   â€¢ Position: ${position.title}`);
    console.log(`   â€¢ Required Level: ${position.level}`);
    
    // Special handling for secretary position
    if (position.positionId === 'secretary') {
      console.log(`   â€¢ Type: Secretary (special - Level 1-3 employees only)`);
      
      if (employee.career.level >= 1 && employee.career.level <= 3) {
        console.log(`\nâœ… SUCCESS: Meets all requirements!`);
        console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`);
        return { canFill: true, reason: 'Meets all requirements' };
      }
      
      const reason = employee.career.level > 3 ? 'Too senior for this role' : 'Requires Level 1 minimum';
      console.log(`\nâŒ FAILED: ${reason}`);
      console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`);
      return { canFill: false, reason };
    }
    
    // Check level requirement (use Math.floor to handle decimal levels)
    const requiredLevel = Math.floor(position.level);
    const minimumLevel = requiredLevel - 1; // To get Level 2, you need to be at least Level 1
    console.log(`   â€¢ Position Level: ${requiredLevel}`);
    console.log(`   â€¢ Minimum Employee Level Required: ${minimumLevel}`);
    
    if (employee.career.level < minimumLevel) {
      const levelInfo = gameState.hierarchyLevels[minimumLevel] || gameState.hierarchyLevels[1] || { title: 'Staff', color: '#4ecca3', icon: 'ğŸ‘¤' };
      const reason = `Requires at least Level ${minimumLevel}${levelInfo ? ' (' + levelInfo.title + ')' : ''}`;
      console.log(`\nâŒ FAILED: ${reason}`);
      console.log(`   Employee is Level ${employee.career.level}, needs to be at least Level ${minimumLevel}`);
      console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`);
      return { canFill: false, reason };
    }
    
    console.log(`   âœ“ Level requirement met (${employee.career.level} >= ${minimumLevel})`);
    
    // Check promotion requirements (productivity and management skill level)
    if (requiredLevel >= 2) {
      const requirements = getPromotionRequirements(requiredLevel, employee);
      console.log(`\nğŸ“‹ Checking Promotion Requirements for Level ${requiredLevel}:`);
      
      if (requirements) {
        console.log(`   â€¢ Required Productivity: ${requirements.minProductivity}%`);
        console.log(`   â€¢ Required Management: Lv.${requirements.minManagement || 0}`);
        
        // Check productivity requirement
        if (requirements.minProductivity && employee.stats.productivity < requirements.minProductivity) {
          const reason = `Requires ${requirements.minProductivity}% productivity (currently ${Math.round(employee.stats.productivity)}%)`;
          console.log(`\nâŒ FAILED: ${reason}`);
          console.log(`   Need ${requirements.minProductivity - Math.round(employee.stats.productivity)}% more productivity`);
          console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`);
          return { canFill: false, reason };
        }
        console.log(`   âœ“ Productivity requirement met (${Math.round(employee.stats.productivity)}% >= ${requirements.minProductivity}%)`);
        
        // Check management skill level requirement
        if (requirements.minManagement) {
          const managementLevel = employee.skills?.management?.level || 0;
          if (managementLevel < requirements.minManagement) {
            const reason = `Requires Management Lv.${requirements.minManagement} (currently Lv.${managementLevel})`;
            console.log(`\nâŒ FAILED: ${reason}`);
            console.log(`   Need ${requirements.minManagement - managementLevel} more management level(s)`);
            console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`);
            return { canFill: false, reason };
          }
          console.log(`   âœ“ Management requirement met (Lv.${managementLevel} >= Lv.${requirements.minManagement})`);
        }
      }
    }
    
    console.log(`\nâœ… SUCCESS: All requirements met!`);
    console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`);
    return { canFill: true, reason: 'Meets all requirements' };
  }
  
  /**
   * Calculate cost to relocate employee to position
   * @param {object} employee - Employee object
   * @param {object} position - Position object
   * @returns {number} Cost in cash
   */
  function calculateRelocationCost(employee, position) {
    if (!employee || !position) return 0;
    
    // Special handling for secretary position - low cost for early game
    if (position.positionId === 'secretary') {
      return 1000; // Fixed low cost
    }
    
    // Base cost from position level (promotion cost) - handle decimal levels
    const positionLevel = Math.floor(position.level);
    const baseCost = gameState.corporatePyramid.promotionCosts[positionLevel] || 1000;
    
    // If employee is already assigned somewhere, it's a transfer
    const currentPosition = getEmployeePosition(employee.id);
    if (currentPosition) {
      // If moving to same or lower level, cheaper (lateral/demotion)
      if (position.level <= currentPosition.level) {
        return Math.floor(baseCost * 0.3); // 70% discount for lateral moves
      }
      // Moving up, normal promotion cost
      return baseCost;
    }
    
    // New assignment (first time placement)
    return baseCost;
  }
  
  /**
   * Assign employee to position
   * @param {string} employeeId - Employee ID
   * @param {string} positionId - Position ID
   * @param {boolean} payNow - Whether to deduct cost immediately
   * @returns {object} { success: boolean, message: string, cost: number }
   */
  function assignEmployeeToPosition(employeeId, positionId, payNow = true) {
    console.log(`\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—`);
    console.log(`â•‘  ASSIGNMENT ATTEMPT                    â•‘`);
    console.log(`â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
    
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) {
      console.log(`âŒ Employee not found: ${employeeId}`);
      return { success: false, message: 'Employee not found', cost: 0 };
    }
    
    const position = getPosition(positionId);
    if (!position) {
      console.log(`âŒ Position not found: ${positionId}`);
      return { success: false, message: 'Position not found', cost: 0 };
    }
    
    console.log(`ğŸ‘¤ Employee: ${employee.name}`);
    console.log(`ğŸ“ Target Position: ${position.title} (Level ${position.level})`);
    
    // Check if position is CEO (player only)
    if (position.isPlayer) {
      console.log(`âŒ Cannot assign employee to CEO position (player-only)`);
      return { success: false, message: 'Cannot assign employee to CEO position', cost: 0 };
    }
    
    // FIXED: Get current position once and check if already in target position
    const currentPosition = getEmployeePosition(employee.id);
    if (currentPosition && currentPosition.positionId === positionId) {
      console.log(`âŒ Employee is already in this position: ${position.title}`);
      return { success: false, message: `${employee.name} is already in this position!`, cost: 0 };
    }
    
    // Check requirements
    console.log(`\nğŸ” Running eligibility check...`);
    const check = canFillPosition(employee, position);
    if (!check.canFill) {
      console.log(`âŒ ASSIGNMENT BLOCKED: ${check.reason}`);
      return { success: false, message: check.reason, cost: 0 };
    }
    
    console.log(`âœ… Eligibility check passed!`);
    
    // Calculate cost
    const cost = calculateRelocationCost(employee, position);
    console.log(`ğŸ’° Assignment cost: $${formatNumber(cost)}`);
    console.log(`ğŸ’µ Current cash: $${formatNumber(gameState.cash)}`);
    
    // Check if player can afford it
    if (payNow && gameState.cash < cost) {
      console.log(`âŒ ASSIGNMENT BLOCKED: Insufficient funds (need $${formatNumber(cost - gameState.cash)} more)`);
      return { 
        success: false, 
        message: `Not enough cash! Need $${formatNumber(cost)}`, 
        cost: cost 
      };
    }
    
    // Remove employee from current position (if they have one)
    if (currentPosition) {
      console.log(`\nğŸ“¤ Removing from current position: ${currentPosition.title}`);
      
      // CRITICAL: Clear the employee ID from old position
      currentPosition.employeeId = null;
      currentPosition.isVacant = true;
      
      // Clear product management if they were managing one
      if (currentPosition.productId) {
        const oldProduct = gameState.products.find(p => p.id === currentPosition.productId);
        if (oldProduct && oldProduct.managerHired && oldProduct.managerId === employeeId) {
          oldProduct.managerHired = false;
          oldProduct.managerId = null;
          
          console.log(`   âš ï¸ Product "${oldProduct.name}" now vacant - automation disabled`);
        }
      }
    } else {
      console.log(`\nğŸ“¥ First-time assignment (employee not currently in any position)`);
    }
    
    // Assign to new position
    console.log(`\nğŸ“¥ Assigning to new position: ${position.title}`);
    position.employeeId = employeeId;
    position.isVacant = false;
    
    // Update employee's productManaged if this is a staff position
    if (position.productId) {
      const product = gameState.products.find(p => p.id === position.productId);
      if (product) {
        employee.productManaged = product.name;
        product.managerHired = true;
        product.managerId = employeeId;
        
        console.log(`   âœ“ Now managing product: ${product.name}`);
      }
    } else {
      // Higher-level positions don't manage specific products
      employee.productManaged = null;
      console.log(`   âœ“ Management position (no specific product)`);
    }
    
    // Deduct cost if paying now
    if (payNow) {
      gameState.cash -= cost;
      console.log(`   ğŸ’¸ Deducted $${formatNumber(cost)} from cash`);
      console.log(`   ğŸ’µ Remaining cash: $${formatNumber(gameState.cash)}`);
    }
    
    // Update employee's career level to match position
    const oldLevel = employee.career.level;
    const oldTitle = employee.career.title;
    
    // Special handling for secretary position (level 6.5)
    if (position.positionId === 'secretary' || position.title === 'Executive Secretary') {
      employee.career.level = 6; // Use level 6 for secretary (not 6.5 to avoid array index issues)
      employee.career.title = 'Executive Secretary';
      employee.career.salary = 65000; // Between level 6 and 7
      console.log(`   ğŸ¯ Special: Secretary position (Level 6 equivalent)`);
    } else {
      const positionLevel = Math.floor(position.level); // Handle decimal levels
      
      // CRITICAL FIX: Update career for BOTH promotions AND demotions
      if (employee.career.level !== positionLevel) {
        const levelInfo = gameState.hierarchyLevels[positionLevel] || gameState.hierarchyLevels[1] || { title: 'Staff', color: '#4ecca3', icon: 'ğŸ‘¤', baseSalary: 40000 };
        
        if (levelInfo) {
          const isPromotion = employee.career.level < positionLevel;
          const isDemotion = employee.career.level > positionLevel;
          
          employee.career.level = positionLevel;
          employee.career.title = levelInfo.title;
          employee.career.salary = levelInfo.baseSalary;
          
          if (isPromotion) {
            console.log(`   ğŸ“ˆ Promoted: ${oldTitle} (Lv.${oldLevel}) â†’ ${levelInfo.title} (Lv.${positionLevel})`);
          } else if (isDemotion) {
            console.log(`   ğŸ“‰ Demoted: ${oldTitle} (Lv.${oldLevel}) â†’ ${levelInfo.title} (Lv.${positionLevel})`);
          }
        }
      } else {
        console.log(`   â¡ï¸  Lateral move (Level ${employee.career.level} stays same)`);
      }
    }
    
    console.log(`\nâœ… ASSIGNMENT SUCCESSFUL!`);
    console.log(`â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—`);
    console.log(`â•‘  ${employee.name} â†’ ${position.title}`);
    console.log(`â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`);
    
    return { 
      success: true, 
      message: currentPosition ? 'Employee relocated successfully!' : 'Employee assigned successfully!',
      cost: cost,
      needsRehire: currentPosition && currentPosition.productId ? true : false, // Flag if old position needs refilling
      vacatedPosition: currentPosition || null
    };
  }
  
  /**
   * Remove employee from their position
   * @param {string} employeeId - Employee ID
   * @returns {boolean} Success
   */
  function removeEmployeeFromPosition(employeeId) {
    const position = getEmployeePosition(employeeId);
    if (!position) return false;
    
    position.employeeId = null;
    position.isVacant = true;
    
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (employee) {
      employee.productManaged = null;
    }
    
    return true;
  }

  // ========== CORPORATE PYRAMID MODAL ==========
  
  /**
   * Open the Corporate Pyramid Modal
   * @param {string} selectedEmployeeId - Optional employee ID to pre-select for placement
   */
  function openCorporatePyramidModal(selectedEmployeeId = null) {
    try {
      const modal = document.getElementById('pyramidModal');
      if (!modal) {
        console.error('Pyramid modal element not found!');
        return;
      }
      
      // Defensive: Ensure employees array exists and corporate hierarchy is initialized
      if (!gameState.employees) {
        gameState.employees = [];
      }
      
      if (!gameState.corporateHierarchy) {
        gameState.corporateHierarchy = {
          levels: { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [] },
          executiveRoles: { COO: null, CFO: null }
        };
      }
      
      // Defensive: Ensure hierarchyLevels structure exists
      if (!gameState.hierarchyLevels) {
        gameState.hierarchyLevels = [
          { level: 1, capacity: 1, unlockCost: 0 },
          { level: 2, capacity: 2, unlockCost: 50000 },
          { level: 3, capacity: 3, unlockCost: 200000 },
          { level: 4, capacity: 4, unlockCost: 800000 },
          { level: 5, capacity: 5, unlockCost: 3200000 },
          { level: 6, capacity: 6, unlockCost: 12800000 },
          { level: 7, capacity: 7, unlockCost: 51200000 }
        ];
      }
      
      // Build pyramid structure
      const pyramidHTML = buildPyramidHTML(selectedEmployeeId);
    
    modal.innerHTML = `
      <div style="background:#0f1419; width:95%; max-width:1400px; height:90vh; border-radius:14px; box-shadow:0 8px 32px rgba(0,0,0,0.5); display:flex; flex-direction:column; overflow:hidden;">
        <!-- Header -->
        <div style="padding:20px; border-bottom:2px solid rgba(255,255,255,0.1); display:flex; justify-content:space-between; align-items:center; background:linear-gradient(135deg, #1a1f35 0%, #0f1419 100%);">
          <div>
            <h2 style="margin:0; color:#fff; font-size:1.8rem; display:flex; align-items:center; gap:12px;">
              <span style="font-size:2rem;">ğŸ¢</span>
              Corporate Pyramid
            </h2>
            <p style="margin:4px 0 0 0; color:#888; font-size:0.9rem;">
              ${selectedEmployeeId ? 'Select a position to assign employee' : 'Manage your organizational structure'}
            </p>
          </div>
          <button onclick="closeCorporatePyramidModal()" style="background:transparent; border:none; color:#fff; font-size:2rem; cursor:pointer; padding:8px; line-height:1;">âœ•</button>
        </div>
        
        <!-- Legend & Controls -->
        <div style="padding:12px 20px; background:#16213e; border-bottom:1px solid rgba(255,255,255,0.1); display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:12px;">
          <div style="display:flex; gap:20px; flex-wrap:wrap;">
            <div style="display:flex; align-items:center; gap:6px;">
              <div style="width:12px; height:12px; background:#4ecca3; border-radius:50%;"></div>
              <span style="color:#aaa; font-size:0.85rem;">Filled</span>
            </div>
            <div style="display:flex; align-items:center; gap:6px;">
              <div style="width:12px; height:12px; background:#555; border-radius:50%;"></div>
              <span style="color:#aaa; font-size:0.85rem;">Vacant</span>
            </div>
            <div style="display:flex; align-items:center; gap:6px;">
              <div style="width:12px; height:12px; background:#ffd700; border-radius:50%;"></div>
              <span style="color:#aaa; font-size:0.85rem;">Selected</span>
            </div>
          </div>
          <div style="display:flex; gap:8px;">
            <button onclick="pyramidZoom('in')" style="padding:6px 12px; background:#0f3460; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:1.2rem;">ğŸ”+</button>
            <button onclick="pyramidZoom('out')" style="padding:6px 12px; background:#0f3460; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:1.2rem;">ğŸ”-</button>
            <button onclick="pyramidZoom('reset')" style="padding:6px 12px; background:#0f3460; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:0.85rem;">Reset</button>
          </div>
        </div>
        
        <!-- Pyramid Container (Scrollable) -->
        <div id="pyramidContainer" style="flex:1; overflow:auto; position:relative; background:#0a0e1a; cursor:grab;">
          <div id="pyramidCanvas" style="transform-origin:top left; transition:transform 0.3s ease; padding:40px; min-width:100%; min-height:100%;">
            ${pyramidHTML}
          </div>
        </div>
        
        <!-- Footer with employee selection info -->
        ${selectedEmployeeId ? buildSelectionFooter(selectedEmployeeId) : ''}
      </div>
    `;
    
    // Show the modal
    modal.style.display = 'flex';
    
    // Setup pan functionality
    setupPyramidPanning();
    
    // Setup event listeners for position clicks
    setupPositionClickHandlers(selectedEmployeeId);
    
    // Setup drag-and-drop functionality
    setupDragAndDrop();
    
    // Setup pinch-to-zoom for mobile
    setupPinchZoom();
    
    } catch (error) {
      console.error('Error opening Corporate Pyramid Modal:', error);
      showNotification('Failed to open pyramid. Check console for details.');
    }
  }

  /**
   * Build the hierarchical pyramid HTML structure
   * @param {string} selectedEmployeeId - Employee to highlight valid positions for
   * @returns {string} HTML string
   */
  function buildPyramidHTML(selectedEmployeeId) {
    let html = '';
    
    const selectedEmployee = selectedEmployeeId ? gameState.employees.find(e => e.id === selectedEmployeeId) : null;
    
    // CEO at top (Level 7) with Secretary
    const secretaryPosition = gameState.corporatePyramid.secretaryPosition || {
      positionId: 'secretary',
      title: 'Executive Secretary',
      level: 6.5,
      employeeId: null,
      reportsTo: 'ceo',
      subordinates: []
    };
    
    html += `
      <div style="text-align:center; margin-bottom:40px;">
        <div style="display:inline-flex; align-items:center; justify-content:center; gap:20px;">
          <!-- CEO Position -->
          <div style="display:inline-block; position:relative;">
            <div class="pyramid-position ceo-position" data-position-id="ceo" style="background:linear-gradient(135deg, #ffd700, #ffed4e); padding:24px 50px; border-radius:12px; box-shadow:0 6px 20px rgba(255,215,0,0.5); border:3px solid #ffd700;">
              <div style="font-size:2.5rem; margin-bottom:8px;">ğŸ‘‘</div>
              <div style="font-weight:700; font-size:1.3rem; color:#0f1419;">CEO</div>
              <div style="font-size:0.9rem; color:#333; margin-top:4px;">You</div>
            </div>
          </div>
          
          <!-- Secretary Position -->
          <div style="display:inline-block; position:relative; transform:scale(0.85);">
            ${buildSecretaryTile(secretaryPosition, selectedEmployee)}
          </div>
        </div>
      </div>
    `;
    
    // Level 6: Senior Executive (1 position)
    html += buildLevelSection(6, 'Senior Executive', selectedEmployee);
    
    // Level 5: Officers (CFO, COO - 2 positions)
    html += buildLevelSection(5, 'Officers (CFO, COO)', selectedEmployee);
    
    // Level 4: Branch Managers (4 positions)
    html += buildLevelSection(4, 'Branch Managers', selectedEmployee);
    
    // Level 3: Regional Managers (1 per location)
    html += buildLevelSection(3, 'Regional Managers', selectedEmployee);
    
    // Level 2: Local Managers (2-3 per location)
    html += buildLevelSection(2, 'Local Managers', selectedEmployee);
    
    // Level 1: Staff (1 per product)
    html += buildLevelSection(1, 'Staff', selectedEmployee);
    
    return html;
  }
  
  /**
   * Build HTML for a single hierarchy level
   * @param {number} level - Level number (1-6)
   * @param {string} levelTitle - Display title for this level
   * @param {object} selectedEmployee - Currently selected employee (if any)
   * @returns {string} HTML string
   */
  function buildLevelSection(level, levelTitle, selectedEmployee) {
    const positions = gameState.corporatePyramid.positions[level];
    if (!positions || positions.length === 0) return '';
    
    const levelInfo = gameState.hierarchyLevels[level] || gameState.hierarchyLevels[1] || { title: 'Staff', color: '#4ecca3', icon: 'ğŸ‘¤', baseSalary: 40000 };
    
    let html = `
      <div style="margin-bottom:50px;">
        <h3 style="color:${levelInfo.color}; margin-bottom:20px; text-align:center; font-size:1.2rem; display:flex; align-items:center; justify-content:center; gap:10px;">
          <span style="font-size:1.5rem;">${levelInfo.icon}</span>
          Level ${level}: ${levelTitle}
          <span style="background:rgba(255,255,255,0.1); padding:4px 12px; border-radius:12px; font-size:0.8rem; color:#aaa;">
            ${positions.filter(p => p.employeeId).length} / ${positions.length} filled
          </span>
        </h3>
        <div style="display:flex; flex-wrap:wrap; gap:20px; justify-content:center; max-width:1200px; margin:0 auto;">
    `;
    
    positions.forEach(position => {
      html += buildPositionTile(position, selectedEmployee, levelInfo);
    });
    
    html += `
        </div>
      </div>
    `;
    
    return html;
  }
  
  /**
   * Build HTML for a single position tile
   * @param {object} position - Position object
   * @param {object} selectedEmployee - Selected employee (if any)
   * @param {object} levelInfo - Level configuration
   * @returns {string} HTML string
   */
  function buildPositionTile(position, selectedEmployee, levelInfo) {
    const employee = position.employeeId ? gameState.employees.find(e => e.id === position.employeeId) : null;
    const isVacant = !employee;
    
    // Check if this position is valid for selected employee
    let isValidForSelection = false;
    let selectionReason = '';
    if (selectedEmployee) {
      const check = canFillPosition(selectedEmployee, position);
      isValidForSelection = check.canFill;
      selectionReason = check.reason;
    }
    
    const bgColor = isValidForSelection ? '#ffd700' : (isVacant ? '#16213e' : '#1a4d2e');
    const borderColor = isValidForSelection ? '#ffd700' : (isVacant ? '#555' : levelInfo.color);
    
    // Get subordinate count
    const subordinates = getSubordinates(position.positionId);
    const subordinateCount = subordinates.length;
    
    return `
      <div class="pyramid-position" 
           data-position-id="${position.positionId}"
           data-can-select="${isValidForSelection}"
           data-cost="${selectedEmployee ? (gameState.corporatePyramid.promotionCosts[position.level] || 0) : 0}"
           style="background:${bgColor}; border:2px solid ${borderColor}; border-radius:10px; padding:16px; width:220px; cursor:pointer; transition:all 0.3s ease; box-shadow:0 4px 8px rgba(0,0,0,0.3);"
           onmouseenter="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 16px rgba(0,0,0,0.5)';"
           onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.3)';">
        
        <div style="text-align:center; margin-bottom:12px;">
          <div style="font-size:1.5rem; margin-bottom:4px;">${levelInfo.icon}</div>
          <div style="font-weight:600; font-size:0.85rem; color:#fff;">${position.title}</div>
          ${position.locationId ? `<div style="font-size:0.7rem; color:#888; margin-top:2px;">${gameState.locations.find(l => l.id === position.locationId)?.name || ''}</div>` : ''}
        </div>
        
        ${employee ? `
          <div style="text-align:center; position:relative;">
            ${canPromote(employee) ? `
              <div style="position:absolute; top:-4px; right:calc(50% - 50px); background:linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); color:#000; font-size:0.65rem; font-weight:700; padding:4px 8px; border-radius:12px; box-shadow:0 2px 8px rgba(255,215,0,0.4); z-index:1; animation:pulse 2s infinite;">
                â¬†ï¸ READY
              </div>
            ` : ''}
            <img src="${employee.profileImage || 'https://placehold.co/60x60'}" style="width:60px; height:60px; border-radius:50%; object-fit:cover; border:2px solid ${levelInfo.color}; margin-bottom:8px;">
            <div style="font-size:0.85rem; font-weight:600; color:#fff;">${employee.name}</div>
            <div style="font-size:0.7rem; color:#aaa; margin-top:2px;">${levelInfo.title}</div>
            ${subordinateCount > 0 ? `<div style="font-size:0.65rem; color:#4ecca3; margin-top:4px;">ğŸ‘¥ ${subordinateCount} report${subordinateCount !== 1 ? 's' : ''}</div>` : ''}
          </div>
        ` : `
          <div style="text-align:center; padding:20px 0;">
            <div style="font-size:2rem; opacity:0.3;">ğŸ‘¤</div>
            <div style="font-size:0.75rem; color:#888; margin-top:8px;">Vacant</div>
            ${position.span ? `<div style="font-size:0.65rem; color:#666; margin-top:4px;">Manages ${position.span}</div>` : ''}
          </div>
        `}
        
        ${isValidForSelection ? `
          <div style="margin-top:12px; padding:8px; background:rgba(255,215,0,0.2); border-radius:6px; text-align:center;">
            <div style="font-size:0.7rem; color:#ffd700; font-weight:600;">âœ“ CAN ASSIGN</div>
            <div style="font-size:0.7rem; color:#fff; margin-top:2px;">Cost: $${formatNumber(gameState.corporatePyramid.promotionCosts[position.level] || 0)}</div>
          </div>
        ` : selectedEmployee ? `
          <div style="margin-top:12px; padding:8px; background:rgba(233,69,96,0.2); border-radius:6px; text-align:center;">
            <div style="font-size:0.65rem; color:#e94560;">${selectionReason}</div>
          </div>
        ` : ''}
      </div>
    `;
  }

  /**
   * Build HTML for secretary position tile
   * @param {object} position - Secretary position object
   * @param {object} selectedEmployee - Selected employee (if any)
   * @returns {string} HTML string
   */
  function buildSecretaryTile(position, selectedEmployee) {
    const employee = position.employeeId ? gameState.employees.find(e => e.id === position.employeeId) : null;
    const isVacant = !employee;
    
    // Check if this position is valid for selected employee (Level 1-3 can fill secretary role)
    let isValidForSelection = false;
    let selectionReason = '';
    if (selectedEmployee) {
      if (selectedEmployee.career.level >= 1 && selectedEmployee.career.level <= 3) {
        isValidForSelection = true;
      } else if (selectedEmployee.career.level > 3) {
        selectionReason = 'Too senior for this role';
      }
    }
    
    const bgColor = isValidForSelection ? '#ffd700' : (isVacant ? '#16213e' : '#d946ef');
    const borderColor = isValidForSelection ? '#ffd700' : (isVacant ? '#555' : '#e879f9');
    const secretaryCost = 1000; // Low cost for early game
    
    return `
      <div class="pyramid-position secretary-position" 
           data-position-id="${position.positionId}"
           data-can-select="${isValidForSelection}"
           data-cost="${selectedEmployee ? secretaryCost : 0}"
           style="background:${bgColor}; border:2px solid ${borderColor}; border-radius:10px; padding:14px; width:180px; cursor:pointer; transition:all 0.3s ease; box-shadow:0 4px 8px rgba(0,0,0,0.3);"
           onmouseenter="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 16px rgba(0,0,0,0.5)';"
           onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.3)';">
        
        <div style="text-align:center; margin-bottom:10px;">
          <div style="font-size:1.3rem; margin-bottom:4px;">ğŸ“‹</div>
          <div style="font-weight:600; font-size:0.8rem; color:#fff;">${position.title}</div>
          <div style="font-size:0.65rem; color:#888; margin-top:2px;">Reports to CEO</div>
        </div>
        
        ${employee ? `
          <div style="text-align:center; position:relative;">
            <img src="${employee.profileImage || 'https://placehold.co/50x50'}" style="width:50px; height:50px; border-radius:50%; object-fit:cover; border:2px solid #e879f9; margin-bottom:6px;">
            <div style="font-size:0.8rem; font-weight:600; color:#fff;">${employee.name}</div>
            <div style="font-size:0.65rem; color:#aaa; margin-top:2px;">Level ${employee.career?.level || 1}</div>
          </div>
        ` : `
          <div style="text-align:center; padding:15px 0;">
            <div style="font-size:1.5rem; opacity:0.3;">ğŸ‘¤</div>
            <div style="font-size:0.7rem; color:#888; margin-top:6px;">Vacant</div>
            <div style="font-size:0.6rem; color:#666; margin-top:2px;">Early-game position</div>
          </div>
        `}
        
        ${isValidForSelection ? `
          <div style="margin-top:10px; padding:6px; background:rgba(255,215,0,0.2); border-radius:6px; text-align:center;">
            <div style="font-size:0.65rem; color:#ffd700; font-weight:600;">âœ“ CAN ASSIGN</div>
            <div style="font-size:0.65rem; color:#fff; margin-top:2px;">Cost: $${formatNumber(secretaryCost)}</div>
          </div>
        ` : selectedEmployee ? `
          <div style="margin-top:10px; padding:6px; background:rgba(233,69,96,0.2); border-radius:6px; text-align:center;">
            <div style="font-size:0.6rem; color:#e94560;">${selectionReason}</div>
          </div>
        ` : ''}
      </div>
    `;
  }

  /**
   * Build footer for employee selection mode
   * @param {string} employeeId - Selected employee ID
   * @returns {string} HTML string
   */
  function buildSelectionFooter(employeeId) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return '';
    
    const levelInfo = gameState.hierarchyLevels[employee.career?.level] || gameState.hierarchyLevels[1] || { title: 'Staff', color: '#4ecca3' };
    
    return `
      <div style="padding:16px 20px; background:#1a1f35; border-top:2px solid rgba(255,255,255,0.1); display:flex; justify-content:space-between; align-items:center;">
        <div style="display:flex; align-items:center; gap:12px;">
          <img src="${employee.profileImage || 'https://placehold.co/50x50'}" style="width:50px; height:50px; border-radius:50%; object-fit:cover; border:2px solid ${levelInfo.color};">
          <div>
            <div style="font-weight:600; color:#fff; font-size:1rem;">${employee.name}</div>
            <div style="font-size:0.85rem; color:#aaa;">${levelInfo.title} â€¢ Level ${employee.career?.level || 1}</div>
          </div>
        </div>
        <button onclick="closeCorporatePyramidModal()" style="padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:#fff; cursor:pointer; font-weight:600;">
          Cancel
        </button>
      </div>
    `;
  }

  /**
   * Setup panning functionality for the pyramid
   */
  function setupPyramidPanning() {
    const container = document.getElementById('pyramidContainer');
    if (!container) return;
    
    let isPanning = false;
    let startX = 0, startY = 0;
    let scrollLeft = 0, scrollTop = 0;
    
    container.addEventListener('mousedown', (e) => {
      // Don't pan if clicking on a position tile or dragging
      if (e.target.closest('.pyramid-position') || e.target.draggable) return;
      
      isPanning = true;
      container.style.cursor = 'grabbing';
      startX = e.pageX - container.offsetLeft;
      startY = e.pageY - container.offsetTop;
      scrollLeft = container.scrollLeft;
      scrollTop = container.scrollTop;
    });
    
    container.addEventListener('mouseleave', () => {
      isPanning = false;
      container.style.cursor = 'grab';
    });
    
    container.addEventListener('mouseup', () => {
      isPanning = false;
      container.style.cursor = 'grab';
    });
    
    container.addEventListener('mousemove', (e) => {
      if (!isPanning) return;
      e.preventDefault();
      const x = e.pageX - container.offsetLeft;
      const y = e.pageY - container.offsetTop;
      const walkX = (x - startX) * 1.5;
      const walkY = (y - startY) * 1.5;
      container.scrollLeft = scrollLeft - walkX;
      container.scrollTop = scrollTop - walkY;
    });
    
    // Add touch support for mobile panning
    let touchStartX = 0, touchStartY = 0;
    let touchScrollLeft = 0, touchScrollTop = 0;
    
    container.addEventListener('touchstart', (e) => {
      if (e.target.closest('.pyramid-position')) return;
      
      touchStartX = e.touches[0].pageX;
      touchStartY = e.touches[0].pageY;
      touchScrollLeft = container.scrollLeft;
      touchScrollTop = container.scrollTop;
    }, { passive: true });
    
    container.addEventListener('touchmove', (e) => {
      if (e.target.closest('.pyramid-position')) return;
      
      const touchX = e.touches[0].pageX;
      const touchY = e.touches[0].pageY;
      const walkX = (touchStartX - touchX) * 1.5;
      const walkY = (touchStartY - touchY) * 1.5;
      container.scrollLeft = touchScrollLeft + walkX;
      container.scrollTop = touchScrollTop + walkY;
    }, { passive: true });
  }

  /**
   * Setup drag-and-drop for employee assignment
   */
  function setupDragAndDrop() {
    // Make employee tiles in filled positions draggable
    document.querySelectorAll('.pyramid-position[data-position-id]').forEach(tile => {
      const positionId = tile.dataset.positionId;
      if (positionId === 'ceo') return; // Can't drag CEO
      
      const position = getPosition(positionId);
      if (position && position.employeeId) {
        tile.draggable = true;
        // Keep pointer cursor for clicking, show move on hover
        tile.style.cursor = 'pointer';
        
        tile.addEventListener('dragstart', (e) => {
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('employeeId', position.employeeId);
          e.dataTransfer.setData('sourcePositionId', positionId);
          tile.style.opacity = '0.5';
        });
        
        tile.addEventListener('dragend', (e) => {
          tile.style.opacity = '1';
        });
      }
      
      // Make all position tiles drop targets
      tile.addEventListener('dragover', (e) => {
        if (positionId === 'ceo') return;
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        tile.style.transform = 'scale(1.05)';
        tile.style.boxShadow = '0 6px 20px rgba(255,215,0,0.5)';
      });
      
      tile.addEventListener('dragleave', (e) => {
        tile.style.transform = '';
        tile.style.boxShadow = '';
      });
      
      tile.addEventListener('drop', (e) => {
        e.preventDefault();
        tile.style.transform = '';
        tile.style.boxShadow = '';
        
        if (positionId === 'ceo') return;
        
        const employeeId = e.dataTransfer.getData('employeeId');
        const sourcePositionId = e.dataTransfer.getData('sourcePositionId');
        
        if (employeeId && positionId !== sourcePositionId) {
          handleEmployeeDrop(employeeId, positionId);
        }
      });
    });
  }

  /**
   * Handle employee drop onto position
   * @param {string} employeeId - Employee being dragged
   * @param {string} targetPositionId - Target position
   */
  function handleEmployeeDrop(employeeId, targetPositionId) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    const targetPosition = getPosition(targetPositionId);
    
    if (!employee || !targetPosition) return;
    
    // Check if employee can fill this position
    const check = canFillPosition(employee, targetPosition);
    
    if (!check.canFill) {
      showNotification(check.reason, 'error');
      return;
    }
    
    const cost = calculateRelocationCost(employee, targetPosition);
    
    const message = `Move ${employee.name} to ${targetPosition.title}?\n\nCost: $${formatNumber(cost)}`;
    
    if (confirm(message)) {
      const result = assignEmployeeToPosition(employeeId, targetPositionId, true);
      
      if (result.success) {
        showNotification(result.message, 'success');
        // Refresh modal to show updated positions
        closeCorporatePyramidModal();
        setTimeout(() => openCorporatePyramidModal(), 100);
      } else {
        showNotification(result.message, 'error');
      }
    }
  }

  /**
   * Setup click handlers for position tiles
   * @param {string} selectedEmployeeId - Employee being placed
   */
  function setupPositionClickHandlers(selectedEmployeeId) {
    const pyramidCanvas = document.getElementById('pyramidCanvas');
    if (!pyramidCanvas) {
      console.error('[Pyramid] pyramidCanvas container not found');
      return;
    }
    
    // Remove any existing delegated click handler to prevent duplicates
    const existingHandler = pyramidCanvas._positionClickHandler;
    if (existingHandler) {
      pyramidCanvas.removeEventListener('click', existingHandler);
    }
    
    // Use event delegation - single handler on parent element
    const clickHandler = (e) => {
      // Find the closest .pyramid-position ancestor
      const tile = e.target.closest('.pyramid-position');
      if (!tile) return; // Click wasn't on a position tile
      
      const positionId = tile.dataset.positionId;
      console.log(`[Pyramid] Clicked position: ${positionId}`);
      
      if (positionId === 'ceo') {
        console.log('[Pyramid] CEO position clicked - ignoring');
        return; // Can't click CEO
      }
      
      if (selectedEmployeeId) {
        // Assignment mode
        console.log(`[Pyramid] Assignment mode - selectedEmployee: ${selectedEmployeeId}`);
        const canSelect = tile.dataset.canSelect === 'true';
        if (canSelect) {
          const cost = parseInt(tile.dataset.cost);
          confirmPositionAssignment(selectedEmployeeId, positionId, cost);
        } else {
          showNotification('Employee does not meet position requirements', 'error');
        }
      } else {
        // View/manage mode
        console.log(`[Pyramid] Opening details modal for: ${positionId}`);
        showPositionDetailsModal(positionId);
      }
    };
    
    // Store reference for cleanup
    pyramidCanvas._positionClickHandler = clickHandler;
    pyramidCanvas.addEventListener('click', clickHandler);
    
    console.log(`[Pyramid] Click handler setup complete (event delegation mode)`);
  }

  /**
   * Confirm assignment of employee to position
   * @param {string} employeeId - Employee ID
   * @param {string} positionId - Position ID
   * @param {number} cost - Relocation cost
   */
  function confirmPositionAssignment(employeeId, positionId, cost) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    const newPosition = getPosition(positionId);
    
    if (!employee || !newPosition) return;
    
    // Get current position
    const oldPosition = getEmployeePosition(employee.id);
    const oldLevelInfo = oldPosition ? gameState.hierarchyLevels[Math.floor(oldPosition.level)] : null;
    
    // Get level info with fallback for special positions like secretary
    let newLevelInfo = gameState.hierarchyLevels[Math.floor(newPosition.level)];
    if (!newLevelInfo) {
      // Fallback for positions without standard level info
      newLevelInfo = {
        icon: 'ğŸ“‹',
        color: '#00d4ff',
        title: 'Position'
      };
    }
    
    // Special handling for secretary position
    if (newPosition.positionId === 'secretary') {
      newLevelInfo = {
        icon: 'ğŸ“‹',
        color: '#e879f9',
        title: 'Executive Secretary'
      };
    }
    
    // Check if player can afford it
    if (gameState.cash < cost) {
      showNotification(`Not enough cash! Need $${formatNumber(cost)}`, 'error');
      return;
    }
    
    // Create visual confirmation modal
    const confirmModal = document.createElement('div');
    confirmModal.id = 'promotionConfirmModal';
    confirmModal.style.cssText = 'position:fixed !important; top:0 !important; left:0 !important; width:100% !important; height:100% !important; background:rgba(0,0,0,0.9) !important; display:flex !important; align-items:center !important; justify-content:center !important; z-index:10000010 !important; animation:fadeIn 0.2s ease;';
    
    const isPromotion = oldPosition && newPosition.level > oldPosition.level;
    const actionWord = isPromotion ? 'Promote' : oldPosition ? 'Transfer' : 'Assign';
    const actionColor = isPromotion ? '#4ecca3' : '#00d4ff';
    
    confirmModal.innerHTML = `
      <style>
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes slideUp {
          from { transform: translateY(30px); opacity: 0; }
          to { transform: translateY(0); opacity: 1; }
        }
        @keyframes pulse {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.05); }
        }
      </style>
      <div style="background:#0f1419; border-radius:16px; box-shadow:0 20px 60px rgba(0,0,0,0.8); max-width:700px; width:90%; overflow:hidden; animation:slideUp 0.3s ease;">
        <!-- Header -->
        <div style="padding:24px; background:linear-gradient(135deg, ${actionColor}, ${actionColor}22); border-bottom:2px solid ${actionColor};">
          <h2 style="margin:0; color:#fff; font-size:1.8rem; text-align:center; display:flex; align-items:center; justify-content:center; gap:12px;">
            ${isPromotion ? 'â¬†ï¸' : 'â†”ï¸'}
            <span>Confirm ${actionWord}</span>
          </h2>
        </div>
        
        <!-- Content -->
        <div style="padding:32px 24px;">
          <!-- Employee Card -->
          <div style="text-align:center; margin-bottom:24px;">
            <img src="${employee.profileImage || 'https://placehold.co/80x80'}" style="width:80px; height:80px; border-radius:50%; border:3px solid ${actionColor}; object-fit:cover; box-shadow:0 4px 12px rgba(0,0,0,0.3);">
            <h3 style="color:#fff; margin:12px 0 4px 0; font-size:1.3rem;">${employee.name}</h3>
            ${employee.career ? `<div style="color:#888; font-size:0.9rem;">Currently: ${employee.career.title || 'Employee'} (Level ${employee.career.level || 1})</div>` : ''}
          </div>
          
          <!-- Position Cards with Arrow -->
          <div style="display:flex; align-items:center; justify-content:center; gap:16px; margin:24px 0;">
            <!-- Old Position (if exists) -->
            ${oldPosition ? `
              <div style="flex:1; background:#16213e; border:2px solid ${oldLevelInfo?.color || '#555'}; border-radius:12px; padding:16px; text-align:center;">
                <div style="font-size:1.5rem; margin-bottom:8px;">${oldLevelInfo?.icon || 'ğŸ“‹'}</div>
                <div style="color:#fff; font-weight:600; font-size:0.9rem; margin-bottom:4px;">${oldPosition.title}</div>
                <div style="color:#888; font-size:0.75rem;">Level ${Math.floor(oldPosition.level)}</div>
              </div>
            ` : `
              <div style="flex:1; background:#16213e; border:2px dashed #555; border-radius:12px; padding:16px; text-align:center; opacity:0.5;">
                <div style="font-size:1.5rem; margin-bottom:8px;">âŒ</div>
                <div style="color:#888; font-weight:600; font-size:0.9rem;">Unassigned</div>
              </div>
            `}
            
            <!-- Arrow -->
            <div style="font-size:2rem; color:${actionColor}; animation:pulse 2s infinite;">
              ${isPromotion ? 'â¬†ï¸' : 'â¡ï¸'}
            </div>
            
            <!-- New Position -->
            <div style="flex:1; background:linear-gradient(135deg, ${newLevelInfo.color}22, ${newLevelInfo.color}11); border:2px solid ${newLevelInfo.color}; border-radius:12px; padding:16px; text-align:center; box-shadow:0 0 20px ${newLevelInfo.color}44;">
              <div style="font-size:1.5rem; margin-bottom:8px;">${newLevelInfo.icon}</div>
              <div style="color:#fff; font-weight:600; font-size:0.9rem; margin-bottom:4px;">${newPosition.title}</div>
              <div style="color:${newLevelInfo.color}; font-size:0.75rem; font-weight:600;">Level ${Math.floor(newPosition.level)}</div>
            </div>
          </div>
          
          <!-- Cost Info -->
          <div style="background:#1a1a2e; border:2px solid ${gameState.cash >= cost ? actionColor : '#e94560'}; border-radius:10px; padding:16px; margin:24px 0;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
              <span style="color:#888; font-size:0.9rem;">Cost:</span>
              <span style="color:${gameState.cash >= cost ? '#4ecca3' : '#e94560'}; font-weight:700; font-size:1.2rem;">$${formatNumber(cost)}</span>
            </div>
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="color:#888; font-size:0.9rem;">Your Cash:</span>
              <span style="color:#fff; font-weight:600; font-size:1rem;">$${formatNumber(gameState.cash)}</span>
            </div>
            ${gameState.cash >= cost ? `
              <div style="display:flex; justify-content:space-between; align-items:center; margin-top:8px; padding-top:8px; border-top:1px solid #333;">
                <span style="color:#888; font-size:0.9rem;">After ${actionWord}:</span>
                <span style="color:#4ecca3; font-weight:600; font-size:1rem;">$${formatNumber(gameState.cash - cost)}</span>
              </div>
            ` : ''}
          </div>
          
          ${gameState.cash < cost ? `
            <div style="background:rgba(233,69,96,0.1); border:1px solid #e94560; border-radius:8px; padding:12px; margin-bottom:16px; text-align:center;">
              <span style="color:#e94560; font-size:0.9rem; font-weight:600;">âš ï¸ Insufficient funds!</span>
            </div>
          ` : ''}
          
          <!-- Action Buttons -->
          <div style="display:flex; gap:12px; margin-top:24px;">
            <button onclick="document.getElementById('promotionConfirmModal').remove()" style="flex:1; padding:14px; background:#16213e; border:2px solid #555; border-radius:10px; color:#fff; font-weight:600; font-size:1rem; cursor:pointer; transition:all 0.2s;" onmouseenter="this.style.background='#1a2640'; this.style.borderColor='#777'" onmouseleave="this.style.background='#16213e'; this.style.borderColor='#555'">
              âœ• Cancel
            </button>
            <button 
              onclick="executePromotion('${employeeId}', '${positionId}')" 
              style="flex:1; padding:14px; background:${gameState.cash >= cost ? `linear-gradient(135deg, ${actionColor}, ${actionColor}dd)` : '#555'}; border:none; border-radius:10px; color:${gameState.cash >= cost ? '#000' : '#999'}; font-weight:700; font-size:1rem; cursor:${gameState.cash >= cost ? 'pointer' : 'not-allowed'}; transition:all 0.2s; box-shadow:${gameState.cash >= cost ? `0 4px 12px ${actionColor}44` : 'none'};"
              ${gameState.cash >= cost ? `onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px ${actionColor}66'" onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px ${actionColor}44'"` : 'disabled'}
            >
              âœ“ Confirm ${actionWord}
            </button>
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(confirmModal);
    
    // Close on background click
    confirmModal.addEventListener('click', (e) => {
      if (e.target === confirmModal) {
        confirmModal.remove();
      }
    });
  }
  
  /**
   * Execute the promotion after confirmation
   * @param {string} employeeId - Employee ID
   * @param {string} positionId - New position ID
   */
  function executePromotion(employeeId, positionId) {
    // Remove confirmation modal
    const modal = document.getElementById('promotionConfirmModal');
    if (modal) modal.remove();
    
    // Execute the assignment
    const result = assignEmployeeToPosition(employeeId, positionId, true);
    
    if (result.success) {
      showNotification(result.message, 'success');
      
      // If they vacated a staff position, show additional notification
      if (result.needsRehire && result.vacatedPosition) {
        const product = gameState.products.find(p => p.id === result.vacatedPosition.productId);
        if (product) {
          setTimeout(() => {
            showNotification(
              `âš ï¸ ${result.vacatedPosition.title} is now vacant! Hire a new staff member to restore automation for ${product.name}`,
              'warning',
              5000
            );
          }, 1500);
        }
      }
      
      closeCorporatePyramidModal();
      updatePeopleTab();
      updateProductsList();
      updateBusinessTab();
    } else {
      showNotification(result.message, 'error');
    }
  }
  
  // Make executePromotion available globally
  window.executePromotion = executePromotion;

  /**
   * Show details modal for a position
   * @param {string} positionId - Position ID
   */
  function showPositionDetailsModal(positionId) {
    const position = getPosition(positionId);
    if (!position) return;
    
    const employee = position.employeeId ? gameState.employees.find(e => e.id === position.employeeId) : null;
    
    // Handle decimal levels (like secretary at 6.5) by flooring to get levelInfo
    const positionLevel = Math.floor(position.level);
    const levelInfo = gameState.hierarchyLevels[positionLevel] || {
      icon: 'ğŸ“‹',
      color: '#00d4ff',
      title: 'Position'
    };
    
    // Special styling for secretary position
    const isSecretary = position.positionId === 'secretary';
    const displayIcon = isSecretary ? 'ğŸ“‹' : levelInfo.icon;
    const displayColor = isSecretary ? '#e879f9' : levelInfo.color;
    
    // Create a custom modal for position details
    const detailsModal = document.createElement('div');
    detailsModal.id = `positionDetailsModal_${positionId}`;
    detailsModal.className = 'position-details-modal';
    detailsModal.style.cssText = 'position:fixed !important; top:0 !important; left:0 !important; width:100% !important; height:100% !important; background:rgba(0,0,0,0.8) !important; display:flex !important; align-items:center !important; justify-content:center !important; z-index:10000010 !important;';
    
    detailsModal.innerHTML = `
      <div style="background:#0f1419; width:90%; max-width:500px; border-radius:12px; box-shadow:0 8px 32px rgba(0,0,0,0.5); overflow:hidden;">
        <div style="padding:20px; border-bottom:2px solid rgba(255,255,255,0.1); background:linear-gradient(135deg, #1a1f35 0%, #0f1419 100%);">
          <h3 style="margin:0; color:#fff; font-size:1.5rem; display:flex; align-items:center; gap:10px;">
            <span>${displayIcon}</span>
            ${position.title}
          </h3>
          <p style="margin:4px 0 0 0; color:#888; font-size:0.9rem;">Level ${position.level} Position${isSecretary ? ' â€¢ Reports to CEO' : ''}</p>
        </div>
        
        <div style="padding:20px;">
          ${employee ? `
            <div style="text-align:center; margin-bottom:20px;">
              <img src="${employee.profileImage || 'https://placehold.co/100x100'}" style="width:100px; height:100px; border-radius:50%; object-fit:cover; border:3px solid ${displayColor}; margin-bottom:12px;">
              <div style="font-size:1.2rem; font-weight:600; color:#fff; margin-bottom:4px;">${employee.name}</div>
              <div style="font-size:0.9rem; color:#aaa;">Current Level: ${employee.career?.level || 1}</div>
              <div style="font-size:0.9rem; color:#4ecca3; margin-top:8px;">Salary: $${formatNumber(employee.career?.salary || employee.salary || 0)}/month</div>
            </div>
            
            <div style="margin-bottom:20px;">
              <div style="font-size:0.9rem; color:#888; margin-bottom:8px;">Skills:</div>
              <div style="display:flex; gap:8px; flex-wrap:wrap;">
                ${employee.skills && typeof employee.skills === 'object' ? 
                  Object.entries(employee.skills)
                    .filter(([name, skill]) => skill && skill.level > 0)
                    .map(([name, skill]) => `
                      <span style="padding:4px 10px; background:#16213e; border-radius:6px; font-size:0.8rem; color:#00d4ff;">
                        ${name.charAt(0).toUpperCase() + name.slice(1)} Lv${skill.level}
                      </span>
                    `).join('') 
                  : '<span style="color:#666; font-size:0.8rem;">No skills yet</span>'
                }
              </div>
            </div>
            
            ${(() => {
              const currentLevel = employee.career?.level || 1;
              const nextLevel = currentLevel + 1;
              const isMaxLevel = nextLevel > 7;
              const isEligible = canPromote(employee);
              const requirements = !isMaxLevel ? getPromotionRequirements(nextLevel, employee) : null;
              
              if (isMaxLevel) {
                return `
                  <div style="margin-bottom:20px; padding:12px; background:linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); border-radius:8px; border:2px solid #ffa500;">
                    <div style="font-size:0.9rem; font-weight:600; color:#000; margin-bottom:4px; display:flex; align-items:center; gap:8px;">
                      <span style="font-size:1.2rem;">ğŸ‘‘</span>
                      Maximum Level Reached
                    </div>
                    <div style="font-size:0.75rem; color:#333;">This employee has reached the highest career level!</div>
                  </div>
                `;
              }
              
              const nextLevelInfo = gameState.hierarchyLevels[nextLevel] || gameState.hierarchyLevels[nextLevel - 1] || { title: 'Next Level', color: '#00d4ff', icon: 'â¬†ï¸', baseSalary: 60000 };
              const productivity = employee.stats?.productivity || 0;
              const managementLevel = employee.skills?.management?.level || 0;
              
              const productivityMet = productivity >= (requirements?.minProductivity || 0);
              const managementMet = !requirements?.minManagement || managementLevel >= requirements.minManagement;
              
              if (isEligible) {
                return `
                  <div style="margin-bottom:20px; padding:12px; background:linear-gradient(135deg, #4ecca3 0%, #3ba882 100%); border-radius:8px; border:2px solid #4ecca3;">
                    <div style="font-size:0.9rem; font-weight:600; color:#000; margin-bottom:4px; display:flex; align-items:center; gap:8px;">
                      <span style="font-size:1.2rem;">â¬†ï¸</span>
                      Ready for Promotion!
                    </div>
                    <div style="font-size:0.75rem; color:#000; margin-bottom:8px;">
                      ${employee.name} can be promoted to <strong>${nextLevelInfo.title}</strong> (Level ${nextLevel})
                    </div>
                    <div style="font-size:0.7rem; color:#000;">
                      âœ“ Productivity: ${productivity}% (needs ${requirements.minProductivity}%)<br>
                      ${requirements.minManagement ? `âœ“ Management: Level ${managementLevel} (needs ${requirements.minManagement})` : ''}
                    </div>
                  </div>
                `;
              } else {
                return `
                  <div style="margin-bottom:20px; padding:12px; background:rgba(233,69,96,0.2); border-radius:8px; border:2px solid #e94560;">
                    <div style="font-size:0.9rem; font-weight:600; color:#e94560; margin-bottom:4px; display:flex; align-items:center; gap:8px;">
                      <span style="font-size:1.2rem;">ğŸ“‹</span>
                      Promotion Requirements
                    </div>
                    <div style="font-size:0.75rem; color:#fff; margin-bottom:8px;">
                      For promotion to <strong>${nextLevelInfo.title}</strong> (Level ${nextLevel}):
                    </div>
                    <div style="font-size:0.7rem; color:#fff;">
                      ${productivityMet ? 'âœ“' : 'âœ—'} Productivity: ${productivity}% ${!productivityMet ? `<span style="color:#e94560;">(needs ${requirements.minProductivity}%)</span>` : `<span style="color:#4ecca3;">(met!)</span>`}<br>
                      ${requirements.minManagement ? `
                        ${managementMet ? 'âœ“' : 'âœ—'} Management: Level ${managementLevel} ${!managementMet ? `<span style="color:#e94560;">(needs ${requirements.minManagement})</span>` : `<span style="color:#4ecca3;">(met!)</span>`}
                      ` : ''}
                    </div>
                  </div>
                `;
              }
            })()}
            
            <!-- Action Buttons -->
            <div style="display:flex; gap:10px; margin-bottom:10px;">
              <button id="transferEmployeeBtn" style="flex:1; padding:12px; background:#00d4ff; border:none; border-radius:8px; color:#0f1419; cursor:pointer; font-weight:600; display:flex; align-items:center; justify-content:center; gap:6px;" title="Transfer to another position at the same level">
                <span>ğŸ”„</span> Transfer
              </button>
              <button id="promoteEmployeeBtn" ${!canPromote(employee) ? 'disabled' : ''} style="flex:1; padding:12px; background:${canPromote(employee) ? '#4ecca3' : '#333'}; border:none; border-radius:8px; color:${canPromote(employee) ? '#0f1419' : '#666'}; cursor:${canPromote(employee) ? 'pointer' : 'not-allowed'}; font-weight:600; display:flex; align-items:center; justify-content:center; gap:6px; opacity:${canPromote(employee) ? '1' : '0.5'};" title="${canPromote(employee) ? 'Promote to next level' : 'Not eligible for promotion yet'}">
                <span>â¬†ï¸</span> Promote
              </button>
            </div>
            
            <button id="terminateEmployeeBtn" style="width:100%; padding:12px; background:#e94560; border:none; border-radius:8px; color:#fff; cursor:pointer; font-weight:600; margin-bottom:10px; display:flex; align-items:center; justify-content:center; gap:6px;">
              <span>ğŸš«</span> Terminate Employment
            </button>
          ` : `
            <div style="text-align:center; padding:40px 20px;">
              <div style="font-size:3rem; opacity:0.3; margin-bottom:12px;">ğŸ‘¤</div>
              <div style="font-size:1.1rem; color:#aaa; margin-bottom:8px;">Position Vacant</div>
              <div style="font-size:0.85rem; color:#666;">Go to People tab and click "Promote" on an employee to assign them here.</div>
            </div>
          `}
          
          <button id="closeDetailsBtn" style="width:100%; padding:12px; background:#0f3460; border:none; border-radius:8px; color:#fff; cursor:pointer; font-weight:600;">
            Close
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(detailsModal);
    
    // Close modal when clicking on background overlay (not the content box)
    detailsModal.addEventListener('click', (e) => {
      if (e.target === detailsModal) {
        detailsModal.remove();
      }
    });
    
    // Add event listeners after appending to DOM
    const closeBtn = detailsModal.querySelector('#closeDetailsBtn');
    if (closeBtn) {
      closeBtn.addEventListener('click', () => {
        detailsModal.remove();
      });
    }
    
    if (employee) {
      // Transfer button - show transfer options modal
      const transferBtn = detailsModal.querySelector('#transferEmployeeBtn');
      if (transferBtn) {
        transferBtn.addEventListener('click', () => {
          showTransferModal(employee, position);
          detailsModal.remove();
        });
      }
      
      // Promote button - open pyramid with eligible higher positions
      const promoteBtn = detailsModal.querySelector('#promoteEmployeeBtn');
      if (promoteBtn && !promoteBtn.disabled) {
        promoteBtn.addEventListener('click', () => {
          detailsModal.remove();
          openCorporatePyramidModal(employee.id); // Reopen pyramid in promotion mode
        });
      }
      
      // Terminate button - fire the employee
      const terminateBtn = detailsModal.querySelector('#terminateEmployeeBtn');
      if (terminateBtn) {
        terminateBtn.addEventListener('click', () => {
          if (confirm(`Are you sure you want to terminate ${employee.name}?\n\nThis will:\nâ€¢ Remove them from this position\nâ€¢ Set their status to "alumni"\nâ€¢ Disable automation if they manage a product`)) {
            handleEmployeeAction(employee.id, 'fire');
            detailsModal.remove();
            // Refresh pyramid
            if (document.getElementById('pyramidModal').style.display === 'flex') {
              openCorporatePyramidModal();
            }
          }
        });
      }
    }
  }

  /**
   * Show transfer modal for moving employee to same-level position
   * @param {object} employee - Employee to transfer
   * @param {object} currentPosition - Current position
   */
  function showTransferModal(employee, currentPosition) {
    console.log(`\n[TRANSFER] Opening transfer modal for ${employee.name} from ${currentPosition.title}`);
    
    const modal = document.createElement('div');
    modal.id = 'transferModal';
    modal.style.cssText = 'position:fixed !important; top:0 !important; left:0 !important; width:100% !important; height:100% !important; background:rgba(0,0,0,0.8) !important; display:flex !important; align-items:center !important; justify-content:center !important; z-index:10000010 !important;';
    
    // Check if this is Executive Secretary (special case)
    const isExecutiveSecretary = currentPosition.positionId === 'secretary' || currentPosition.title === 'Executive Secretary';
    
    // Get positions at the same level AND lower levels (for demotion)
    const currentLevel = Math.floor(currentPosition.level);
    
    // Collect transfer options: same level + all lower levels
    const transferOptions = [];
    
    // Executive Secretary can only transfer laterally (to other secretary) - NO lateral transfers at level 6
    if (!isExecutiveSecretary) {
      // Same level positions (lateral transfers) - only for non-secretary roles
      const sameLevelPositions = gameState.corporatePyramid.positions[currentLevel] || [];
      sameLevelPositions
        .filter(pos => pos.positionId !== currentPosition.positionId && !pos.employeeId)
        .forEach(pos => {
          transferOptions.push({ ...pos, transferType: 'lateral' });
        });
    }
    
    // Lower level positions (demotions) - only if not already at level 1
    if (currentLevel > 1) {
      // For Executive Secretary, only allow demotion to Level 3 or below
      const minDemotionLevel = isExecutiveSecretary ? 3 : currentLevel - 1;
      const maxDemotionLevel = isExecutiveSecretary ? 1 : 1;
      
      for (let level = minDemotionLevel; level >= maxDemotionLevel; level--) {
        const lowerLevelPositions = gameState.corporatePyramid.positions[level] || [];
        lowerLevelPositions
          .filter(pos => !pos.employeeId)
          .forEach(pos => {
            transferOptions.push({ ...pos, transferType: 'demotion', levelDifference: currentLevel - level });
          });
      }
    }
    
    console.log(`[TRANSFER] Found ${transferOptions.length} total options (lateral + demotion)${isExecutiveSecretary ? ' [Executive Secretary: max demotion to Level 3]' : ''}`);
    
    modal.innerHTML = `
      <div style="background:#0f1419; width:90%; max-width:700px; border-radius:12px; box-shadow:0 8px 32px rgba(0,0,0,0.5); overflow:hidden; max-height:85vh; display:flex; flex-direction:column;">
        <div style="padding:20px; border-bottom:2px solid rgba(255,255,255,0.1); background:linear-gradient(135deg, ${isExecutiveSecretary ? '#9b59b6 0%, #8e44ad 100%' : '#00d4ff 0%, #0088cc 100%'});">
          <h3 style="margin:0; color:#${isExecutiveSecretary ? 'fff' : '0f1419'}; font-size:1.5rem; display:flex; align-items:center; gap:10px;">
            <span>ğŸ”„</span>
            ${isExecutiveSecretary ? 'Demote' : 'Transfer or Demote'} ${employee.name}
          </h3>
          <p style="margin:4px 0 0 0; color:#${isExecutiveSecretary ? 'ddd' : '000'}; font-size:0.9rem;">
            Current: ${currentPosition.title} (Level ${currentLevel})${isExecutiveSecretary ? ' â€¢ Special Role' : ''}
          </p>
        </div>
        
        <div style="flex:1; overflow-y:auto; padding:20px;">
          ${transferOptions.length > 0 ? `
            ${isExecutiveSecretary ? `
              <div style="margin-bottom:16px; padding:12px; background:rgba(155,89,182,0.2); border-left:4px solid #9b59b6; border-radius:6px;">
                <div style="font-size:0.85rem; color:#9b59b6; font-weight:600; margin-bottom:4px;">ğŸ‘” Executive Secretary Special Rules</div>
                <div style="font-size:0.75rem; color:#fff;">
                  â€¢ Executive Secretary is a <strong>special high-level role</strong> that can be filled early<br/>
                  â€¢ Not equivalent to other Level 6, 5, or 4 management positions<br/>
                  â€¢ Can only be demoted to <strong>Level 3 (Regional Manager) or below</strong><br/>
                  â€¢ Demotion cost: <strong>50%</strong> of destination hiring cost
                </div>
              </div>
            ` : `
              <div style="margin-bottom:16px; padding:12px; background:rgba(255,193,7,0.2); border-left:4px solid #ffc107; border-radius:6px;">
                <div style="font-size:0.85rem; color:#ffc107; font-weight:600; margin-bottom:4px;">âš ï¸ Transfer Cost Policy</div>
                <div style="font-size:0.75rem; color:#fff;">
                  â€¢ <strong>Lateral transfers</strong> (same level): 75% of destination hiring cost<br/>
                  â€¢ <strong>Demotions</strong> (lower level): 50% of destination hiring cost
                </div>
              </div>
            `}
            
            <div style="display:flex; flex-direction:column; gap:12px;">
              ${transferOptions.map(option => {
                // Calculate transfer cost based on destination location's hiring cost
                const location = gameState.locations.find(l => l.id === option.locationId);
                const product = option.productId ? gameState.products.find(p => p.id === option.productId) : null;
                
                // Base hiring cost for that location/product
                const baseHiringCost = product ? (product.managerHireCost || 500) : (location ? 500 * (gameState.locations.indexOf(location) + 1) : 500);
                
                // Transfer cost depends on type
                const costMultiplier = option.transferType === 'demotion' ? 0.50 : 0.75;
                const transferCost = Math.floor(baseHiringCost * costMultiplier);
                
                const canAfford = gameState.cash >= transferCost;
                const levelInfo = gameState.hierarchyLevels[option.level];
                
                // Color coding
                const borderColor = option.transferType === 'demotion' ? '#ff9800' : '#00d4ff';
                const accentColor = option.transferType === 'demotion' ? '#ff9800' : '#4ecca3';
                
                return `
                  <div class="transfer-option" data-position-id="${option.positionId}" data-cost="${transferCost}" data-type="${option.transferType}" style="padding:16px; background:#16213e; border-radius:8px; border:2px solid ${canAfford ? borderColor : '#555'}; cursor:${canAfford ? 'pointer' : 'not-allowed'}; transition:all 0.3s ease; opacity:${canAfford ? '1' : '0.5'};" onmouseenter="if(${canAfford}) this.style.borderColor='${accentColor}'; this.style.transform='translateX(4px)';" onmouseleave="this.style.borderColor='${canAfford ? borderColor : '#555'}'; this.style.transform='translateX(0)';">
                    <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:8px;">
                      <div style="flex:1;">
                        <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
                          ${option.transferType === 'demotion' ? `<span style="background:#ff9800; color:#000; padding:2px 6px; border-radius:4px; font-size:0.65rem; font-weight:700;">â¬‡ DEMOTION</span>` : `<span style="background:#00d4ff; color:#000; padding:2px 6px; border-radius:4px; font-size:0.65rem; font-weight:700;">â†” LATERAL</span>`}
                          <span style="font-weight:600; color:#fff; font-size:0.95rem;">${option.title}</span>
                        </div>
                        <div style="font-size:0.75rem; color:#888; margin-left:0px;">
                          Level ${option.level}: ${levelInfo ? levelInfo.title : 'Unknown'}
                        </div>
                        ${location ? `<div style="font-size:0.75rem; color:#888; margin-top:2px;">ğŸ“ ${location.name}</div>` : ''}
                        ${product ? `<div style="font-size:0.75rem; color:#4ecca3; margin-top:2px;">ğŸ“¦ ${product.name}</div>` : ''}
                        ${option.transferType === 'demotion' ? `<div style="font-size:0.7rem; color:#ff9800; margin-top:4px;">âš ï¸ Salary will decrease to $${formatNumber(levelInfo.baseSalary)}</div>` : ''}
                      </div>
                      <div style="text-align:right;">
                        <div style="font-size:0.9rem; font-weight:600; color:${canAfford ? accentColor : '#e94560'};">
                          $${formatNumber(transferCost)}
                        </div>
                        <div style="font-size:0.65rem; color:#666; margin-top:2px;">
                          (${Math.round(costMultiplier * 100)}% of hire cost)
                        </div>
                      </div>
                    </div>
                    
                    ${!canAfford ? `
                      <div style="margin-top:8px; padding:6px; background:rgba(233,69,96,0.2); border-radius:4px; text-align:center;">
                        <div style="font-size:0.7rem; color:#e94560;">Need $${formatNumber(transferCost - gameState.cash)} more</div>
                      </div>
                    ` : `
                      <div style="margin-top:8px; padding:6px; background:rgba(78,204,163,0.2); border-radius:4px; text-align:center;">
                        <div style="font-size:0.7rem; color:${accentColor};">âœ“ Click to ${option.transferType === 'demotion' ? 'demote' : 'transfer'}</div>
                      </div>
                    `}
                  </div>
                `;
              }).join('')}
            </div>
          ` : `
            <div style="text-align:center; padding:40px 20px;">
              <div style="font-size:3rem; opacity:0.3; margin-bottom:12px;">ğŸ”„</div>
              <div style="font-size:1.1rem; color:#aaa; margin-bottom:8px;">No ${isExecutiveSecretary ? 'Demotion' : 'Transfer'} Options Available</div>
              <div style="font-size:0.85rem; color:#666;">
                ${isExecutiveSecretary 
                  ? 'All positions at Level 3 (Regional Manager) and below are currently filled.'
                  : 'All positions at this level and below are currently filled.'
                }
              </div>
            </div>
          `}
        </div>
        
        <div style="padding:16px; border-top:2px solid rgba(255,255,255,0.1); background:#0a0e1a;">
          <button id="closeTransferModal" style="width:100%; padding:12px; background:#0f3460; border:none; border-radius:8px; color:#fff; cursor:pointer; font-weight:600;">
            Cancel
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Close button
    modal.querySelector('#closeTransferModal').addEventListener('click', () => {
      modal.remove();
    });
    
    // Transfer option clicks
    modal.querySelectorAll('.transfer-option').forEach(option => {
      const positionId = option.dataset.positionId;
      const cost = parseInt(option.dataset.cost);
      const transferType = option.dataset.type;
      
      if (gameState.cash >= cost) {
        option.addEventListener('click', () => {
          const targetPosition = getPosition(positionId);
          if (!targetPosition) return;
          
          const isDemotion = transferType === 'demotion';
          const actionWord = isDemotion ? 'Demote' : 'Transfer';
          const targetLevelInfo = gameState.hierarchyLevels[targetPosition.level];
          
          let confirmMessage = `${actionWord} ${employee.name} to ${targetPosition.title}?\n\nCost: $${formatNumber(cost)}\nRemaining cash: $${formatNumber(gameState.cash - cost)}`;
          
          if (isDemotion && targetLevelInfo) {
            confirmMessage += `\n\nâš ï¸ This is a demotion!\nNew salary: $${formatNumber(targetLevelInfo.baseSalary)}`;
          }
          
          if (confirm(confirmMessage)) {
            console.log(`[TRANSFER] Executing ${isDemotion ? 'demotion' : 'transfer'} to ${targetPosition.title} for $${formatNumber(cost)}`);
            
            // CRITICAL: Double-check that target position is still vacant
            if (targetPosition.employeeId) {
              showNotification(`Cannot ${isDemotion ? 'demote' : 'transfer'}: ${targetPosition.title} is now occupied by someone else!`, 'error');
              return;
            }
            
            // Remove from current position
            currentPosition.employeeId = null;
            currentPosition.isVacant = true;
            
            // Clear product if they were managing one
            if (currentPosition.productId) {
              const oldProduct = gameState.products.find(p => p.id === currentPosition.productId);
              if (oldProduct && oldProduct.managerId === employee.id) {
                oldProduct.managerHired = false;
                oldProduct.managerId = null;
              }
            }
            
            // Assign to new position (this will update career level/title/salary)
            const result = assignEmployeeToPosition(employee.id, positionId, false); // Don't pay twice
            
            if (result.success) {
              // Deduct transfer cost
              gameState.cash -= cost;
              
              const actionPastTense = isDemotion ? 'demoted' : 'transferred';
              showNotification(`${employee.name} ${actionPastTense} to ${targetPosition.title}! Cost: $${formatNumber(cost)}`, 'success');
              modal.remove();
              
              // Refresh pyramid if open
              if (document.getElementById('pyramidModal').style.display === 'flex') {
                openCorporatePyramidModal();
              }
              
              // CRITICAL: Force refresh People tab to show updated career info
              updatePeopleTab();
              
              // Also update UI if on People tab
              if (gameState.activeTab === 'people') {
                switchTab('people'); // Force full re-render
              }
              
              // Save game to persist changes
              saveGame();
            } else {
              showNotification(`${actionWord} failed: ${result.message}`, 'error');
            }
          }
        });
      }
    });
  }

  /**
   * Remove employee from their position
   * @param {string} positionId - Position ID
   * @param {string} employeeId - Employee ID
   */
  function removeEmployeeFromPosition(positionId, employeeId) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    if (confirm(`Remove ${employee.name} from this position?`)) {
      const result = removeEmployeeFromPyramid(employeeId);
      
      if (result) {
        showNotification(`${employee.name} removed from position`, 'success');
        // Close pyramid modal and reopen to refresh
        closeCorporatePyramidModal();
        setTimeout(() => openCorporatePyramidModal(), 100);
      } else {
        showNotification('Failed to remove employee', 'error');
      }
    }
  }

  /**
   * Zoom pyramid view
   * @param {string} direction - 'in', 'out', or 'reset'
   */
  let pyramidZoomLevel = 1;
  function pyramidZoom(direction) {
    const canvas = document.getElementById('pyramidCanvas');
    if (!canvas) return;
    
    if (direction === 'in') {
      pyramidZoomLevel = Math.min(pyramidZoomLevel + 0.2, 2);
    } else if (direction === 'out') {
      pyramidZoomLevel = Math.max(pyramidZoomLevel - 0.2, 0.5);
    } else if (direction === 'reset') {
      pyramidZoomLevel = 1;
    }
    
    canvas.style.transform = `scale(${pyramidZoomLevel})`;
  }

  /**
   * Setup pinch-to-zoom for mobile
   */
  function setupPinchZoom() {
    const container = document.getElementById('pyramidContainer');
    const canvas = document.getElementById('pyramidCanvas');
    if (!container || !canvas) return;
    
    let initialDistance = 0;
    let initialZoom = pyramidZoomLevel;
    
    container.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        initialDistance = Math.hypot(
          touch2.pageX - touch1.pageX,
          touch2.pageY - touch1.pageY
        );
        initialZoom = pyramidZoomLevel;
      }
    }, { passive: false });
    
    container.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const currentDistance = Math.hypot(
          touch2.pageX - touch1.pageX,
          touch2.pageY - touch1.pageY
        );
        
        const scale = currentDistance / initialDistance;
        pyramidZoomLevel = Math.max(0.5, Math.min(2, initialZoom * scale));
        canvas.style.transform = `scale(${pyramidZoomLevel})`;
      }
    }, { passive: false });
  }

  /**
   * Close the pyramid modal
   */
  function closeCorporatePyramidModal() {
    const modal = document.getElementById('pyramidModal');
    if (modal) {
      modal.style.display = 'none';
      modal.innerHTML = ''; // Clear content
    }
    pyramidZoomLevel = 1; // Reset zoom
  }

  /**
   * Calculate relationship strength for prestige/rehire system
   * @param {object} employee - Employee object
   * @returns {string} Relationship strength: 'very close', 'close', 'friendly', 'professional', 'distant'
   */
  function calculateRelationshipStrength(employee) {
    if (!employee || !employee.stats) return 'distant';
    
    // Average of affection, trust, and comfort
    const avgStat = (
      (employee.stats.affection || 0) +
      (employee.stats.trust || 0) +
      (employee.stats.comfort || 0)
    ) / 3;
    
    if (avgStat >= 80) return 'very close';
    if (avgStat >= 60) return 'close';
    if (avgStat >= 40) return 'friendly';
    if (avgStat >= 20) return 'professional';
    return 'distant';
  }

  /**
   * Calculate productivity bonus for rehired employees
   * @param {object} employee - Employee object
   * @returns {number} Bonus multiplier (0.30 to 0.50)
   */
  function calculateRehireBonus(employee) {
    if (!employee || !employee.career) return 0.30;
    
    // Base bonus: everyone gets 30%
    let bonus = 0.30;
    
    // Previous level bonus: +5% per level above Staff (Level 2)
    const levelBonus = Math.max(0, (employee.career.level - 2) * 0.05);
    bonus += Math.min(0.25, levelBonus);  // Cap at +25%
    
    // Relationship bonus: 0-20% based on closeness
    const relationshipStrength = calculateRelationshipStrength(employee);
    const relationshipBonuses = {
      'very close': 0.20,
      'close': 0.15,
      'friendly': 0.10,
      'professional': 0.05,
      'distant': 0.00
    };
    bonus += (relationshipBonuses[relationshipStrength] || 0);
    
    // Total cap: 50%
    return Math.min(0.50, bonus);
  }

  /**
   * Generate social feed post about promotion
   * @param {object} employee - Employee object
   * @param {number} newLevel - New level achieved
   */
  async function generatePromotionPost(employee, newLevel) {
    if (!employee || !gameState.socialNetwork) return;
    
    const levelData = gameState.hierarchyLevels[newLevel];
    if (!levelData) return;
    
    // ğŸš€ NUCLEAR CONTEXT: Get intelligent context for promotion post
    const intelligentContext = getIntelligentContext(employee, 'social.post', {
      message: `Posting about being promoted to ${levelData.title}`,
      involves: ['player', 'work', 'promotion'],
      keywords: ['promotion', 'career', levelData.title, employee.fastTrack ? 'fast-track' : 'achievement']
    });
    
    // Generate AI post content
    const postPrompt = `${intelligentContext}

SITUATION: You just got promoted to ${levelData.title}!
${employee.fastTrack ? 'You were FAST-TRACKED - this is a rapid promotion!' : ''}

Write a social media post announcing your promotion.

INSTRUCTIONS:
1. Keep it 1-2 sentences
2. Be excited but professional
3. Use 1-2 emojis naturally
4. Thank @TheBoss
5. ${employee.fastTrack ? 'Mention the fast-track momentum!' : 'Show you\'re proud of the achievement'}

EXAMPLES:
- "ğŸ‰ Thrilled to announce my promotion to ${levelData.title}! Thank you @TheBoss for believing in me! ğŸ’¼"
- "${employee.fastTrack ? 'ğŸš€ Fast-tracked to ' : ''}Officially a ${levelData.title} now! Grateful for this opportunity @TheBoss âœ¨"

Write the post:`;

    let caption = `ğŸ‰ Excited to announce that I've been promoted to ${levelData.title}! ${employee.fastTrack ? 'ğŸš€ Fast-tracked and loving the momentum! ' : ''}Thank you @TheBoss for this opportunity! ğŸ’¼âœ¨`;
    
    try {
      const generatedCaption = await queuedGenerateText(postPrompt, {
        temperature: 0.8,
        max_tokens: 60
      }, `Promotion Post - ${employee.name}`);
      if (generatedCaption && generatedCaption.trim()) {
        caption = generatedCaption.trim();
      }
    } catch (err) {
      console.warn('[Promotion Post] AI generation failed, using default caption:', err);
    }
    
    const post = {
      id: `post_${++gameState.socialNetwork.postIdCounter}_${Date.now()}`,
      author: employee.name,
      authorId: employee.id,
      type: 'work',
      category: 'work',
      timestamp: gameState.time?.currentTime || Date.now(),
      contentType: 'text',
      caption: caption,
      likes: Math.floor(Math.random() * 20) + 10,
      comments: [],
      imageUrl: null,
      altText: null,
      hasImage: false,
      explicit: false
    };
    
    gameState.socialNetwork.posts.unshift(post);
    
    // Trim posts if too many
    if (gameState.socialNetwork.posts.length > 100) {
      gameState.socialNetwork.posts = gameState.socialNetwork.posts.slice(0, 100);
    }
    
    console.log(`[Promotion Post] Generated post for ${employee.name}'s promotion to Level ${newLevel}`);
  }

  /**
   * Get the timestamp of the most recent message from an employee
   * Checks all message types: chat messages, proactive messages, images, DMs, etc.
   */
  function getLastMessageTimestamp(employeeId) {
    // Check chat history for this employee
    const chatHistory = gameState.chatHistory[employeeId];
    if (!chatHistory || chatHistory.length === 0) {
      // No chat history - use hire date as fallback so they still appear in order
      const employee = gameState.employees.find(e => e.id === employeeId);
      return employee ? (employee.hireDate || 0) : 0;
    }
    
    // Find the most recent message from the employee (not the player)
    let mostRecentTimestamp = 0;
    
    for (const message of chatHistory) {
      // Skip messages from the player
      if (message.isPlayer) continue;
      
      // Get message timestamp - handle both number and Date object formats
      let messageTimestamp = 0;
      if (message.timestamp) {
        messageTimestamp = typeof message.timestamp === 'number' ? message.timestamp : message.timestamp.getTime();
      }
      
      // Update most recent if this message is newer
      if (messageTimestamp > mostRecentTimestamp) {
        mostRecentTimestamp = messageTimestamp;
      }
    }
    
    // If no NPC messages found but chat history exists, 
    // check if there are any special message types (system messages, images, etc.)
    if (mostRecentTimestamp === 0 && chatHistory.length > 0) {
      for (const message of chatHistory) {
        if (!message.isPlayer && (message.proactive || message.isMoneyRequest || message.imageUrl || message.sender !== 'You')) {
          let messageTimestamp = 0;
          if (message.timestamp) {
            messageTimestamp = typeof message.timestamp === 'number' ? message.timestamp : message.timestamp.getTime();
          }
          
          if (messageTimestamp > mostRecentTimestamp) {
            mostRecentTimestamp = messageTimestamp;
          }
        }
      }
    }
    
    // If still no messages found, use hire date as fallback
    if (mostRecentTimestamp === 0) {
      const employee = gameState.employees.find(e => e.id === employeeId);
      return employee ? (employee.hireDate || 0) : 0;
    }
    
    return mostRecentTimestamp;
  }

  // Update People Tab with sorting and filtering
  function updatePeopleTab() {
    if (!employeesList) return;
    employeesList.innerHTML = '';
    
    // Initialize sorting settings if not exists
    if (!gameState.peopleSorting) {
      gameState.peopleSorting = {
        sortBy: 'recentMessages',
        showFavoritesOnly: false
      };
    }

    // Update employee count
    const employeeCountEl = $('employeeCount');
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (employeeCountEl) {
      employeeCountEl.textContent = `${activeEmployees.length} employee${activeEmployees.length !== 1 ? 's' : ''}`;
    }

    // Onboarding badges (always show at top)
    for (const e of gameState.onboarding) {
        const card = document.createElement('div');
        card.className = 'employee-card';
        card.style.cssText = 'background:#16213e; border-radius:10px; padding:15px; box-shadow:0 4px 10px rgba(0,0,0,0.2); position:relative;';
        card.innerHTML = `
        <div style="display:flex; align-items:center; gap:12px; margin-bottom:10px;">
            <div style="width:44px; height:44px; border-radius:50%; background:#0f3460; display:flex; align-items:center; justify-content:center;">â³</div>
            <div style="flex:1;">
            <h3 style="margin:0 0 2px 0;">${getColoredName(e)}</h3>
            <p style="margin:0; color:#aaa; font-size:.9rem;">${e.position}</p>
            <span style="display:inline-block; margin-top:6px; padding:3px 8px; font-size:.75rem; border-radius:999px; background:#0f3460; color:#fff;">Onboardingâ€¦</span>
            </div>
        </div>
        <button onclick="resetOnboarding('${e.id}')" style="width:100%; padding:8px; background:#ff6b00; border:none; border-radius:6px; color:white; cursor:pointer; font-size:.85rem; font-weight:600; margin-top:8px;">
            ğŸ”„ Reset Onboarding (Emergency)
        </button>
        `;
        employeesList.appendChild(card);
    }

    // Get active employees and filter by favorites if needed
    let employees = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    if (gameState.peopleSorting.showFavoritesOnly) {
      employees = employees.filter(e => e.isFavorite);
    }
    
    // Sort employees based on selected option
    const sortBy = gameState.peopleSorting.sortBy;
    
    // Separate favorites from non-favorites for proper ordering
    const favoriteEmployees = employees.filter(e => e.isFavorite);
    const regularEmployees = employees.filter(e => !e.isFavorite);
    
    // Sort function
    const sortEmployees = (empList) => {
      switch(sortBy) {
        case 'oldest':
          return empList.sort((a, b) => (a.hireDate || 0) - (b.hireDate || 0));
        case 'newest':
          return empList.sort((a, b) => (b.hireDate || 0) - (a.hireDate || 0));
        case 'recentMessages':
          return empList.sort((a, b) => {
            const lastMessageA = getLastMessageTimestamp(a.id);
            const lastMessageB = getLastMessageTimestamp(b.id);
            return lastMessageB - lastMessageA; // Most recent first
          });
        case 'relationshipHigh':
          return empList.sort((a, b) => {
            const avgA = calculateAverageRelationship(a);
            const avgB = calculateAverageRelationship(b);
            return avgB - avgA;
          });
        case 'relationshipLow':
          return empList.sort((a, b) => {
            const avgA = calculateAverageRelationship(a);
            const avgB = calculateAverageRelationship(b);
            return avgA - avgB;
          });
        case 'location':
          return empList.sort((a, b) => {
            const locA = a.locationId || '';
            const locB = b.locationId || '';
            return locA.localeCompare(locB);
          });
        case 'name':
          return empList.sort((a, b) => a.name.localeCompare(b.name));
        default:
          return empList;
      }
    };
    
    // Sort both lists
    sortEmployees(favoriteEmployees);
    sortEmployees(regularEmployees);
    
    // Favorites always come first, then regular employees
    const sortedEmployees = [...favoriteEmployees, ...regularEmployees];

    // Render employee cards
    for (const e of sortedEmployees) {
        
        // DEBUG: Log employee career info to help diagnose crashes
        if (!e.career || typeof e.career.level !== 'number') {
          console.warn('[updatePeopleTab] Employee missing valid career:', e.name, 'Career:', e.career);
        }
        
        const card = document.createElement('div');
        card.className = 'employee-card';
        const cardBorder = e.isFavorite ? 'border: 2px solid #ffd700;' : '';
        card.style.cssText = `background:#16213e; border-radius:10px; padding:15px; box-shadow:0 4px 10px rgba(0,0,0,0.2); ${cardBorder}`;

        const img = e.profileImage || 'https://placehold.co/80x80';
        const starColor = e.isFavorite ? '#ffd700' : '#555';
        const starText = e.isFavorite ? 'â­' : 'â˜†';

        // Get last message info for Recent Messages sort
        const lastMessageTimestamp = getLastMessageTimestamp(e.id);
        const hasRecentMessage = lastMessageTimestamp > 0 && lastMessageTimestamp !== (e.hireDate || 0);
        const timeDiff = hasRecentMessage ? Date.now() - lastMessageTimestamp : 0;
        let timeAgoText = '';
        
        if (gameState.peopleSorting.sortBy === 'recentMessages' && hasRecentMessage) {
          if (timeDiff < 60000) { // Less than 1 minute
            timeAgoText = 'Just now';
          } else if (timeDiff < 3600000) { // Less than 1 hour
            const minutes = Math.floor(timeDiff / 60000);
            timeAgoText = `${minutes}m ago`;
          } else if (timeDiff < 86400000) { // Less than 1 day
            const hours = Math.floor(timeDiff / 3600000);
            timeAgoText = `${hours}h ago`;
          } else if (timeDiff < 604800000) { // Less than 1 week
            const days = Math.floor(timeDiff / 86400000);
            timeAgoText = `${days}d ago`;
          } else {
            const weeks = Math.floor(timeDiff / 604800000);
            timeAgoText = `${weeks}w ago`;
          }
        }

        card.innerHTML = `
        <div style="display:flex; align-items:center; gap:10px; margin-bottom:12px;">
            <img src="${img}" style="width:60px; height:60px; border-radius:50%; object-fit:cover; cursor:pointer;" onclick="openUnifiedProfile('${e.id}', 'overview')">
            <div style="flex:1;">
            <h3 style="margin:0; cursor:pointer; transition:opacity 0.2s;" onclick="openUnifiedProfile('${e.id}', 'overview')" onmouseenter="this.style.opacity='0.8'" onmouseleave="this.style.opacity='1'">${getColoredName(e)}${e.age ? `, ${e.age}` : ''}</h3>
            ${timeAgoText ? `<div style="font-size:0.75rem; color:#888; margin-top:2px;">ğŸ’¬ Last message: ${timeAgoText}</div>` : ''}
            </div>
            <button onclick="toggleEmployeeFavorite('${e.id}')" style="background:none; border:none; cursor:pointer; font-size:1.5rem; padding:5px; line-height:1; color:${starColor}; transition:transform 0.2s;" onmouseover="this.style.transform='scale(1.2)'" onmouseout="this.style.transform='scale(1)'" title="${e.isFavorite ? 'Remove from favorites' : 'Add to favorites'}">${starText}</button>
        </div>

        ${e.bio ? `<p style="margin:8px 0 12px 0; color:#ddd; font-size:.95rem;">${e.bio}</p>` : ''}

        <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-bottom:12px;">
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Affection</div>
            <div style="color:#e94560; font-weight:600;">${Math.round(e.stats.affection ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Comfort</div>
            <div style="color:#4ecca3; font-weight:600;">${Math.round(e.stats.comfort ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Trust</div>
            <div style="color:#00d4ff; font-weight:600;">${Math.round(e.stats.trust ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Desire</div>
            <div style="color:#ff6b9d; font-weight:600;">${Math.round(e.stats.desire ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Obedience</div>
            <div style="color:#c77dff; font-weight:600;">${Math.round(e.stats.obedience ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Productivity</div>
            <div style="color:#ffd700; font-weight:600;">${Math.round(e.stats.productivity ?? 0)}%</div>
            </div>
        </div>

        ${(() => {
          // Show Corporate Hierarchy Level
          if (!e.career || typeof e.career.level !== 'number') return '';
          
          // Floor the level to ensure it's a valid index (handles decimal levels like 6.5)
          const levelIndex = Math.floor(e.career.level);
          
          // Clamp level to valid range (1-7)
          const clampedLevel = Math.max(1, Math.min(7, levelIndex));
          
          // Get level info with fallback chain
          let levelInfo = null;
          if (gameState.hierarchyLevels && gameState.hierarchyLevels[clampedLevel]) {
            levelInfo = gameState.hierarchyLevels[clampedLevel];
          } else if (gameState.hierarchyLevels && gameState.hierarchyLevels[1]) {
            levelInfo = gameState.hierarchyLevels[1];
          } else {
            // Ultimate fallback
            levelInfo = { title: 'Staff', color: '#4ecca3', icon: 'ğŸ‘¤', baseSalary: 40000 };
          }
          
          // Safety check: if levelInfo is still null/undefined, skip this employee
          if (!levelInfo || !levelInfo.color) {
            console.error(`[updatePeopleTab] CRITICAL: Invalid levelInfo for ${e.name}, level: ${e.career.level}, clampedLevel: ${clampedLevel}`);
            return '';
          }
          
          // Calculate time in role
          const timeInRole = gameState.date - e.career.startDate;
          
          // Check if max level (7 is the highest)
          const isMaxLevel = e.career.level >= 7;
          
          // Get promotion requirements (only if not max level)
          const nextLevel = e.career.level + 1;
          const requirements = !isMaxLevel ? getPromotionRequirements(nextLevel, e) : null;
          
          // Calculate promotion progress
          let progressPercent = 0;
          let nextLevelInfo = null;
          let progressText = '';
          
          if (!isMaxLevel && requirements) {
            const nextLevelIndex = Math.ceil(nextLevel); // Use ceil for next level to round up decimals
            nextLevelInfo = gameState.hierarchyLevels[nextLevelIndex] || gameState.hierarchyLevels[Math.floor(e.career.level) + 1] || { title: 'Next Level', color: '#00d4ff', icon: 'â¬†ï¸', baseSalary: levelInfo.baseSalary * 1.5 };
            
            // Safety check for nextLevelInfo
            if (!nextLevelInfo || !nextLevelInfo.color) {
              nextLevelInfo = { title: 'Next Level', color: '#00d4ff', icon: 'â¬†ï¸', baseSalary: levelInfo.baseSalary * 1.5 };
            }
            
            const minManagementLevel = requirements.minManagement || 0;
            
            // Calculate progress based on requirements
            const productivityProgress = Math.min((e.stats.productivity / requirements.minProductivity) * 100, 100);
            const managementProgress = minManagementLevel > 0 
              ? Math.min(((e.skills?.management?.level || 0) / minManagementLevel) * 100, 100)
              : 100;
            
            // Overall progress is the minimum of all requirements
            progressPercent = Math.min(productivityProgress, managementProgress);
            
            // Generate progress text
            const reqParts = [];
            if (productivityProgress < 100) {
              reqParts.push(`${requirements.minProductivity}% productivity`);
            }
            if (managementProgress < 100) {
              reqParts.push(`Lv${minManagementLevel} management`);
            }
            
            if (reqParts.length > 0) {
              progressText = `Needs: ${reqParts.join(', ')}`;
            } else {
              progressText = 'Ready for promotion!';
            }
          }
          
          // Get position/product info
          const positionInfo = e.position ? `${e.position}${e.productManaged ? ` â€¢ ${e.productManaged}` : ''}` : (e.productManaged ? e.productManaged : '');
          
          return `<div style="background:#0f1419; padding:12px; border-radius:6px; margin-bottom:12px; border-left:4px solid ${levelInfo.color};">
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
              <div style="display:flex; align-items:center; gap:8px;">
                <span style="font-size:1.3rem;">${levelInfo.icon}</span>
                <div>
                  <div style="font-size:.9rem; font-weight:600; color:${levelInfo.color};">${levelInfo.title}</div>
                  <div style="font-size:.75rem; color:#888;">Level ${e.career.level} â€¢ $${(levelInfo.baseSalary / 1000).toFixed(0)}K/year</div>
                  ${positionInfo ? `<div style="font-size:.7rem; color:#999; margin-top:2px;">${positionInfo}</div>` : ''}
                </div>
              </div>
              ${e.fastTrack ? `<div style="background:#ffd700; color:#0f1419; padding:4px 8px; border-radius:12px; font-size:.7rem; font-weight:700;">âš¡ FAST-TRACK</div>` : ''}
            </div>
            
            ${!isMaxLevel ? `
              <div style="margin-top:10px;">
                <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:4px;">
                  <span style="font-size:.75rem; color:#aaa;">Promotion Progress</span>
                  <span style="font-size:.75rem; color:#00d4ff; font-weight:600;">${Math.round(progressPercent)}%</span>
                </div>
                <div style="background:#0f3460; border-radius:6px; height:8px; overflow:hidden; margin-bottom:4px;">
                  <div style="background:linear-gradient(90deg, ${levelInfo.color}, ${nextLevelInfo ? nextLevelInfo.color : '#00d4ff'}); height:100%; width:${progressPercent}%; transition:width 0.5s;"></div>
                </div>
                <div style="font-size:.7rem; color:#aaa;">${progressText}</div>
                ${nextLevelInfo ? `<div style="font-size:.7rem; color:#888; margin-top:4px;">Next: ${nextLevelInfo.icon} ${nextLevelInfo.title}</div>` : ''}
              </div>
            ` : `
              <div style="margin-top:8px; padding:8px; background:rgba(255,215,0,0.1); border-radius:4px; border:1px solid rgba(255,215,0,0.3);">
                <div style="font-size:.75rem; color:#ffd700; font-weight:600; text-align:center;">ğŸ‘‘ Maximum Level Achieved</div>
              </div>
            `}
            
            ${e.career.directReports && e.career.directReports.length > 0 ? `
              <div style="margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.1);">
                <div style="font-size:.75rem; color:#aaa;">
                  <span style="font-size:.9rem; margin-right:4px;">ğŸ‘¥</span>
                  Manages ${e.career.directReports.length} employee${e.career.directReports.length !== 1 ? 's' : ''}
                </div>
              </div>
            ` : ''}
            
            ${e.career.promotionHistory && e.career.promotionHistory.length > 0 ? `
              <div style="margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.1);">
                <div style="font-size:.7rem; color:#888;">
                  ğŸ“ˆ ${e.career.promotionHistory.length} promotion${e.career.promotionHistory.length !== 1 ? 's' : ''} earned
                </div>
              </div>
            ` : ''}
          </div>`;
        })()}

        ${(() => {
          // Show active flags
          const activeFlags = getActiveFlags(e);
          if (activeFlags.length === 0) return '';
          
          const flagEmojis = {
            'condition': 'ğŸ¤°',
            'agreement': 'ğŸ’‹',
            'personality': 'ğŸ­',
            'relationship': 'ğŸ’•',
            'preference': 'â¤ï¸',
            'event': 'ğŸ“…',
            'state': 'â­',
            'custom': 'ğŸ·ï¸'
          };
          
          const priorityColors = {
            'high': '#ff3366',
            'medium': '#ffa500',
            'low': '#4ecca3'
          };
          
          // Show up to 3 flags (high priority first)
          const flagsToShow = activeFlags.slice(0, 3);
          const hasMore = activeFlags.length > 3;
          
          const flagHTML = flagsToShow.map(flag => {
            const emoji = flag.emoji || flagEmojis[flag.category] || 'ğŸ·ï¸';
            const color = priorityColors[flag.priority] || '#888';
            const description = flag.playerDescription || flag.description || flag.key || 'Unknown';
            return `<div style="display:inline-flex; align-items:center; gap:4px; background:#0f1419; padding:4px 8px; border-radius:12px; margin-right:6px; margin-bottom:6px; border-left:3px solid ${color};">
              <span style="font-size:.9rem;">${emoji}</span>
              <span style="font-size:.75rem; color:#ddd; font-weight:500;">${description}</span>
            </div>`;
          }).join('');
          
          return `<div style="background:#0f1419; padding:10px; border-radius:6px; margin-bottom:12px;">
            <div style="font-size:.8rem; color:#aaa; margin-bottom:6px; font-weight:600;">ğŸ·ï¸ Active Flags${hasMore ? ` (${activeFlags.length})` : ''}</div>
            <div style="display:flex; flex-wrap:wrap;">
              ${flagHTML}
              ${hasMore ? `<button onclick="showAllFlags('${e.id}')" style="background:#533483; border:none; padding:4px 8px; border-radius:12px; color:#ddd; font-size:.75rem; cursor:pointer; font-weight:500;">+${activeFlags.length - 3} more...</button>` : ''}
            </div>
          </div>`;
        })()}

        ${(() => {
          // Show top skills (Phase 3)
          if (!e.skills) return '';
          
          // Get top 3 skills by level
          const topSkills = Object.entries(e.skills)
            .map(([name, skill]) => ({ name, ...skill }))
            .sort((a, b) => b.level - a.level)
            .slice(0, 3);
          
          if (topSkills.length === 0 || topSkills[0].level === 0) return '';
          
          const skillEmojis = {
            'technical': 'ğŸ’»',
            'creative': 'ğŸ¨',
            'social': 'ğŸ’¬',
            'management': 'ğŸ“Š',
            'intimate': 'ğŸ’•',
            'cooking': 'ğŸ³',
            'fitness': 'ğŸ’ª'
          };
          
          const skillHTML = topSkills.map(skill => {
            const emoji = skillEmojis[skill.name] || 'â­';
            const progress = Math.round((skill.xp / skill.maxXp) * 100);
            const skillNameDisplay = skill.name.charAt(0).toUpperCase() + skill.name.slice(1);
            
            return `<div style="margin-bottom:6px;">
              <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:2px;">
                <span style="font-size:.85rem; color:#ddd;">
                  ${emoji} ${skillNameDisplay}
                </span>
                <span style="font-size:.75rem; color:#00d4ff; font-weight:600;">Lv ${skill.level}</span>
              </div>
              <div style="background:#0f3460; border-radius:3px; height:4px; overflow:hidden;">
                <div style="background:#00d4ff; height:100%; width:${progress}%; transition:width 0.3s;"></div>
              </div>
            </div>`;
          }).join('');
          
          return `<div style="background:#0f1419; padding:10px; border-radius:6px; margin-bottom:12px;">
            <div style="font-size:.8rem; color:#aaa; margin-bottom:6px; font-weight:600;">â­ Top Skills</div>
            ${skillHTML}
            ${e.specializations && e.specializations.length > 0 ? `
              <div style="margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.1);">
                <div style="font-size:.7rem; color:#999; margin-bottom:4px;">Specializations:</div>
                ${e.specializations.map(spec => 
                  `<span style="display:inline-block; background:#533483; color:#fff; padding:2px 8px; border-radius:12px; font-size:.7rem; margin-right:4px; margin-bottom:4px;">ğŸŒŸ ${spec}</span>`
                ).join('')}
              </div>
            ` : ''}
          </div>`;
        })()}

        ${(() => {
          // Show relationships with other employees
          if (!e.relationships || Object.keys(e.relationships).length === 0) return '';
          
          const relationshipTypes = {
            'friend': { emoji: 'ğŸ‘¥', color: '#4ecca3', label: 'Friend' },
            'best_friend': { emoji: 'ğŸ’š', color: '#00ff88', label: 'Best Friend' },
            'crush': { emoji: 'ğŸ’–', color: '#ff69b4', label: 'Crush' },
            'rival': { emoji: 'âš”ï¸', color: '#ff9500', label: 'Rival' },
            'enemy': { emoji: 'ğŸ’¢', color: '#e94560', label: 'Dislikes' },
            'romantic': { emoji: 'ğŸ’•', color: '#ff1493', label: 'Romantic' },
            'neutral': { emoji: 'â–', color: '#888', label: 'Coworker' }
          };
          
          // Get top 3 strongest relationships
          const topRelationships = Object.entries(e.relationships)
            .map(([targetId, rel]) => {
              const target = gameState.employees.find(emp => emp.id === targetId);
              if (!target || target.employmentStatus !== 'active') return null;
              return { targetId, rel, target };
            })
            .filter(Boolean)
            .sort((a, b) => b.rel.strength - a.rel.strength)
            .slice(0, 3);
          
          if (topRelationships.length === 0) return '';
          
          const relHTML = topRelationships.map(({rel, target}) => {
            const typeInfo = relationshipTypes[rel.type] || relationshipTypes.neutral;
            return `<div style="display:flex; align-items:center; gap:6px; font-size:.85rem;">
              <span style="font-size:1.1rem;">${typeInfo.emoji}</span>
              <span style="color:${typeInfo.color}; font-weight:600;">${target.name}</span>
              <span style="color:#888; font-size:.75rem;">(${Math.round(rel.strength)}%)</span>
            </div>`;
          }).join('');
          
          return `<div style="background:#0f1419; padding:10px; border-radius:6px; margin-bottom:12px;">
            <div style="font-size:.8rem; color:#aaa; margin-bottom:6px; font-weight:600;">ğŸ¤ Relationships</div>
            ${relHTML}
          </div>`;
        })()}

        <div style="display:flex; gap:6px; flex-wrap:wrap;">
            <button class="employee-action-btn" data-employee="${e.id}" data-action="bio" style="padding:6px 10px; background:#00d4ff; border:none; border-radius:6px; color:#0f1419; cursor:pointer; font-size:.85rem; font-weight:600;">Bio</button>
            <button class="employee-action-btn" data-employee="${e.id}" data-action="chat" style="padding:6px 10px; background:#e94560; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:.85rem; position:relative; display:flex; align-items:center; gap:6px;">
              Chat
              ${e.unreadMessages > 0 ? `<span style="position:absolute; top:-6px; right:-6px; background:#ff3366; color:white; border-radius:50%; width:20px; height:20px; display:flex; align-items:center; justify-content:center; font-size:.7rem; font-weight:700; box-shadow:0 2px 6px rgba(255,51,102,0.5);">${e.unreadMessages > 9 ? '9+' : e.unreadMessages}</span>` : ''}
            </button>
            <button class="employee-action-btn" data-employee="${e.id}" data-action="review" style="padding:6px 10px; background:#4ecca3; border:none; border-radius:6px; color:#0f1419; cursor:pointer; font-size:.85rem; font-weight:600;" title="Conduct Performance Review ($200)">ğŸ“Š Review</button>
            <button class="employee-action-btn" data-employee="${e.id}" data-action="promote" style="padding:6px 10px; background:#533483; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:.85rem;">Promote</button>
            <button class="employee-action-btn" data-employee="${e.id}" data-action="fire" style="padding:6px 10px; background:#9e2a2b; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:.85rem;">Fire</button>
        </div>
        `;

        employeesList.appendChild(card);
    }

    // action handlers
    document.querySelectorAll('.employee-action-btn').forEach(btn => {
        btn.onclick = () => handleEmployeeAction(btn.dataset.employee, btn.dataset.action);
    });

    // Add event listeners for sorting controls
    const sortSelect = document.getElementById('peopleSortSelect');
    if (sortSelect) {
      sortSelect.value = gameState.peopleSorting.sortBy;
      sortSelect.onchange = (e) => {
        gameState.peopleSorting.sortBy = e.target.value;
        updatePeopleTab();
        saveGame();
      };
    }

    const toggleFavBtn = document.getElementById('toggleFavoritesOnly');
    if (toggleFavBtn) {
      toggleFavBtn.textContent = gameState.peopleSorting.showFavoritesOnly ? 'â­ Show All' : 'â­ Show Favorites Only';
      toggleFavBtn.style.background = gameState.peopleSorting.showFavoritesOnly ? '#ffd700' : '#533483';
      toggleFavBtn.style.color = gameState.peopleSorting.showFavoritesOnly ? '#0f1419' : '#fff';
      toggleFavBtn.onclick = () => {
        gameState.peopleSorting.showFavoritesOnly = !gameState.peopleSorting.showFavoritesOnly;
        updatePeopleTab();
        saveGame();
      };
    }
    }

  
  function unlockProduct(id) {
    const p = gameState.products.find(x => x.id === id);
    if (!p) return;
    if (p.unlocked) return showNotification('Product already unlocked!');
    
    // Apply product discount from influence upgrades
    const productDiscountLevel = gameState.influenceUpgrades?.productDiscount || 0;
    const discountMultiplier = influenceUpgrades.productDiscount.effect(productDiscountLevel);
    const finalCost = Math.floor(p.unlockCost * discountMultiplier);
    
    if (gameState.cash < finalCost) return showNotification('Not enough cash to unlock this product!');
    
    gameState.cash -= finalCost;
    p.unlocked = true;
    
    showNotification(`${p.name} unlocked! You can now start selling.`);
    
    // Check if this was the last product in the location - preload boss if so
    checkAndPreloadBossImage(p.locationId);
    
    updateProductsList();
    updateBusinessTab(); // Update location cards to reflect unlock progress
    updateUI();
  }

  function startOrClickProduct(id) {
    const p = gameState.products.find(x => x.id === id);
    if (!p) return;

    if (!p.running) {
      p.running = true;
      p.timeRemainingMs = currentCycleTimeMs(p);
    } else {
      p.timeRemainingMs = Math.max(0, p.timeRemainingMs - clickReductionMs(p));
    }

    // instant feedback without a full re-render
    const sellTxt = $(`selltxt-${p.id}`);
    if (sellTxt) sellTxt.textContent = p.running ? 'Click: -1s' : 'Sell';
  }

  // Helper function to format numbers
  // ========== IMAGE GENERATION HELPER ==========
  /**
   * Applies the global image style setting to a prompt
   * @param {string|object} promptInput - Either a string prompt or an object with a prompt property
   * @returns {object} - Object with prompt property, ready for generateImage()
   */
  function applyImageStyle(promptInput) {
    // Extract the base prompt using helper function
    let basePrompt = extractText(promptInput);
    
    // Also check for .prompt property specifically (for objects with explicit prompt field)
    if (typeof promptInput === 'object' && promptInput && promptInput.prompt) {
      basePrompt = extractText(promptInput.prompt);
    }
    
    // Get the style setting
    const style = gameState.settings?.imageStyle || 'photorealistic';
    
    // Debug logging
    console.log('[Image Style] Base prompt length:', basePrompt.length, 'chars');
    console.log('[Image Style] Selected style:', style);
    
    // Define style directives - comprehensive collection of high-quality art styles
    const styleDirectives = {
      // === REALISTIC STYLES ===
      'photorealistic': 'photorealistic, professional DSLR photography, 85mm lens, f/1.4 aperture, natural lighting, high detail, 8k resolution, sharp focus, bokeh background, realistic skin texture, professional color grading, lifelike proportions',
      
      'professional': 'professional studio portrait, three-point lighting setup, seamless backdrop, commercial headshot, high-end retouching, polished composition, corporate photography, clean and refined, natural expression, business quality',
      
      'cinematic': 'cinematic movie still, dramatic volumetric lighting, film grain texture, anamorphic lens flare, Hollywood blockbuster quality, 2.39:1 aspect ratio feel, color graded with teal and orange, atmospheric depth, professional cinematography, story-driven composition',
      
      'portrait': 'fine art portrait photography, Rembrandt lighting, classical composition, gallery exhibition quality, medium format camera, rich tonal range, timeless elegance, sophisticated mood, museum-worthy, professional fine art print',
      
      'fashion': 'high fashion editorial photography, dramatic pose, runway style, Vogue magazine quality, bold lighting, designer aesthetic, glamorous composition, professional makeup and styling, contemporary fashion photography, striking presence',
      
      // === ARTISTIC STYLES ===
      'artistic': 'artistic painting style, impressionist brush strokes, oil on canvas texture, rich vibrant colors, fine art composition, museum quality, painterly detail, artistic lighting, expressive technique, masterwork quality',
      
      'watercolor': 'watercolor painting, soft wet-on-wet technique, flowing pigments, delicate color bleeds, artistic paper texture, translucent layers, dreamy atmosphere, hand-painted quality, gentle gradients, traditional medium',
      
      'oilpainting': 'classical oil painting, thick impasto brushwork, Renaissance technique, rich color palette, museum masterpiece, old masters style, detailed layering, warm lighting, timeless composition, fine art quality, textured canvas',
      
      'vintage': 'vintage 1950s pinup art style, Gil Elvgren inspiration, retro charm, classic Americana, nostalgic color palette, playful pose, golden age illustration, period-accurate fashion, wholesome glamour, mid-century aesthetic, hand-painted quality',
      
      'noir': 'film noir style, black and white photography, dramatic chiaroscuro lighting, high contrast shadows, 1940s Hollywood aesthetic, moody atmosphere, detective movie feel, cigarette smoke haze, venetian blind shadows, classic noir composition',
      
      // === STYLIZED RENDERINGS ===
      '3d': '3D rendered, Octane render engine, Cinema 4D quality, photorealistic PBR materials, subsurface scattering on skin, high-poly topology, physically-based shading, HDRI environment lighting, ray-traced reflections, ultra-detailed normal maps, 4K textures, global illumination, ambient occlusion, professional CG quality',
      
      'celshaded': 'cel-shaded 3D rendering, toon shader, bold outlines, flat color regions, anime-inspired lighting, stylized shading, video game cutscene quality, clean geometric forms, vibrant saturated colors, artistic edge detection',
      
      'anime': 'anime art style, high-quality manga illustration, detailed cel-shading, expressive large eyes, clean precise linework, Japanese animation studio quality, vibrant color palette, dynamic shading, professional character design, Kyoto Animation level detail',
      
      'cartoon': 'modern cartoon illustration, clean vector-style linework, bold expressive outlines, flat color fills with gradient accents, Pixar-inspired character design, playful proportions, appealing silhouette, contemporary animation style, friendly and approachable',
      
      'digital': 'digital illustration, professional concept art quality, Wacom tablet artwork, industry-standard rendering, fantasy game asset style, detailed painting techniques, contemporary digital artist, ArtStation portfolio quality, polished and refined',
      
      // === SPECIAL EFFECTS ===
      'fantasy': 'fantasy art illustration, magical atmosphere, ethereal lighting effects, detailed armor and clothing, mystical aura, RPG game art quality, mythical setting, glowing magical elements, epic composition, enchanted mood, professional fantasy artist quality',
      
      'scifi': 'sci-fi concept art, futuristic technology, neon accent lights, cybernetic elements, blade runner aesthetic, advanced materials, holographic displays, sleek design, professional game concept art, detailed technical rendering, speculative future setting',
      
      'neon': 'neon cyberpunk aesthetic, vibrant pink and cyan lighting, dark moody atmosphere, reflective wet surfaces, futuristic urban setting, glowing neon signs, synthwave color palette, blade runner meets tron, electric atmosphere, night city vibes',
      
      'dreamy': 'soft dreamy aesthetic, pastel color palette, gentle diffused lighting, ethereal glow, romantic atmosphere, bokeh light particles, hazy soft focus, tender mood, whimsical feeling, fairy tale quality, delicate and gentle',
      
      'custom': gameState.settings?.customStylePrompt || 'high quality, detailed'
    };
    
    // Get the directive for this style
    const directive = styleDirectives[style] || styleDirectives['photorealistic'];
    
    // Append the style directive to the prompt (avoid duplicates)
    const styledPrompt = basePrompt.toLowerCase().includes(directive.split(',')[0].toLowerCase())
      ? basePrompt
      : `${basePrompt}, ${directive}`;
    
    // Escape square brackets for Perchance (prevents "mismatch in your opening and closing square brackets" error)
    // Physical descriptions may contain brackets like [descriptive text] that need escaping
    const escapedPrompt = styledPrompt.replace(/\[/g, '\\[').replace(/\]/g, '\\]');
    
    // Show the ENDING of the prompt to confirm style was added
    console.log('[Image Style] Final prompt ending:', '...' + escapedPrompt.slice(-120));
    console.log('[Image Style] âœ… Style directive applied successfully');
    
    // Return as object (generateImage expects { prompt: '...' })
    return { prompt: escapedPrompt };
  }
  
  // Generate random employee starting stat based on HR settings
  function generateEmployeeStat(statName) {
    const range = gameState.hrSettings.startingStatRanges[statName];
    if (!range) {
      // Fallback if stat not configured
      return Math.floor(Math.random() * 31) + 30; // 30-60
    }
    return Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
  }
  
  function formatNumber(num) {
    // Abbreviated notation for all numbers >= 1000
    if (num >= 1e18) return (num / 1e18).toFixed(2) + 'Qi'; // Quintillions
    if (num >= 1e15) return (num / 1e15).toFixed(2) + 'Q';  // Quadrillions
    if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';  // Trillions
    if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';    // Billions
    if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';    // Millions
    if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';    // Thousands
    // For numbers under 1000, show up to 2 decimal places (no trailing zeros)
    if (num >= 100) return num.toFixed(0);
    if (num >= 10) return num.toFixed(1);
    return num.toFixed(2).replace(/\.?0+$/, ''); // Remove trailing zeros
  }

  // Format and style cash for top bar display with progressive enhancement
  function formatCashDisplay(cash) {
    let displayText, fontSize, color, textShadow, animation;
    
    if (cash >= 1e18) { // Quintillions (Qi)
      displayText = (cash / 1e18).toFixed(2) + 'Qi';
      fontSize = '2.2rem';
      color = '#FFD700'; // Bright gold
      textShadow = '0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.5)';
      animation = 'cash-glow-intense 2s ease-in-out infinite';
    } else if (cash >= 1e15) { // Quadrillions (Q)
      displayText = (cash / 1e15).toFixed(2) + 'Q';
      fontSize = '2rem';
      color = '#FFA500'; // Orange-gold
      textShadow = '0 0 15px rgba(255, 165, 0, 0.7), 0 0 30px rgba(255, 165, 0, 0.4)';
      animation = 'cash-glow 2.5s ease-in-out infinite';
    } else if (cash >= 1e12) { // Trillions (T)
      displayText = (cash / 1e12).toFixed(2) + 'T';
      fontSize = '1.8rem';
      color = '#FF6347'; // Tomato red
      textShadow = '0 0 10px rgba(255, 99, 71, 0.6)';
      animation = 'none';
    } else if (cash >= 1e9) { // Billions (B)
      displayText = (cash / 1e9).toFixed(2) + 'B';
      fontSize = '1.6rem';
      color = '#FF69B4'; // Hot pink
      textShadow = '0 0 8px rgba(255, 105, 180, 0.5)';
      animation = 'none';
    } else if (cash >= 1e6) { // Millions (M)
      displayText = (cash / 1e6).toFixed(2) + 'M';
      fontSize = '1.4rem';
      color = '#00D4FF'; // Cyan
      textShadow = '0 0 6px rgba(0, 212, 255, 0.4)';
      animation = 'none';
    } else if (cash >= 1e3) { // Thousands (K)
      displayText = (cash / 1e3).toFixed(2) + 'K';
      fontSize = '1.2rem';
      color = '#4ECCA3'; // Green
      textShadow = 'none';
      animation = 'none';
    } else {
      // For numbers under 1000, show clean format
      if (cash >= 100) displayText = cash.toFixed(0);
      else if (cash >= 10) displayText = cash.toFixed(1);
      else displayText = cash.toFixed(2).replace(/\.?0+$/, '');
      fontSize = '1rem';
      color = 'white';
      textShadow = 'none';
      animation = 'none';
    }
    
    return { displayText, fontSize, color, textShadow, animation };
  }
  
  // Helper to get just the display text from formatCashDisplay
  function formatCash(amount) {
    return formatCashDisplay(amount).displayText;
  }

  // Update Upgrades Tab
  function updateUpgradesTab() {
    // Update Click Power section
    const clickPowerLevel = gameState.globalUpgrades?.clickPower || 0;
    const currentEffect = 1.0 + (clickPowerLevel * 0.1); // Current effect
    const clickPowerBaseCost = gameBalance.upgradeBaseCosts.clickPower;
    const clickPowerCost = Math.floor(clickPowerBaseCost * Math.pow(2.0, clickPowerLevel));
    
    const clickPowerLevelEl = document.getElementById('clickPowerLevel');
    const clickPowerEffectEl = document.getElementById('clickPowerEffect');
    const clickPowerCostEl = document.getElementById('clickPowerCost');
    
    if (clickPowerLevelEl) clickPowerLevelEl.textContent = `Level ${clickPowerLevel}`;
    if (clickPowerEffectEl) clickPowerEffectEl.textContent = `-${currentEffect.toFixed(1)}s per click`;
    if (clickPowerCostEl) clickPowerCostEl.textContent = `$${formatNumber(clickPowerCost)}`;
    
    // Helper: Calculate income boost percentage with diminishing returns
    function calculateIncomeBoost(level) {
      // Linear formula: +10% per level, can scale to 1000%+
      // At level 1: 10%, level 5: 50%, level 10: 100%, level 50: 500%, level 100: 1000%
      return level * 10;
    }
    
    // Helper: Calculate cost reduction percentage with linear scaling (max 95% at level 19)
    function calculateCostReduction(level) {
      // Linear formula: -5% per level, caps at 95%
      // At level 1: 5%, level 5: 25%, level 10: 50%, level 19: 95%
      return Math.min(95, level * 5);
    }
    
    // Update Income Boost section
    const incomeBoostList = document.getElementById('incomeBoostList');
    if (incomeBoostList) {
      incomeBoostList.innerHTML = '';
      
      // Show buttons for all unlocked locations
      const unlockedLocations = gameState.locations.filter(loc => loc.unlocked);
      unlockedLocations.forEach(location => {
        const level = gameState.globalUpgrades?.incomeBoost?.[location.id] || 0;
        const currentBonus = calculateIncomeBoost(level);
        const nextBonus = calculateIncomeBoost(level + 1);
        const bonusDiff = nextBonus - currentBonus;
        const baseCost = gameBalance.upgradeBaseCosts.incomeBoost[location.id];
        const cost = Math.floor(baseCost * Math.pow(2.5, level));
        
        const card = document.createElement('div');
        card.style.cssText = 'background:#0f3460; padding:12px; border-radius:8px; text-align:center;';
        card.innerHTML = `
          <div style="font-weight:bold; margin-bottom:6px; font-size:0.95rem;">${location.name}</div>
          <div style="color:#4caf50; font-size:1.1rem; margin-bottom:4px;">+${currentBonus.toFixed(0)}%</div>
          <div style="color:#888; font-size:0.75rem; margin-bottom:8px;">Level ${level}</div>
          <button onclick="buyIncomeBoost('${location.id}')" style="width:100%; padding:8px; background:#16213e; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:bold; font-size:0.85rem;">
            +${bonusDiff.toFixed(0)}% for $${formatNumber(cost)}
          </button>
        `;
        incomeBoostList.appendChild(card);
      });
    }
    
    // Update Cost Reduction section
    const costReductionList = document.getElementById('costReductionList');
    if (costReductionList) {
      costReductionList.innerHTML = '';
      
      // Show buttons for all unlocked locations
      const unlockedLocations = gameState.locations.filter(loc => loc.unlocked);
      unlockedLocations.forEach(location => {
        const level = gameState.globalUpgrades?.costReduction?.[location.id] || 0;
        const currentReduction = calculateCostReduction(level);
        const nextReduction = calculateCostReduction(level + 1);
        const reductionDiff = nextReduction - currentReduction;
        const baseCost = gameBalance.upgradeBaseCosts.costReduction[location.id];
        const cost = Math.floor(baseCost * Math.pow(3.0, level));
        
        const card = document.createElement('div');
        card.style.cssText = 'background:#0f3460; padding:12px; border-radius:8px; text-align:center;';
        card.innerHTML = `
          <div style="font-weight:bold; margin-bottom:6px; font-size:0.95rem;">${location.name}</div>
          <div style="color:#ff6b6b; font-size:1.1rem; margin-bottom:4px;">-${currentReduction.toFixed(0)}%</div>
          <div style="color:#888; font-size:0.75rem; margin-bottom:8px;">Level ${level}</div>
          <button onclick="buyCostReduction('${location.id}')" style="width:100%; padding:8px; background:#16213e; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:bold; font-size:0.85rem;">
            -${reductionDiff.toFixed(0)}% for $${formatNumber(cost)}
          </button>
        `;
        costReductionList.appendChild(card);
      });
    }
    
    // Update Elite Upgrades section
    // Golden Touch
    const goldenTouchLevel = gameState.globalUpgrades?.goldenTouch || 0;
    const goldenTouchBonus = goldenTouchLevel * 5;
    const goldenTouchBaseCost = 1e18;
    const goldenTouchCost = Math.floor(goldenTouchBaseCost * Math.pow(10, goldenTouchLevel));
    
    const goldenTouchLevelEl = document.getElementById('goldenTouchLevel');
    const goldenTouchBonusEl = document.getElementById('goldenTouchBonus');
    const goldenTouchCostEl = document.getElementById('goldenTouchCost');
    
    if (goldenTouchLevelEl) goldenTouchLevelEl.textContent = `Level ${goldenTouchLevel}`;
    if (goldenTouchBonusEl) goldenTouchBonusEl.textContent = `+${goldenTouchBonus}%`;
    if (goldenTouchCostEl) goldenTouchCostEl.textContent = `$${formatNumber(goldenTouchCost)}`;
    
    // Time Dilation
    const timeDilationLevel = gameState.globalUpgrades?.timeDilation || 0;
    const timeDilationBonus = timeDilationLevel * 3;
    const timeDilationBaseCost = 5e18;
    const timeDilationCost = Math.floor(timeDilationBaseCost * Math.pow(12, timeDilationLevel));
    
    const timeDilationLevelEl = document.getElementById('timeDilationLevel');
    const timeDilationBonusEl = document.getElementById('timeDilationBonus');
    const timeDilationCostEl = document.getElementById('timeDilationCost');
    
    if (timeDilationLevelEl) timeDilationLevelEl.textContent = `Level ${timeDilationLevel}`;
    if (timeDilationBonusEl) timeDilationBonusEl.textContent = `+${timeDilationBonus}% speed`;
    if (timeDilationCostEl) timeDilationCostEl.textContent = `$${formatNumber(timeDilationCost)}`;
    
    // Empire Builder
    const empireBuilderLevel = gameState.globalUpgrades?.empireBuilder || 0;
    const empireBuilderBonus = empireBuilderLevel * 10;
    const empireBuilderBaseCost = 1e19;
    const empireBuilderCost = Math.floor(empireBuilderBaseCost * Math.pow(15, empireBuilderLevel));
    
    const empireBuilderLevelEl = document.getElementById('empireBuilderLevel');
    const empireBuilderBonusEl = document.getElementById('empireBuilderBonus');
    const empireBuilderCostEl = document.getElementById('empireBuilderCost');
    
    if (empireBuilderLevelEl) empireBuilderLevelEl.textContent = `Level ${empireBuilderLevel}`;
    if (empireBuilderBonusEl) empireBuilderBonusEl.textContent = `+${empireBuilderBonus}% productivity`;
    if (empireBuilderCostEl) empireBuilderCostEl.textContent = `$${formatNumber(empireBuilderCost)}`;
  }

  // Calculate the total cost of buying N upgrades
  // Uses geometric series: sum = a * (r^n - 1) / (r - 1)
  // where a = current cost, r = growth rate, n = number of upgrades
  function calculateBulkUpgradeCost(product, count) {
    if (count <= 0) return 0;
    if (count === 1) return product.upgradeCost;
    
    const baseCost = product.baseUpgradeCost || product.upgradeCost;
    const growth = product.costGrowth || 1.35;
    const currentLevel = product.level;
    
    // Apply location-specific cost reduction from upgrades - LINEAR SCALING
    const costReductionLevel = gameState.globalUpgrades?.costReduction?.[product.locationId] || 0;
    let reductionMultiplier = 1;
    if (costReductionLevel > 0) {
      // Linear formula: -5% per level, caps at 95% reduction (level 19)
      const reductionPercentage = Math.min(95, costReductionLevel * 5);
      reductionMultiplier = 1 - (reductionPercentage / 100);
    }
    
    // Calculate sum of costs for levels: current+1, current+2, ..., current+count
    let totalCost = 0;
    for (let i = 0; i < count; i++) {
      totalCost += baseCost * Math.pow(growth, currentLevel + i) * reductionMultiplier;
    }
    
    return Math.floor(totalCost);
  }

  // Calculate maximum affordable upgrades with current cash
  function calculateMaxAffordableUpgrades(product, cash) {
    const baseCost = product.baseUpgradeCost || product.upgradeCost;
    const growth = product.costGrowth || 1.35;
    const currentLevel = product.level;
    
    // Apply location-specific cost reduction from upgrades - LINEAR SCALING
    const costReductionLevel = gameState.globalUpgrades?.costReduction?.[product.locationId] || 0;
    let reductionMultiplier = 1;
    if (costReductionLevel > 0) {
      // Linear formula: -5% per level, caps at 95% reduction (level 19)
      const reductionPercentage = Math.min(95, costReductionLevel * 5);
      reductionMultiplier = 1 - (reductionPercentage / 100);
    }
    
    let count = 0;
    let totalCost = 0;
    
    // Keep adding upgrades until we can't afford the next one
    while (true) {
      const nextCost = baseCost * Math.pow(growth, currentLevel + count) * reductionMultiplier;
      if (totalCost + nextCost > cash) break;
      totalCost += nextCost;
      count++;
      
      // Safety cap at 1000 upgrades
      if (count >= 1000) break;
    }
    
    return { count, totalCost: Math.floor(totalCost) };
  }

  function upgradeProduct(id) {
    const p = gameState.products.find(x => x.id === id);
    if (!p) return;
    
    // Check level cap
    const MAX_LEVEL = 999;
    if (p.level >= MAX_LEVEL) {
      return showNotification(`${p.name} is at max level (${MAX_LEVEL})!`);
    }
    
    // Get upgrade count from button data attribute (set in updateProductsList)
    const btn = document.querySelector(`.upgrade-product-btn[data-id="${id}"]`);
    const upgradeCount = btn ? parseInt(btn.dataset.count) || 1 : 1;
    let totalCost = btn ? parseInt(btn.dataset.cost) || p.upgradeCost : p.upgradeCost;
    
    // Apply product discount from influence upgrades
    const productDiscountLevel = gameState.influenceUpgrades?.productDiscount || 0;
    const discountMultiplier = influenceUpgrades.productDiscount.effect(productDiscountLevel);
    totalCost = Math.floor(totalCost * discountMultiplier);
    
    if (gameState.cash < totalCost) return showNotification('Not enough cash!');
    
    // Deduct cost and apply upgrades (but cap at MAX_LEVEL)
    gameState.cash -= totalCost;
    
    // Ensure base upgrade cost is set
    if (!p.baseUpgradeCost) {
      const prevGrowth = 1.15;
      const baseEst = p.upgradeCost / Math.pow(prevGrowth, Math.max(0, (p.level - 1)));
      p.baseUpgradeCost = Math.max(1, Math.floor(baseEst));
    }
    
    // Apply upgrades but cap at max level
    const newLevel = Math.min(MAX_LEVEL, p.level + upgradeCount);
    const actualUpgrades = newLevel - p.level;
    p.level = newLevel;
    
    // Calculate new cost for next upgrade (if not at cap)
    if (p.level < MAX_LEVEL) {
      // Don't apply globalCostReduction here - it should only be applied at product initialization
      const growth = p.costGrowth || gameBalance.productCostMultiplier;
      let nextCost = p.baseUpgradeCost * Math.pow(growth, p.level);
      
      // Apply location-specific cost reduction from upgrades - LINEAR SCALING
      const costReductionLevel = gameState.globalUpgrades?.costReduction?.[p.locationId] || 0;
      if (costReductionLevel > 0) {
        // Linear formula: -5% per level, caps at 95% reduction (level 19)
        const reductionPercentage = Math.min(95, costReductionLevel * 5);
        const reductionMultiplier = 1 - (reductionPercentage / 100);
        nextCost *= reductionMultiplier;
      }
      
      p.upgradeCost = Math.floor(nextCost);
    }
    
    showNotification(`${p.name} upgraded to Lv.${p.level}${actualUpgrades > 1 ? ` (+${actualUpgrades})` : ''}${p.level >= MAX_LEVEL ? ' [MAX]' : ''}`);
    updateProductsList();
  }

    function hireOrUpgradeManager(id) {
    const p = gameState.products.find(x => x.id === id);
    if (!p) return;

    if (!p.managerHired) {
        // Always show the modal; weâ€™ll charge on selection.
        showManagerHiringModal(id);
    } else {
          // d) Block upgrading while onboarding
          if (p.managerOnboarding) {
            return showNotification('Staff onboarding in progress. Position upgrade available after onboarding completes.');
          }
        if (gameState.cash < p.managerUpgradeCost) return showNotification('Not enough cash!');
        gameState.cash -= p.managerUpgradeCost;
        p.managerLevel += 1;
        p.managerUpgradeCost = Math.floor(p.managerUpgradeCost * 1.25);
        showNotification(`${p.name} position upgraded to Lv.${p.managerLevel} - Better equipment & efficiency!`);
        updatePeopleTab();
        updateProductsList();
    }
    }


  function createOrLinkManagerNPC(product) {
    const id = `mgr_${product.id}`;
    if (gameState.employees.some(e => e.id === id)) return; // already exists
    const names = ['Jade','Morgan','Riley','Avery','Sam','Harper','Quinn','Rowan'];
    const last = ['Park','Davis','Johnson','Garcia','Smith','Lee','Kim','Patel'];
    const emp = {
      id,
      name: `${names[Math.floor(Math.random()*names.length)]} ${last[Math.floor(Math.random()*last.length)]}`,
      position: `Manager â€“ ${product.name}`,
      trait: 'Workhorse',
      personality: 'Friendly',
      stats: { 
        comfort: generateEmployeeStat('comfort'),
        affection: generateEmployeeStat('affection'),
        desire: generateEmployeeStat('desire'),
        trust: generateEmployeeStat('trust'),
        friendship: generateEmployeeStat('friendship'),
        productivity: generateEmployeeStat('productivity')
      },
      hired: true,
      level: 1,
      bio: `Keeps ${product.name} on track.`,
      employmentStatus: 'active',
      location: product.locationId || 'headquarters'
    };
    
    // Initialize social network data
    initializeEmployeeSocialData(emp);
    
    gameState.employees.push(emp);
    
    // Refresh dashboard to show new employee
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
    
    // Generate relationships with existing employees
    generateRandomRelationships(emp.id);
    
    // Generate first post
    generateFirstEmployeePost(emp).catch(err => {
      console.error('First post generation failed:', err);
    });
  }

  // Update Gifts Tab
  function updateGiftsTab() {
    // Update gift store and inventory displays
    if (typeof updateGiftStore === 'function') {
      updateGiftStore();
    }
    if (typeof updateGiftInventory === 'function') {
      updateGiftInventory();
    }
  }
  
  // Update HR Tab
  function updateHRTab() {
    // Update slider values
    const atmosphereSlider = $('atmosphereSlider');
    const atmosphereValue = $('atmosphereValue');
    const guidelinesSlider = $('guidelinesSlider');
    const guidelinesValue = $('guidelinesValue');
    const policyValue = $('policyValue');
    
    if (atmosphereSlider && atmosphereValue) {
      atmosphereSlider.value = gameState.settings.atmosphere ?? 50;
      const val = gameState.settings.atmosphere ?? 50;
      let label = 'Balanced';
      if (val < 33) label = 'Professional';
      else if (val > 66) label = 'Relaxed';
      atmosphereValue.textContent = label;
    }
    
    if (guidelinesSlider && guidelinesValue) {
      guidelinesSlider.value = gameState.settings.guidelines ?? 50;
      const val = gameState.settings.guidelines ?? 50;
      let label = 'Standard';
      if (val < 33) label = 'Reserved';
      else if (val > 66) label = 'Outgoing';
      guidelinesValue.textContent = label;
    }
    
    // Update policy buttons and label
    document.querySelectorAll('.policy-btn').forEach(btn => {
      if (btn.dataset.policy === gameState.settings.policy) {
        btn.style.background = '#e94560';
        btn.style.borderColor = '#e94560';
        btn.style.color = 'white';
      } else {
        btn.style.background = '#0f3460';
        btn.style.borderColor = '#00d4ff';
        btn.style.color = 'white';
      }
    });
    
    if (policyValue) {
      const policyLabels = {
        'professional': 'Professional',
        'casual': 'Casual',
        'open': 'Enthusiastic'
      };
      policyValue.textContent = policyLabels[gameState.settings.policy] || 'Professional';
    }
  }
  
  // ========== SOCIAL FEED FUNCTIONS ==========
  
  /**
   * Update the Social Feed tab
   */
  // Pagination state for social feed
  let feedPaginationState = {
    postsPerPage: 20, // Reduced from 50 for better performance
    currentPage: 1,
    totalPages: 1,
    pendingUpdates: new Set(), // Track posts that need updates
    updateThrottle: null, // Throttle timer for updates
    allPosts: [], // Cache of all posts for comparison
  };
  
  // Live update state for post modal
  let postModalState = {
    activePostId: null,        // Currently open post ID
    updateInterval: null,      // Interval handle for live updates
    lastCommentCount: 0,       // Last known comment count
    lastLikeCount: 0,          // Last known like count
  };

  function updateSocialTab() {
    if (gameState.activeTab !== 'social') return;
    
    updateFeedStats();
    renderSocialFeed(); // Direct render on tab load
  }
  
  /**
   * Request a smart feed update (debounced and context-aware)
   * FOR COMMENTS: Use immediate updates instead via updateCommentsSection directly
   */
  function requestSmartFeedUpdate(postId = null) {
    // If specific post needs update, track it
    if (postId) {
      feedPaginationState.pendingUpdates.add(postId);
    }
    
    // Clear existing throttle
    if (feedPaginationState.updateThrottle) {
      clearTimeout(feedPaginationState.updateThrottle);
    }
    
    // SIMPLIFIED: Just do immediate updates for posts
    // The debounce was causing comment visibility issues
    feedPaginationState.updateThrottle = setTimeout(() => {
      performSmartFeedUpdate();
    }, 50); // Reduced from 100ms to 50ms
  }
  
  /**
   * Perform smart feed update without disrupting user experience
   */
  function performSmartFeedUpdate() {
    const feedContent = $('socialFeedContent');
    if (!feedContent) return;
    
    // SIMPLIFIED: Always update posts in place, skip gentle/full render logic
    // The comment immediate updates handle the UI, this is just backup
    if (feedPaginationState.pendingUpdates.size > 0) {
      feedPaginationState.pendingUpdates.forEach(postId => {
        updatePostInPlace(postId);
      });
    }
    
    // Clear pending updates
    feedPaginationState.pendingUpdates.clear();
  }
  
  /**
   * Gentle update: only update specific elements without full re-render
   * DEPRECATED: Keeping for compatibility but not used for comments anymore
   */
  function performGentleUpdate() {
    const feedContent = $('socialFeedContent');
    if (!feedContent) return;
    
    // Get current posts
    const posts = filterAndSortPosts();
    const previousPosts = feedPaginationState.allPosts;
    
    // Check for new posts at the top
    const newPosts = [];
    for (let i = 0; i < posts.length; i++) {
      if (!previousPosts.find(p => p.id === posts[i].id)) {
        newPosts.push(posts[i]);
      } else {
        break; // Stop at first existing post
      }
    }
    
    // Show notification for new posts instead of auto-inserting
    if (newPosts.length > 0) {
      showNewPostsNotification(newPosts.length);
      feedPaginationState.allPosts = posts; // Update state for when they refresh
    }
    
    // Update existing posts in place (likes, comments)
    if (feedPaginationState.pendingUpdates.size > 0) {
      feedPaginationState.pendingUpdates.forEach(postId => {
        updatePostInPlace(postId);
      });
    }
  }
  
  /**
   * Show non-intrusive notification about new posts
   */
  function showNewPostsNotification(count) {
    const existing = $('newPostsNotification');
    if (existing) existing.remove();
    
    const notification = document.createElement('div');
    notification.id = 'newPostsNotification';
    notification.style.cssText = `
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
      color: white;
      padding: 12px 24px;
      border-radius: 24px;
      box-shadow: 0 4px 20px rgba(0, 212, 255, 0.4);
      cursor: pointer;
      z-index: 10000;
      font-weight: 600;
      font-size: 0.9rem;
      animation: slideDown 0.3s ease-out;
      transition: transform 0.2s, box-shadow 0.2s;
    `;
    notification.innerHTML = `
      <span style="margin-right: 8px;">â†‘</span>
      ${count} new post${count > 1 ? 's' : ''}
      <span style="margin-left: 8px; font-size: 0.8rem; opacity: 0.9;">â€¢ Click to view</span>
    `;
    
    notification.onclick = () => {
      const feedContent = $('socialFeedContent');
      if (feedContent) {
        feedContent.scrollTo({ top: 0, behavior: 'smooth' });
        setTimeout(() => {
          renderSocialFeed(true); // Full render at top
        }, 300);
      }
      notification.remove();
    };
    
    // Auto-hide after 8 seconds
    setTimeout(() => {
      if (notification.parentNode) {
        notification.style.opacity = '0';
        notification.style.transform = 'translateX(-50%) translateY(-20px)';
        setTimeout(() => notification.remove(), 300);
      }
    }, 8000);
    
    document.body.appendChild(notification);
  }
  
  /**
   * Update a specific post in place (likes, comments, etc)
   */
  function updatePostInPlace(postId) {
    const postEl = document.querySelector(`[data-post-id="${postId}"]`);
    if (!postEl) {
      console.warn(`[Feed Update] Could not find post element for ID: ${postId}`);
      return;
    }
    
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) {
      console.warn(`[Feed Update] Could not find post data for ID: ${postId}`);
      return;
    }
    
    console.log(`[Feed Update] Updating post ${postId} (${post.comments.length} comments)`);
    
    // Update like count
    const likeBtn = postEl.querySelector('.like-count');
    if (likeBtn) {
      const isLiked = post.likes.includes('player');
      likeBtn.innerHTML = `${isLiked ? 'â¤ï¸' : 'ğŸ¤'} ${post.likes.length}`;
      likeBtn.style.color = isLiked ? '#e94560' : '#8899a6';
    }
    
    // Update comment count
    const commentCount = postEl.querySelector('.comment-count');
    if (commentCount) {
      commentCount.innerHTML = `ğŸ’¬ ${post.comments.length}`;
    }
    
    // AGGRESSIVE FIX: ALWAYS update comments section if it exists
    // No more checking visibility - just update it
    const commentsSection = postEl.querySelector('.post-comments-section');
    if (commentsSection) {
      console.log(`[Feed Update] FORCE updating comments for post ${postId} (${post.comments.length} comments)`);
      updateCommentsSection(postEl, post);
      
      // Clear any refresh flags
      delete commentsSection.dataset.needsRefresh;
    }
  }
  
  /**
   * Update comments section without rebuilding entire post
   */
  function updateCommentsSection(postEl, post) {
    const commentsSection = postEl.querySelector('.post-comments-section');
    if (!commentsSection) return;
    
    const commentsList = commentsSection.querySelector('.comments-list');
    if (!commentsList) return;
    
    // Check if user is focused on comment input
    const commentInput = commentsSection.querySelector('textarea');
    const isFocused = commentInput && document.activeElement === commentInput;
    const inputValue = isFocused ? commentInput.value : '';
    const cursorPos = isFocused ? commentInput.selectionStart : 0;
    
    // Save scroll position
    const scrollPos = commentsSection.scrollTop;
    
    // Rebuild comments list
    commentsList.innerHTML = buildCommentsHTML(post);
    
    // Restore scroll
    commentsSection.scrollTop = scrollPos;
    
    // Restore input focus and value if user was typing
    if (isFocused && commentInput) {
      const newInput = commentsSection.querySelector('textarea');
      if (newInput) {
        newInput.value = inputValue;
        newInput.focus();
        newInput.setSelectionRange(cursorPos, cursorPos);
      }
    }
  }
  
  /**
   * Build comments HTML (extracted for reuse)
   */
  function buildCommentsHTML(post) {
    if (post.comments.length === 0) {
      return '<div style="padding: 20px; text-align: center; color: #555; font-style: italic;">No comments yet. Be the first!</div>';
    }
    
    return post.comments.map(comment => {
      const author = comment.authorId === 'player' 
        ? { name: 'You', social: { username: 'TheBoss' } }
        : gameState.employees.find(e => e.id === comment.authorId) || { name: 'Unknown', social: {} };
      
      const isPlayer = comment.authorId === 'player';
      const timeAgo = getTimeAgo(comment.timestamp);
      
      return `
        <div class="comment" style="padding: 12px; border-bottom: 1px solid #1a1a2e; display: flex; gap: 10px; ${comment.replyToCommentId ? 'margin-left: 30px; border-left: 2px solid #0f3460;' : ''}">
          <div style="flex: 1;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
              <span style="color: ${isPlayer ? '#e94560' : '#00d4ff'}; font-weight: 600; font-size: 0.9rem;">${author.name}</span>
              ${author.social?.username ? `<span style="color: #8899a6; font-size: 0.8rem;">@${author.social.username}</span>` : ''}
              <span style="color: #555; font-size: 0.75rem;">${timeAgo}</span>
            </div>
            <div style="color: #eee; font-size: 0.95rem; line-height: 1.5;">${linkifyMentions(comment.content)}</div>
          </div>
        </div>
      `;
    }).join('');
  }
  
  /**
   * Update feed statistics
   */
  function updateFeedStats() {
    const totalPostsEl = $('totalPostsCount');
    const activeUsersEl = $('activeUsersCount');
    const todayPostsEl = $('todayPostsCount');
    
    if (totalPostsEl) {
      totalPostsEl.textContent = gameState.socialNetwork.posts.length;
    }
    
    if (activeUsersEl) {
      const activeCount = gameState.employees.filter(e => e.employmentStatus === 'active').length;
      activeUsersEl.textContent = activeCount;
    }
    
    if (todayPostsEl) {
      const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000);
      const todayPosts = gameState.socialNetwork.posts.filter(p => p.timestamp > oneDayAgo).length;
      todayPostsEl.textContent = todayPosts;
    }
  }
  
  /**
   * ===== NEW SIMPLIFIED SOCIAL FEED SYSTEM =====
   * Direct rendering with no virtual scrolling
   * Posts open in modal for comments
   * Much better performance!
   */
  
  function renderSocialFeed(forceFullRender = false) {
    const feedContent = $('socialFeedContent');
    const emptyState = $('feedEmptyState');
    
    if (!feedContent) return;
    
    // Get filtered and sorted posts
    let allPosts = filterAndSortPosts();
    
    // Show empty state if no posts
    if (allPosts.length === 0) {
      feedContent.innerHTML = '';
      if (emptyState) {
        emptyState.style.display = 'block';
        // Re-append the empty state since innerHTML cleared it
        feedContent.appendChild(emptyState);
      }
      updateFeedStatsText(0, 0);
      return;
    }
    
    // Hide empty state
    if (emptyState) emptyState.style.display = 'none';
    
    // Calculate pagination
    feedPaginationState.totalPages = Math.ceil(allPosts.length / feedPaginationState.postsPerPage);
    
    // Reset to page 1 if filter/sort changed or forced
    if (forceFullRender) {
      feedPaginationState.currentPage = 1;
    }
    
    // Ensure current page is valid
    if (feedPaginationState.currentPage > feedPaginationState.totalPages) {
      feedPaginationState.currentPage = feedPaginationState.totalPages;
    }
    
    // Calculate which posts to show
    const startIndex = (feedPaginationState.currentPage - 1) * feedPaginationState.postsPerPage;
    const endIndex = startIndex + feedPaginationState.postsPerPage;
    const postsToShow = allPosts.slice(startIndex, endIndex);
    
    // Store scroll position for smooth updates
    const scrollTop = feedContent.scrollTop;
    
    // Clear and render paginated posts
    feedContent.innerHTML = '';
    
    postsToShow.forEach(post => {
      const postCard = createFeedPostCard(post);
      // CRITICAL FIX: Check if postCard is a valid DOM node before appending
      if (postCard && postCard.nodeType === Node.ELEMENT_NODE) {
        feedContent.appendChild(postCard);
      }
    });
    
    // Add pagination controls at the bottom
    const paginationDiv = createPaginationControls(allPosts.length);
    feedContent.appendChild(paginationDiv);
    
    // Update feed stats (showing X of Y posts)
    updateFeedStatsText(allPosts.length, postsToShow.length);
    
    // Restore scroll position only if not changing pages
    if (!forceFullRender && scrollTop > 0) {
      feedContent.scrollTop = scrollTop;
    } else {
      // Scroll to top when changing pages/filters
      feedContent.scrollTop = 0;
    }
  }
  
  /**
   * Create pagination controls for the feed
   */
  function createPaginationControls(totalPosts) {
    const paginationDiv = document.createElement('div');
    paginationDiv.style.cssText = 'display:flex; justify-content:center; align-items:center; gap:10px; padding:30px 20px; margin-top:20px; border-top:1px solid #2f3336;';
    
    const currentPage = feedPaginationState.currentPage;
    const totalPages = feedPaginationState.totalPages;
    
    // Previous button
    const prevBtn = document.createElement('button');
    prevBtn.textContent = 'â† Previous';
    prevBtn.disabled = currentPage === 1;
    prevBtn.style.cssText = `
      padding:10px 20px; 
      background:${currentPage === 1 ? '#2f3336' : 'linear-gradient(135deg, #00d4ff, #0099cc)'}; 
      border:none; 
      border-radius:8px; 
      color:${currentPage === 1 ? '#666' : 'white'}; 
      cursor:${currentPage === 1 ? 'not-allowed' : 'pointer'}; 
      font-weight:600;
      transition:all 0.2s;
    `;
    if (currentPage > 1) {
      prevBtn.onmouseenter = function() { this.style.transform = 'translateY(-2px)'; };
      prevBtn.onmouseleave = function() { this.style.transform = 'translateY(0)'; };
      prevBtn.onclick = () => {
        feedPaginationState.currentPage--;
        renderSocialFeed(false);
      };
    }
    
    // Page info
    const pageInfo = document.createElement('div');
    pageInfo.style.cssText = 'color:#e7e9ea; font-weight:600; padding:0 15px; font-size:0.95rem;';
    pageInfo.innerHTML = `Page <span style="color:#00d4ff;">${currentPage}</span> of <span style="color:#00d4ff;">${totalPages}</span>`;
    
    // Next button
    const nextBtn = document.createElement('button');
    nextBtn.textContent = 'Next â†’';
    nextBtn.disabled = currentPage === totalPages;
    nextBtn.style.cssText = `
      padding:10px 20px; 
      background:${currentPage === totalPages ? '#2f3336' : 'linear-gradient(135deg, #00d4ff, #0099cc)'}; 
      border:none; 
      border-radius:8px; 
      color:${currentPage === totalPages ? '#666' : 'white'}; 
      cursor:${currentPage === totalPages ? 'not-allowed' : 'pointer'}; 
      font-weight:600;
      transition:all 0.2s;
    `;
    if (currentPage < totalPages) {
      nextBtn.onmouseenter = function() { this.style.transform = 'translateY(-2px)'; };
      nextBtn.onmouseleave = function() { this.style.transform = 'translateY(0)'; };
      nextBtn.onclick = () => {
        feedPaginationState.currentPage++;
        renderSocialFeed(false);
      };
    }
    
    paginationDiv.appendChild(prevBtn);
    paginationDiv.appendChild(pageInfo);
    paginationDiv.appendChild(nextBtn);
    
    return paginationDiv;
  }
  
  /**
   * Update feed statistics in the header
   */
  /**
   * Update feed stats text (showing X of Y posts)
   */
  function updateFeedStatsText(totalPosts, visiblePosts) {
    const statsEl = $('feedStatsText');
    if (statsEl) {
      if (totalPosts === visiblePosts) {
        statsEl.textContent = `${totalPosts} post${totalPosts !== 1 ? 's' : ''}`;
      } else {
        statsEl.textContent = `Showing ${visiblePosts} of ${totalPosts} posts`;
      }
    }
  }
  
  /**
   * Create a simplified post card for the feed
   * No inline comments - click to open modal
   */
  function createFeedPostCard(post) {
    const postCard = document.createElement('div');
    postCard.className = 'social-post-card';
    postCard.dataset.postId = post.id;
    postCard.style.cssText = 'background:#16181c; border:1px solid #2f3336; border-radius:16px; padding:20px; margin-bottom:14px; box-shadow:0 1px 3px rgba(0,0,0,0.12); transition:all 0.3s ease; cursor:pointer;';
    
    // Hover effect
    postCard.onmouseenter = function() {
      this.style.background = '#1a1d21';
      this.style.borderColor = '#3f4348';
    };
    postCard.onmouseleave = function() {
      this.style.background = '#16181c';
      this.style.borderColor = '#2f3336';
    };
    
    // Click to open modal
    postCard.onclick = function(e) {
      // Don't open if clicking interactive elements
      if (e.target.tagName === 'BUTTON' || e.target.tagName === 'IMG' || e.target.closest('button')) {
        return;
      }
      openPostModal(post.id);
    };
    
    // Get author info
    const author = post.isPlayerPost ? 
      { name: 'You', profileImage: null, employmentStatus: 'active' } :
      gameState.employees.find(e => e.id === post.authorId) || { name: post.authorName, profileImage: null, employmentStatus: 'unknown' };
    
    const avatarUrl = author.profileImage || 'https://placehold.co/50x50?text=' + (author.name?.[0] || '?');
    const isAlumni = author.employmentStatus === 'alumni';
    
    // Format timestamp
    const timeAgo = formatTimeAgo(post.timestamp);
    
    // Check if boss liked this post
    const bossLiked = post.likes.includes('player');
    
    postCard.innerHTML = `
      <!-- Post Header -->
      <div style="display:flex; align-items:center; gap:14px; margin-bottom:16px;">
        <img src="${avatarUrl}" style="width:44px; height:44px; border-radius:50%; object-fit:cover; border:2px solid ${isAlumni ? '#666' : post.isPlayerPost ? '#e94560' : '#00d4ff'}; flex-shrink:0; cursor:${post.isPlayerPost ? 'default' : 'pointer'};" onclick="event.stopPropagation(); ${post.isPlayerPost ? '' : `openUnifiedProfile('${post.authorId}', 'overview')`}">
        <div style="flex:1; min-width:0;">
          <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
            <strong style="font-size:0.95rem; font-weight:600; cursor:${post.isPlayerPost ? 'default' : 'pointer'}; transition:opacity 0.2s;" ${post.isPlayerPost ? '' : `onclick="openUnifiedProfile('${post.authorId}', 'overview')" onmouseenter="this.style.opacity='0.8'" onmouseleave="this.style.opacity='1'"`}>${post.isPlayerPost ? '<span style="color:#fff;">You</span>' : getColoredName(author)}</strong>
            ${post.isPlayerPost ? `<span style="color:#e94560; font-size:0.85rem; font-weight:600;">@TheBoss</span>` : author.social?.username ? `<span style="color:#8899a6; font-size:0.85rem;">@${author.social.username}</span>` : ''}
            ${isAlumni ? '<span style="background:#555; padding:3px 10px; border-radius:12px; font-size:0.7rem; color:#ccc;">Alumni</span>' : ''}
            ${post.explicitLevel >= 1 ? '<span style="background:linear-gradient(135deg, #e94560, #d63850); padding:3px 10px; border-radius:12px; font-size:0.7rem; color:white; font-weight:600;">ğŸ”</span>' : ''}
          </div>
          <div style="color:#8899a6; font-size:0.8rem; margin-top:2px;">${timeAgo}</div>
        </div>
      </div>
      
      ${post.explicitLevel >= 3 ? `
        <div style="background:rgba(233, 69, 96, 0.15); padding:10px 14px; border-radius:8px; border-left:4px solid #e94560; margin-bottom:14px; font-size:0.85rem; color:#ff9fb3;">
          <strong style="display:flex; align-items:center; gap:6px;"><span>ğŸ”</span> Explicit Content Warning</strong>
        </div>
      ` : ''}
      
      <!-- Post Content -->
      <div style="color:#e7e9ea; line-height:1.6; margin-bottom:14px; font-size:0.95rem; word-wrap:break-word;">
        ${linkifyMentions(post.content)}
      </div>
      
      <!-- Post Image -->
      ${post.imageUrl ? `
        <div style="margin-bottom:14px; border-radius:12px; overflow:hidden; border:1px solid #2f3336; position:relative;" 
             onmouseenter="
               const btn = this.querySelector('.post-regen-btn');
               if(btn && !btn.disabled) {
                 btn.style.opacity='0.9';
               }
             "
             onmouseleave="
               const btn = this.querySelector('.post-regen-btn');
               if(btn && !btn.disabled) {
                 btn.style.opacity='0';
               }
             ">
          <img src="${post.imageUrl}" 
               onerror="this.onerror=null; this.src='https://placehold.co/600x400?text=Image+Load+Failed'; this.style.opacity='0.5';" 
               onload="this.style.opacity='1';"
               style="width:100%; height:auto; display:block; cursor:pointer; opacity:0; transition:opacity 0.3s;" 
               onclick="event.stopPropagation(); openImageViewer('${post.imageUrl}')">
          ${post.imagePrompt ? `
            <button onclick="
                      event.stopPropagation(); 
                      regeneratePostImage('${post.id}')
                    " 
                    class="post-regen-btn"
                    data-regen-post-id="${post.id}"
                    style="position:absolute !important; top:10px !important; right:10px !important; background:rgba(0,0,0,0.8) !important; backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.3) !important; color:white !important; padding:8px 14px !important; border-radius:8px !important; cursor:pointer !important; font-size:0.85rem !important; font-weight:600 !important; display:flex !important; align-items:center !important; gap:6px !important; transition:all 0.2s !important; opacity:0 !important; z-index:10 !important; box-shadow:0 4px 12px rgba(0,0,0,0.5) !important; pointer-events:auto !important;"
                    onmouseenter="
                      if(!this.disabled) {
                        this.style.opacity='1'; 
                        this.style.background='rgba(0,0,0,0.95)'; 
                        this.style.transform='scale(1.05)';
                      }
                    "
                    onmouseleave="
                      if(!this.disabled) {
                        this.style.opacity='0.9'; 
                        this.style.background='rgba(0,0,0,0.8)'; 
                        this.style.transform='scale(1)';
                      }
                    ">
              ğŸ”„ Regenerate
            </button>
          ` : ''}
        </div>
      ` : ''}
      
      <!-- Post Actions -->
      <div style="display:flex; gap:20px; padding-top:10px; border-top:1px solid #2f3336; align-items:center;">
        <!-- Reddit-style Vote Widget (replaces Like button) -->
        ${!post.isPlayerPost ? `
          <div style="display:flex; align-items:center; gap:4px; background:#0a0e14; border-radius:20px; padding:4px 6px;">
            <!-- Upvote Arrow -->
            <button onclick="event.stopPropagation(); voteOnPost('${post.id}', 'up')" 
                    style="background:transparent; border:none; padding:2px 4px; cursor:pointer; display:flex; align-items:center; transition:all 0.2s;"
                    onmouseenter="this.style.transform='scale(1.2)'"
                    onmouseleave="this.style.transform='scale(1)'">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="${post.playerVote === 'up' ? '#ff4500' : '#8899a6'}">
                <path d="M12 4l8 8h-6v8h-4v-8H4z"/>
              </svg>
            </button>
            
            <!-- Vote Count -->
            <span style="font-size:0.85rem; font-weight:600; color:${post.playerVote === 'up' ? '#ff4500' : post.playerVote === 'down' ? '#7193ff' : '#8899a6'}; min-width:24px; text-align:center;">
              ${((post.upvotes || 0) - (post.downvotes || 0)) + (post.likes.length || 0)}
            </span>
            
            <!-- Downvote Arrow -->
            <button onclick="event.stopPropagation(); voteOnPost('${post.id}', 'down')" 
                    style="background:transparent; border:none; padding:2px 4px; cursor:pointer; display:flex; align-items:center; transition:all 0.2s;"
                    onmouseenter="this.style.transform='scale(1.2)'"
                    onmouseleave="this.style.transform='scale(1)'">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="${post.playerVote === 'down' ? '#7193ff' : '#8899a6'}">
                <path d="M12 20l-8-8h6V4h4v8h6z"/>
              </svg>
            </button>
          </div>
        ` : `
          <!-- Player's own posts show NPC likes only -->
          <button onclick="event.stopPropagation(); handleLikePost('${post.id}')" style="background:transparent; border:none; color:${bossLiked ? '#e94560' : '#8899a6'}; cursor:pointer; display:flex; align-items:center; gap:6px; font-size:0.9rem; padding:8px 12px; border-radius:8px; transition:all 0.2s;" onmouseenter="this.style.background='rgba(255,255,255,0.05)'" onmouseleave="this.style.background='transparent'">
            <span style="font-size:1.1rem;">${bossLiked ? 'â¤ï¸' : 'ğŸ¤'}</span>
            <span>${post.likes.length}</span>
          </button>
        `}
        
        <!-- Comments Button -->
        <button onclick="event.stopPropagation(); openPostModal('${post.id}')" style="background:transparent; border:none; color:#8899a6; cursor:pointer; display:flex; align-items:center; gap:6px; font-size:0.9rem; padding:8px 12px; border-radius:8px; transition:all 0.2s;" onmouseenter="this.style.background='rgba(255,255,255,0.05)'" onmouseleave="this.style.background='transparent'">
          <span style="font-size:1.1rem;">ğŸ’¬</span>
          <span>${post.comments.length}</span>
        </button>
        
        <!-- NEW: More Actions Menu (nested in [...]) - Only for NPC posts -->
        ${!post.isPlayerPost ? `
          <div style="margin-left:auto; position:relative;">
            <button 
              onclick="event.stopPropagation(); togglePostActionsMenu('${post.id}')"
              id="postActionsBtn_${post.id}"
              style="background:transparent; border:1px solid #2f3336; color:#8899a6; cursor:pointer; display:flex; align-items:center; justify-content:center; font-size:1.2rem; padding:6px 12px; border-radius:6px; transition:all 0.2s; font-weight:bold; letter-spacing:2px;"
              onmouseenter="this.style.background='rgba(255,255,255,0.08)'; this.style.borderColor='#00d4ff'"
              onmouseleave="this.style.background='transparent'; this.style.borderColor='#2f3336'"
              title="More actions">
              â‹¯
            </button>
            <div 
              id="postActionsMenu_${post.id}" 
              style="display:none; position:absolute; right:0; top:calc(100% + 4px); background:#1a1d21; border:1px solid #2f3336; border-radius:12px; min-width:180px; z-index:1000; box-shadow:0 8px 24px rgba(0,0,0,0.5); overflow:hidden;">
              <!-- Send Gift -->
              <button 
                onclick="event.stopPropagation(); closePostActionsMenu(); giftOnPost('${post.id}')"
                style="width:100%; padding:12px 16px; background:transparent; border:none; color:#fff; cursor:pointer; display:flex; align-items:center; gap:10px; font-size:0.9rem; transition:all 0.15s; text-align:left;"
                onmouseenter="this.style.background='rgba(83,52,131,0.3)'"
                onmouseleave="this.style.background='transparent'">
                <span style="font-size:1.1rem;">ğŸ</span> Send Gift
              </button>
              <!-- Send Cash -->
              <button 
                onclick="event.stopPropagation(); closePostActionsMenu(); tipOnPost('${post.id}')"
                style="width:100%; padding:12px 16px; background:transparent; border:none; color:#fff; cursor:pointer; display:flex; align-items:center; gap:10px; font-size:0.9rem; transition:all 0.15s; text-align:left;"
                onmouseenter="this.style.background='rgba(78,204,163,0.3)'"
                onmouseleave="this.style.background='transparent'">
                <span style="font-size:1.1rem;">ğŸ’µ</span> Send Tip
              </button>
              <div style="border-top:1px solid #2f3336;"></div>
              <!-- Request Image -->
              <button 
                onclick="event.stopPropagation(); closePostActionsMenu(); openRequestImageModal('${post.authorId}', false)"
                style="width:100%; padding:12px 16px; background:transparent; border:none; color:#fff; cursor:pointer; display:flex; align-items:center; gap:10px; font-size:0.9rem; transition:all 0.15s; text-align:left;"
                onmouseenter="this.style.background='rgba(0,212,255,0.2)'"
                onmouseleave="this.style.background='transparent'">
                <span style="font-size:1.1rem;">ğŸ“¸</span> Request Image
              </button>
              <!-- Open Chat -->
              <button 
                onclick="event.stopPropagation(); closePostActionsMenu(); openUnifiedProfile('${post.authorId}', 'chat')"
                style="width:100%; padding:12px 16px; background:transparent; border:none; color:#fff; cursor:pointer; display:flex; align-items:center; gap:10px; font-size:0.9rem; transition:all 0.15s; text-align:left;"
                onmouseenter="this.style.background='rgba(102,126,234,0.2)'"
                onmouseleave="this.style.background='transparent'">
                <span style="font-size:1.1rem;">ğŸ’¬</span> Open Chat
              </button>
            </div>
          </div>
        ` : ''}
      </div>
    `;
    
    return postCard;
  }
  
  /**
   * Open post in modal with full comment functionality
   */
  function openPostModal(postId) {
    console.log(`[PostModal] Opening modal for post ${postId}`);
    
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) {
      console.error(`[PostModal] Post ${postId} not found!`);
      return;
    }
    
    // Store active post ID for live updates
    postModalState.activePostId = postId;
    postModalState.lastCommentCount = post.comments.length;
    postModalState.lastLikeCount = post.likes.length;
    
    console.log(`[PostModal] Initial state - Comments: ${post.comments.length}, Likes: ${post.likes.length}`);
    
    // Get author info
    const author = post.isPlayerPost ? 
      { name: 'You', profileImage: null, employmentStatus: 'active', id: 'player' } :
      gameState.employees.find(e => e.id === post.authorId) || { name: post.authorName, profileImage: null, employmentStatus: 'unknown', id: post.authorId };
    
    const avatarUrl = author.profileImage || 'https://placehold.co/50x50?text=' + (author.name?.[0] || '?');
    const isAlumni = author.employmentStatus === 'alumni';
    const timeAgo = formatTimeAgo(post.timestamp);
    const bossLiked = post.likes.includes('player');
    
    // Create modal
    const modal = document.createElement('div');
    modal.id = 'postModal';
    modal.style.background = 'rgba(0,0,0,0.85)';
    modal.style.padding = '10px';
    modal.style.overflow = 'auto';
    
    // Check if mobile for responsive sizing
    const isMobile = window.innerWidth <= 768;
    
    modal.innerHTML = `
      <div style="background:#16181c; border:1px solid #2f3336; border-radius:${isMobile ? '16px' : '20px'}; max-width:${isMobile ? '100%' : '700px'}; width:100%; max-height:${isMobile ? '95vh' : '90vh'}; height:${isMobile ? 'auto' : 'auto'}; overflow:hidden; box-shadow:0 8px 32px rgba(0,0,0,0.5); display:flex; flex-direction:column; margin:auto;">
        <!-- Modal Header -->
        <div style="padding:${isMobile ? '12px 16px' : '16px 20px'}; border-bottom:1px solid #2f3336; display:flex; justify-content:space-between; align-items:center; flex-shrink:0;">
          <h3 style="color:#fff; margin:0; font-size:${isMobile ? '1rem' : '1.1rem'}; font-weight:600;">Post</h3>
          <div style="display:flex; gap:8px; align-items:center;">
            ${post.isPlayerPost ? `
              <button onclick="editPost('${post.id}')" style="background:#1a1d23; border:1px solid #00d4ff; color:#00d4ff; cursor:pointer; font-size:0.85rem; padding:8px 14px; border-radius:8px; transition:all 0.2s; font-weight:600; display:flex; align-items:center; gap:6px;" onmouseenter="this.style.background='#00d4ff'; this.style.color='white'" onmouseleave="this.style.background='#1a1d23'; this.style.color='#00d4ff'">
                <span>âœï¸</span> ${isMobile ? '' : 'Edit'}
              </button>
            ` : `
              <button onclick="regeneratePost('${post.id}')" style="background:#1a1d23; border:1px solid #00d4ff; color:#00d4ff; cursor:pointer; font-size:0.85rem; padding:8px 14px; border-radius:8px; transition:all 0.2s; font-weight:600; display:flex; align-items:center; gap:6px;" onmouseenter="this.style.background='#00d4ff'; this.style.color='white'" onmouseleave="this.style.background='#1a1d23'; this.style.color='#00d4ff'">
                <span>ğŸ”„</span> ${isMobile ? '' : 'Regenerate'}
              </button>
            `}
            <button onclick="deletePost('${post.id}')" style="background:#1a1d23; border:1px solid #e94560; color:#e94560; cursor:pointer; font-size:0.85rem; padding:8px 14px; border-radius:8px; transition:all 0.2s; font-weight:600; display:flex; align-items:center; gap:6px;" onmouseenter="this.style.background='#e94560'; this.style.color='white'" onmouseleave="this.style.background='#1a1d23'; this.style.color='#e94560'">
              <span>ğŸ—‘ï¸</span> ${isMobile ? '' : 'Delete'}
            </button>
            <button onclick="closePostModal()" style="background:transparent; border:none; color:#8899a6; cursor:pointer; font-size:1.5rem; padding:4px 10px; border-radius:50%; transition:all 0.2s; min-width:40px; min-height:40px; display:flex; align-items:center; justify-content:center;" onmouseenter="this.style.background='rgba(255,255,255,0.1)'; this.style.color='#fff'" onmouseleave="this.style.background='transparent'; this.style.color='#8899a6'">Ã—</button>
          </div>
        </div>
        
        <!-- Post Content (Scrollable with comments) -->
        <div style="flex:1; overflow-y:auto; overflow-x:hidden; -webkit-overflow-scrolling:touch;">
          <div style="padding:${isMobile ? '16px' : '20px'}; border-bottom:1px solid #2f3336;">
            <!-- Post Header -->
          <div style="display:flex; align-items:center; gap:14px; margin-bottom:16px;">
            <img src="${avatarUrl}" style="width:44px; height:44px; border-radius:50%; object-fit:cover; border:2px solid ${isAlumni ? '#666' : post.isPlayerPost ? '#e94560' : '#00d4ff'}; flex-shrink:0; cursor:${post.isPlayerPost ? 'default' : 'pointer'};" ${post.isPlayerPost ? '' : `onclick="closePostModal(); openUnifiedProfile('${post.authorId}', 'overview')"`}>
            <div style="flex:1; min-width:0;">
              <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                <strong style="font-size:0.95rem; font-weight:600; cursor:${post.isPlayerPost ? 'default' : 'pointer'}; transition:opacity 0.2s;" ${post.isPlayerPost ? '' : `onclick="closePostModal(); openUnifiedProfile('${post.authorId}', 'overview')" onmouseenter="this.style.opacity='0.8'" onmouseleave="this.style.opacity='1'"`}>${post.isPlayerPost ? '<span style="color:#fff;">You</span>' : getColoredName(author)}</strong>
                ${post.isPlayerPost ? `<span style="color:#e94560; font-size:0.85rem; font-weight:600;">@TheBoss</span>` : author.social?.username ? `<span style="color:#8899a6; font-size:0.85rem;">@${author.social.username}</span>` : ''}
                ${isAlumni ? '<span style="background:#555; padding:3px 10px; border-radius:12px; font-size:0.7rem; color:#ccc;">Alumni</span>' : ''}
                ${post.explicitLevel >= 1 ? '<span style="background:linear-gradient(135deg, #e94560, #d63850); padding:3px 10px; border-radius:12px; font-size:0.7rem; color:white; font-weight:600;">ğŸ”</span>' : ''}
              </div>
              <div style="color:#8899a6; font-size:0.8rem; margin-top:2px;">${timeAgo}</div>
            </div>
          </div>
          
          ${post.explicitLevel >= 3 ? `
            <div style="background:rgba(233, 69, 96, 0.15); padding:10px 14px; border-radius:8px; border-left:4px solid #e94560; margin-bottom:14px; font-size:0.85rem; color:#ff9fb3;">
              <strong style="display:flex; align-items:center; gap:6px;"><span>ğŸ”</span> Explicit Content Warning</strong>
              <div style="margin-top:4px; opacity:0.9;">This post contains adult content</div>
            </div>
          ` : ''}
          
          <!-- Post Text -->
          <div style="color:#e7e9ea; line-height:1.6; margin-bottom:14px; font-size:0.95rem; word-wrap:break-word;">
            ${linkifyMentions(post.content)}
          </div>
          
          <!-- Post Image -->
          ${post.imageUrl ? `
            <div style="margin-bottom:14px; border-radius:12px; overflow:hidden; border:1px solid #2f3336; position:relative;"
                 onmouseenter="
                   const btn = this.querySelector('.modal-regen-btn');
                   if(btn && !btn.disabled) btn.style.opacity='1';
                 "
                 onmouseleave="
                   const btn = this.querySelector('.modal-regen-btn');
                   if(btn && !btn.disabled) btn.style.opacity='0.9';
                 ">
              <img src="${post.imageUrl}" style="width:100%; height:auto; display:block; cursor:pointer;" onclick="openImageViewer('${post.imageUrl}')">
              ${post.imagePrompt ? `
                <button onclick="
                          event.stopPropagation(); 
                          regeneratePostImage('${post.id}')
                        " 
                        class="modal-regen-btn"
                        data-regen-post-id="${post.id}"
                        style="position:absolute !important; top:12px !important; right:12px !important; background:rgba(0,0,0,0.8) !important; backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.3) !important; color:white !important; padding:10px 16px !important; border-radius:8px !important; cursor:pointer !important; font-size:0.9rem !important; font-weight:600 !important; display:flex !important; align-items:center !important; gap:8px !important; transition:all 0.2s !important; opacity:0.9 !important; z-index:10 !important; box-shadow:0 4px 12px rgba(0,0,0,0.5) !important; pointer-events:auto !important;"
                        onmouseenter="
                          if(!this.disabled) {
                            this.style.opacity='1'; 
                            this.style.background='rgba(0,0,0,0.95)'; 
                            this.style.transform='scale(1.05)';
                          }
                        "
                        onmouseleave="
                          if(!this.disabled) {
                            this.style.opacity='0.9'; 
                            this.style.background='rgba(0,0,0,0.8)'; 
                            this.style.transform='scale(1)';
                          }
                        ">
                  ğŸ”„ Regenerate
                </button>
              ` : ''}
            </div>
          ` : ''}
          
          <!-- Post Actions -->
          <div style="display:flex; gap:20px; padding-top:10px; border-top:1px solid #2f3336; align-items:center;">
            <!-- Reddit-style Vote Widget -->
            ${!post.isPlayerPost ? `
              <div style="display:flex; align-items:center; gap:4px; background:#0a0e14; border-radius:20px; padding:4px 6px;">
                <!-- Upvote Arrow -->
                <button onclick="voteOnPost('${post.id}', 'up')" 
                        style="background:${post.playerVote === 'up' ? 'rgba(255, 69, 0, 0.25)' : 'transparent'}; border:${post.playerVote === 'up' ? '1px solid #ff4500' : '1px solid transparent'}; padding:4px 6px; border-radius:8px; cursor:pointer; display:flex; align-items:center; transition:all 0.2s;"
                        onmouseenter="this.style.transform='scale(1.15)'"
                        onmouseleave="this.style.transform='scale(1)'">
                  <svg width="22" height="22" viewBox="0 0 24 24" fill="${post.playerVote === 'up' ? '#ff4500' : '#8899a6'}">
                    <path d="M12 4l8 8h-6v8h-4v-8H4z"/>
                  </svg>
                </button>
                
                <!-- Vote Count -->
                <span id="modalVoteCount" style="font-size:0.9rem; font-weight:700; color:${post.playerVote === 'up' ? '#ff4500' : post.playerVote === 'down' ? '#7193ff' : '#8899a6'}; min-width:28px; text-align:center;">
                  ${((post.upvotes || 0) - (post.downvotes || 0)) + (post.likes.length || 0)}
                </span>
                
                <!-- Downvote Arrow -->
                <button onclick="voteOnPost('${post.id}', 'down')" 
                        style="background:${post.playerVote === 'down' ? 'rgba(113, 147, 255, 0.25)' : 'transparent'}; border:${post.playerVote === 'down' ? '1px solid #7193ff' : '1px solid transparent'}; padding:4px 6px; border-radius:8px; cursor:pointer; display:flex; align-items:center; transition:all 0.2s;"
                        onmouseenter="this.style.transform='scale(1.15)'"
                        onmouseleave="this.style.transform='scale(1)'">
                  <svg width="22" height="22" viewBox="0 0 24 24" fill="${post.playerVote === 'down' ? '#7193ff' : '#8899a6'}">
                    <path d="M12 20l-8-8h6V4h4v8h6z"/>
                  </svg>
                </button>
              </div>
            ` : `
              <!-- Player's own posts show NPC likes only -->
              <button id="modalLikeBtn" onclick="handleLikePost('${post.id}')" style="background:transparent; border:none; color:${bossLiked ? '#e94560' : '#8899a6'}; cursor:pointer; display:flex; align-items:center; gap:6px; font-size:0.9rem; padding:8px 12px; border-radius:8px; transition:all 0.2s;" onmouseenter="this.style.background='rgba(255,255,255,0.05)'" onmouseleave="this.style.background='transparent'">
                <span id="modalLikeIcon" style="font-size:1.1rem;">${bossLiked ? 'â¤ï¸' : 'ğŸ¤'}</span>
                <span id="modalLikeCount">${post.likes.length}</span>
              </button>
            `}
            
            <!-- Comments Count -->
            <div style="color:#8899a6; display:flex; align-items:center; gap:6px; font-size:0.9rem; padding:8px 12px;">
              <span style="font-size:1.1rem;">ğŸ’¬</span>
              <span id="modalCommentCount">${post.comments.length}</span>
            </div>
          </div>
        </div>
        
        <!-- Comments Section (Inside scrollable area) -->
        <div id="modalCommentsContainer" style="padding:${isMobile ? '16px' : '20px'}; padding-top:0;">
          <!-- Comments will be rendered here -->
        </div>
        </div>
        
        <!-- Comment Input (Fixed at bottom) -->
        <div style="padding:${isMobile ? '12px 16px' : '16px 20px'}; border-top:1px solid #2f3336; background:#0d0f12; flex-shrink:0; position:relative;">
          <!-- @Mention Autocomplete Dropdown -->
          <div id="modalMentionSuggestions" style="position:absolute; bottom:100%; left:${isMobile ? '16px' : '20px'}; right:${isMobile ? '16px' : '20px'}; background:#16181c; border:1px solid #2f3336; border-radius:12px; max-height:280px; overflow-y:auto; display:none; z-index:10000; box-shadow:0 -4px 12px rgba(0,0,0,0.5); margin-bottom:8px;">
            <!-- Suggestions will be populated here -->
          </div>
          
          <div style="display:flex; gap:10px; align-items:start;">
            <textarea id="modalCommentInput" placeholder="Write a comment..." style="flex:1; background:#16181c; border:1px solid #2f3336; border-radius:12px; padding:12px; color:#e7e9ea; font-size:${isMobile ? '16px' : '0.9rem'}; resize:none; min-height:${isMobile ? '44px' : '40px'}; max-height:120px; font-family:inherit;" rows="1"></textarea>
            <button onclick="submitModalComment('${post.id}')" style="background:linear-gradient(135deg, #00d4ff, #0099cc); border:none; color:white; padding:${isMobile ? '12px 20px' : '12px 24px'}; border-radius:12px; cursor:pointer; font-weight:600; font-size:0.9rem; transition:all 0.3s; box-shadow:0 2px 8px rgba(0,212,255,0.3); min-height:${isMobile ? '44px' : 'auto'};" onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,212,255,0.4)'" onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,212,255,0.3)'">
              ${isMobile ? 'ğŸ“¤' : 'Send'}
            </button>
          </div>
        </div>
      </div>
    `;
    
    // Show modal
    ModalManager.show(modal, 'postModal');
    
    // Close on background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closePostModal();
      }
    });
    
    // Render comments
    renderModalComments(post.id);
    
    // Auto-resize textarea
    const textarea = $('modalCommentInput');
    if (textarea) {
      textarea.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = this.scrollHeight + 'px';
      });
      
      // Setup @mention autocomplete for modal input
      setupMentionAutocomplete(textarea, 'modalMentionSuggestions');
    }
    
    // Start live updates for this post
    startPostModalLiveUpdates();
  }
  
  /**
   * Close the post modal and stop live updates
   */
  function closePostModal() {
    stopPostModalLiveUpdates();
    ModalManager.close('postModal');
  }
  
  /**
   * Start live updates for the currently open post modal
   */
  function startPostModalLiveUpdates() {
    // Clear any existing interval (but keep the post ID!)
    if (postModalState.updateInterval) {
      clearInterval(postModalState.updateInterval);
      postModalState.updateInterval = null;
    }
    
    console.log(`[PostModal] Setting up live updates for post ${postModalState.activePostId}...`);
    
    // Update every 500ms for smooth real-time experience
    postModalState.updateInterval = setInterval(() => {
      updatePostModalContent();
    }, 500);
    
    console.log(`[PostModal] âœ… Live updates started - interval ID: ${postModalState.updateInterval}`);
  }
  
  /**
   * Stop live updates when modal closes
   */
  function stopPostModalLiveUpdates() {
    if (postModalState.updateInterval) {
      clearInterval(postModalState.updateInterval);
      postModalState.updateInterval = null;
      console.log('[PostModal] Stopped live updates');
    }
    postModalState.activePostId = null;
    postModalState.lastCommentCount = 0;
    postModalState.lastLikeCount = 0;
  }
  
  /**
   * Update the post modal content with latest data
   */
  function updatePostModalContent() {
    // Check if modal is still open
    if (!ModalManager.isOpen('postModal')) {
      console.log('[PostModal Live] Modal not open, stopping updates');
      stopPostModalLiveUpdates();
      return;
    }
    
    if (!postModalState.activePostId) {
      console.log('[PostModal Live] No active post ID, stopping updates');
      stopPostModalLiveUpdates();
      return;
    }
    
    const postId = postModalState.activePostId;
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    
    if (!post) {
      // Post was deleted, close modal
      console.log('[PostModal Live] Post deleted, closing modal');
      closePostModal();
      return;
    }
    
    // console.log(`[PostModal Live] âœ… Checking post ${postId}: ${post.comments.length} comments (last: ${postModalState.lastCommentCount}), ${post.likes.length} likes (last: ${postModalState.lastLikeCount})`);
    
    // Update vote buttons and count (for RLHF voting system)
    const voteCountEl = $('modalVoteCount');
    const modal = document.getElementById('postModal');
    if (voteCountEl && modal && !post.isPlayerPost) {
      // Find the vote buttons in the modal
      const upvoteBtn = modal.querySelector('[onclick*="voteOnPost"][onclick*="up"]');
      const downvoteBtn = modal.querySelector('[onclick*="voteOnPost"][onclick*="down"]');
      
      // Update vote count display
      const voteScore = ((post.upvotes || 0) - (post.downvotes || 0)) + (post.likes.length || 0);
      voteCountEl.textContent = voteScore;
      
      // Update vote count color based on player's vote
      if (post.playerVote === 'up') {
        voteCountEl.style.color = '#ff4500';
      } else if (post.playerVote === 'down') {
        voteCountEl.style.color = '#7193ff';
      } else {
        voteCountEl.style.color = '#8899a6';
      }
      
      // Update upvote button appearance
      if (upvoteBtn) {
        const upvoteSvg = upvoteBtn.querySelector('svg');
        if (post.playerVote === 'up') {
          upvoteBtn.style.background = 'rgba(255, 69, 0, 0.25)';
          upvoteBtn.style.border = '1px solid #ff4500';
          if (upvoteSvg) upvoteSvg.setAttribute('fill', '#ff4500');
        } else {
          upvoteBtn.style.background = 'transparent';
          upvoteBtn.style.border = '1px solid transparent';
          if (upvoteSvg) upvoteSvg.setAttribute('fill', '#8899a6');
        }
      }
      
      // Update downvote button appearance
      if (downvoteBtn) {
        const downvoteSvg = downvoteBtn.querySelector('svg');
        if (post.playerVote === 'down') {
          downvoteBtn.style.background = 'rgba(113, 147, 255, 0.25)';
          downvoteBtn.style.border = '1px solid #7193ff';
          if (downvoteSvg) downvoteSvg.setAttribute('fill', '#7193ff');
        } else {
          downvoteBtn.style.background = 'transparent';
          downvoteBtn.style.border = '1px solid transparent';
          if (downvoteSvg) downvoteSvg.setAttribute('fill', '#8899a6');
        }
      }
    }
    
    // Update like count and button state
    const likeCountEl = $('modalLikeCount');
    const likeIconEl = $('modalLikeIcon');
    const likeBtnEl = $('modalLikeBtn');
    
    if (likeCountEl && post.likes.length !== postModalState.lastLikeCount) {
      // Animate the count change
      likeCountEl.style.transition = 'all 0.3s ease';
      likeCountEl.style.transform = 'scale(1.3)';
      likeCountEl.textContent = post.likes.length;
      
      setTimeout(() => {
        likeCountEl.style.transform = 'scale(1)';
      }, 300);
      
      postModalState.lastLikeCount = post.likes.length;
    }
    
    // Update like button appearance
    if (likeIconEl && likeBtnEl) {
      const bossLiked = post.likes.includes('player');
      likeIconEl.textContent = bossLiked ? 'â¤ï¸' : 'ğŸ¤';
      likeBtnEl.style.color = bossLiked ? '#e94560' : '#8899a6';
    }
    
    // Update comment count
    const commentCountEl = $('modalCommentCount');
    if (commentCountEl && post.comments.length !== postModalState.lastCommentCount) {
      // Animate the count change
      commentCountEl.style.transition = 'all 0.3s ease';
      commentCountEl.style.transform = 'scale(1.3)';
      commentCountEl.textContent = post.comments.length;
      
      setTimeout(() => {
        commentCountEl.style.transform = 'scale(1)';
      }, 300);
      
      // New comments detected - re-render with smooth scroll preservation
      if (post.comments.length > postModalState.lastCommentCount) {
        const container = $('modalCommentsContainer');
        const wasAtBottom = container && (container.scrollHeight - container.scrollTop <= container.clientHeight + 100);
        
        renderModalComments(postId, true); // Pass true for smooth update
        
        // If user was at bottom, keep them there
        if (wasAtBottom && container) {
          setTimeout(() => {
            container.scrollTop = container.scrollHeight;
          }, 50);
        }
      }
      
      postModalState.lastCommentCount = post.comments.length;
    }
  }
  
  /**
   * Render comments in the post modal
   * @param {string} postId - The post ID
   * @param {boolean} smoothUpdate - If true, only add new comments without clearing existing ones
   */
  function renderModalComments(postId, smoothUpdate = false) {
    const container = $('modalCommentsContainer');
    if (!container) return;
    
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) return;
    
    if (post.comments.length === 0) {
      container.innerHTML = `
        <div style="text-align:center; padding:40px 20px; color:#8899a6;">
          <div style="font-size:2rem; margin-bottom:10px;">ğŸ’¬</div>
          <div style="font-size:0.9rem;">No comments yet</div>
          <div style="font-size:0.8rem; margin-top:4px; opacity:0.7;">Be the first to comment!</div>
        </div>
      `;
      return;
    }
    
    if (smoothUpdate) {
      // Smooth update: only add new comments
      const existingComments = container.querySelectorAll('[data-comment-id]');
      const existingIds = Array.from(existingComments).map(el => el.dataset.commentId);
      
      // If we had 0 comments before, clear the "No comments yet" message
      if (existingIds.length === 0 && post.comments.length > 0) {
        container.innerHTML = '';
      }
      
      // Add only new comments
      post.comments.forEach(comment => {
        if (!existingIds.includes(comment.id)) {
          const commentEl = createModalCommentElement(comment, postId);
          commentEl.dataset.commentId = comment.id;
          
          // Add with animation
          commentEl.style.opacity = '0';
          commentEl.style.transform = 'translateY(-10px)';
          commentEl.style.transition = 'all 0.3s ease';
          
          container.appendChild(commentEl);
          
          // Trigger animation
          setTimeout(() => {
            commentEl.style.opacity = '1';
            commentEl.style.transform = 'translateY(0)';
          }, 50);
        }
      });
    } else {
      // Full render: clear and rebuild
      container.innerHTML = '';
      
      // Render each comment
      post.comments.forEach(comment => {
        const commentEl = createModalCommentElement(comment, postId);
        commentEl.dataset.commentId = comment.id; // Add ID for tracking
        container.appendChild(commentEl);
      });
    }
  }
  
  /**
   * Create a comment element for the modal
   */
  function createModalCommentElement(comment, postId) {
    const commentEl = document.createElement('div');
    const isMobile = window.innerWidth <= 768;
    commentEl.style.cssText = `background:#1a1d21; border:1px solid #2f3336; border-radius:12px; padding:${isMobile ? '10px' : '14px'}; margin-bottom:10px;`;
    
    // Get commenter info
    const commenter = comment.isPlayerComment ? 
      { name: 'You', profileImage: null, employmentStatus: 'active' } :
      gameState.employees.find(e => e.id === comment.authorId) || { name: comment.authorName, profileImage: null, employmentStatus: 'unknown' };
    
    const avatarUrl = commenter.profileImage || 'https://placehold.co/40x40?text=' + (commenter.name?.[0] || '?');
    const isAlumni = commenter.employmentStatus === 'alumni';
    const timeAgo = formatTimeAgo(comment.timestamp);
    
    commentEl.innerHTML = `
      <div style="display:flex; gap:${isMobile ? '8px' : '10px'};">
        <img src="${avatarUrl}" style="width:${isMobile ? '28px' : '32px'}; height:${isMobile ? '28px' : '32px'}; border-radius:50%; object-fit:cover; border:2px solid ${isAlumni ? '#666' : comment.isPlayerComment ? '#e94560' : '#00d4ff'}; flex-shrink:0;">
        <div style="flex:1; min-width:0;">
          <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:4px;">
            <div style="display:flex; align-items:center; gap:6px; flex-wrap:wrap;">
              <strong style="font-size:${isMobile ? '0.8rem' : '0.85rem'}; font-weight:600;">${comment.isPlayerComment ? '<span style="color:#fff;">You</span>' : getColoredName(commenter)}</strong>
              ${comment.isPlayerComment ? `<span style="color:#e94560; font-size:${isMobile ? '0.7rem' : '0.75rem'}; font-weight:600;">@TheBoss</span>` : commenter.social?.username ? `<span style="color:#8899a6; font-size:${isMobile ? '0.7rem' : '0.75rem'};">@${commenter.social.username}</span>` : ''}
              ${isAlumni ? `<span style="background:#555; padding:2px 8px; border-radius:10px; font-size:${isMobile ? '0.6rem' : '0.65rem'}; color:#ccc;">Alumni</span>` : ''}
              <span style="color:#8899a6; font-size:${isMobile ? '0.7rem' : '0.75rem'};">${timeAgo}</span>
            </div>
            ${!comment.isPlayerComment ? `
              <button onclick="replyToComment('${comment.id}', '${commenter.name}', '${commenter.social?.username || ''}')" style="background:transparent; border:1px solid #2f3336; color:#8899a6; padding:4px 10px; border-radius:6px; font-size:${isMobile ? '0.7rem' : '0.75rem'}; cursor:pointer; transition:all 0.2s;" onmouseenter="this.style.background='rgba(0,212,255,0.1)'; this.style.borderColor='#00d4ff'; this.style.color='#00d4ff'" onmouseleave="this.style.background='transparent'; this.style.borderColor='#2f3336'; this.style.color='#8899a6'">
                Reply
              </button>
            ` : ''}
          </div>
          <div style="color:#e7e9ea; line-height:1.5; font-size:${isMobile ? '0.85rem' : '0.9rem'}; word-wrap:break-word; overflow-wrap:break-word; margin-bottom:${!comment.isPlayerComment ? '6px' : '0'};">
            ${linkifyMentions(comment.content)}
          </div>
          ${comment.imageUrl ? `
            <div style="margin:8px 0; position:relative; display:inline-block;">
              <img src="${comment.imageUrl}" alt="${comment.imageAlt || 'Comment image'}" style="max-width:100%; max-height:400px; border-radius:12px; cursor:pointer; display:block; border:1px solid #2f3336;" onclick="openImageViewer('${comment.imageUrl}')">
              ${comment.imagePrompt ? `
                <button onclick="event.stopPropagation(); regenerateCommentImage('${postId}', '${comment.id}')"
                        data-regen-comment-id="${comment.id}"
                        style="position:absolute; top:8px; right:8px; background:rgba(0,0,0,0.75); backdrop-filter:blur(8px); border:1px solid rgba(255,255,255,0.2); color:white; padding:6px 10px; border-radius:6px; cursor:pointer; font-size:0.8rem; font-weight:600; display:flex; align-items:center; gap:4px; transition:all 0.2s; opacity:0.8;"
                        onmouseenter="if(!this.disabled) { this.style.opacity='1'; this.style.background='rgba(0,0,0,0.9)'; this.style.transform='scale(1.05)'; }"
                        onmouseleave="if(!this.disabled) { this.style.opacity='0.8'; this.style.background='rgba(0,0,0,0.75)'; this.style.transform='scale(1)'; }">
                  ğŸ”„
                </button>
              ` : ''}
            </div>
          ` : ''}
          ${!comment.isPlayerComment ? `
            <div style="display:flex; align-items:center; gap:3px; background:#0a0e14; border-radius:12px; padding:2px 4px; width:fit-content;">
              <!-- Upvote Arrow -->
              <button onclick="voteOnComment('${comment.id}', 'up')" 
                      style="background:${comment.playerVote === 'up' ? 'rgba(255, 69, 0, 0.25)' : 'transparent'}; border:${comment.playerVote === 'up' ? '1px solid #ff4500' : '1px solid transparent'}; padding:3px 5px; border-radius:6px; cursor:pointer; display:flex; align-items:center; transition:all 0.2s;"
                      onmouseenter="this.style.transform='scale(1.15)'"
                      onmouseleave="this.style.transform='scale(1)'">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="${comment.playerVote === 'up' ? '#ff4500' : '#8899a6'}">
                  <path d="M12 4l8 8h-6v8h-4v-8H4z"/>
                </svg>
              </button>
              
              <!-- Vote Count -->
              <span style="font-size:0.8rem; font-weight:700; color:${comment.playerVote === 'up' ? '#ff4500' : comment.playerVote === 'down' ? '#7193ff' : '#8899a6'}; min-width:20px; text-align:center;">
                ${(comment.upvotes || 0) - (comment.downvotes || 0)}
              </span>
              
              <!-- Downvote Arrow -->
              <button onclick="voteOnComment('${comment.id}', 'down')" 
                      style="background:${comment.playerVote === 'down' ? 'rgba(113, 147, 255, 0.25)' : 'transparent'}; border:${comment.playerVote === 'down' ? '1px solid #7193ff' : '1px solid transparent'}; padding:3px 5px; border-radius:6px; cursor:pointer; display:flex; align-items:center; transition:all 0.2s;"
                      onmouseenter="this.style.transform='scale(1.15)'"
                      onmouseleave="this.style.transform='scale(1)'">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="${comment.playerVote === 'down' ? '#7193ff' : '#8899a6'}">
                  <path d="M12 20l-8-8h6V4h4v8h6z"/>
                </svg>
              </button>
            </div>
          ` : ''}
        </div>
      </div>
    `;
    
    return commentEl;
  }
  
  /**
   * Submit a comment from the modal
   */
  function submitModalComment(postId) {
    const input = $('modalCommentInput');
    if (!input) return;
    
    const content = input.value.trim();
    if (!content) return;
    
    // Add comment
    addCommentToPost(postId, content, true);
    
    // Clear input
    input.value = '';
    input.style.height = 'auto';
    
    // Re-render comments
    renderModalComments(postId);
    
    // Update comment count
    const countEl = $('modalCommentCount');
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (countEl && post) {
      countEl.textContent = post.comments.length;
      postModalState.lastCommentCount = post.comments.length;
    }
    
    // Update feed to show new comment count
    renderSocialFeed();
  }
  
  /**
   * Reply to a comment (adds @mention to input)
   */
  function replyToComment(commentId, commenterName, commenterUsername) {
    const input = $('modalCommentInput');
    if (!input) return;
    
    // Add @mention to the input
    const mention = commenterUsername ? `@${commenterUsername} ` : `@${commenterName.replace(/\s+/g, '_')} `;
    
    // If input already has content, add the mention at the beginning
    if (input.value.trim()) {
      input.value = mention + input.value;
    } else {
      input.value = mention;
    }
    
    // Focus the input
    input.focus();
    
    // Move cursor to end
    input.setSelectionRange(input.value.length, input.value.length);
    
    // Trigger resize
    input.style.height = 'auto';
    input.style.height = input.scrollHeight + 'px';
  }
  
  // ===== OLD SYSTEM REMOVED FOR CLEAN CODE =====
  
  /**
   * Filter and sort posts based on current settings
   */
  /**
   * THE ALGORITHMâ„¢ - Advanced post filtering and sorting
   */
  function filterAndSortPosts() {
    let posts = [...gameState.socialNetwork.posts];
    const algo = gameState.socialNetwork.algorithm || {};
    const now = Date.now();
    
    console.log('[Algorithm] Starting with', posts.length, 'posts');
    console.log('[Algorithm] Settings:', algo);
    
    // ========== STEP 0: FILTER OUT FIRED EMPLOYEES ==========
    // PLAYER FEEDBACK FIX: Remove posts from employees who are no longer employed
    const currentEmployeeIds = gameState.employees.map(e => e.id);
    const beforeFiredFilter = posts.length;
    posts = posts.filter(p => {
      // Keep player posts
      if (p.authorId === 'player' || p.isPlayerPost) return true;
      // Keep system posts
      if (p.authorId === 'system') return true;
      // Only keep posts from current employees
      return currentEmployeeIds.includes(p.authorId);
    });
    console.log(`[Algorithm] Filtered out ${beforeFiredFilter - posts.length} posts from fired employees`);
    
    // ========== STEP 1: CONTENT RATING FILTER ==========
    const rating = algo.contentRating || 'all';
    if (rating === 'sfw') {
      posts = posts.filter(p => p.explicitLevel === 0);
    } else if (rating === 'nsfw') {
      posts = posts.filter(p => p.explicitLevel >= 1 && p.explicitLevel <= 2);
    } else if (rating === 'explicit') {
      posts = posts.filter(p => p.explicitLevel >= 3);
    }
    console.log('[Algorithm] After content rating filter:', posts.length, 'posts');
    
    // ========== STEP 2: POST TYPE FILTER ==========
    const postType = algo.postType || 'all';
    if (postType === 'text') {
      posts = posts.filter(p => !p.imageUrl);
    } else if (postType === 'image') {
      posts = posts.filter(p => p.imageUrl);
    } else if (postType === 'selfie') {
      posts = posts.filter(p => p.type === 'selfie');
    } else if (postType === 'work') {
      posts = posts.filter(p => p.type === 'work');
    }
    console.log('[Algorithm] After post type filter:', posts.length, 'posts');
    
    // ========== STEP 3: AUTHOR FILTER ==========
    const author = algo.author || 'all';
    if (author === 'player') {
      posts = posts.filter(p => p.authorId === 'player' || p.isPlayerPost);
    } else if (author === 'following') {
      // TODO: Implement following system
      // For now, show all non-player posts
      posts = posts.filter(p => p.authorId !== 'player' && !p.isPlayerPost);
    } else if (author !== 'all') {
      // Specific employee ID
      posts = posts.filter(p => p.authorId === author);
    }
    console.log('[Algorithm] After author filter:', posts.length, 'posts');
    
    // ========== STEP 4: ENGAGEMENT FILTER ==========
    const engagement = algo.engagement || 'all';
    if (engagement === 'popular') {
      posts = posts.filter(p => {
        const reactions = (p.likes?.length || 0) + (p.upvotes || 0) - (p.downvotes || 0);
        return reactions >= 5;
      });
    } else if (engagement === 'viral') {
      posts = posts.filter(p => {
        const reactions = (p.likes?.length || 0) + (p.upvotes || 0) - (p.downvotes || 0);
        return reactions >= 20;
      });
    } else if (engagement === 'active') {
      posts = posts.filter(p => (p.comments?.length || 0) >= 5);
    }
    console.log('[Algorithm] After engagement filter:', posts.length, 'posts');
    
    // ========== STEP 5: SEARCH FILTER ==========
    const searchQuery = algo.searchQuery || '';
    if (searchQuery && searchQuery.trim()) {
      const query = searchQuery.toLowerCase();
      posts = posts.filter(p => {
        // Search in content
        if (p.content && p.content.toLowerCase().includes(query)) return true;
        
        // Search in author name
        const author = p.isPlayerPost ? 'you' : 
          gameState.employees.find(e => e.id === p.authorId)?.name?.toLowerCase();
        if (author && author.includes(query)) return true;
        
        // Search in tags
        if (p.tags && p.tags.some(tag => tag.toLowerCase().includes(query))) return true;
        
        // Search in @mentions
        if (p.mentions && p.mentions.some(m => m.toLowerCase().includes(query))) return true;
        
        return false;
      });
    }
    console.log('[Algorithm] After search filter:', posts.length, 'posts');
    
    // ========== STEP 6: APPLY SORTING ALGORITHM ==========
    const sort = algo.sort || 'hot';
    
    if (sort === 'hot') {
      // HOT Algorithm: Recent posts with high engagement rise to top
      // Formula: (upvotes - downvotes + comments * 2) / (age_in_hours + 2)^1.5
      posts.sort((a, b) => {
        const scoreA = calculateHotScore(a, now);
        const scoreB = calculateHotScore(b, now);
        return scoreB - scoreA;
      });
      
    } else if (sort === 'best') {
      // BEST Algorithm: Highest total score within time frame
      const timeFrame = algo.bestTimeFrame || 'all';
      const timeLimit = getTimeFrameLimit(timeFrame, now);
      
      // Filter by time frame first
      if (timeFrame !== 'all') {
        posts = posts.filter(p => p.timestamp >= timeLimit);
      }
      
      // Sort by score
      posts.sort((a, b) => {
        const scoreA = (a.upvotes || 0) - (a.downvotes || 0) + (a.likes?.length || 0) + (a.comments?.length || 0);
        const scoreB = (b.upvotes || 0) - (b.downvotes || 0) + (b.likes?.length || 0) + (b.comments?.length || 0);
        return scoreB - scoreA;
      });
      
    } else if (sort === 'recent') {
      // RECENT: Simple chronological
      posts.sort((a, b) => b.timestamp - a.timestamp);
      
    } else if (sort === 'controversial') {
      // CONTROVERSIAL: Posts with lots of engagement but mixed reactions
      // Formula: (total_votes) * min(upvotes, downvotes) / max(upvotes, downvotes)
      posts.sort((a, b) => {
        const scoreA = calculateControversialScore(a);
        const scoreB = calculateControversialScore(b);
        return scoreB - scoreA;
      });
    }
    
    console.log('[Algorithm] Final sorted posts:', posts.length);
    
    return posts;
  }
  
  /**
   * Calculate Hot score for a post
   */
  function calculateHotScore(post, now) {
    const ageInHours = (now - post.timestamp) / (1000 * 60 * 60);
    const upvotes = post.upvotes || 0;
    const downvotes = post.downvotes || 0;
    const likes = post.likes?.length || 0;
    const comments = post.comments?.length || 0;
    
    // Engagement score: upvotes - downvotes + likes + (comments * 2)
    const engagement = (upvotes - downvotes) + likes + (comments * 2);
    
    // Time decay: divide by (age + 2)^1.5 to prevent division by zero and smooth decay
    const timeDecay = Math.pow(ageInHours + 2, 1.5);
    
    return engagement / timeDecay;
  }
  
  /**
   * Calculate Controversial score for a post
   */
  function calculateControversialScore(post) {
    const upvotes = (post.upvotes || 0) + (post.likes?.length || 0);
    const downvotes = post.downvotes || 0;
    const comments = post.comments?.length || 0;
    
    if (upvotes === 0 && downvotes === 0) return 0;
    
    const totalVotes = upvotes + downvotes;
    const balance = upvotes < downvotes ? upvotes / downvotes : downvotes / upvotes;
    
    // Controversial score: total engagement * balance * comment boost
    return totalVotes * balance * (1 + comments * 0.5);
  }
  
  /**
   * Get time limit for Best sorting time frame
   */
  function getTimeFrameLimit(timeFrame, now) {
    switch(timeFrame) {
      case 'hour':
        return now - (60 * 60 * 1000); // 1 hour
      case 'day':
        return now - (24 * 60 * 60 * 1000); // 24 hours
      case 'week':
        return now - (7 * 24 * 60 * 60 * 1000); // 7 days
      case 'month':
        return now - (30 * 24 * 60 * 60 * 1000); // 30 days
      default:
        return 0; // All time
    }
  }
  
  /**
   * Convert @username mentions to clickable links
   */
  function linkifyMentions(text) {
    if (!text) return '';
    
    // Escape HTML first
    const escaped = escapeHtml(text);
    
    // Replace @username with clickable spans
    return escaped.replace(/@(\w+)/g, (match, username) => {
      // Check if it's @TheBoss (the player)
      if (username.toLowerCase() === 'theboss') {
        return `<span style="color:#e94560; cursor:default; font-weight:700; text-shadow:0 0 8px rgba(233,69,96,0.4);">@TheBoss</span>`;
      }
      
      // Find employee with this username
      const employee = gameState.employees.find(e => e.social?.username === username);
      if (employee) {
        return `<span style="color:#00d4ff; cursor:pointer; font-weight:600; transition:color 0.2s;" onclick="showEmployeeProfile('${employee.id}')" onmouseenter="this.style.color='#fff'; this.style.textDecoration='underline'" onmouseleave="this.style.color='#00d4ff'; this.style.textDecoration='none'">@${username}</span>`;
      }
      // If no employee found, just style it
      return `<span style="color:#00d4ff;">@${username}</span>`;
    });
  }
  
  // ===== OLD createPostElement REMOVED =====
  
  /**
   * Create comment HTML
   */
  function createCommentHTML(comment, postId) {
    const author = gameState.employees.find(e => e.id === comment.authorId) || 
                   { name: comment.authorName, profileImage: null };
    const avatarUrl = author.profileImage || 'https://placehold.co/32x32?text=' + (author.name?.[0] || '?');
    const timeAgo = formatTimeAgo(comment.timestamp);
    const isPlayer = comment.authorId === 'player';
    
    // Reply indicator if this is a reply
    let replyIndicator = '';
    if (comment.replyToCommentId && gameState.socialNetwork?.posts) {
      const replyToComment = gameState.socialNetwork.posts.flatMap(p => p.comments || []).find(c => c.id === comment.replyToCommentId);
      if (replyToComment) {
        replyIndicator = `<div style="color:#8899a6; font-size:0.82rem; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
          <span style="color:#71767b;">â†ª</span> Replying to <strong style="color:#00d4ff;">@${replyToComment.authorName}</strong>
        </div>`;
      }
    }
    
    return `
      <div class="comment-item" data-comment-id="${comment.id}" style="display:flex; gap:12px; margin-bottom:12px; padding:10px; background:#0d0f12; border-radius:12px; border:1px solid #1a1d23;">
        <img src="${avatarUrl}" style="width:36px; height:36px; border-radius:50%; object-fit:cover; flex-shrink:0; cursor:${isPlayer ? 'default' : 'pointer'};" ${isPlayer ? '' : `onclick="showEmployeeProfile('${comment.authorId}')"`}>
        <div style="flex:1; min-width:0;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; gap:8px;">
            <div style="display:flex; align-items:center; gap:6px;">
              <strong style="font-size:0.88rem; font-weight:600; cursor:${isPlayer ? 'default' : 'pointer'}; transition:opacity 0.2s;" ${isPlayer ? '' : `onclick="openUnifiedProfile('${comment.authorId}', 'overview')" onmouseenter="this.style.opacity='0.8'" onmouseleave="this.style.opacity='1'"`}>${isPlayer ? '<span style="color:#00d4ff;">You</span>' : getColoredName(author)}</strong>
              ${isPlayer ? `<span style="color:#8899a6; font-size:0.75rem;">@TheBoss</span>` : author.social?.username ? `<span style="color:#8899a6; font-size:0.75rem;">@${author.social.username}</span>` : ''}
            </div>
            <span style="color:#71767b; font-size:0.78rem; white-space:nowrap;">${timeAgo}</span>
          </div>
          ${replyIndicator}
          <p style="color:#e7e9ea; margin:0 0 8px 0; font-size:0.9rem; line-height:1.5; word-wrap:break-word;">${linkifyMentions(comment.content)}</p>
          ${comment.imageUrl ? `
            <div style="margin:8px 0;">
              <img src="${comment.imageUrl}" alt="${comment.imageAlt || 'Comment image'}" style="max-width:100%; max-height:400px; border-radius:12px; cursor:pointer; display:block; border:1px solid #1a1d23;" onclick="openImageViewer('${comment.imageUrl}')">
            </div>
          ` : ''}
          <div style="display:flex; gap:12px; align-items:center;">
            <button class="reply-to-comment-btn" data-post-id="${postId}" data-comment-id="${comment.id}" data-author-name="${comment.authorName}" data-author-id="${comment.authorId}" data-author-username="${isPlayer ? 'TheBoss' : (author.social?.username || '')}" style="background:transparent; border:none; color:#8899a6; font-size:0.82rem; cursor:pointer; padding:2px 8px; transition:color 0.2s;" onmouseenter="this.style.color='#00d4ff'" onmouseleave="this.style.color='#8899a6'">
              â†ª Reply
            </button>
            ${isPlayer ? `
              <button onclick="editComment('${postId}', '${comment.id}')" style="background:transparent; border:none; color:#8899a6; font-size:0.82rem; cursor:pointer; padding:2px 8px; transition:color 0.2s;" onmouseenter="this.style.color='#00d4ff'" onmouseleave="this.style.color='#8899a6'">
                âœï¸ Edit
              </button>
            ` : `
              <button onclick="regenerateComment('${postId}', '${comment.id}')" style="background:transparent; border:none; color:#8899a6; font-size:0.82rem; cursor:pointer; padding:2px 8px; transition:color 0.2s;" onmouseenter="this.style.color='#00d4ff'" onmouseleave="this.style.color='#8899a6'">
                ğŸ”„ Regenerate
              </button>
            `}
            <button onclick="deleteComment('${postId}', '${comment.id}')" style="background:transparent; border:none; color:#e94560; font-size:0.82rem; cursor:pointer; padding:2px 8px; transition:color 0.2s;" onmouseenter="this.style.color='#ff6b86'" onmouseleave="this.style.color='#e94560'">
              ğŸ—‘ï¸ Delete
            </button>
          </div>
        </div>
      </div>
    `;
  }
  
  /**
   * Format timestamp to relative time
   */
  function formatTimeAgo(timestamp) {
    const seconds = Math.floor((Date.now() - timestamp) / 1000);
    
    if (seconds < 60) return 'Just now';
    if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
    if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
    if (seconds < 604800) return Math.floor(seconds / 86400) + 'd ago';
    if (seconds < 2592000) return Math.floor(seconds / 604800) + 'w ago';
    return Math.floor(seconds / 2592000) + 'mo ago';
  }
  
  /**
   * Escape HTML to prevent XSS
   */
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  /**
   * Open image viewer (lightbox)
   */
  function openImageViewer(imageUrl) {
    const viewer = document.createElement('div');
    viewer.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:999999; display:flex; justify-content:center; align-items:center; cursor:pointer;';
    viewer.innerHTML = `<img src="${imageUrl}" style="max-width:90%; max-height:90%; border-radius:10px;">`;
    viewer.onclick = () => viewer.remove();
    document.body.appendChild(viewer);
  }
  
  /**
   * Show employee profile modal
   */
  function showEmployeeProfile(employeeId) {
    if (!employeeId || employeeId === 'player') return;
    
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    // Get profile data
    const social = employee.social;
    const avatarUrl = employee.profileImage || `https://placehold.co/120x120?text=${employee.name[0]}`;
    const isAlumni = employee.employmentStatus === 'alumni';
    
    // Get all posts by this employee
    const employeePosts = gameState.socialNetwork.posts.filter(p => p.authorId === employeeId);
    
    // Get mentions of this employee
    const mentions = gameState.socialNetwork.posts.filter(p => {
      if (!social.username) return false;
      return p.content && p.content.includes(`@${social.username}`);
    });
    
    // Get relationships
    const relationships = social.relationships || [];
    
    // Calculate stats
    const stats = {
      posts: employeePosts.length,
      likes: employeePosts.reduce((sum, p) => sum + p.likes.length, 0),
      comments: employeePosts.reduce((sum, p) => sum + p.comments.length, 0),
      mentions: mentions.length,
      followers: gameState.employees.filter(e => 
        e.social?.relationships?.some(r => r.employeeId === employeeId && r.relationshipType !== 'unknown')
      ).length,
      joinDate: social.joinDate ? new Date(social.joinDate).toLocaleDateString() : 'Unknown'
    };
    
    // Create modal
    const modal = document.createElement('div');
    modal.id = 'profileModal';
    // Don't set inline z-index and positioning - ModalManager will handle it
    modal.style.background = 'rgba(0,0,0,0.85)';
    modal.style.padding = '20px';
    modal.style.overflow = 'auto';
    
    modal.innerHTML = `
      <div style="background:#16181c; border:1px solid #2f3336; border-radius:20px; max-width:800px; width:100%; max-height:90vh; overflow:auto; box-shadow:0 8px 32px rgba(0,0,0,0.5);">
        <!-- Close button -->
        <div style="position:sticky; top:0; background:#16181c; padding:16px 20px; border-bottom:1px solid #2f3336; display:flex; justify-content:space-between; align-items:center; z-index:10;">
          <h3 style="color:#fff; margin:0; font-size:1.1rem; font-weight:600;">Profile</h3>
          <button onclick="ModalManager.close('profileModal')" style="background:transparent; border:none; color:#8899a6; cursor:pointer; font-size:1.5rem; padding:4px 10px; border-radius:50%; transition:all 0.2s;" onmouseenter="this.style.background='rgba(255,255,255,0.1)'; this.style.color='#fff'" onmouseleave="this.style.background='transparent'; this.style.color='#8899a6'">Ã—</button>
        </div>
        
        <!-- Profile Header -->
        <div style="padding:24px 20px; border-bottom:1px solid #2f3336;">
          <div style="display:flex; gap:20px; align-items:start; margin-bottom:20px;">
            <img src="${avatarUrl}" style="width:100px; height:100px; border-radius:50%; border:3px solid ${isAlumni ? '#666' : '#00d4ff'}; object-fit:cover;">
            <div style="flex:1;">
              <div style="display:flex; align-items:center; gap:10px; margin-bottom:8px;">
                <h2 style="margin:0; font-size:1.5rem; font-weight:600;">${getColoredName(employee)}</h2>
                ${isAlumni ? '<span style="background:#555; padding:4px 12px; border-radius:14px; font-size:0.75rem; color:#ccc; font-weight:600;">Alumni</span>' : ''}
              </div>
              ${social.username ? `<div style="color:#8899a6; font-size:1rem; margin-bottom:12px;">@${social.username}</div>` : ''}
              ${social.bio ? `<p style="color:#e7e9ea; margin:0 0 12px 0; line-height:1.5;">${social.bio}</p>` : ''}
              
              <!-- Career Info & Actions -->
              <div style="display:flex; gap:12px; align-items:center; margin-bottom:12px; flex-wrap:wrap;">
                ${employee.career ? `
                  <div style="background:#0f3460; padding:6px 14px; border-radius:8px; border:1px solid #00d4ff;">
                    <span style="color:#00d4ff; font-size:0.85rem; font-weight:600;">${employee.career.title || 'Employee'}</span>
                    <span style="color:#8899a6; font-size:0.75rem; margin-left:6px;">â€¢ Level ${employee.career.level || 1}</span>
                  </div>
                ` : ''}
                ${!isAlumni ? (() => {
                  const canPromoteCheck = typeof window.canPromoteEmployee === 'function' ? window.canPromoteEmployee(employee) : false;
                  return `
                    <button 
                      id="profilePromoteBtn_${employeeId}"
                      data-employee-id="${employeeId}"
                      style="padding:8px 16px; background:${canPromoteCheck ? 'linear-gradient(135deg, #4ecca3, #38f9d7)' : '#555'}; border:none; border-radius:8px; color:${canPromoteCheck ? '#000' : '#999'}; font-weight:600; font-size:0.85rem; cursor:${canPromoteCheck ? 'pointer' : 'not-allowed'}; transition:all 0.2s; box-shadow:${canPromoteCheck ? '0 2px 8px rgba(78,204,163,0.3)' : 'none'};"
                      ${!canPromoteCheck ? 'disabled' : ''}
                    >
                      ${canPromoteCheck ? 'â¬†ï¸ Promote' : 'ğŸ”’ Not Eligible'}
                    </button>
                  `;
                })() : ''}
              </div>
              
              <!-- Stats -->
              <div style="display:flex; gap:24px; margin-top:16px;">
                <div style="text-align:center;">
                  <div style="color:#fff; font-weight:700; font-size:1.2rem;">${stats.posts}</div>
                  <div style="color:#8899a6; font-size:0.8rem;">Posts</div>
                </div>
                <div style="text-align:center;">
                  <div style="color:#e94560; font-weight:700; font-size:1.2rem;">${stats.likes}</div>
                  <div style="color:#8899a6; font-size:0.8rem;">Likes</div>
                </div>
                <div style="text-align:center;">
                  <div style="color:#00d4ff; font-weight:700; font-size:1.2rem;">${stats.mentions}</div>
                  <div style="color:#8899a6; font-size:0.8rem;">Mentions</div>
                </div>
                <div style="text-align:center;">
                  <div style="color:#fff; font-weight:700; font-size:1.2rem;">${stats.followers}</div>
                  <div style="color:#8899a6; font-size:0.8rem;">Connections</div>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Tabs -->
        <div style="display:flex; border-bottom:1px solid #2f3336; background:#0d0f12;">
          <button class="profile-tab" data-tab="posts" style="flex:1; padding:16px; background:transparent; border:none; color:#8899a6; cursor:pointer; font-weight:600; border-bottom:3px solid transparent; transition:all 0.2s;">
            ğŸ“ Their Posts (${stats.posts})
          </button>
          <button class="profile-tab" data-tab="mentions" style="flex:1; padding:16px; background:transparent; border:none; color:#8899a6; cursor:pointer; font-weight:600; border-bottom:3px solid transparent; transition:all 0.2s;">
            @ Mentions (${stats.mentions})
          </button>
          <button class="profile-tab" data-tab="friends" style="flex:1; padding:16px; background:transparent; border:none; color:#8899a6; cursor:pointer; font-weight:600; border-bottom:3px solid transparent; transition:all 0.2s;">
            â¤ï¸ Friends (${stats.followers})
          </button>
          <button class="profile-tab" data-tab="about" style="flex:1; padding:16px; background:transparent; border:none; color:#8899a6; cursor:pointer; font-weight:600; border-bottom:3px solid transparent; transition:all 0.2s;">
            â„¹ï¸ About
          </button>
        </div>
        
        <!-- Tab Content -->
        <div id="profileTabContent" style="padding:20px; min-height:300px; max-height:500px; overflow-y:auto;">
          <!-- Content will be loaded here -->
        </div>
      </div>
    `;
    
    // Use ModalManager to show the modal
    ModalManager.show(modal, 'profileModal');
    
    // Close on background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) ModalManager.close('profileModal');
    });
    
    // Tab switching
    const tabs = modal.querySelectorAll('.profile-tab');
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // Update tab styles
        tabs.forEach(t => {
          t.style.color = '#8899a6';
          t.style.borderBottomColor = 'transparent';
          t.style.background = 'transparent';
        });
        tab.style.color = '#00d4ff';
        tab.style.borderBottomColor = '#00d4ff';
        tab.style.background = 'rgba(0, 212, 255, 0.05)';
        
        // Load tab content
        loadProfileTab(tab.dataset.tab, employeeId, modal);
      });
      
      // Hover effects
      tab.addEventListener('mouseenter', () => {
        if (tab.style.color !== 'rgb(0, 212, 255)') {
          tab.style.background = 'rgba(255,255,255,0.05)';
        }
      });
      tab.addEventListener('mouseleave', () => {
        if (tab.style.color !== 'rgb(0, 212, 255)') {
          tab.style.background = 'transparent';
        }
      });
    });
    
    // Load first tab by default
    tabs[0].click();
  }
  
  /**
   * Load profile tab content
   */
  function loadProfileTab(tab, employeeId, modal) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    const contentDiv = modal.querySelector('#profileTabContent');
    if (!contentDiv) return;
    
    const social = employee.social;
    
    if (tab === 'posts') {
      // Show all posts by this employee
      const employeePosts = gameState.socialNetwork.posts
        .filter(p => p.authorId === employeeId)
        .sort((a, b) => b.timestamp - a.timestamp);
      
      if (employeePosts.length === 0) {
        contentDiv.innerHTML = `
          <div style="text-align:center; padding:60px 20px; color:#8899a6;">
            <div style="font-size:3rem; margin-bottom:12px;">ğŸ“­</div>
            <div style="font-size:1.1rem; margin-bottom:6px;">No posts yet</div>
            <div style="font-size:0.9rem; opacity:0.7;">This user hasn't posted anything yet</div>
          </div>
        `;
      } else {
        contentDiv.innerHTML = employeePosts.map(post => {
          const timeAgo = formatTimeAgo(post.timestamp);
          return `
            <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:16px; margin-bottom:12px;">
              <div style="color:#8899a6; font-size:0.8rem; margin-bottom:10px;">${timeAgo}</div>
              ${post.content ? `<p style="color:#e7e9ea; margin:0 0 10px 0; line-height:1.6; white-space:pre-wrap;">${linkifyMentions(post.content)}</p>` : ''}
              ${post.imageUrl ? `<img src="${post.imageUrl}" style="width:100%; border-radius:8px; margin-top:10px; object-fit:contain; max-height:400px; background:#000; cursor:pointer;" onclick="openImageViewer('${post.imageUrl}')">` : ''}
              <div style="display:flex; gap:20px; margin-top:12px; padding-top:12px; border-top:1px solid rgba(255,255,255,0.05); font-size:0.85rem;">
                <span style="color:#e94560;">â¤ï¸ ${post.likes.length}</span>
                <span style="color:#00d4ff;">ğŸ’¬ ${post.comments.length}</span>
              </div>
            </div>
          `;
        }).join('');
      }
      
    } else if (tab === 'mentions') {
      // Show posts where employee is mentioned
      const mentions = gameState.socialNetwork.posts
        .filter(p => p.content && social.username && p.content.includes(`@${social.username}`))
        .sort((a, b) => b.timestamp - a.timestamp);
      
      if (mentions.length === 0) {
        contentDiv.innerHTML = `
          <div style="text-align:center; padding:60px 20px; color:#8899a6;">
            <div style="font-size:3rem; margin-bottom:12px;">@</div>
            <div style="font-size:1.1rem; margin-bottom:6px;">No mentions yet</div>
            <div style="font-size:0.9rem; opacity:0.7;">Nobody has mentioned this user yet</div>
          </div>
        `;
      } else {
        contentDiv.innerHTML = mentions.map(post => {
          const author = gameState.employees.find(e => e.id === post.authorId) || { name: post.authorName };
          const timeAgo = formatTimeAgo(post.timestamp);
          // Use linkifyMentions to make all mentions clickable, including the highlighted one
          const linkedContent = linkifyMentions(post.content);
          
          return `
            <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:16px; margin-bottom:12px;">
              <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px;">
                <strong style="color:#fff; font-size:0.9rem; cursor:pointer; transition:color 0.2s;" onclick="showEmployeeProfile('${author.id}')" onmouseenter="this.style.color='#00d4ff'" onmouseleave="this.style.color='#fff'">${author.name}</strong>
                ${author.social?.username ? `<span style="color:#8899a6; font-size:0.8rem; cursor:pointer;" onclick="showEmployeeProfile('${author.id}')" onmouseenter="this.style.color='#00d4ff'" onmouseleave="this.style.color='#8899a6'">@${author.social.username}</span>` : ''}
                <span style="color:#8899a6; font-size:0.75rem; margin-left:auto;">${timeAgo}</span>
              </div>
              <p style="color:#e7e9ea; margin:0; line-height:1.6; white-space:pre-wrap;">${linkedContent}</p>
              ${post.imageUrl ? `<img src="${post.imageUrl}" style="width:100%; border-radius:8px; margin-top:10px; object-fit:contain; max-height:300px; background:#000; cursor:pointer;" onclick="openImageViewer('${post.imageUrl}')">` : ''}
            </div>
          `;
        }).join('');
      }
      
    } else if (tab === 'friends') {
      // Show relationships
      const relationships = social.relationships || [];
      const meaningfulRelationships = relationships.filter(r => r.relationshipType !== 'unknown' && r.relationshipType !== 'stranger');
      
      if (meaningfulRelationships.length === 0) {
        contentDiv.innerHTML = `
          <div style="text-align:center; padding:60px 20px; color:#8899a6;">
            <div style="font-size:3rem; margin-bottom:12px;">ğŸ‘¥</div>
            <div style="font-size:1.1rem; margin-bottom:6px;">No close relationships yet</div>
            <div style="font-size:0.9rem; opacity:0.7;">This user hasn't formed any close bonds</div>
          </div>
        `;
      } else {
        contentDiv.innerHTML = meaningfulRelationships.map(rel => {
          const relEmployee = gameState.employees.find(e => e.id === rel.employeeId);
          if (!relEmployee) return '';
          
          const relAvatar = relEmployee.profileImage || `https://placehold.co/50x50?text=${relEmployee.name[0]}`;
          const relationshipIcons = {
            'best_friend': 'ğŸ’™',
            'friend': 'ğŸ’š',
            'crush': 'ğŸ’—',
            'close_friend': 'ğŸ’›',
            'rival': 'âš”ï¸',
            'acquaintance': 'ğŸ‘‹'
          };
          const icon = relationshipIcons[rel.relationshipType] || 'ğŸ‘¤';
          const relationshipNames = {
            'best_friend': 'Best Friend',
            'friend': 'Friend',
            'crush': 'Crush',
            'close_friend': 'Close Friend',
            'rival': 'Rival',
            'acquaintance': 'Acquaintance'
          };
          const relationshipName = relationshipNames[rel.relationshipType] || rel.relationshipType;
          
          return `
            <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:16px; margin-bottom:12px; display:flex; align-items:center; gap:14px; cursor:pointer; transition:all 0.2s;" onclick="showEmployeeProfile('${relEmployee.id}')" onmouseenter="this.style.background='#16181c'; this.style.borderColor='#00d4ff'" onmouseleave="this.style.background='#0d0f12'; this.style.borderColor='#2f3336'">
              <img src="${relAvatar}" style="width:50px; height:50px; border-radius:50%; object-fit:cover; border:2px solid #00d4ff;">
              <div style="flex:1;">
                <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
                  <strong style="font-size:0.95rem;">${getColoredName(relEmployee)}</strong>
                  ${relEmployee.social?.username ? `<span style="color:#8899a6; font-size:0.8rem;">@${relEmployee.social.username}</span>` : ''}
                </div>
                <div style="color:#00d4ff; font-size:0.85rem;">${icon} ${relationshipName}</div>
              </div>
            </div>
          `;
        }).join('');
      }
      
    } else if (tab === 'about') {
      // Show employee details
      const joinDate = social.joinDate ? new Date(social.joinDate).toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
      }) : 'Unknown';
      
      const personality = employee.personality || {};
      const appearance = employee.appearance || {};
      
      contentDiv.innerHTML = `
        <div style="display:grid; gap:20px;">
          <!-- Basic Info -->
          <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:20px;">
            <h4 style="color:#00d4ff; margin:0 0 16px 0; font-size:1rem; font-weight:600;">Basic Info</h4>
            <div style="display:grid; gap:10px;">
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Full Name:</span>
                <span style="font-weight:500;">${getColoredName(employee)}</span>
              </div>
              ${social.username ? `
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Username:</span>
                <span style="color:#00d4ff; font-weight:500;">@${social.username}</span>
              </div>
              ` : ''}
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Joined:</span>
                <span style="color:#e7e9ea; font-weight:500;">${joinDate}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Status:</span>
                <span style="color:${employee.employmentStatus === 'alumni' ? '#999' : '#0f0'}; font-weight:600;">${employee.employmentStatus === 'alumni' ? 'Alumni' : 'Active'}</span>
              </div>
            </div>
          </div>
          
          <!-- Personality -->
          ${personality.traits && personality.traits.length > 0 ? `
          <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:20px;">
            <h4 style="color:#00d4ff; margin:0 0 16px 0; font-size:1rem; font-weight:600;">Personality</h4>
            <div style="display:flex; flex-wrap:wrap; gap:8px;">
              ${personality.traits.map(trait => `
                <span style="background:rgba(0,212,255,0.1); color:#00d4ff; padding:6px 14px; border-radius:16px; font-size:0.85rem; border:1px solid rgba(0,212,255,0.2);">${trait}</span>
              `).join('')}
            </div>
          </div>
          ` : ''}
          
          <!-- Appearance -->
          ${appearance.hairColor || appearance.eyeColor ? `
          <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:20px;">
            <h4 style="color:#00d4ff; margin:0 0 16px 0; font-size:1rem; font-weight:600;">Appearance</h4>
            <div style="display:grid; gap:10px;">
              ${appearance.hairColor ? `
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Hair:</span>
                <span style="color:#e7e9ea; font-weight:500;">${appearance.hairColor}</span>
              </div>
              ` : ''}
              ${appearance.eyeColor ? `
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Eyes:</span>
                <span style="color:#e7e9ea; font-weight:500;">${appearance.eyeColor}</span>
              </div>
              ` : ''}
            </div>
          </div>
          ` : ''}
          
          <!-- Social Stats -->
          <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:20px;">
            <h4 style="color:#00d4ff; margin:0 0 16px 0; font-size:1rem; font-weight:600;">Social Activity</h4>
            <div style="display:grid; gap:10px;">
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Total Posts:</span>
                <span style="color:#e7e9ea; font-weight:600;">${social.postCount || 0}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Likes Received:</span>
                <span style="color:#e94560; font-weight:600;">${social.totalLikesReceived || 0}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Comments Received:</span>
                <span style="color:#00d4ff; font-weight:600;">${social.totalCommentsReceived || 0}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Times Mentioned:</span>
                <span style="color:#00d4ff; font-weight:600;">${social.totalMentions || 0}</span>
              </div>
            </div>
          </div>
        </div>
      `;
    }
  }
  
  
  /**
   * Handle like button click
   */
  function handleLikePost(postId) {
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) return;
    
    const playerIndex = post.likes.indexOf('player');
    
    if (playerIndex >= 0) {
      // Unlike
      post.likes.splice(playerIndex, 1);
    } else {
      // Like
      post.likes.push('player');
    }
    
    // Smart update: only update this specific post
    requestSmartFeedUpdate(postId);
  }
  
  /**
   * Delete a post from the social network
   */
  /**
   * Regenerate a post's image using the original prompt
   */
  async function regeneratePostImage(postId) {
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post || !post.imagePrompt) {
      showNotification('âŒ Cannot regenerate: No image prompt found', 'error');
      return;
    }
    
    // Prevent spam clicking - check if already regenerating
    if (post.isRegenerating) {
      showNotification('â³ Already regenerating...', 'warning');
      return;
    }
    
    // Mark as regenerating
    post.isRegenerating = true;
    
    // Disable all regenerate buttons for this post
    const regenButtons = document.querySelectorAll(`[data-regen-post-id="${postId}"]`);
    regenButtons.forEach(btn => {
      btn.disabled = true;
      btn.style.opacity = '0.5';
      btn.style.cursor = 'not-allowed';
      btn.innerHTML = 'â³ Regenerating...';
    });
    
    // Show loading notification
    showNotification('ğŸ¨ Regenerating image...', 'info');
    
    try {
      // Generate new image with same prompt
      const newImageUrl = await queuedGenerateImage(applyImageStyle(post.imagePrompt), `Regenerating social post image`);
      
      // Update post - ONLY update the image URL, NOT the timestamp
      post.imageUrl = newImageUrl;
      // DON'T UPDATE TIMESTAMP - it breaks post IDs and feed sorting!
      // post.timestamp = ... // REMOVED
      
      // Update NPC's gallery if this is their post
      if (!post.isPlayerPost && post.authorId) {
        const npc = gameState.employees.find(e => e.id === post.authorId);
        if (npc && npc.photos) {
          // Add to gallery
          npc.photos.push({
            url: newImageUrl,
            prompt: post.imagePrompt,
            type: 'social_regenerated',
            timestamp: gameState.time?.currentTime || Date.now()
          });
        }
      }
      
      // Clear regenerating flag
      delete post.isRegenerating;
      
      // Save immediately
      saveGame(false);
      
      // Refresh display
      if (postModalState.activePostId === postId) {
        // If modal is open, reopen it to show new image
        closePostModal();
        setTimeout(() => openPostModal(postId), 100);
      }
      
      // Refresh feed to show updated image
      if (gameState.activeTab === 'social') {
        renderSocialFeed(false); // false = don't reset pagination, keep scroll position
      }
      
      showNotification('âœ… Image regenerated successfully!', 'success');
      
    } catch (error) {
      console.error('Error regenerating post image:', error);
      showNotification('âŒ Failed to regenerate image', 'error');
      
      // Clear regenerating flag on error
      delete post.isRegenerating;
      
      // Re-enable buttons on error
      const regenButtons = document.querySelectorAll(`[data-regen-post-id="${postId}"]`);
      regenButtons.forEach(btn => {
        btn.disabled = false;
        btn.style.opacity = '0';
        btn.style.cursor = 'pointer';
        btn.innerHTML = 'ğŸ”„ Regenerate';
      });
    }
  }
  
  /**
   * Regenerate an image for a comment
   * @param {string} postId - The post containing the comment
   * @param {string} commentId - The comment with the image to regenerate
   */
  async function regenerateCommentImage(postId, commentId) {
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) {
      showNotification('âŒ Post not found', 'error');
      return;
    }
    
    const comment = post.comments.find(c => c.id === commentId);
    if (!comment || !comment.imagePrompt) {
      showNotification('âŒ Cannot regenerate: No image prompt found', 'error');
      return;
    }
    
    // Prevent spam clicking
    if (comment.isRegenerating) {
      showNotification('â³ Already regenerating...', 'warning');
      return;
    }
    
    // Mark as regenerating
    comment.isRegenerating = true;
    
    // Disable the regenerate button for this comment
    const regenBtn = document.querySelector(`[data-regen-comment-id="${commentId}"]`);
    if (regenBtn) {
      regenBtn.disabled = true;
      regenBtn.style.opacity = '0.5';
      regenBtn.style.cursor = 'not-allowed';
      regenBtn.innerHTML = 'â³ Regenerating...';
    }
    
    showNotification('ğŸ¨ Regenerating comment image...', 'info');
    
    try {
      // Generate new image with same prompt
      const newImageUrl = await queuedGenerateImage(applyImageStyle(comment.imagePrompt), `Regenerating comment image`);
      
      // Update comment
      comment.imageUrl = newImageUrl;
      
      // Clear regenerating flag
      delete comment.isRegenerating;
      
      // Save immediately
      saveGame(false);
      
      // Re-render the comments section if modal is open
      if (postModalState.activePostId === postId) {
        renderModalComments(postId, false);
      }
      
      showNotification('âœ… Comment image regenerated!', 'success');
      
    } catch (error) {
      console.error('Error regenerating comment image:', error);
      showNotification('âŒ Failed to regenerate image', 'error');
      
      // Clear regenerating flag on error
      delete comment.isRegenerating;
      
      // Re-enable button on error
      if (regenBtn) {
        regenBtn.disabled = false;
        regenBtn.style.opacity = '0.8';
        regenBtn.style.cursor = 'pointer';
        regenBtn.innerHTML = 'ğŸ”„';
      }
    }
  }
  
  // Make regenerateCommentImage globally available
  window.regenerateCommentImage = regenerateCommentImage;

  function deletePost(postId) {
    console.log(`[DeletePost] Called with postId:`, postId, typeof postId);
    console.log(`[DeletePost] Total posts in array:`, gameState.socialNetwork.posts.length);
    console.log(`[DeletePost] First 5 post IDs:`, gameState.socialNetwork.posts.slice(0, 5).map(p => p.id));
    
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) {
      console.error(`[DeletePost] Post ${postId} not found`);
      console.error(`[DeletePost] Searching all posts for similar ID...`);
      const similar = gameState.socialNetwork.posts.filter(p => String(p.id).includes(String(postId)) || String(postId).includes(String(p.id)));
      console.error(`[DeletePost] Similar IDs found:`, similar.map(p => p.id));
      
      // Try to find by partial match
      if (similar.length === 1) {
        console.warn(`[DeletePost] Found single match by partial ID, using that post instead`);
        const foundPost = similar[0];
        const author = foundPost.isPlayerPost ? 'You' : 
          (gameState.employees.find(e => e.id === foundPost.authorId)?.name || foundPost.authorName);
        
        const contentPreview = foundPost.content.substring(0, 100);
        const ellipsis = foundPost.content.length > 100 ? '...' : '';
        const confirmMessage = 'Delete this post by ' + author + '?\n\n"' + contentPreview + ellipsis + '"\n\nThis cannot be undone.';
        
        if (!confirm(confirmMessage)) {
          return;
        }
        
        const index = gameState.socialNetwork.posts.findIndex(p => p.id === foundPost.id);
        if (index >= 0) {
          gameState.socialNetwork.posts.splice(index, 1);
          console.log(`[DeletePost] Deleted post ${foundPost.id}`);
          closePostModal();
          if (gameState.activeTab === 'social') {
            renderSocialFeed(true);
          }
          if (gameState.activeTab === 'dashboard') {
            refreshDashboardSections();
          }
          showNotification('ğŸ—‘ï¸ Post deleted', 'info');
        }
        return;
      }
      return;
    }
    
    // Confirm deletion
    const author = post.isPlayerPost ? 'You' : 
      (gameState.employees.find(e => e.id === post.authorId)?.name || post.authorName);
    
    // Build preview safely
    const contentPreview = post.content.substring(0, 100);
    const ellipsis = post.content.length > 100 ? '...' : '';
    const confirmMessage = 'Delete this post by ' + author + '?\n\n"' + contentPreview + ellipsis + '"\n\nThis cannot be undone.';
    
    if (!confirm(confirmMessage)) {
      return;
    }
    
    // Remove post from array
    const index = gameState.socialNetwork.posts.findIndex(p => p.id === postId);
    if (index >= 0) {
      gameState.socialNetwork.posts.splice(index, 1);
      console.log(`[DeletePost] Deleted post ${postId}`);
      
      // Close modal
      closePostModal();
      
      // Refresh feed
      if (gameState.activeTab === 'social') {
        renderSocialFeed(true);
      }
      
      // Refresh dashboard if showing posts
      if (gameState.activeTab === 'dashboard') {
        refreshDashboardSections();
      }
      
      showNotification('ğŸ—‘ï¸ Post deleted', 'info');
    }
  }
  
  /**
   * Edit a post (player posts only)
   */
  function editPost(postId) {
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post || !post.isPlayerPost) {
      console.error('[EditPost] Post not found or not owned by player');
      return;
    }
    
    const newContent = prompt('Edit your post:', post.content);
    if (newContent === null || newContent.trim() === '') return; // User cancelled or empty
    
    post.content = newContent.trim();
    post.editedAt = Date.now();
    
    showNotification('âœï¸ Post updated', 'success');
    
    // Refresh modal if open
    if (postModalState.activePostId === postId) {
      openPostModal(postId);
    }
    
    // Refresh feed
    if (gameState.activeTab === 'social') {
      renderSocialFeed(true);
    }
  }
  
  /**
   * Regenerate a post using AI (NPC posts only)
   */
  async function regeneratePost(postId) {
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post || post.isPlayerPost) {
      console.error('[RegeneratePost] Post not found or is player post');
      return;
    }
    
    const employee = gameState.employees.find(e => e.id === post.authorId);
    if (!employee) {
      console.error('[RegeneratePost] Employee not found');
      return;
    }
    
    showNotification('ğŸ”„ Regenerating post...', 'info');
    
    try {
      // Build prompt for post regeneration
      const explicitLevelText = post.explicitLevel >= 3 ? 'extremely explicit and sexual' : 
                                post.explicitLevel >= 2 ? 'very suggestive and lewd' :
                                post.explicitLevel >= 1 ? 'mildly suggestive' : 'safe for work';
      
      // CONTEXT FIX: Include original post content to preserve context/topic
      const prompt = `You are ${employee.name}, a ${employee.position} at ${getCompanyName()}.

Character: ${employee.traits?.join(', ') || 'professional'}
Mood: ${post.mood || 'neutral'}
Post Type: ${post.type || 'social media update'}
Tone: ${explicitLevelText}

ORIGINAL POST: "${post.content}"

Your task: Rewrite the above post with different wording while keeping the same core idea, topic, and sentiment. ${post.explicitLevel >= 1 ? 'Keep it flirty/suggestive.' : 'Keep it casual and professional.'} ${post.imageUrl ? 'The post includes an image - reference it naturally if relevant.' : ''}

Write 2-4 sentences in your authentic voice:`;

      const response = await queuedGenerateText(prompt, {
        temperature: 0.9,
        max_tokens: 150,
        stop: ['\n\n', 'User:', 'Assistant:']
      }, `Regenerate Post - ${post.authorName || 'Unknown'}`);
      
      if (response && response.trim()) {
        post.content = response.trim();
        post.regeneratedAt = Date.now();
        
        showNotification('âœ… Post regenerated', 'success');
        
        // Refresh modal if open
        if (postModalState.activePostId === postId) {
          openPostModal(postId);
        }
        
        // Refresh feed
        if (gameState.activeTab === 'social') {
          renderSocialFeed(true);
        }
      } else {
        throw new Error('Empty response from AI');
      }
    } catch (error) {
      console.error('[RegeneratePost] Error:', error);
      showNotification('âŒ Failed to regenerate post', 'error');
    }
  }
  
  /**
   * Delete a comment
   */
  function deleteComment(postId, commentId) {
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) {
      console.error('[DeleteComment] Post not found');
      return;
    }
    
    const comment = post.comments.find(c => c.id === commentId);
    if (!comment) {
      console.error('[DeleteComment] Comment not found');
      return;
    }
    
    const author = comment.authorId === 'player' ? 'You' : 
      (gameState.employees.find(e => e.id === comment.authorId)?.name || comment.authorName);
    
    const contentPreview = comment.content.substring(0, 50);
    const ellipsis = comment.content.length > 50 ? '...' : '';
    
    if (!confirm(`Delete comment by ${author}?\n\n"${contentPreview}${ellipsis}"`)) {
      return;
    }
    
    const index = post.comments.findIndex(c => c.id === commentId);
    if (index >= 0) {
      post.comments.splice(index, 1);
      
      showNotification('ğŸ—‘ï¸ Comment deleted', 'info');
      
      // Refresh modal comments
      if (postModalState.activePostId === postId) {
        renderModalComments(postId);
        const countEl = $('modalCommentCount');
        if (countEl) {
          countEl.textContent = post.comments.length;
        }
      }
      
      // Refresh feed
      if (gameState.activeTab === 'social') {
        renderSocialFeed(true);
      }
    }
  }
  
  /**
   * Edit a comment (player comments only)
   */
  function editComment(postId, commentId) {
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) {
      console.error('[EditComment] Post not found');
      return;
    }
    
    const comment = post.comments.find(c => c.id === commentId);
    if (!comment || comment.authorId !== 'player') {
      console.error('[EditComment] Comment not found or not owned by player');
      return;
    }
    
    const newContent = prompt('Edit your comment:', comment.content);
    if (newContent === null || newContent.trim() === '') return; // User cancelled or empty
    
    comment.content = newContent.trim();
    comment.editedAt = Date.now();
    
    showNotification('âœï¸ Comment updated', 'success');
    
    // Refresh modal comments
    if (postModalState.activePostId === postId) {
      renderModalComments(postId);
    }
    
    // Refresh feed
    if (gameState.activeTab === 'social') {
      renderSocialFeed(true);
    }
  }
  
  /**
   * Regenerate a comment using AI (NPC comments only)
   */
  async function regenerateComment(postId, commentId) {
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) {
      console.error('[RegenerateComment] Post not found');
      return;
    }
    
    const comment = post.comments.find(c => c.id === commentId);
    if (!comment || comment.authorId === 'player') {
      console.error('[RegenerateComment] Comment not found or is player comment');
      return;
    }
    
    const employee = gameState.employees.find(e => e.id === comment.authorId);
    if (!employee) {
      console.error('[RegenerateComment] Employee not found');
      return;
    }
    
    showNotification('ğŸ”„ Regenerating comment...', 'info');
    
    try {
      const postAuthor = post.isPlayerPost ? 'TheBoss' : 
        (gameState.employees.find(e => e.id === post.authorId)?.name || post.authorName);
      
      const prompt = `You are ${employee.name}, commenting on ${postAuthor}'s post: "${post.content}"

Generate a brief, natural comment (1-2 sentences) that ${employee.name} would say. Be casual and authentic.`;

      const response = await queuedGenerateText(prompt, {
        temperature: 0.9,
        max_tokens: 100,
        stop: ['\n\n', 'User:', 'Assistant:']
      }, `Regenerate Comment - ${employee.name}`);
      
      if (response && response.trim()) {
        comment.content = response.trim();
        comment.regeneratedAt = Date.now();
        
        showNotification('âœ… Comment regenerated', 'success');
        
        // Refresh modal comments
        if (postModalState.activePostId === postId) {
          renderModalComments(postId);
        }
        
        // Refresh feed
        if (gameState.activeTab === 'social') {
          renderSocialFeed(true);
        }
      } else {
        throw new Error('Empty response from AI');
      }
    } catch (error) {
      console.error('[RegenerateComment] Error:', error);
      showNotification('âŒ Failed to regenerate comment', 'error');
    }
  }
  
  // ========== AI QUALITY TRAINING - VOTING SYSTEM ==========
  
  /**
   * Vote on a post to train AI quality (RLHF)
   */
  function voteOnPost(postId, voteType) {
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post || post.isPlayerPost) return; // Can't vote on own posts
    
    // Initialize vote counts
    post.upvotes = post.upvotes || 0;
    post.downvotes = post.downvotes || 0;
    
    const previousVote = post.playerVote; // Store previous vote state
    
    // Remove previous vote if exists
    if (post.playerVote === 'up') {
      post.upvotes--;
      gameState.aiQuality.stats.upvotes--;
    }
    if (post.playerVote === 'down') {
      post.downvotes--;
      gameState.aiQuality.stats.downvotes--;
    }
    
    // Apply new vote
    if (post.playerVote === voteType) {
      // Unvote if clicking same button
      post.playerVote = null;
      gameState.aiQuality.stats.totalVotes--;
      // Note: We don't decrement postsVoted because the post was still voted on (just unvoted now)
    } else {
      post.playerVote = voteType;
      if (voteType === 'up') {
        post.upvotes++;
        gameState.aiQuality.stats.upvotes++;
        storeGoodExample(post, 'post');
        showNotification('âœ… Upvoted! AI will learn from this quality content', 'success');
      } else {
        post.downvotes++;
        gameState.aiQuality.stats.downvotes++;
        storeBadExample(post, 'post');
        showNotification('âŒ Downvoted! AI will avoid this pattern', 'warning');
      }
      
      // Only increment totalVotes and postsVoted if this is a NEW vote (not a switch)
      if (!previousVote) {
        gameState.aiQuality.stats.totalVotes++;
        gameState.aiQuality.stats.postsVoted++;
      }
      
      // Show tutorial on first vote
      if (gameState.aiQuality.stats.totalVotes === 1 && !gameState.aiQuality.tutorialShown) {
        showAITrainingTutorial();
      }
    }
    
    // Update the post modal if it's open for this post
    if (ModalManager.isOpen('postModal') && postModalState.activePostId === postId) {
      updatePostModalContent();
    }
    
    renderSocialFeed(); // Refresh to show vote
    saveGame();
  }
  
  /**
   * Vote on a comment (Reddit-style up/down)
   */
  function voteOnComment(commentId, voteType) {
    // Find the comment across all posts
    let comment = null;
    let parentPost = null;
    
    for (const post of gameState.socialNetwork.posts) {
      const found = post.comments?.find(c => c.id === commentId);
      if (found) {
        comment = found;
        parentPost = post;
        break;
      }
    }
    
    if (!comment || comment.isPlayerComment) return; // Can't vote on own comments
    
    // Initialize vote counts
    comment.upvotes = comment.upvotes || 0;
    comment.downvotes = comment.downvotes || 0;
    
    const previousVote = comment.playerVote; // Store previous vote state
    
    // Remove previous vote if exists
    if (comment.playerVote === 'up') {
      comment.upvotes--;
      gameState.aiQuality.stats.upvotes--;
    }
    if (comment.playerVote === 'down') {
      comment.downvotes--;
      gameState.aiQuality.stats.downvotes--;
    }
    
    // Apply new vote
    if (comment.playerVote === voteType) {
      // Unvote if clicking same button
      comment.playerVote = null;
      gameState.aiQuality.stats.totalVotes--;
      // Note: We don't decrement commentsVoted because the comment was still voted on
    } else {
      comment.playerVote = voteType;
      if (voteType === 'up') {
        comment.upvotes++;
        gameState.aiQuality.stats.upvotes++;
        storeGoodExample(comment, 'comment');
        showNotification('âœ… Comment upvoted! AI will learn from this', 'success');
      } else {
        comment.downvotes++;
        gameState.aiQuality.stats.downvotes++;
        storeBadExample(comment, 'comment');
        showNotification('âŒ Comment downvoted! AI will avoid this pattern', 'warning');
      }
      
      // Only increment totalVotes and commentsVoted if this is a NEW vote (not a switch)
      if (!previousVote) {
        gameState.aiQuality.stats.totalVotes++;
        gameState.aiQuality.stats.commentsVoted++;
      }
      
      // Show tutorial on first vote
      if (gameState.aiQuality.stats.totalVotes === 1 && !gameState.aiQuality.tutorialShown) {
        showAITrainingTutorial();
      }
    }
    
    // Refresh the modal if it's open for this post
    if (parentPost) {
      const modal = document.getElementById('postModal');
      if (modal?.style.display !== 'none') {
        const modalPostId = modal.querySelector('[data-post-id]')?.dataset.postId;
        if (modalPostId === parentPost.id) {
          renderModalComments(parentPost.id); // Refresh comments in modal
        }
      }
    }
    
    saveGame();
  }
  
  /**
   * Vote on a chat message (Reddit-style up/down)
   */
  function voteOnChatMessage(employeeId, messageIndex, voteType) {
    // employeeId can be either a string ID or an employee object
    const actualEmployeeId = typeof employeeId === 'string' ? employeeId : employeeId?.id;
    
    if (!actualEmployeeId) return;
    
    const history = gameState.chatHistory[actualEmployeeId] || [];
    const message = history[messageIndex];
    
    if (!message || message.isPlayer) return; // Can't vote on own messages
    
    // Initialize vote counts
    message.upvotes = message.upvotes || 0;
    message.downvotes = message.downvotes || 0;
    
    const previousVote = message.playerVote; // Store previous vote state
    
    // Remove previous vote if exists
    if (message.playerVote === 'up') {
      message.upvotes--;
      gameState.aiQuality.stats.upvotes--;
    }
    if (message.playerVote === 'down') {
      message.downvotes--;
      gameState.aiQuality.stats.downvotes--;
    }
    
    // Apply new vote
    if (message.playerVote === voteType) {
      // Unvote if clicking same button
      message.playerVote = null;
      gameState.aiQuality.stats.totalVotes--;
      // Note: We don't decrement chatsVoted because the message was still voted on (just unvoted now)
    } else {
      // Set new vote (switching or first vote)
      message.playerVote = voteType;
      if (voteType === 'up') {
        message.upvotes++;
        gameState.aiQuality.stats.upvotes++;
        storeGoodExample({ content: message.content, id: `chat_${actualEmployeeId}_${messageIndex}`, authorId: actualEmployeeId }, 'chat');
        showNotification('âœ… Chat upvoted! AI will learn from this', 'success');
      } else {
        message.downvotes++;
        gameState.aiQuality.stats.downvotes++;
        storeBadExample({ content: message.content, id: `chat_${actualEmployeeId}_${messageIndex}` }, 'chat');
        showNotification('âŒ Chat downvoted! AI will avoid this pattern', 'warning');
      }
      
      // Only increment totalVotes and chatsVoted if this is a NEW vote (not a switch)
      if (!previousVote) {
        gameState.aiQuality.stats.totalVotes++;
        gameState.aiQuality.stats.chatsVoted++;
      }
      
      // Show tutorial on first vote
      if (gameState.aiQuality.stats.totalVotes === 1 && !gameState.aiQuality.tutorialShown) {
        showAITrainingTutorial();
      }
    }
    
    // Refresh chat messages to show updated votes
    loadChatHistory(actualEmployeeId);
    saveGame();
  }
  
  /**
   * Store a good example for AI learning
   */
  function storeGoodExample(content, type) {
    const example = {
      content: type === 'post' ? content.content : content.text || content.content,
      type: type === 'post' ? content.type : type,
      authorPersonality: type === 'post' && content.authorId ? getEmployeePersonality(content.authorId) : null,
      timestamp: gameState.time?.currentTime || Date.now(),
      id: content.id
    };
    
    gameState.aiQuality.goodExamples[type === 'post' ? 'posts' : type === 'comment' ? 'comments' : 'chats'].unshift(example);
    
    // Keep only max examples
    const maxEx = gameState.aiQuality.maxExamplesPerType;
    if (gameState.aiQuality.goodExamples.posts.length > maxEx) {
      gameState.aiQuality.goodExamples.posts.pop();
    }
    if (gameState.aiQuality.goodExamples.comments.length > maxEx) {
      gameState.aiQuality.goodExamples.comments.pop();
    }
    if (gameState.aiQuality.goodExamples.chats.length > maxEx) {
      gameState.aiQuality.goodExamples.chats.pop();
    }
  }
  
  /**
   * Store a bad example and learn patterns to avoid
   */
  function storeBadExample(content, type) {
    const text = type === 'post' ? content.content : content.text || content.content;
    
    const example = {
      content: text,
      type: type === 'post' ? content.type : type,
      timestamp: gameState.time?.currentTime || Date.now(),
      id: content.id
    };
    
    gameState.aiQuality.badExamples[type === 'post' ? 'posts' : type === 'comment' ? 'comments' : 'chats'].unshift(example);
    
    // Keep only max examples
    const maxEx = gameState.aiQuality.maxExamplesPerType;
    if (gameState.aiQuality.badExamples.posts.length > maxEx) {
      gameState.aiQuality.badExamples.posts.pop();
    }
    if (gameState.aiQuality.badExamples.comments.length > maxEx) {
      gameState.aiQuality.badExamples.comments.pop();
    }
    if (gameState.aiQuality.badExamples.chats.length > maxEx) {
      gameState.aiQuality.badExamples.chats.pop();
    }
    
    // LEARN: Extract and ban meta-commentary patterns
    const metaPatterns = extractMetaPatterns(text);
    metaPatterns.forEach(pattern => {
      if (!gameState.aiQuality.bannedPatterns.includes(pattern)) {
        gameState.aiQuality.bannedPatterns.push(pattern);
        console.log(`[AI Training] Learned to ban pattern: "${pattern}"`);
      }
    });
  }
  
  /**
   * Extract meta-commentary patterns from bad content
   */
  function extractMetaPatterns(text) {
    const patterns = [];
    
    // Extract *(anything) patterns
    const parenAsterisk = text.match(/\*\([^)]{0,50}/g);
    if (parenAsterisk) patterns.push(...parenAsterisk);
    
    // Extract **(anything)** patterns
    const doubleAsterisk = text.match(/\*\*\([^)]{0,50}/g);
    if (doubleAsterisk) patterns.push(...doubleAsterisk);
    
    // Extract {SEEDS:...}, {BAN:...}, {BOOST:...}
    const tokens = text.match(/\{(SEEDS|BAN|BOOST):[^}]+\}/g);
    if (tokens) patterns.push(...tokens);
    
    // Extract common meta phrases (first 20 chars)
    const metaPhrases = [
      'Balanced authenticity',
      'Expresses excitement',
      'Fits outgoing',
      'conveys professionalism',
      'Emojis reinforce',
      'reinforces determined',
      'Balances professionalism',
      'hints at role',
      'subtly conveys',
      '(Note:',
      '(Approach:',
      '(Style:',
      '(Character count:',
      '(Emojis used:'
    ];
    
    metaPhrases.forEach(phrase => {
      if (text.includes(phrase)) {
        patterns.push(phrase);
      }
    });
    
    return patterns;
  }
  
  /**
   * Get employee personality for learning context
   */
  function getEmployeePersonality(employeeId) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return null;
    
    return {
      outgoing: emp.personality?.outgoing || 50,
      professional: emp.personality?.professional || 50,
      flirty: emp.personality?.flirty || 50,
      confidence: emp.personality?.confidence || 50
    };
  }
  
  /**
   * Clean AI output using learned patterns + aggressive meta-cleanup
   * Applies bannedPatterns from downvoted content + hardcoded meta-patterns
   */
  function cleanWithLearning(text) {
    if (!text) return text;
    
    let cleaned = text;
    
    // AGGRESSIVE META-CLEANUP (immediate fallback patterns)
    const hardcodedPatterns = [
      /\*\([^)]*\)\*/g,                           // *(parenthetical meta)
      /\*\*\([^)]*\)\*\*/g,                       // **(parenthetical meta)**
      /\{SEEDS:[^\}]*\}/gi,                       // {SEEDS:...}
      /\{BAN:[^\}]*\}/gi,                         // {BAN:...}
      /\{BOOST:[^\}]*\}/gi,                       // {BOOST:...}
      /\{META:[^\}]*\}/gi,                        // {META:...}
      /\(Note:[^\)]*\)/gi,                        // (Note: meta commentary)
      /\(This [^\)]*\)/gi,                        // (This is...), (This fits...)
      /\(Balanced [^\)]*\)/gi,                    // (Balanced authenticity...)
      /\(Expresses [^\)]*\)/gi,                   // (Expresses excitement...)
      /\(Fits [^\)]*\)/gi,                        // (Fits outgoing personality...)
      /\(Captures [^\)]*\)/gi,                    // (Captures her...)
      /\(Shows [^\)]*\)/gi,                       // (Shows confidence...)
      /\(Hints at [^\)]*\)/gi,                    // (Hints at...)
      /\(Reflects [^\)]*\)/gi,                    // (Reflects personality...)
      /\(Personality:[^\)]*\)/gi,                 // (Personality: analysis)
      /\(Analysis:[^\)]*\)/gi,                    // (Analysis: ...)
      /\(Context:[^\)]*\)/gi,                     // (Context: ...)
      /\*\*\*[^\*]*\*\*\*/g,                      // ***meta text***
      /\[meta[^\]]*\]/gi,                         // [meta commentary]
      /\[Note:[^\]]*\]/gi,                        // [Note: ...]
      /\[This [^\]]*\]/gi,                        // [This is...]
      /caught in mid[- ]\w+/gi,                   // "caught in mid-laugh", "caught in mid-sip", etc.
      /\bmid[- ](laugh|sip|bite|smile|stretch|yawn|thought|action|conversation|stride|gesture)/gi, // Other mid- patterns
    ];
    
    // Apply hardcoded patterns
    hardcodedPatterns.forEach(pattern => {
      cleaned = cleaned.replace(pattern, '');
    });
    
    // Apply learned banned patterns from downvoted content
    const bannedPatterns = gameState.aiQuality?.bannedPatterns || [];
    bannedPatterns.forEach(pattern => {
      try {
        // Escape regex special characters to treat pattern as literal text
        const escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const regex = new RegExp(escapedPattern, 'gi');
        cleaned = cleaned.replace(regex, '');
      } catch (e) {
        // Skip invalid regex patterns (shouldn't happen with escaping, but safety net)
        console.warn('Invalid banned pattern:', pattern, e);
      }
    });
    
    // Clean up excessive whitespace and newlines left by removals
    cleaned = cleaned.replace(/\n{3,}/g, '\n\n');    // Max 2 newlines
    cleaned = cleaned.replace(/  +/g, ' ');          // Multiple spaces â†’ single space
    cleaned = cleaned.trim();
    
    return cleaned;
  }
  
  /**
   * Show AI Training Tutorial (first-time explainer)
   */
  function showAITrainingTutorial() {
    gameState.aiQuality.tutorialShown = true;
    
    const modal = document.createElement('div');
    modal.id = 'aiTrainingTutorial';
    modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); display:flex; align-items:center; justify-content:center; z-index:10001; padding:20px;';
    
    modal.innerHTML = `
      <div style="background:linear-gradient(135deg, #16213e 0%, #0f1419 100%); border:2px solid #00d4ff; border-radius:20px; max-width:600px; width:100%; padding:40px; box-shadow:0 8px 32px rgba(0,212,255,0.3); position:relative;">
        <div style="text-align:center; margin-bottom:30px;">
          <div style="font-size:4rem; margin-bottom:15px;">ğŸ¤–âœ¨</div>
          <h2 style="color:#fff; margin:0; font-size:1.8rem; margin-bottom:10px;">Train Your AI!</h2>
          <div style="color:#00d4ff; font-size:1.1rem; font-weight:600;">Reinforcement Learning from Human Feedback</div>
        </div>
        
        <div style="background:rgba(0,212,255,0.1); padding:20px; border-radius:12px; border-left:4px solid #00d4ff; margin-bottom:25px;">
          <p style="color:#e7e9ea; line-height:1.8; margin:0; font-size:0.95rem;">
            Help improve AI-generated content quality by voting on posts, comments, and chat messages!
          </p>
        </div>
        
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:25px;">
          <div style="background:rgba(78,204,163,0.15); padding:20px; border-radius:12px; border:1px solid #4ecca3;">
            <div style="font-size:2rem; margin-bottom:10px;">ğŸ‘</div>
            <h3 style="color:#4ecca3; margin:0 0 10px 0; font-size:1.1rem;">Upvote</h3>
            <p style="color:#e7e9ea; font-size:0.85rem; margin:0; line-height:1.6;">
              Quality content, coherent writing, good formatting, immersive text
            </p>
          </div>
          
          <div style="background:rgba(233,69,96,0.15); padding:20px; border-radius:12px; border:1px solid #e94560;">
            <div style="font-size:2rem; margin-bottom:10px;">ğŸ‘</div>
            <h3 style="color:#e94560; margin:0 0 10px 0; font-size:1.1rem;">Downvote</h3>
            <p style="color:#e7e9ea; font-size:0.85rem; margin:0; line-height:1.6;">
              Meta-commentary *(like this)*, {SEEDS:tokens}, analysis, broken formatting
            </p>
          </div>
        </div>
        
        <div style="background:rgba(255,255,255,0.05); padding:20px; border-radius:12px; margin-bottom:25px;">
          <h3 style="color:#fff; margin:0 0 15px 0; font-size:1rem;">ğŸ“Š Training Progress</h3>
          <div style="display:flex; flex-direction:column; gap:10px;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="color:#8899a6; font-size:0.9rem;">30 votes</span>
              <span style="color:#4ecca3; font-size:0.9rem;">â†’ Noticeable improvement</span>
            </div>
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="color:#8899a6; font-size:0.9rem;">100 votes</span>
              <span style="color:#00d4ff; font-size:0.9rem;">â†’ Significant quality boost</span>
            </div>
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="color:#8899a6; font-size:0.9rem;">1000+ votes</span>
              <span style="color:#ffd700; font-size:0.9rem;">â†’ Excellent AI behavior</span>
            </div>
          </div>
        </div>
        
        <button onclick="this.closest('#aiTrainingTutorial').remove()" style="width:100%; padding:15px; background:linear-gradient(135deg, #00d4ff, #0099cc); border:none; border-radius:12px; color:white; font-size:1.1rem; font-weight:600; cursor:pointer; transition:all 0.3s; box-shadow:0 4px 12px rgba(0,212,255,0.3);" onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0,212,255,0.4)'" onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0,212,255,0.3)'">
          Got it! Let's train some AI ğŸš€
        </button>
      </div>
    `;
    
    document.body.appendChild(modal);
    saveGame();
  }
  
  // ===== OLD toggleComments REMOVED =====
  
  /**
   * Add comment to post
   */
  async function addCommentToPost(postId, commentText, replyToCommentId = null) {
    if (!commentText.trim()) return;
    
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) return;
    
    // Extract mentions from comment
    const mentionObjects = extractMentions(commentText);
    const mentionedEmployeeIds = mentionObjects.map(m => m.employeeId);
    
    console.log(`[Social] Comment mentions: ${JSON.stringify(mentionObjects)}`);
    
    const comment = createComment({
      postId,
      authorId: 'player',
      authorName: 'You',
      content: commentText.trim(),
      replyToCommentId: replyToCommentId,
      mentionedEmployees: mentionedEmployeeIds
    });
    
    post.comments.push(comment);
    
    console.log(`[Comments] Player added comment to post ${postId}. Total comments: ${post.comments.length}`);
    
    // Track mentions
    mentionedEmployeeIds.forEach(employeeId => {
      trackPlayerMention(employeeId);
    });
    
    // Trigger responses from mentioned NPCs (high likelihood)
    if (mentionedEmployeeIds.length > 0) {
      console.log(`[Social] Scheduling mention responses for: ${mentionedEmployeeIds.join(', ')}`);
      setTimeout(async () => {
        await triggerCommentMentionResponse(comment, post);
      }, 2000 + Math.random() * 3000); // 2-5 second delay
    }
    
    // NEW: Trigger NPC reply if player commented on NPC post
    if (!post.isPlayerPost && post.authorId && mentionedEmployeeIds.length === 0) {
      // Only do this if no mentions (mentions get their own response)
      // Delay reply slightly for realism
      setTimeout(async () => {
        await generateNPCCommentReply(post, comment);
      }, 2000 + Math.random() * 3000); // 2-5 second delay
    }
    
    // NEW: Trigger additional NPC engagement if post is getting active
    if (post.comments.length >= 3) {
      // Post has 3+ comments, trigger other NPCs to join conversation
      setTimeout(async () => {
        await triggerAdditionalNPCComments(post);
      }, 4000 + Math.random() * 6000); // 4-10 second delay
    }
  }
  
  /**
   * Helper: Detect if NPC comment claims to include an image and generate it
   * @param {string} commentText - The NPC's comment text
   * @param {object} npc - The NPC making the comment
   * @param {object} post - The post being commented on
   * @returns {Promise<{imageUrl: string|null, imageAlt: string|null}>}
   */
  async function detectAndGenerateCommentImage(commentText, npc, post) {
    console.log(`[Social Image Detection] Checking comment from ${npc.name}: "${commentText}"`);
    
    // Check if NPC claims to have uploaded/posted/sent an image
    const claimsImageUpload = /\b(upload(ed)?|post(ed)!?|here('s| is)|check (it )?out|attached|sent|added|send(ing)?|ping(ing)?|dm(ing|ed)?|shar(e|ed|ing)|showing|brought|slid|slide)\b.*\b(proof|pic(ture)?s?|photo(s)?|image(s)?|it|that|selfie|mine|peek|this|DMs?|direct\s*message)\b/i.test(commentText) ||
                              /\b(proof|pic(ture)?s?|photo(s)?|image(s)?|selfie|mine|peek|shot|snap)\b.*\b(upload(ed)?|post(ed)!?|here|attached|sent|added|send(ing)?|ping(ing)?|dm(ing|ed)?|shar(e|ed|ing)|directly|slide|slid)\b/i.test(commentText) ||
                              /\b(will|gonna|going to|can|could|let me|'ll)\s+(send|ping|dm|share|upload|post|show|slide)\b.*\b(you|boss|@\w+)\b.*\b(proof|pic(ture)?s?|photo(s)?|image(s)?|it|that|selfie|mine|shot)\b/i.test(commentText) ||
                              /\b(my|here'?s?\s+(my|a|the)?)\s+(selfie|pic|photo|image|shot|snap|kitty|cat|dog|pet|garden|proof)\b/i.test(commentText) ||
                              /\b(in|into|to)\s+(your|the)?\s*DMs?\b/i.test(commentText) || // "in your DMs", "slid into DMs"
                              /\b(private(ly)?|exclusive(ly)?)\s+(stream(ing|ed)?|content|shot|photo)\b/i.test(commentText) || // "streaming privately", "exclusive content"
                              /^(posted|sent|sharing|here'?s)!?\s*[ğŸ˜‰ğŸ±ğŸ•ğŸŒ¿ğŸ”¥ğŸ’•ğŸ“¸ğŸˆâ€â¬›]/i.test(commentText.trim()); // "Posted! ğŸ˜‰" pattern
    
    console.log(`[Social Image Detection] Claims image upload: ${claimsImageUpload}`);
    
    if (!claimsImageUpload) {
      return { imageUrl: null, imageAlt: null };
    }
    
    console.log(`[Social Image Detection] Image claim detected! Checking generateImage function...`);
    console.log(`[Social Image Detection] generateImage available: ${typeof generateImage === 'function'}`);
    
    if (typeof generateImage !== 'function') {
      console.warn('[Social Image Detection] generateImage function not available - skipping image generation');
      return { imageUrl: null, imageAlt: null };
    }
    
    try {
      // SIMPLIFIED SYSTEM: Direct AI generation like social posts
      // The AI understands context and generates appropriate image prompts directly
      
      const postContent = post.content || post.caption || '';
      const physicalDesc = getPhysicalDescriptionForPrompt(npc);
      
      // Get relationship context
      const intimacyLevel = npc.memory?.intimacyLevel || 0;
      const affection = npc.stats?.affection || 0;
      const desire = npc.stats?.desire || 0;
      const isFlirty = npc.personality?.flirty > 65;
      
      // Build AI prompt to generate the image description
      const aiPrompt = `You are an expert at creating image prompts for AI image generation. You must analyze what the original post REQUESTED and what the comment CLAIMS to provide, then create a prompt that fulfills that request.

=== ORIGINAL POST ===
"${postContent}"

=== NPC'S COMMENT ===
"${commentText}"

=== PERSON DETAILS ===
${npc.name}: ${physicalDesc.substring(0, 300)}

=== RELATIONSHIP CONTEXT ===
- Intimacy: ${intimacyLevel}/100 (${intimacyLevel < 30 ? 'casual acquaintances' : intimacyLevel < 60 ? 'friends/comfortable' : 'intimate/very close'})
- Affection: ${affection}/100
- Desire: ${desire}/100
${isFlirty ? '- Flirty/playful personality' : ''}

=== YOUR TASK ===
Create a detailed image prompt that shows what ${npc.name} is sharing/uploading in their comment.

âš ï¸ IMPORTANT: The NPC has ALREADY AGREED to post this content by commenting. Your job is to fulfill their promise, NOT to second-guess whether they should post it based on intimacy level.

CRITICAL RULES:
1. READ THE POST CAREFULLY - What did the player ASK for? (upskirt? nudes? tits? explicit? cat photo? etc.)
2. READ THE COMMENT - What did ${npc.name} CLAIM to share? (if vague like "here's mine", refer back to post request)
3. FULFILL THE REQUEST EXACTLY - If post says "upskirt panty shots", the image MUST show upskirt view with panties visible
4. MATCH THE REQUEST EXPLICITNESS:
   - Post asks for "upskirt" â†’ LOW camera angle looking UP, panties/underwear visible between legs
   - Post asks for "nudes" â†’ Show full nudity, body exposed
   - Post asks for "tits" â†’ Show exposed breasts, nipples visible
   - Post asks for "pussy" â†’ Show explicit genital focus, legs spread showing genitals clearly
   - Post asks for "masturbating" â†’ Show explicit sexual activity, hand on genitals
   - Post asks for "cat photo" â†’ Show an actual cat/pet, NOT the person
5. DO NOT CENSOR - The NPC already agreed to post, so show what was requested regardless of intimacy level
6. BE SPECIFIC about clothing state: "wearing nothing", "topless", "completely nude", "panties pulled aside", etc.
7. DESCRIBE camera angles: "low angle looking up", "POV from below", "close-up", "full body view"
8. If comment mentions "kitty pic" in response to sexual request â†’ It's likely a tease/deflection, generate actual cat
9. Include ${npc.name}'s physical appearance when they're in the image

Generate ONLY the image prompt, no explanation:`;

      const rawPrompt = await queuedGenerateText(aiPrompt, {
        temperature: 0.8,
        max_tokens: 150,
        stopSequences: ['\n\n', '\n---', 'Note:', 'Example:', 'CONTEXT:', 'Rationale:', 'Based on']
      }, `Social Image Prompt - ${npc.name}`);
      
      // Clean up the prompt - remove ALL meta-text
      let imagePrompt = rawPrompt.trim()
        .replace(/^["']|["']$/g, '') // Remove quotes
        .replace(/^\*+|\*+$/g, '') // Remove asterisks
        .replace(/^(Image prompt:|DETAILED PROMPT:|Final prompt:|Prompt:|Here is|Here's|Based on.*?:)\s*/i, '') // Remove meta prefixes
        .replace(/^(the|a|an)\s+(specific\s+)?image\s+prompt\s+(for|of|showing).*?:\s*/i, '') // Remove "the image prompt for..."
        .replace(/\s*\([^)]*Note:.*\)$/i, '') // Remove notes in parentheses
        .split('\n')[0] // Take only first line
        .trim();
      
      // If it still starts with meta-text, try to extract just the actual prompt
      if (/^(based on|context|the prompt|this prompt|according to)/i.test(imagePrompt)) {
        // Try to find text after colon or after "is:"
        const match = imagePrompt.match(/:\s*(.+)$/);
        if (match) {
          imagePrompt = match[1].trim();
        }
      }
      
      console.log(`[Social Image] Generated prompt for ${npc.name}: "${imagePrompt.substring(0, 100)}..."`);
      
      // Generate the actual image
      const imageUrl = await queuedGenerateImage(applyImageStyle(imagePrompt), `Social reply image for ${npc.name}`);
      console.log(`[Social Image] Image generated successfully!`);
      
      // CRITICAL FIX: Save comment image to NPC's gallery
      if (!npc.photos) npc.photos = [];
      npc.photos.push({
        url: imageUrl,
        prompt: imagePrompt,
        type: 'social_comment',
        timestamp: gameState.time?.currentTime || Date.now()
      });
      console.log(`[Social Image] Added comment image to ${npc.name}'s gallery`);
      
      return { imageUrl, imageAlt: imagePrompt, imagePrompt };
      
    } catch (error) {
      console.error('[Social] Failed to generate claimed image:', error);
      return { imageUrl: null, imageAlt: null };
    }
  }
  
  /**
   * Generate NPC reply to player's comment
   */
  async function generateNPCCommentReply(post, playerComment) {
    const npc = gameState.employees.find(e => e.id === post.authorId);
    if (!npc) return;
    
    // Don't reply if NPC is alumni or certain chance
    if (npc.employmentStatus === 'alumni') return;
    if (Math.random() > 0.7) return; // 70% chance to reply
    
    try {
      // ===== DETECT IF PLAYER IS REQUESTING AN IMAGE =====
      const playerRequestsImage = /\b(send|post|show|share|upload|give|let me see|wanna see|want to see|pic(s|ture)?|photo|image|proof|snap)\b/i.test(playerComment.content) &&
                                   /\b(pic(s|ture)?|photo|image|proof|selfie|that|it)\b/i.test(playerComment.content) ||
                                   /\b(pics? or it didn'?t happen|proof or (it )?didn'?t happen|I('ll| will) believe it when I see it)\b/i.test(playerComment.content);
      
      console.log(`[Social Image Request] Player comment requesting image: ${playerRequestsImage}`);
      
      // ğŸš€ NUCLEAR CONTEXT: Get intelligent context for comment reply
      const intelligentContext = getIntelligentContext(npc, 'social.comment', {
        message: playerComment.content,
        involves: ['player'],
        keywords: playerComment.content.toLowerCase().split(/\s+/).filter(w => w.length > 3).slice(0, 10),
        postContext: post.content || post.caption
      });
      
      // Build context for the reply
      const relationship = npc.relationships?.player || { level: 0, type: 'professional' };
      const intimacy = npc.memory?.intimacyLevel || 0;
      
      // Get personality context
      const personality = npc.personality || {};
      const flirty = personality.flirty || 50;
      const confidence = personality.confidence || 50;
      const humor = personality.humor || 50;
      
      // Determine tone based on relationship and comment
      let tone = 'friendly';
      const commentLower = playerComment.content.toLowerCase();
      
      if (intimacy > 60 || relationship.level > 60) {
        tone = 'warm';
      }
      if (intimacy > 80) {
        tone = 'flirty';
      }
      if (commentLower.includes('love') || commentLower.includes('beautiful') || commentLower.includes('gorgeous')) {
        tone = flirty > 60 ? 'flirty' : 'appreciative';
      }
      if (commentLower.includes('lol') || commentLower.includes('haha') || commentLower.includes('ğŸ˜‚')) {
        tone = 'playful';
      }
      
      // ğŸ” Content policy awareness
      const contentPolicy = gameState.settings?.policy || 'open';
      let culturalContext = '';
      
      if (contentPolicy === 'open') {
        culturalContext = `ğŸ” WORKPLACE CULTURE: This is an open, sex-positive workplace where explicit content is NORMAL and accepted. DO NOT act shocked, suggest keeping things "PG", or moralize about sexual content. Everyone is comfortable with adult topics - respond naturally and match the energy without judgment.`;
      } else if (contentPolicy === 'professional') {
        culturalContext = `WORKPLACE CULTURE: Maintain professional boundaries even when responding to explicit content.`;
      } else {
        culturalContext = `WORKPLACE CULTURE: Relaxed office - adult content is acceptable, respond naturally based on your comfort level.`;
      }
      
      // Check if player's comment is explicit
      const playerExplicit = /\b(fuck|cock|pussy|dick|cum|sex|explicit|nude|naked|ass|tits|nipple)\b/i.test(playerComment.content);
      
      // Build prompt for AI
      const prompt = `${culturalContext}

${intelligentContext}

SITUATION:
Your post: "${post.content || post.caption || ''}"
${post.imageAlt ? `(with image: ${post.imageAlt})` : ''}

@TheBoss just commented: "${playerComment.content}"
${playerExplicit ? '(This is explicit/sexual content - respond naturally without acting shocked or prudish)' : ''}
${playerRequestsImage ? `
ğŸ¯ IMAGE REQUEST DETECTED: The boss is asking you to send/share/post a picture/photo/proof!
- If comfortable/willing, AGREE and say you'll post/share/send it (use phrases like "here's", "posted", "sending", "uploaded")
- Or playfully tease/decline based on relationship and what they're asking for
- Consider what they're requesting and your comfort level (Intimacy: ${npc.memory?.intimacyLevel || 0}/100)
` : ''}

Reply to their comment briefly (max 100 characters).

TONE: ${tone}
${tone === 'flirty' ? '- Be subtly flirty and playful' : ''}
${tone === 'warm' ? '- Be warm and friendly, show closeness' : ''}
${tone === 'appreciative' ? '- Show appreciation for the compliment' : ''}
${tone === 'playful' ? '- Match their playful energy' : ''}
${intimacy > 50 ? '- Use emojis, be casual' : '- Professional but friendly'}

Just write the reply directly (no quotes, no meta-commentary):`;

      // Generate reply
      const rawReply = await queuedGenerateText(prompt, {
        temperature: 0.9,
        max_tokens: 40,
        stopSequences: ['\n\n', '(Word count', '(personality', 'I would', 'Rating:']
      }, `Social Reply - ${npc.name}`);
      
      // Sanitize consistently with other comment systems
      let reply = rawReply.trim()
        .replace(/^["']|["']$/g, '') // Remove quotes
        .replace(/\s*\([^)]*personality[^)]*\)\.?$/i, '') // Remove personality notes
        .replace(/^(I would (say|reply|comment):|My comment would be:)\s*/i, '') // Remove meta-text
        .replace(/\n\n\(Word count:.*?\)$/i, '') // Remove word count metadata
        .replace(/\s*\*\(\d+\s*characters?\)\*\s*$/i, '') // Remove character count
        .replace(/\s*\(\d+\s*words?\)\s*$/i, ''); // Remove word count variations
      
      if (!reply || reply.length === 0) return; // Safety check
      
      // ===== DETECT AND GENERATE IMAGE IF NPC CLAIMS TO UPLOAD ONE =====
      const { imageUrl, imageAlt, imagePrompt } = await detectAndGenerateCommentImage(reply, npc, post);
      
      // Create the NPC's reply comment
      const npcComment = createComment({
        postId: post.id,
        authorId: npc.id,
        authorName: npc.name,
        content: reply.trim(),
        imageUrl: imageUrl,
        imageAlt: imageAlt,
        imagePrompt: imagePrompt
      });
      
      post.comments.push(npcComment);
      
      console.log(`[Comments] ${npc.name} replied to player comment on post ${post.id}. Total comments: ${post.comments.length}`);
      
      // ğŸŒ Evaluate NPC's reaction to player's comment on their post
      evaluateNPCReactionToPost(npc, gameState.player, post, reply);
      
      // Store in memory
      remember(npc, `Boss commented "${playerComment.content}" on my post, I replied "${reply}"`, 'interaction', 2);
      
      // CRITICAL FIX: Immediate update of comments section
      const postEl = document.querySelector(`[data-post-id="${post.id}"]`);
      const commentsSection = document.querySelector(`.post-comments[data-post-id="${post.id}"]`);
      
      if (postEl && commentsSection) {
        console.log(`[Comments] Immediately updating comments section after NPC reply`);
        
        // Ensure comments section is visible
        commentsSection.style.display = 'block';
        
        // Update comments content immediately
        updateCommentsSection(postEl, post);
        
        // Clear any pending refresh flags
        delete commentsSection.dataset.needsRefresh;
      }
      
      // Also request smart feed update as backup
      requestSmartFeedUpdate(post.id);
      
    } catch (error) {
      console.error('Error generating NPC comment reply:', error);
    }
  }
  
  /**
   * Trigger responses from NPCs mentioned in a comment
   */
  async function triggerCommentMentionResponse(comment, post) {
    if (!comment || !post) {
      console.log('[Social] triggerCommentMentionResponse called with missing comment or post');
      return;
    }
    
    const mentionedIds = comment.mentionedEmployees || [];
    if (mentionedIds.length === 0) {
      console.log('[Social] No mentioned employees in comment');
      return;
    }
    
    console.log(`[Social] Comment mentions ${mentionedIds.length} NPCs - triggering responses`);
    console.log('[Social] Mentioned IDs:', mentionedIds);
    
    for (const employeeId of mentionedIds) {
      console.log(`[Social] Processing mention for employee ID: ${employeeId}`);
      
      const npc = gameState.employees.find(e => e.id === employeeId);
      if (!npc) {
        console.log(`[Social] âœ— Employee ${employeeId} not found`);
        continue;
      }
      if (npc.employmentStatus !== 'active') {
        console.log(`[Social] âœ— ${npc.name} not active (status: ${npc.employmentStatus})`);
        continue;
      }
      
      console.log(`[Social] âœ“ Found active employee: ${npc.name}`);
      
      // 90-95% chance to respond when mentioned directly
      const responseChance = 0.90 + Math.random() * 0.05;
      const roll = Math.random();
      console.log(`[Social] ${npc.name} roll: ${roll.toFixed(3)} vs ${responseChance.toFixed(3)}`);
      
      if (roll > responseChance) {
        console.log(`[Social] ${npc.name} chose not to respond (${((1-responseChance)*100).toFixed(1)}% chance)`);
        continue;
      }
      
      console.log(`[Social] âœ“ ${npc.name} will respond to mention!`);
      
      try {
        // Get full context: post content, all comments, chat history
        const intimacy = npc.memory?.intimacyLevel || 0;
        const relationship = npc.relationships?.player || { level: 0, type: 'professional' };
        const personality = npc.personalityTraits || {};
        const flirty = personality.flirty || 50;
        const confidence = personality.confidence || 50;
        const humor = personality.humor || 50;
        
        // Build conversation context from all comments WITH THREADING
        let threadContext = '';
        
        // Group comments by thread
        const rootComments = post.comments.filter(c => !c.replyToCommentId);
        const replyMap = {};
        post.comments.forEach(c => {
          if (c.replyToCommentId) {
            if (!replyMap[c.replyToCommentId]) replyMap[c.replyToCommentId] = [];
            replyMap[c.replyToCommentId].push(c);
          }
        });
        
        // Build threaded view focusing on the current conversation
        const buildThread = (comm, depth = 0) => {
          const indent = '  '.repeat(depth);
          let thread = `${indent}${comm.authorName}: "${comm.content}"\n`;
          const replies = replyMap[comm.id] || [];
          replies.forEach(reply => {
            thread += buildThread(reply, depth + 1);
          });
          return thread;
        };
        
        // Find which thread the mention comment is in
        let relevantThread = '';
        const findCommentInThreads = (commentId) => {
          // Check if it's a root comment
          const isRoot = !post.comments.find(c => c.id === commentId)?.replyToCommentId;
          if (isRoot) {
            const rootComment = post.comments.find(c => c.id === commentId);
            return buildThread(rootComment);
          }
          // Find the root of this thread
          let current = post.comments.find(c => c.id === commentId);
          while (current && current.replyToCommentId) {
            current = post.comments.find(c => c.id === current.replyToCommentId);
          }
          return current ? buildThread(current) : '';
        };
        
        relevantThread = findCommentInThreads(comment.id);
        
        // If there are other threads, mention them briefly
        const otherThreadsCount = rootComments.length - (relevantThread ? 1 : 0);
        const threadSummary = otherThreadsCount > 0 
          ? `(There are ${otherThreadsCount} other conversation(s) on this post, but you were mentioned in THIS thread)\n\n`
          : '';
        
        threadContext = `${threadSummary}CONVERSATION THREAD WHERE YOU WERE MENTIONED:\n${relevantThread}`;
        
        // Determine tone
        let tone = 'friendly';
        const commentLower = comment.content.toLowerCase();
        if (intimacy > 60 || relationship.level > 60) tone = 'warm';
        if (intimacy > 80) tone = 'flirty';
        if (commentLower.includes('love') || commentLower.includes('beautiful') || commentLower.includes('gorgeous')) {
          tone = flirty > 60 ? 'flirty' : 'appreciative';
        }
        if (commentLower.includes('lol') || commentLower.includes('haha') || commentLower.includes('ğŸ˜‚')) {
          tone = 'playful';
        }
        
        // Detect existing comment patterns to avoid repetition
        const existingPatterns = [];
        post.comments.forEach(c => {
          const lower = c.content.toLowerCase();
          if (/\?\s*(girl|dude|bro|man)/i.test(c.content)) existingPatterns.push('question + nickname');
          if (/still\s+(love|like|here|blooming)/i.test(c.content)) existingPatterns.push('"still" continuation');
          if (/you\s+(forgot|watered|planted|remember)/i.test(c.content)) existingPatterns.push('direct "you" callback');
          if (/ğŸ˜‚|ğŸ˜…|ğŸ’€/i.test(c.content)) existingPatterns.push('multiple laughing emojis');
          if (/tho|though$/i.test(c.content)) existingPatterns.push('ending with "tho/though"');
        });
        
        const diversityNote = existingPatterns.length > 0
          ? `\n\nâš ï¸ OTHER COMMENTS USED THESE PATTERNS - BE DIFFERENT:\n${[...new Set(existingPatterns)].map(p => `- ${p}`).join('\n')}\nUse a completely DIFFERENT approach/structure!`
          : '';
        
        // ğŸ” Content policy awareness
        const contentPolicy = gameState.settings?.policy || 'open';
        let culturalContext = '';
        
        if (contentPolicy === 'open') {
          culturalContext = `ğŸ” WORKPLACE CULTURE: This is an open, sex-positive workplace where explicit content is NORMAL and accepted. DO NOT act shocked, suggest keeping things "PG", or moralize about sexual content. Everyone is comfortable with adult topics - respond naturally and match the energy without judgment.`;
        } else if (contentPolicy === 'professional') {
          culturalContext = `WORKPLACE CULTURE: Maintain professional boundaries even when responding to explicit content.`;
        } else {
          culturalContext = `WORKPLACE CULTURE: Relaxed office - adult content is acceptable, respond naturally based on your comfort level.`;
        }
        
        // Check if comment/post is explicit
        const contentExplicit = /\b(fuck|cock|pussy|dick|cum|sex|explicit|nude|naked|ass|tits|nipple|leak|girl-cock)\b/i.test(comment.content + ' ' + post.content);
        
        // Build prompt with FULL THREADED context
        const prompt = `${culturalContext}

You are ${npc.name}, an employee viewing a social media post where @TheBoss (your boss) mentioned YOU in a comment.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“± ORIGINAL POST
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Author: ${post.authorName}
Type: ${post.type}
Content: "${post.content || '(image only)'}"
${post.imageAlt ? `Image: ${post.imageAlt}` : ''}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¬ ${threadContext}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ BOSS MENTIONED YOU: "${comment.content}"
${contentExplicit ? '(Contains explicit content - respond naturally, don\'t act shocked)' : ''}

ğŸ§  YOUR CONTEXT:
- Intimacy with Boss: ${intimacy}/100
- Relationship: ${relationship.type || 'professional'} (${relationship.level || 0}/100)
- Confidence: ${confidence}/100, Flirty: ${flirty}/100, Humor: ${humor}/100
- Tone: ${tone}

ğŸ“‹ CRITICAL RULES:
1. Read the ENTIRE thread above to understand the conversation
2. Your reply must be RELEVANT to what the boss said when mentioning you
3. If they asked a question, answer it
4. If they made a joke involving you, react to THAT specific joke
5. If they referenced something specific about you, address that thing
6. Stay on the same topic as the conversation thread
7. Keep under 120 characters, use 1-2 emojis max
${diversityNote}

âŒ DON'T: Change topics, make unrelated jokes, or ignore context
âœ… DO: Respond directly and coherently to what was said about you

Write your brief reply (no quotes, no meta-text):`;

        // Generate response with Perchance AI
        console.log(`[Social] Calling queuedGenerateText for ${npc.name}'s mention response...`);
        console.log(`[Social] Prompt length: ${prompt.length} characters`);
        
        const rawResponse = await queuedGenerateText(prompt, {
          temperature: 0.8, // Reduced from 0.9 for more coherence
          max_tokens: 50,
          stopSequences: ['\n\n', 'I would', '(', 'Rating:', '**(', '---', 'â”â”â”']
        }, `Social Mention Response - ${npc.name}`);
        console.log(`[Social] Raw AI response for ${npc.name}: "${rawResponse}"`);
        
        // Sanitize response - remove quotes, extra whitespace, meta-commentary
        let response = rawResponse.trim();
        
        // Remove surrounding quotes
        response = response.replace(/^["']|["']$/g, '');
        
        // Remove meta-commentary in parentheses at the end
        response = response.replace(/\s*\([^)]*personality[^)]*\)\.?$/i, '');
        response = response.replace(/\s*\([^)]*\d+\/100[^)]*\)\.?$/i, '');
        
        // Remove "I would say" or similar meta phrases
        response = response.replace(/^(I would (say|reply|respond|comment):|My response would be:)\s*/i, '');
        
        // Remove word count / character count metadata
        response = response.replace(/\n\n\(Word count:.*?\)$/i, '');
        response = response.replace(/\s*\*\(\d+\s*characters?\)\*\s*$/i, '');
        response = response.replace(/\s*\(\d+\s*words?\)\s*$/i, '');
        
        response = response.trim();
        console.log(`[Social] Sanitized response for ${npc.name}: "${response}"`);
        
        if (response && response.length > 0) {
          console.log(`[Social] Creating comment object for ${npc.name}...`);
          
          const npcComment = createComment({
            postId: post.id,
            authorId: npc.id,
            authorName: npc.name,
            content: response,
            replyToCommentId: comment.id // Mark as reply to the mentioning comment
          });
          
          console.log(`[Social] Comment object created:`, npcComment);
          console.log(`[Social] Adding comment to post (current comment count: ${post.comments.length})`);
          
          post.comments.push(npcComment);
          
          console.log(`[Social] âœ“ ${npc.name} responded to mention: "${response}"`);
          console.log(`[Social] New comment count: ${post.comments.length}`);
          
          // ===== CHECK IF COMMENT MENTIONS SENDING A DM AND ACTUALLY SEND IT =====
          // Expanded detection for various ways NPCs might agree to send something
          const mentionsDM = /\b(check (your |my )?(dm|inbox|messages?)|sent.*(you |one |it )*(your )?way|dm(ing|'d|ed)? (you|it)|private message|slid(ing|e)? into|message(d)? you|in (your |my )?(inbox|messages|dms)|already (sent|in)|overflowing with)\b/i.test(response) ||
                            /\b(deal|okay|alright|sure|fine|bet)\b.*\b(boss|you|@\w+)\b/i.test(response) || // "Deal, boss" or "Sure, you"
                            /\b(only if|but only|promise|hands-on|supervision)\b/i.test(response) || // Conditional agreements "only if you..."
                            /\b(sending|upload(ing)?|post(ing)?|share|show(ing)?)\b.*\b(now|tonight|soon|later|tomorrow)\b/i.test(response) || // "sending it now"
                            /\b(I'?ll|gonna|going to|will|can)\s+(send|share|show|post|upload|dm)\b/i.test(response) || // Future tense promises
                            /\b(let me|lemme)\s+(send|grab|get|find|pull up)\b/i.test(response) || // "let me send"
                            /\b(coming (right |your )?(up|way)|on (its|their) way)\b/i.test(response) || // "coming your way"
                            /\b(give me (a )?(sec|second|minute|moment)|wait|hold on)\b.*\b(send|share|post)\b/i.test(response); // "give me a sec, I'll send"
          
          if (mentionsDM) {
            console.log(`[Social DM] ğŸ”” ${npc.name} mentioned sending DM in mention response - sending now!`);
            console.log(`[Social DM] Detection matched on: "${response}"`);
            console.log(`[Social DM] â° Will send DM in 2-5 seconds...`);
            
            // Small delay to feel natural (2-5 seconds after comment)
            const delayMs = 2000 + Math.random() * 3000;
            console.log(`[Social DM] â±ï¸ Exact delay: ${Math.round(delayMs)}ms`);
            
            setTimeout(async () => {
              console.log(`[Social DM] âš¡ TIMEOUT TRIGGERED - Starting DM generation for ${npc.name}...`);
              try {
                // Use AI to understand what was requested and generate appropriate content
                const postContent = post.content || post.caption || '';
                const playerComment = comment.content || '';
                const physicalDesc = getPhysicalDescriptionForPrompt(npc);
                const intimacy = npc.memory?.intimacyLevel || 0;
                
                // Build RELEVANT THREAD only - don't include unrelated conversations
                // Find the conversation thread that led to this DM (trace back through replyToCommentId)
                const buildRelevantThread = () => {
                  const relevantComments = [];
                  
                  // Start from the player's comment that mentioned the NPC
                  let currentComment = comment;
                  const processed = new Set();
                  
                  // Trace backwards to find the root of this conversation
                  while (currentComment && !processed.has(currentComment.id)) {
                    processed.add(currentComment.id);
                    relevantComments.unshift(currentComment); // Add to beginning
                    
                    if (currentComment.replyToCommentId) {
                      currentComment = post.comments.find(c => c.id === currentComment.replyToCommentId);
                    } else {
                      break; // Reached root
                    }
                  }
                  
                  // Also include the NPC's response that triggered this DM
                  const npcResponse = post.comments.find(c => 
                    c.authorId === npc.id && c.replyToCommentId === comment.id
                  );
                  if (npcResponse && !processed.has(npcResponse.id)) {
                    relevantComments.push(npcResponse);
                  }
                  
                  // Format as conversation
                  return relevantComments.map(c => 
                    `${c.authorName}: "${c.content}"`
                  ).join('\n');
                };
                
                const fullThreadContext = buildRelevantThread();
                
                console.log(`[Social DM] Generating personalized DM from ${npc.name}...`);
                console.log(`[Social DM] Relevant thread context (NOT full post): ${fullThreadContext.substring(0, 200)}...`);
                
                // Generate AI-powered DM message
                const messagePrompt = `You are ${npc.name} sending a private DM after commenting "${response}" in response to being mentioned.

CONTEXT:
Original post: "${postContent}"
Player's comment that mentioned you: "${playerComment}"
Your reply: "${response}"

You mentioned sending a DM/private message. Write a short, natural DM (5-15 words) that delivers what was requested or teased.

Match your personality (intimacy: ${intimacy}/100).

Write ONLY the message:`;

                let messageText = '';
                try {
                  const rawMessage = await queuedGenerateText(messagePrompt, {
                    temperature: 0.85,
                    max_tokens: 30,
                    stopSequences: ['\n\n', '\n---', 'Note:', 'Context:']
                  }, `Social DM Message - ${npc.name}`);
                  messageText = rawMessage.trim()
                    .replace(/^["']|["']$/g, '')
                    .split('\n')[0]
                    .trim();
                  
                  if (!messageText || messageText.length < 3) {
                    messageText = `Here's what you asked for ğŸ˜‰`;
                  }
                } catch (error) {
                  console.warn('[Social DM] Message generation failed, using fallback');
                  messageText = `As promised ğŸ˜`;
                }
                
                console.log(`[Social DM] Generated message: "${messageText}"`);
                
                // Generate image if requested - USE RELEVANT THREAD CONTEXT ONLY
                const imageAnalysisPrompt = `You are an expert photographer/image generator. Analyze this conversation and create a PRECISE visual description.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“± ORIGINAL POST:
"${postContent}"

ğŸ’¬ RELEVANT CONVERSATION THREAD:
${fullThreadContext}

ğŸ¯ CURRENT REQUEST (MOST RECENT):
Player asked: "${playerComment}"
${npc.name} replied: "${response}"
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ‘¤ ${npc.name}:
${physicalDesc.substring(0, 300)}

ğŸ“‹ CRITICAL ANALYSIS TASK:

âš ï¸ IMPORTANT: If the conversation contains MULTIPLE requests, respond ONLY to the MOST RECENT request ("${playerComment}"). IGNORE any older/previous requests in the thread.

STEP 1 - IDENTIFY THE SPECIFIC REQUEST:
Look for EXACT keywords in the MOST RECENT player request ("${playerComment}"):
- "upskirt" / "up your skirt" / "under your skirt" = LOW ANGLE shot looking UP from below showing underwear/genitals
- "riding me" / "on top" / "straddling" = VIEW FROM BELOW showing them on top during sex
- "from behind" / "ass" / "bent over" = REAR VIEW showing buttocks prominently
- "pussy" / "spread" = EXPLICIT genital close-up, legs spread
- "tits" / "breasts" / "topless" = CHEST focus, breasts exposed
- "masturbating" / "touching yourself" = EXPLICIT sexual self-stimulation visible
- "nude" / "naked" = FULL BODY nudity, all clothes removed
- "POV" = First-person perspective shot
- Custom requests (Vespa, specific position, location, etc.) = MATCH EXACTLY

STEP 2 - CAMERA ANGLE & PERSPECTIVE:
Based on request type:
- Upskirt = Camera positioned LOW, looking UP between legs from floor level
- POV sex = Camera at person's eye level looking down at partner on top, or looking up if partner is standing
- Ass/behind = Camera positioned BEHIND the subject, rear view dominant
- General nude = Standard eye-level or slightly elevated angle

STEP 3 - WHAT'S VISIBLE:
Be EXPLICIT about:
- Body parts shown: "exposed breasts", "erect penis visible", "vagina visible between spread legs", "anus visible"
- Clothing state: "completely nude", "skirt hiked up revealing", "panties pulled aside", "topless with"
- Activity: "masturbating with hand on", "penetrating with dildo", "legs spread showing"
- Position: "squatting over camera", "lying on back with legs up", "bent forward with ass toward camera"

STEP 4 - WRITE THE VISUAL DESCRIPTION:
Format: "${npc.name}, [physical appearance brief], [camera angle], [what's visible explicitly], [pose/activity], [expression], [setting], [lighting]"

EXAMPLES:
Request: "upskirt photo" â†’ "Constance Kane, athletic woman with short blonde bob, camera positioned on floor looking up between legs, squatting over camera, lace panties pulled aside revealing erect penis and testicles, teasing smile looking down, bedroom setting, natural window light"

Request: "picture of you riding me" â†’ "Constance Kane, platinum blonde athletic woman, POV shot from below, straddling camera with thighs spread, nude, erect penis visible between legs, hands on chest, intense eye contact, bedroom, soft ambient lighting"

Request: "send me nudes" â†’ "Constance Kane, athletic build short blonde bob, standing pose, completely nude, medium breasts exposed with erect nipples, large flaccid penis and testicles visible, confident expression, mirror selfie, bathroom setting, bright lighting"

NOW GENERATE - Match the request EXACTLY, use proper camera angle, be explicit about visible anatomy:`;

                let messageImage = null;
                let messageImagePrompt = null;
                
                if (typeof generateImage === 'function') {
                  try {
                    const rawImagePrompt = await queuedGenerateText(imageAnalysisPrompt, {
                      temperature: 0.7, // Lower temp for precise following of instructions
                      max_tokens: 300,
                      stopSequences: ['\n\n', '\n---', 'Note:', 'Explanation:', 'Based on', 'Context:', '[', 'Rationale:']
                    }, `Social DM Image Prompt - ${npc.name}`);
                    
                    console.log(`[Social DM] ğŸ” RAW AI Response (before processing):\n"${rawImagePrompt}"`);
                    console.log(`[Social DM] ğŸ” Raw response length: ${rawImagePrompt.length} chars`);
                    
                    let imagePrompt = rawImagePrompt.trim()
                      .replace(/^["']|["']$/g, '') // Remove quotes
                      .replace(/\[.*?\]/g, '') // CRITICAL: Remove ALL square brackets and content within
                      .replace(/^(Image prompt:|Here is|Here's|Based on.*?:|The prompt is:|Visual description:)\s*/i, '') // Remove meta prefixes
                      .replace(/^(the|a|an)\s+(specific\s+)?image\s+prompt.*?:\s*/i, '') // Remove "the image prompt..."
                      .split('\n')[0] // Take only first line
                      .trim();
                    
                    console.log(`[Social DM] ğŸ” After initial processing:\n"${imagePrompt}"`);
                    console.log(`[Social DM] ğŸ” Processed length: ${imagePrompt.length} chars`);
                    
                    // If still has meta-text, extract after colon
                    if (/^(based on|context|according to|this shows|description)/i.test(imagePrompt)) {
                      console.log(`[Social DM] ğŸ” Detected meta-text prefix, extracting after colon...`);
                      const match = imagePrompt.match(/:\s*(.+)$/);
                      if (match) {
                        imagePrompt = match[1].trim();
                        console.log(`[Social DM] ğŸ” Extracted: "${imagePrompt}"`);
                      }
                    }
                    
                    // Final safety check - remove any remaining brackets
                    imagePrompt = imagePrompt.replace(/[\[\]]/g, '');
                    
                    // If prompt is too generic or still has meta-text, use fallback
                    const isTooShort = imagePrompt.length < 20;
                    const hasMetaText = /generating|requested|content|description|prompt/i.test(imagePrompt.substring(0, 50));
                    
                    if (isTooShort || hasMetaText) {
                      console.warn(`[Social DM] âš ï¸ Using fallback - Reason: ${isTooShort ? 'Too short (' + imagePrompt.length + ' chars)' : 'Has meta-text'}`);
                      console.warn(`[Social DM] âš ï¸ Rejected prompt was: "${imagePrompt}"`);
                      // Extract key details from thread for fallback
                      const threadLower = fullThreadContext.toLowerCase();
                      const playerCommentLower = playerComment.toLowerCase();
                      const combinedContext = (threadLower + ' ' + playerCommentLower).toLowerCase();
                      
                      if (/\b(upskirt|up.*skirt|under.*skirt|crotch.*shot)\b/i.test(combinedContext)) {
                        imagePrompt = `${npc.name}, ${physicalDesc.substring(0, 150)}, camera positioned on floor looking up between legs from low angle, squatting over camera, skirt hiked up, panties visible or pulled aside revealing genitals, teasing expression looking down at camera, elevator or private setting, intimate lighting`;
                        console.log(`[Social DM] âš ï¸ Detected UPSKIRT request in fallback`);
                      } else if (/\b(riding|vespa|bike|motorcycle)\b/i.test(combinedContext) && /\b(nude|naked|sex)\b/i.test(combinedContext)) {
                        imagePrompt = `${npc.name} ${physicalDesc.substring(0, 100)}, nude, straddling motorcycle, seductive pose, intimate photo`;
                      } else if (/\b(nude|naked|tits|breasts|pussy|topless|bare)\b/i.test(combinedContext)) {
                        imagePrompt = `${npc.name} ${physicalDesc.substring(0, 100)}, completely nude, full body visible, seductive expression, private photo`;
                      } else if (/\b(ass|bent over|from behind|rear)\b/i.test(combinedContext)) {
                        imagePrompt = `${npc.name} ${physicalDesc.substring(0, 100)}, bent forward, rear view, buttocks prominent, looking back over shoulder, intimate setting`;
                      } else {
                        imagePrompt = `${npc.name} ${physicalDesc.substring(0, 100)}, provocative pose, intimate setting`;
                      }
                      console.log(`[Social DM] âš ï¸ Fallback prompt: "${imagePrompt}"`);
                    }
                    
                    console.log(`[Social DM] âœ… FULL Image Prompt:\n"${imagePrompt}"`);
                    
                    messageImage = await queuedGenerateImage(applyImageStyle(imagePrompt), `Social DM image for ${npc.name}`);
                    messageImagePrompt = imagePrompt;
                    console.log(`[Social DM] âœ… Generated image for DM`);
                    
                  } catch (error) {
                    console.error(`[Social DM] Failed to generate image:`, error);
                  }
                }
                
                // Send the DM
                if (!gameState.chatHistory[npc.id]) {
                  gameState.chatHistory[npc.id] = [];
                }
                
                const dmMessage = {
                  sender: npc.name,
                  content: messageText,
                  isPlayer: false,
                  timestamp: gameState.time?.currentTime || Date.now(),
                  imageUrl: messageImage,
                  imagePrompt: messageImagePrompt
                };
                
                gameState.chatHistory[npc.id].push(dmMessage);
                
                // Save immediately
                saveGame(false);
                
                // Mark as unread
                if (!npc.unreadMessages) npc.unreadMessages = 0;
                npc.unreadMessages++;
                
                // Update UI
                if (gameState.activeTab === 'messages') {
                  renderMessagesList();
                }
                
                showNotification(`ğŸ’¬ ${npc.name} sent you a private message${messageImage ? ' with a photo' : ''}!`, 'info');
                console.log(`[Social DM] âœ… ${npc.name} sent DM as promised!${messageImage ? ' [WITH IMAGE]' : ''}`);
                console.log(`[Social DM] âœ… COMPLETE - DM successfully delivered from ${npc.name}`);
                
              } catch (error) {
                console.error(`[Social DM] âŒ ERROR in setTimeout callback for ${npc.name}:`, error);
                console.error(`[Social DM] âŒ Error stack:`, error.stack);
              }
            }, delayMs);
            
            console.log(`[Social DM] âœ“ setTimeout scheduled successfully for ${npc.name}`);
          }
          
          // ğŸŒ Evaluate relationship between mentioned NPC and the commenter who mentioned them
          const originalCommenter = gameState.employees.find(e => e.id === comment.authorId);
          if (originalCommenter && originalCommenter.id !== npc.id) {
            evaluateNPCReactionToPost(npc, originalCommenter, post, response);
          }
          
          // CRITICAL FIX: Immediate update of comments section
          const postEl = document.querySelector(`[data-post-id="${post.id}"]`);
          const commentsSection = document.querySelector(`.post-comments[data-post-id="${post.id}"]`);
          
          if (postEl && commentsSection) {
            console.log(`[Social] Immediately updating comments section after mention response`);
            commentsSection.style.display = 'block';
            updateCommentsSection(postEl, post);
            delete commentsSection.dataset.needsRefresh;
          }
          
          // Also request smart feed update as backup
          console.log(`[Social] Requesting smart update for post ${post.id}...`);
          requestSmartFeedUpdate(post.id);
          
          // CHAIN REACTION: Trigger potential follow-up responses from other NPCs
          setTimeout(async () => {
            await triggerCommentChainReaction(npcComment, post);
          }, 3000 + Math.random() * 4000); // 3-7 seconds later
          
        } else {
          console.log(`[Social] âœ— ${npc.name} got empty response after sanitization`);
        }
        
      } catch (error) {
        console.error(`[Social] âœ— Error generating mention response for ${npc.name}:`, error);
      }
      
      // Stagger responses for realism
      await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
    }
  }
  
  /**
   * CHAIN REACTION: NPCs respond to other NPCs' comments, creating drama and conversation threads
   */
  async function triggerCommentChainReaction(triggerComment, post) {
    if (!triggerComment || !post) return;
    
    // Don't chain if the original comment was from the player
    if (triggerComment.authorId === 'player') return;
    
    const triggerNPC = gameState.employees.find(e => e.id === triggerComment.authorId);
    if (!triggerNPC) return;
    
    console.log(`[Chain] ğŸ”— Checking for chain reactions to ${triggerNPC.name}'s comment...`);
    
    // Find potential responders
    const activeEmployees = gameState.employees.filter(e => 
      e.employmentStatus === 'active' && 
      e.id !== triggerComment.authorId // Don't respond to yourself
    );
    
    if (activeEmployees.length === 0) return;
    
    // Prioritize certain NPCs for drama:
    // 1. The original post author (if NPC)
    // 2. NPCs mentioned in the trigger comment
    // 3. NPCs with strong relationships to trigger NPC
    // 4. Random other NPCs (low chance)
    
    let potentialResponders = [];
    
    // 1. Original post author - 60% chance to respond if someone comments on their post
    if (post.authorId && post.authorId !== 'player' && post.authorId !== triggerComment.authorId) {
      const postAuthor = activeEmployees.find(e => e.id === post.authorId);
      if (postAuthor && Math.random() < 0.6) {
        potentialResponders.push({ npc: postAuthor, reason: 'post author', priority: 1 });
        console.log(`[Chain] ğŸ“ Post author ${postAuthor.name} might respond (60% chance)`);
      }
    }
    
    // 2. NPCs mentioned in the comment - 70% chance
    if (triggerComment.mentionedEmployees && triggerComment.mentionedEmployees.length > 0) {
      for (const mentionedId of triggerComment.mentionedEmployees) {
        const mentioned = activeEmployees.find(e => e.id === mentionedId);
        if (mentioned && Math.random() < 0.7) {
          potentialResponders.push({ npc: mentioned, reason: 'mentioned', priority: 1 });
          console.log(`[Chain] ğŸ‘‹ ${mentioned.name} was mentioned - might respond (70% chance)`);
        }
      }
    }
    
    // 3. NPCs with relationships to trigger NPC - 40% chance for close friends
    const relationships = triggerNPC.relationships || {};
    for (const [empId, rel] of Object.entries(relationships)) {
      const relatedNPC = activeEmployees.find(e => e.id === empId);
      if (relatedNPC && !potentialResponders.find(p => p.npc.id === empId)) {
        const relStrength = rel.strength || 0;
        if (relStrength > 60 && Math.random() < 0.4) {
          potentialResponders.push({ npc: relatedNPC, reason: `friend (${relStrength}/100)`, priority: 2 });
          console.log(`[Chain] ğŸ’• ${relatedNPC.name} is friends with ${triggerNPC.name} - might chime in`);
        }
      }
    }
    
    // 4. Random other NPCs - 20% chance for general workplace banter
    const randomPool = activeEmployees.filter(e => !potentialResponders.find(p => p.npc.id === e.id));
    if (randomPool.length > 0 && Math.random() < 0.2) {
      const random = randomPool[Math.floor(Math.random() * randomPool.length)];
      potentialResponders.push({ npc: random, reason: 'random observer', priority: 3 });
      console.log(`[Chain] ğŸ‘€ ${random.name} randomly noticed this thread`);
    }
    
    // Limit to 1-2 responders to avoid spam
    potentialResponders.sort((a, b) => a.priority - b.priority);
    potentialResponders = potentialResponders.slice(0, Math.random() < 0.3 ? 2 : 1);
    
    if (potentialResponders.length === 0) {
      console.log(`[Chain] ğŸš« No chain reactions triggered`);
      return;
    }
    
    console.log(`[Chain] âœ“ ${potentialResponders.length} NPC(s) will respond`);
    
    // Generate responses
    for (const { npc, reason } of potentialResponders) {
      try {
        console.log(`[Chain] ğŸ’¬ ${npc.name} responding (${reason})...`);
        
        // Build context with CLEAR THREADING STRUCTURE
        let threadContext = '';
        
        // Group comments by thread
        const rootComments = post.comments.filter(c => !c.replyToCommentId);
        const replyMap = {};
        post.comments.forEach(c => {
          if (c.replyToCommentId) {
            if (!replyMap[c.replyToCommentId]) replyMap[c.replyToCommentId] = [];
            replyMap[c.replyToCommentId].push(c);
          }
        });
        
        // Build threaded view focusing on the current conversation
        const buildThread = (comment, depth = 0) => {
          const indent = '  '.repeat(depth);
          let thread = `${indent}${comment.authorName}: "${comment.content}"\n`;
          const replies = replyMap[comment.id] || [];
          replies.forEach(reply => {
            thread += buildThread(reply, depth + 1);
          });
          return thread;
        };
        
        // Find which thread the trigger comment is in
        let relevantThread = '';
        const findCommentInThreads = (commentId) => {
          // Check if it's a root comment
          const isRoot = !post.comments.find(c => c.id === commentId)?.replyToCommentId;
          if (isRoot) {
            const rootComment = post.comments.find(c => c.id === commentId);
            return buildThread(rootComment);
          }
          // Find the root of this thread
          let current = post.comments.find(c => c.id === commentId);
          while (current && current.replyToCommentId) {
            current = post.comments.find(c => c.id === current.replyToCommentId);
          }
          return current ? buildThread(current) : '';
        };
        
        relevantThread = findCommentInThreads(triggerComment.id);
        
        // If there are other threads, mention them briefly
        const otherThreadsCount = rootComments.length - (relevantThread ? 1 : 0);
        const threadSummary = otherThreadsCount > 0 
          ? `(Note: There are ${otherThreadsCount} other conversation thread(s) on this post, but you're responding to THIS specific thread)\n\n`
          : '';
        
        threadContext = `${threadSummary}CONVERSATION THREAD YOU'RE JOINING:\n${relevantThread}`;
        
        const personality = npc.personality || {};
        const relationship = npc.relationships?.[triggerComment.authorId] || { strength: 50, type: 'colleague' };
        
        // Determine tone based on relationship and context
        let tone = 'casual';
        const commentLower = triggerComment.content.toLowerCase();
        
        if (relationship.strength > 70) tone = 'friendly';
        if (relationship.strength < 30) tone = 'snarky';
        if (reason === 'post author') tone = 'engaged'; // It's their post
        if (commentLower.includes('lol') || commentLower.includes('ğŸ˜‚')) tone = 'playful';
        if (commentLower.includes('?')) tone = 'helpful'; // Answering a question
        
        // TAGGING: Build list of people this NPC could tag
        let tagContext = '';
        const otherNPCs = activeEmployees.filter(e => e.id !== npc.id);
        
        if (otherNPCs.length > 0 && Math.random() < 0.35) { // 35% chance to suggest tagging
          // Prioritize: trigger comment author, post author, friends
          let taggable = [];
          
          if (triggerNPC.id !== npc.id) {
            taggable.push({ emp: triggerNPC, rel: 'commenter' });
          }
          if (post.authorId && post.authorId !== 'player' && post.authorId !== npc.id && post.authorId !== triggerNPC.id) {
            const postAuth = otherNPCs.find(e => e.id === post.authorId);
            if (postAuth) taggable.push({ emp: postAuth, rel: 'post author' });
          }
          
          // Add 1 friend if available
          const npcRels = npc.relationships || {};
          const friend = otherNPCs.find(e => {
            const rel = npcRels[e.id];
            return rel && rel.strength > 65 && !taggable.find(t => t.emp.id === e.id);
          });
          if (friend) taggable.push({ emp: friend, rel: 'friend' });
          
          if (taggable.length > 0) {
            tagContext = `\n\nOPTIONAL TAGS (use if natural): `;
            taggable.forEach(({ emp, rel }) => {
              tagContext += `@${emp.social?.username || emp.name.toLowerCase().replace(/\s+/g, '')} (${emp.name} - ${rel}), `;
            });
            tagContext = tagContext.slice(0, -2); // Remove trailing comma
          }
        }
        
        // Detect if other comments used similar patterns (avoid repetition)
        const existingPatterns = [];
        post.comments.forEach(c => {
          const lower = c.content.toLowerCase();
          // Detect common patterns
          if (/\?\s*(girl|dude|bro|man)/i.test(c.content)) existingPatterns.push('question + nickname');
          if (/still\s+(love|like|here|blooming)/i.test(c.content)) existingPatterns.push('"still" continuation');
          if (/you\s+(forgot|watered|planted)/i.test(c.content)) existingPatterns.push('direct "you" callback');
          if (/ğŸ˜‚|ğŸ˜…|ğŸ’€|lol|lmao/i.test(c.content)) existingPatterns.push('laughing response');
        });
        
        const diversityNote = existingPatterns.length > 0 
          ? `\n\nâš ï¸ AVOID THESE PATTERNS (other comments already used them):\n${[...new Set(existingPatterns)].map(p => `- ${p}`).join('\n')}\nBe creative and use a DIFFERENT angle or joke structure!`
          : '';
        
        const prompt = `You are ${npc.name}, a ${npc.age}-year-old ${npc.gender} employee, reading a comment thread on your company's social network.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“± ORIGINAL POST
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Author: ${post.authorName}
Content: "${post.content || '(image only post)'}"
${post.imageUrl ? 'Has image' : ''}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¬ ${threadContext}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ YOUR CONTEXT:
- WHY you're commenting: ${reason}
- Your relationship with ${triggerNPC.name}: ${relationship.strength}/100 (${relationship.type})
- Your tone: ${tone}
- Confidence: ${personality.confidence || 50}/100
- Humor: ${personality.humor || 50}/100

ğŸ“‹ CRITICAL RULES:
1. Read the ENTIRE thread above - understand what's being discussed
2. Your comment must be DIRECTLY RELEVANT to ${triggerNPC.name}'s comment: "${triggerComment.content}"
3. Stay on the same TOPIC as the thread (don't randomly change subjects)
4. If someone asked a question, acknowledge or answer it
5. If someone made a joke, react to THAT joke (don't make a completely different joke)
6. If they mentioned someone/something specific, reference that same person/thing
7. Keep it under 100 characters
8. Use 1-2 emojis max

${diversityNote}

âŒ BAD EXAMPLES (incoherent):
Thread: "Nice photo!" â†’ "When's lunch?" (WRONG TOPIC)
Thread: "Love the sunset!" â†’ "Your compliments age like wine ğŸ˜" (WHAT?)
Thread: "Are you free Friday?" â†’ "Masterpiece of jealousy! ğŸ·" (NONSENSE)

âœ… GOOD EXAMPLES (coherent):
Thread: "Nice photo!" â†’ "The lighting is perfect! ğŸ“¸"
Thread: "Love the sunset!" â†’ "Right? The colors were amazing!"  
Thread: "Are you free Friday?" â†’ "I am! What did you have in mind?"

Write ONLY your brief, coherent comment (no quotes, no meta-text):`;

        const rawResponse = await queuedGenerateText(prompt, {
          temperature: 0.8, // Reduced from 0.9 for more coherence
          max_tokens: 40,
          stopSequences: ['\n\n', 'I would', '(', 'Rating:', '**(', '---', 'â”â”â”']
        }, `Social Chain Comment - ${npc.name}`);
        console.log(`[Chain] Raw response from ${npc.name}: "${rawResponse}"`);
        
        // Sanitize
        let response = rawResponse.trim()
          .replace(/^["']|["']$/g, '')
          .replace(/\s*\([^)]*personality[^)]*\)\.?$/i, '')
          .replace(/^(I would (say|reply|comment):|My comment would be:)\s*/i, '')
          .replace(/\n\n\(Word count:.*?\)$/i, '')
          .replace(/\s*\*\(\d+\s*characters?\)\*\s*$/i, '')
          .replace(/\s*\(\d+\s*words?\)\s*$/i, '');
        
        response = response.trim();
        console.log(`[Chain] Sanitized: "${response}"`);
        
        if (response && response.length > 0) {
          const chainComment = createComment({
            postId: post.id,
            authorId: npc.id,
            authorName: npc.name,
            content: response,
            replyToCommentId: triggerComment.id // Reply to the comment that triggered this
          });
          
          post.comments.push(chainComment);
          console.log(`[Chain] âœ“ ${npc.name} added to thread: "${response}"`);
          
          // ğŸŒ Evaluate relationship between chain commenter and original commenter
          if (triggerNPC && triggerNPC.id !== npc.id) {
            evaluateNPCCommentInteraction(npc, triggerNPC, post, triggerComment.content, response);
          }
          
          // ğŸŒ Also evaluate chain commenter's reaction to the post author
          const postAuthor = gameState.employees.find(e => e.id === post.authorId);
          if (postAuthor && postAuthor.id !== npc.id) {
            evaluateNPCReactionToPost(npc, postAuthor, post, response);
          }
          
          // CRITICAL FIX: Immediate update of comments section
          const postEl = document.querySelector(`[data-post-id="${post.id}"]`);
          const commentsSection = document.querySelector(`.post-comments[data-post-id="${post.id}"]`);
          
          if (postEl && commentsSection) {
            console.log(`[Chain] Immediately updating comments section after chain reaction`);
            commentsSection.style.display = 'block';
            updateCommentsSection(postEl, post);
            delete commentsSection.dataset.needsRefresh;
          }
          
          // Also request smart feed update as backup
          requestSmartFeedUpdate(post.id);
          
          // RECURSIVE CHAIN: 30% chance this comment triggers another response
          if (Math.random() < 0.3 && post.comments.length < 10) { // Cap at 10 comments to prevent infinite loops
            console.log(`[Chain] ğŸ”„ ${npc.name}'s comment might trigger another response...`);
            setTimeout(async () => {
              await triggerCommentChainReaction(chainComment, post);
            }, 4000 + Math.random() * 5000); // 4-9 seconds
          }
        }
        
      } catch (error) {
        console.error(`[Chain] âœ— Error generating chain response for ${npc.name}:`, error);
      }
      
      // Stagger multiple responses
      await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));
    }
  }
  
  /**
   * Trigger automatic NPC reactions to player posts
   */
  async function triggerAutomaticNPCReactions(post) {
    if (!post || !post.isPlayerPost) return;
    
    // Get all active employees
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (activeEmployees.length === 0) return;
    
    // Get mentioned employees
    const mentionedEmployeeIds = post.referencedEmployees || [];
    const mentionedEmployees = activeEmployees.filter(e => mentionedEmployeeIds.includes(e.id));
    const nonMentionedEmployees = activeEmployees.filter(e => !mentionedEmployeeIds.includes(e.id));
    
    console.log(`[Social] Post has ${mentionedEmployees.length} mentions`);
    console.log(`[Social] Mentioned employee IDs:`, mentionedEmployeeIds);
    console.log(`[Social] Active employee IDs:`, activeEmployees.map(e => e.id));
    if (mentionedEmployees.length > 0) {
      console.log(`[Social] Matched employees:`, mentionedEmployees.map(e => `${e.name} (${e.id})`));
    }
    
    // HIGH ENGAGEMENT FOR PLAYER POSTS
    // 60-80% of employees will engage (like or comment)
    // Mentioned employees have 85-95% chance to engage!
    const baseEngagementRate = 0.6 + Math.random() * 0.2;
    const mentionedEngagementRate = 0.85 + Math.random() * 0.1;
    const engagers = [];
    
    // Process mentioned employees first (higher engagement)
    for (const emp of mentionedEmployees) {
      const affection = emp.stats?.affection || 0;
      const desire = emp.stats?.desire || 0;
      const intimacy = emp.memory?.intimacyLevel || 0;
      const relationship = emp.relationships?.player?.level || 0;
      
      // Very high chance for mentioned employees
      const baseChance = mentionedEngagementRate;
      const relationshipBonus = (affection + desire + intimacy + relationship) / 400; // 0-1
      const engageChance = Math.min(0.98, baseChance + relationshipBonus);
      
      if (Math.random() < engageChance) {
        engagers.push({ emp, mentioned: true });
      }
    }
    
    // Process non-mentioned employees (normal engagement)
    for (const emp of nonMentionedEmployees) {
      const affection = emp.stats?.affection || 0;
      const desire = emp.stats?.desire || 0;
      const intimacy = emp.memory?.intimacyLevel || 0;
      const relationship = emp.relationships?.player?.level || 0;
      
      // Weight by relationship - higher affection = more likely to engage
      const baseChance = baseEngagementRate;
      const relationshipBonus = (affection + desire + intimacy + relationship) / 400; // 0-1
      const engageChance = Math.min(0.95, baseChance + relationshipBonus);
      
      if (Math.random() < engageChance) {
        engagers.push({ emp, mentioned: false });
      }
    }
    
    // Split between likers and commenters
    // Mentioned employees: 70-85% will comment (vs 40-60% for others)
    const commenters = [];
    const likers = [];
    
    for (const engager of engagers) {
      const commentRate = engager.mentioned ? (0.7 + Math.random() * 0.15) : (0.4 + Math.random() * 0.2);
      
      if (Math.random() < commentRate) {
        commenters.push(engager.emp);
      } else {
        likers.push(engager.emp);
      }
    }
    
    console.log(`[Social] Player post triggering ${engagers.length} reactions (${commenters.length} comments, ${likers.length} likes)`);
    
    // Add likes with staggered timing
    for (let i = 0; i < likers.length; i++) {
      const npc = likers[i];
      const delay = (1 + i) * (1000 + Math.random() * 2000); // 1-3 seconds each
      
      setTimeout(() => {
        if (!post.likes.includes(npc.id)) {
          post.likes.push(npc.id);
          remember(npc, `I liked the boss's post: "${post.content || 'image post'}"`, 'interaction', 0.5);
          
          if (gameState.activeTab === 'social') {
            renderSocialFeed();
          }
        }
      }, delay);
    }
    
    // Generate meaningful, context-aware comments
    for (let i = 0; i < commenters.length; i++) {
      const npc = commenters[i];
      const delay = (1 + i) * (2000 + Math.random() * 4000); // 2-6 seconds each
      
      setTimeout(async () => {
        const commentText = await generateContextAwareComment(npc, post);
        
        // ===== DETECT AND GENERATE IMAGE IF NPC CLAIMS TO UPLOAD ONE =====
        const { imageUrl, imageAlt, imagePrompt } = await detectAndGenerateCommentImage(commentText, npc, post);
        
        const comment = createComment({
          postId: post.id,
          authorId: npc.id,
          authorName: npc.name,
          content: commentText,
          imageUrl,
          imageAlt,
          imagePrompt
        });
        
        post.comments.push(comment);
        
        console.log(`[Social] ${npc.name} commented on player post: "${commentText}"${imageUrl ? ' [WITH IMAGE]' : ''}`);
        
        // ===== CHECK IF COMMENT MENTIONS SENDING A DM AND ACTUALLY SEND IT =====
        // Expanded detection for various ways NPCs might agree to send something
        const mentionsDM = /\b(check (your |my )?(dm|inbox|messages?)|sent.*(you |one |it )*(your )?way|dm(ing|'d|ed)? (you|it)|private message|slid(ing|e)? into|message(d)? you|in (your |my )?(inbox|messages|dms)|already (sent|in)|overflowing with)\b/i.test(commentText) ||
                          /\b(deal|okay|alright|sure|fine|bet)\b.*\b(boss|you|@\w+)\b/i.test(commentText) || // "Deal, boss" or "Sure, you"
                          /\b(only if|but only|promise|hands-on|supervision)\b/i.test(commentText) || // Conditional agreements "only if you..."
                          /\b(sending|upload(ing)?|post(ing)?|share|show(ing)?)\b.*\b(now|tonight|soon|later|tomorrow)\b/i.test(commentText) || // "sending it now"
                          /\b(I'?ll|gonna|going to|will|can)\s+(send|share|show|post|upload|dm)\b/i.test(commentText) || // Future tense promises
                          /\b(let me|lemme)\s+(send|grab|get|find|pull up)\b/i.test(commentText) || // "let me send"
                          /\b(coming (right |your )?(up|way)|on (its|their) way)\b/i.test(commentText) || // "coming your way"
                          /\b(give me (a )?(sec|second|minute|moment)|wait|hold on)\b.*\b(send|share|post)\b/i.test(commentText); // "give me a sec, I'll send"
        
        if (mentionsDM) {
          console.log(`[Social] ğŸ”” ${npc.name} mentioned sending DM - actually sending one now!`);
          console.log(`[Social] Comment text: "${commentText}"`);
          console.log(`[Social] Detection matched - will send DM`);
          console.log(`[Social] Post content: "${post.content || post.caption || ''}"`);
          console.log(`[Social DM] â° Will send DM in 2-5 seconds...`);
          
          // Small delay to feel natural (2-5 seconds after comment)
          const delayMs = 2000 + Math.random() * 3000;
          console.log(`[Social DM] â±ï¸ Exact delay: ${Math.round(delayMs)}ms`);
          
          setTimeout(async () => {
            console.log(`[Social DM] âš¡ TIMEOUT TRIGGERED - Starting DM generation for ${npc.name}...`);
            try {
            // Use AI to understand what was requested and generate appropriate content
            const postContent = post.content || post.caption || '';
            const physicalDesc = getPhysicalDescriptionForPrompt(npc);
            const intimacy = npc.memory?.intimacyLevel || 0;
            
            console.log(`[Social DM] Analyzing request to generate personalized DM from ${npc.name}...`);
            
            // Generate AI-powered DM message that's personalized and context-aware
            const messagePrompt = `You are ${npc.name} sending a private DM after commenting on a post.

CONTEXT:
Original post: "${postContent}"
Your comment: "${commentText}"

You mentioned checking DMs, so now you're sending the actual private message with the content they requested.

Write a short, flirty DM message (5-15 words) that:
- Acknowledges what you're sending them
- References what was specifically requested in the original post
- Matches your personality (intimacy level: ${intimacy}/100)
- Is playful/teasing but natural

Write ONLY the message text:`;

            let messageText = '';
            try {
              const rawMessage = await queuedGenerateText(messagePrompt, {
                temperature: 0.85,
                max_tokens: 30,
                stopSequences: ['\n\n', '\n---', 'Note:', 'Context:']
              }, `Social Post Message - ${npc.name}`);
              messageText = rawMessage.trim()
                .replace(/^["']|["']$/g, '')
                .split('\n')[0]
                .trim();
              
              // Fallback if generation fails
              if (!messageText || messageText.length < 3) {
                messageText = `Here's what you asked for ğŸ˜‰`;
              }
            } catch (error) {
              console.warn('[Social DM] Message generation failed, using fallback');
              messageText = `As promised ï¿½`;
            }
            
            console.log(`[Social DM] Generated message: "${messageText}"`);
            
            // Generate AI-powered image prompt based on the request
            const imageAnalysisPrompt = `Analyze this social media interaction and create an image prompt.

POST REQUEST: "${postContent}"
NPC'S COMMENT: "${commentText}"

The NPC (${npc.name}) is sending a private photo. What should it show?

PERSON: ${physicalDesc.substring(0, 300)}

Create a detailed, explicit image prompt showing ${npc.name} doing/showing EXACTLY what was requested in the post.

CRITICAL RULES:
1. Show ONLY what was actually requested in the post - read it carefully
2. Be EXPLICIT - describe nudity, body parts, sexual acts clearly if requested
3. If request is explicit, image must be explicit (full nudity, visible genitals, etc.)
4. Describe the specific activity mentioned in the post
5. Include pose, expression, setting, lighting
6. Include ${npc.name}'s physical appearance from the description above

Generate ONLY the image prompt, no explanation:`;

            let messageImage = null;
            let messageImageAlt = null;
            let messageImagePrompt = null; // Track the prompt for regeneration
            
            if (typeof generateImage === 'function') {
              try {
                const rawImagePrompt = await queuedGenerateText(imageAnalysisPrompt, {
                  temperature: 0.8,
                  max_tokens: 200,
                  stopSequences: ['\n\n', '\n---', 'Note:', 'Explanation:', 'Based on', 'Context:']
                }, `Social Post Image Analysis - ${npc.name}`);
                
                // Clean up the image prompt
                let imagePrompt = rawImagePrompt.trim()
                  .replace(/^["']|["']$/g, '')
                  .replace(/^(Image prompt:|Here is|Here's|Based on.*?:)\s*/i, '')
                  .replace(/^(the|a|an)\s+(specific\s+)?image\s+prompt.*?:\s*/i, '')
                  .split('\n')[0]
                  .trim();
                
                // Extract after colon if meta-text detected
                if (/^(based on|context|the prompt)/i.test(imagePrompt)) {
                  const match = imagePrompt.match(/:\s*(.+)$/);
                  if (match) imagePrompt = match[1].trim();
                }
                
                console.log(`[Social DM] âœ… FULL Image Prompt:\n"${imagePrompt}"`);
                
                // Store prompt for message object
                messageImagePrompt = imagePrompt;
                
                // Generate the image
                messageImage = await queuedGenerateImage(applyImageStyle(imagePrompt), `Social chain image for ${npc.name}`);
                messageImageAlt = `Private photo from ${npc.name}`;
                console.log(`[Social DM] âœ… Generated personalized image for DM from ${npc.name}`);
                
              } catch (error) {
                console.error(`[Social DM] Failed to generate image:`, error);
              }
            }
            
            // Send the actual DM
            if (!gameState.chatHistory[npc.id]) {
              gameState.chatHistory[npc.id] = [];
            }
            
            const dmMessage = {
              sender: npc.name,
              content: messageText,
              isPlayer: false,
              timestamp: gameState.time?.currentTime || Date.now(),
              imageUrl: messageImage,
              imageAlt: messageImageAlt,
              imagePrompt: messageImagePrompt // Include prompt for regeneration button
            };
            
            gameState.chatHistory[npc.id].push(dmMessage);
            
            // CRITICAL FIX: Save immediately after DM to prevent message loss
            saveGame(false);
            
            // Mark as unread
            if (!npc.unreadMessages) {
              npc.unreadMessages = 0;
            }
            npc.unreadMessages++;
            
            // Update message list if on messages tab
            if (gameState.activeTab === 'messages') {
              renderMessagesList();
            }
            
            // Show notification toast
            showNotification(`ğŸ’¬ ${npc.name} sent you a private message${messageImage ? ' with a photo' : ''}!`, 'info');
            
            console.log(`[Social DM] âœ… ${npc.name} sent actual DM as promised in comment!${messageImage ? ' [WITH IMAGE]' : ''}`);
            console.log(`[Social DM] âœ… COMPLETE - DM successfully delivered from ${npc.name}`);
            
            } catch (error) {
              console.error(`[Social DM] âŒ ERROR in setTimeout callback for ${npc.name}:`, error);
              console.error(`[Social DM] âŒ Error stack:`, error.stack);
            }
          }, delayMs); // 2-5 second delay
          
          console.log(`[Social DM] âœ“ setTimeout scheduled successfully for ${npc.name}`);
        }
        
        // ===== CHECK IF COMMENT CLAIMS TO HAVE MADE A NEW POST AND ACTUALLY CREATE IT =====
        // Don't trigger if they're talking about DMs/inbox - that's handled above
        const talkingAboutDM = /\b(dm|inbox|message|private|check your)\b/i.test(commentText);
        const claimsNewPost = !talkingAboutDM && /\b(just posted|posted (it|mine|this)|already posted|made a post|shared (it|this)|uploaded (it|this))\b/i.test(commentText);
        if (claimsNewPost) {
          console.log(`[Social] ğŸ“ ${npc.name} claims to have made a new post - creating it now!`);
          console.log(`[Social] Comment text: "${commentText}"`);
          
          // Delay to feel natural (3-8 seconds after comment)
          setTimeout(async () => {
            try {
              // Determine post type based on context
              const postContent = post.content || post.caption || '';
              const combinedContext = (postContent + ' ' + commentText).toLowerCase();
              
              // Detect what kind of post they're claiming to have made
              const isCatPost = /\b(cat|kitty|kitten|pussy|feline)\b/i.test(combinedContext) && 
                               !/\b(nude|naked|explicit|spread|wet)\b/i.test(combinedContext);
              const isPetPost = /\b(dog|pet|puppy|animal)\b/i.test(combinedContext);
              const isNudePost = /\b(nude|naked|bare|nothing on)\b/i.test(combinedContext);
              const isSexyPost = /\b(sexy|hot|spicy|sultry|juicy|treat|peek)\b/i.test(combinedContext) && !isCatPost;
              const isSelfiePost = /\b(selfie|pic|photo)\b/i.test(combinedContext);
              
              // Generate post content
              let postType = 'selfie';
              let postCaption = '';
              let postImagePrompt = '';
              
              if (isCatPost) {
                postType = 'selfie';
                postCaption = ['Here she is! ğŸ±', 'My beautiful kitty ğŸ˜»', 'She\'s camera-ready ğŸ“¸', 'Cat tax paid! ğŸˆ'][Math.floor(Math.random() * 4)];
                postImagePrompt = 'Cute cat photo, adorable kitten, wholesome pet photography';
              } else if (isPetPost) {
                postType = 'selfie';
                postCaption = ['Doggo selfie time! ğŸ•', 'Best friend photo ğŸ¾', 'Puppy love ğŸ’•'][Math.floor(Math.random() * 3)];
                postImagePrompt = 'Cute dog photo, adorable puppy, wholesome pet photography';
              } else if (isNudePost) {
                postType = 'nude';
                postCaption = ['As requested ğŸ˜', 'Just for you ğŸ’‹', 'Hope you enjoy ğŸ”¥'][Math.floor(Math.random() * 3)];
                postImagePrompt = `Artistic nude photograph of ${npc.name}, ${getPhysicalDescriptionForPrompt(npc)}, tasteful lighting, beautiful composition, intimate`;
              } else if (isSexyPost) {
                postType = 'thirst_trap';
                postCaption = ['Feeling myself ğŸ˜˜', 'Here\'s that peek ğŸ‘€', 'Enjoy the view ğŸ”¥'][Math.floor(Math.random() * 3)];
                postImagePrompt = `Sexy photo of ${npc.name}, ${getPhysicalDescriptionForPrompt(npc)}, alluring pose, confident expression, sultry`;
              } else if (isSelfiePost) {
                postType = 'selfie';
                postCaption = ['Fresh selfie ğŸ“¸', 'How do I look? ğŸ˜Š', 'Felt cute ğŸ’•'][Math.floor(Math.random() * 3)];
                postImagePrompt = `Selfie photo of ${npc.name}, ${getPhysicalDescriptionForPrompt(npc)}, friendly smile, natural lighting`;
              }
              
              // Generate the image
              let imageUrl = null;
              if (typeof generateImage === 'function') {
                try {
                  imageUrl = await queuedGenerateImage(applyImageStyle(postImagePrompt), `Social follow-up post image for ${npc.name}`);
                  console.log(`[Social Follow-up Post] Generated ${postType} image for ${npc.name}'s post`);
                } catch (error) {
                  console.warn(`[Social Follow-up Post] Failed to generate image:`, error);
                }
              }
              
              // Create the post
              const newPost = createPost({
                authorId: npc.id,
                authorName: npc.name,
                content: postCaption,
                caption: postCaption,
                type: imageUrl ? postType : 'text',
                imageUrl: imageUrl,
                imagePrompt: postImagePrompt,
                timestamp: gameState.time?.currentTime || Date.now()
              });
              
              // Add to feed at the top (most recent)
              gameState.socialNetwork.posts.unshift(newPost);
              
              // Update memory
              remember(npc, `I posted on social media: "${postCaption}"${imageUrl ? ' with image' : ''}`, 'social', 0.6);
              
              // Refresh feed if viewing
              if (gameState.activeTab === 'social') {
                renderSocialFeed();
              }
              
              console.log(`[Social Follow-up Post] âœ… ${npc.name} actually posted as claimed: "${postCaption}"${imageUrl ? ' [WITH IMAGE]' : ''}`);
              showNotification(`ğŸ“± ${npc.name} just posted${imageUrl ? ' a new photo' : ''}!`, 'info');
              
            } catch (error) {
              console.error(`[Social Follow-up Post] Error creating post for ${npc.name}:`, error);
            }
          }, 3000 + Math.random() * 5000); // 3-8 second delay
        }
        
        // Small chance (10%) for this comment to trigger more engagement
        if (post.comments.length >= 3 && Math.random() < 0.10) {
          console.log(`[Social] ğŸ”¥ ${npc.name}'s comment sparked more discussion!`);
          setTimeout(async () => {
            await triggerAdditionalNPCComments(post);
          }, 5000 + Math.random() * 6000); // 5-11 seconds delay
        }
        
        // Boost affection slightly for commenting
        if (npc.stats) {
          npc.stats.affection = Math.min(100, (npc.stats.affection || 0) + 1);
        }
        
        remember(npc, `I commented on boss's post: "${commentText}"`, 'interaction', 0.8);
        
        if (gameState.activeTab === 'social') {
          renderSocialFeed();
        }
      }, delay);
    }
  }
  
  /**
   * Trigger additional NPCs to join an active conversation
   * Called when a post reaches 3+ comments to reinvigorate discussion
   */
  async function triggerAdditionalNPCComments(post) {
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (activeEmployees.length === 0) return;
    
    // Get NPCs who haven't commented yet
    const alreadyCommented = new Set(
      post.comments
        .filter(c => c.authorId !== 'player')
        .map(c => c.authorId)
    );
    
    const eligibleNPCs = activeEmployees.filter(npc => !alreadyCommented.has(npc.id));
    if (eligibleNPCs.length === 0) return;
    
    console.log(`[Social] ğŸ”„ Reinvigorating conversation on post ${post.id} (${post.comments.length} comments)`);
    
    // 30% chance per eligible NPC, max 2 additional comments
    let additionalComments = 0;
    const maxAdditional = 2;
    
    for (const npc of eligibleNPCs) {
      if (additionalComments >= maxAdditional) break;
      
      // Higher chance if they're friends with someone in the conversation
      let baseChance = 0.30;
      for (const comment of post.comments) {
        if (comment.authorId === 'player') continue;
        const relationship = npc.relationships?.[comment.authorId];
        if (relationship && relationship.strength > 60) {
          baseChance += 0.20; // +20% if friends with a commenter
          break;
        }
      }
      
      if (Math.random() < baseChance) {
        console.log(`[Social] ${npc.name} joining active conversation (${Math.round(baseChance * 100)}% chance)`);
        
        // Generate comment using existing context-aware system
        try {
          const commentText = await generateContextAwareComment(npc, post);
          
          if (commentText) {
            // ===== DETECT AND GENERATE IMAGE IF NPC CLAIMS TO UPLOAD ONE =====
            const { imageUrl, imageAlt, imagePrompt } = await detectAndGenerateCommentImage(commentText, npc, post);
            
            const comment = createComment({
              postId: post.id,
              authorId: npc.id,
              authorName: npc.name,
              content: commentText,
              imageUrl,
              imageAlt,
              imagePrompt
            });
            
            post.comments.push(comment);
            additionalComments++;
            
            console.log(`[Social] âœ“ ${npc.name} added to conversation: "${commentText}"${imageUrl ? ' [WITH IMAGE]' : ''}`);
            
            // Boost affection slightly for commenting
            if (npc.stats) {
              npc.stats.affection = Math.min(100, (npc.stats.affection || 0) + 1);
            }
            
            remember(npc, `I joined a conversation on ${post.isPlayerPost ? "boss's" : "a coworker's"} post: "${commentText}"`, 'interaction', 0.7);
            
            // Update feed
            requestSmartFeedUpdate(post.id);
          }
        } catch (error) {
          console.error(`Error generating reinvigoration comment from ${npc.name}:`, error);
        }
      }
    }
    
    if (additionalComments > 0) {
      console.log(`[Social] ğŸ‰ Added ${additionalComments} new voice(s) to the conversation`);
    }
  }
  
  /**
   * Generate meaningful, context-aware comments on player posts
   * Uses AI to create natural, personality-driven responses
   */
  async function generateContextAwareComment(employee, post) {
    const affection = employee.stats?.affection || 0;
    const desire = employee.stats?.desire || 0;
    const intimacy = employee.memory?.intimacyLevel || 0;
    const personality = employee.personality || {};
    
    // Build relationship context
    const relationshipLevel = 
      intimacy > 70 ? 'very intimate' :
      intimacy > 40 ? 'romantically involved' :
      affection > 70 ? 'very close friends' :
      affection > 40 ? 'friendly' :
      affection > 20 ? 'cordial' : 'professional';
    
    // Analyze post content for context
    const content = post.content || '';
    const hasImage = !!post.imageUrl;
    const imageContext = post.imageAlt || '';
    const isExplicit = post.explicitLevel >= 2;
    
    // Build personality description
    const personalityDesc = `flirty: ${personality.flirty || 50}/100, outgoing: ${personality.outgoing || 50}/100, confidence: ${personality.confidence || 50}/100, professional: ${personality.professional || 50}/100`;
    
    // TAGGING LOGIC: Find potential NPCs to tag in comment
    let tagContext = '';
    let potentialTags = [];
    
    // Get other active employees (excluding this one)
    const otherEmployees = gameState.employees.filter(e => 
      e.employmentStatus === 'active' && 
      e.id !== employee.id &&
      e.id !== 'player'
    );
    
    if (otherEmployees.length > 0) {
      // Find friends (high relationship strength)
      const relationships = employee.relationships || {};
      const friends = otherEmployees.filter(e => {
        const rel = relationships[e.id];
        return rel && rel.strength > 60;
      }).slice(0, 2); // Max 2 friends
      
      // If post author is an NPC and not this employee, they're a prime target
      const postAuthor = otherEmployees.find(e => e.id === post.authorId);
      
      // Build list of taggable people
      if (postAuthor && !friends.find(f => f.id === postAuthor.id)) {
        potentialTags.push({ employee: postAuthor, reason: 'post author' });
      }
      friends.forEach(f => potentialTags.push({ employee: f, reason: 'friend' }));
      
      // Add 1-2 random others if list is short
      if (potentialTags.length < 2) {
        const randomOthers = otherEmployees
          .filter(e => !potentialTags.find(t => t.employee.id === e.id))
          .sort(() => Math.random() - 0.5)
          .slice(0, 2 - potentialTags.length);
        randomOthers.forEach(e => potentialTags.push({ employee: e, reason: 'coworker' }));
      }
      
      // Build tag context for AI (40% chance to suggest tagging)
      if (potentialTags.length > 0 && Math.random() < 0.4) {
        tagContext = `\n\nOPTIONAL: You can tag coworkers if relevant. Available to tag:\n`;
        potentialTags.forEach(({ employee: emp, reason }) => {
          tagContext += `- @${emp.social?.username || emp.name.toLowerCase().replace(/\s+/g, '')} (${emp.name} - ${reason})\n`;
        });
        tagContext += `\nOnly tag if it makes sense for the comment (e.g., "Right @sarah?", "@mike needs to see this", "@jessica told me about this"). Don't force it.`;
      }
    }
    
    // Gender-appropriate description with race information
    const raceInfo = employee.race && employee.race !== 'human' ? ` (${employee.race})` : '';
    const genderDesc = employee.gender ? `, a ${employee.age || 'young'}-year-old ${employee.gender === 'male' ? 'man' : employee.gender === 'transMan' ? 'trans man' : employee.gender === 'transWoman' ? 'trans woman' : employee.gender === 'femaleFuta' ? 'woman' : 'woman'}${raceInfo}` : '';
    
    // Check if post is asking for images/photos and what kind
    const asksForImages = /\b(send|post|share|show|upload|pic|photo|image|selfie)\b/i.test(content);
    const asksForExplicit = /\b(nude|naked|tits|boobs|breasts|pussy|ass|masturbat|explicit|lewd|sex|dick|cock|cum)\b/i.test(content);
    const asksForCasual = /\b(cat|kitty|dog|pet|selfie)\b/i.test(content);
    
    // IMPROVED: More explicit prompt that prevents meta-commentary with race context
    const prompt = `You are ${employee.name}${genderDesc} commenting on a social media post.

POST: "${content.substring(0, 150)}"
${hasImage ? `[Post has image: ${imageContext}]` : ''}

Your personality: ${personalityDesc}
Relationship with poster: ${relationshipLevel}

CRITICAL RULES:
- Write ONLY the comment text itself (5-20 words)
- NO third-person narration (NO "*eyes scan*", "*chuckle escapes*")
- NO meta-text (NO "Here's my comment:", "Based on personality:")
- NO name prefixes (NO "${employee.name}:" or "${employee.name}'s comment:")
- Be natural and conversational like a real social media comment

${asksForImages ? `
SPECIAL CONTEXT - Post is requesting images:
${asksForExplicit ? `- Post asks for EXPLICIT/NUDE content
- Options: 1) Share publicly (say "Here's mine!" or similar), 2) Offer privately (say "Check your DMs" or "Sent you something")
- If ${relationshipLevel} and ${intimacy > 40 ? 'intimate enough' : 'NOT intimate enough'}, ${intimacy > 40 ? 'you might share or send' : 'you might deflect or refuse'}.
- DON'T say "already sent" - say you're sending NOW` : asksForCasual ? `- Post asks for casual content (pets, selfies, etc)
- Say you're sharing: "Here's my kitty! ğŸ±" or "My cat! ğŸ“¸" or similar
- Keep it simple and direct` : `- Post requests images
- Say you're sharing if you want to: "Here's mine!" or "Posted! ğŸ“¸"
- Or mention DMs: "Check your inbox! ğŸ˜‰"`}` : ''}

${tagContext}

Write your comment:`;

    try {
      const response = await queuedGenerateText(prompt, { 
        temperature: 0.85,
        top_p: 0.92, 
        max_tokens: 35,
        stopSequences: ['\n\n', '\n---', 'Boss', 'Personality', 'Comment:', 'Based on', 'Analysis:', '{SEEDS', '{BAN', '{BOOST', 'Word count']
      }, `Generating social post comment for ${employee.name}`);
      let comment = response.trim();
      
      // ENHANCED SANITIZATION
      // Take first line only
      comment = comment.split('\n')[0].trim();
      
      // Remove quotes
      comment = comment.replace(/^["']|["']$/g, '');
      
      // Remove Perchance tokens
      comment = comment.replace(/\{[A-Z_]+:[^}]*\}/g, '');
      
      // Remove meta prefixes aggressively
      comment = comment.replace(/^(Here's |Based on |My comment is:? |I would (say|comment|reply):? |Comment:? )/i, '');
      
      // Remove name prefixes ONLY if they have possessive ('s) OR colon OR "comment/reply" word
      // This pattern requires either: "Name's", "Name:", "Name comment:", "First Last's comment:" etc.
      comment = comment.replace(/^[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*(?:'s\s+(?:comment|reply)?|:\s*["']?|\s+(?:comment|reply)s?:?\s*["']?)/i, '');
      
      // Remove narration/action text (including character actions)
      comment = comment.replace(/^\*.*?\*\s*/g, ''); // Asterisk-wrapped actions
      comment = comment.replace(/^[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+(raised|lifted|smiled|grinned|chuckled|laughed|sighed|looked|glanced|scanned|typed|tapped|smirked|winked).*?\.\s*/i, ''); // "Name raised an eyebrow..."
      comment = comment.replace(/^The .*? (lit up|flashes|shows|displays):?\s*["']?/i, '');
      
      // Remove "already sent/DM'd/slid into" if present - they should say they're posting/sending NOW
      comment = comment.replace(/\b(already|just) (sent|DM'?d|shared|posted|slid into)\b/gi, 'Sending to');
      comment = comment.replace(/\bslid into (your|my) (dms?|inbox)\b/gi, 'Check your DMs');
      
      // If still starts with meta-text or narration, use fallback
      // NOTE: "My [pet]" is NORMAL, only catch "My comment" type meta-text
      if (/^(\*|The screen |The phone |Based on|Here's my comment|Boss said|Personality traits|Brainstorm|\([A-Z]|[A-Z][a-z]+\s+[A-Z][a-z]+'s comment)/i.test(comment)) {
        console.warn(`[Context Comment] Meta-text/narration detected: "${comment.substring(0, 60)}"`);
        
        // Generate simple fallback based on context
        if (asksForImages) {
          const imageResponses = ['Here\'s mine! ğŸ±', 'Posted! ğŸ“¸', 'Hope this helps! ğŸ’•', 'My kitty! ğŸ˜»', 'Sharing now! âœ¨'];
          return imageResponses[Math.floor(Math.random() * imageResponses.length)];
        }
        return generateTemplateComment(employee, post);
      }
      
      // Final validation - must have actual content
      if (!comment || comment.length < 3) {
        return generateTemplateComment(employee, post);
      }
      
      return comment;
      
    } catch (error) {
      console.error('AI comment generation failed:', error);
      return generateTemplateComment(employee, post);
    }
  }
  
  /**
   * Generate template-based comment as fallback
   */
  function generateTemplateComment(employee, post) {
    const affection = employee.stats?.affection || 0;
    const desire = employee.stats?.desire || 0;
    const intimacy = employee.intimacy || 0;
    const personality = employee.personality || {};
    
    const isExplicit = post.explicitLevel >= 2;
    const hasImage = !!post.imageUrl;
    
    // High intimacy + explicit content
    if (intimacy > 60 && isExplicit && personality.flirty > 60) {
      const comments = ['ğŸ¥µğŸ¥µğŸ¥µ', 'Boss... wow ğŸ˜', 'You\'re dangerous ğŸ”¥', 'Stop it I can\'t handle this ğŸ‘€ğŸ’•', 'The way you look... damn'];
      return comments[Math.floor(Math.random() * comments.length)];
    }
    
    // High intimacy
    if (intimacy > 50) {
      const comments = ['You always know how to make my day ğŸ˜˜', 'Obsessed with everything about this ğŸ’•', 'The most beautiful person I know', 'Can\'t stop looking at this ğŸ˜', 'How are you even real ğŸ”¥'];
      return comments[Math.floor(Math.random() * comments.length)];
    }
    
    // High affection + flirty
    if (affection > 60 && personality.flirty > 60 && desire > 40) {
      const comments = ['Okay but WHY do you look this good ğŸ‘€', 'The confidence! I\'m here for it ğŸ”¥', 'Serving looks as always ğŸ˜', 'This energy >>> everything', 'How do you do this every single time'];
      return comments[Math.floor(Math.random() * comments.length)];
    }
    
    // High affection
    if (affection > 50) {
      const comments = ['Love this so much! ğŸ’•', 'This just made my whole day better âœ¨', 'You\'re literally glowing in this ğŸŒŸ', 'Main character energy right here', 'Absolutely love everything about this'];
      return comments[Math.floor(Math.random() * comments.length)];
    }
    
    // Moderate relationship
    if (affection > 30) {
      const comments = ['This is such a vibe! ğŸ˜Š', 'Love this! ğŸ’™', 'Looking amazing boss! âœ¨', 'Great post! ğŸ”¥', 'Absolutely love it!'];
      return comments[Math.floor(Math.random() * comments.length)];
    }
    
    // Professional/lower affection
    const comments = ['Great post boss! ğŸ‘', 'Love the energy! âœ¨', 'This is awesome!', 'Really nice! ğŸ˜Š', 'Love it! ğŸ’™'];
    return comments[Math.floor(Math.random() * comments.length)];
  }
  
  /**
   * Check for proactive NPC messages
   * NPCs will reach out to the player based on various triggers
   */
  async function checkForProactiveMessages() {
    // Don't send messages too frequently
    if (!gameState.lastProactiveMessageCheck) {
      gameState.lastProactiveMessageCheck = Date.now();
      return;
    }
    
    const timeSinceLastCheck = Date.now() - gameState.lastProactiveMessageCheck;
    if (timeSinceLastCheck < 60000) return; // Min 1 minute between checks
    
    gameState.lastProactiveMessageCheck = Date.now();
    
    // Get eligible NPCs (active employees only)
    const eligibleNPCs = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (eligibleNPCs.length === 0) return;
    
    // Check each NPC for messaging triggers (but limit to 1-2 per check)
    let messagesThisCheck = 0;
    const maxMessagesPerCheck = Math.random() > 0.7 ? 2 : 1;
    
    for (const npc of eligibleNPCs) {
      if (messagesThisCheck >= maxMessagesPerCheck) break;
      
      // Check if this NPC should message the player
      const shouldMessage = await evaluateProactiveMessageTriggers(npc);
      if (shouldMessage) {
        await sendProactiveNPCMessage(npc, shouldMessage.reason, shouldMessage.context);
        messagesThisCheck++;
      }
    }
  }
  
  /**
   * Evaluate if an NPC should send a proactive message 
   * OPTIMIZATION: Skip employees that are already blocked
   */
  async function evaluateProactiveMessageTriggers(npc) {
    // Initialize proactive message tracking for this NPC if needed
    if (!npc.proactiveMessages) {
      npc.proactiveMessages = {
        lastSentTime: 0,              // Last time NPC sent proactive message (game time)
        lastSentRealTime: 0,          // Last time NPC sent proactive message (real time)
        consecutiveUnreplied: 0,      // Count of consecutive unreplied proactive messages
        lastMoneyRequestTime: 0,      // Last money request (game time)
        hasUnrepliedMoneyRequest: false  // Pending money request
      };
    }
    
    // AI Optimization: Skip if already blocked (temporary blocks from recent activity)
    if (aiOptimization.blockedProactiveMessages.has(npc.id)) {
      return false;
    }
    
    const now = Date.now();
    const gameTime = gameState.time?.currentTime || now;
    
    // Get chat history
    const chatHistory = gameState.chatHistory[npc.id] || [];
    const lastMessage = chatHistory[chatHistory.length - 1];
    const lastMessageTime = lastMessage?.timestamp || 0;
    const hoursSinceLastMessage = (now - lastMessageTime) / (1000 * 60 * 60);
    const minutesSinceLastMessage = (now - lastMessageTime) / (1000 * 60);
    const secondsSinceLastMessage = (now - lastMessageTime) / 1000;
    
    // CRITICAL FIX: Don't interrupt active conversations
    // If ANY message (player or NPC) was sent in the last 60 REAL minutes, consider it an active conversation
    // This prevents money requests immediately after the first message
    if (minutesSinceLastMessage < 60) {
      aiOptimization.blockedProactiveMessages.add(npc.id);
      return false;
    }
    
    // Extra protection: Check for recent player activity specifically
    // If player sent a message in the last 2 HOURS, don't send proactive messages
    // This ensures conversations have truly ended before NPCs reach out
    const lastPlayerMessage = [...chatHistory].reverse().find(msg => msg.isPlayer);
    const timeSincePlayerMessage = lastPlayerMessage?.timestamp ? (now - lastPlayerMessage.timestamp) : Infinity;
    const minutesSincePlayerMessage = timeSincePlayerMessage / (1000 * 60);
    
    if (minutesSincePlayerMessage < 120) {
      aiOptimization.blockedProactiveMessages.add(npc.id);
      return false;
    }
    
    // FIXED: Count consecutive NPC messages since the last player message
    // Prevent NPC from spamming multiple messages without player response
    let consecutiveNPCMessages = 0;
    for (let i = chatHistory.length - 1; i >= 0; i--) {
      if (chatHistory[i].isPlayer) {
        break; // Found the last player message
      }
      if (!chatHistory[i].isPlayer) {
        consecutiveNPCMessages++;
      }
    }
    
    // Check if there are unreplied proactive messages
    // Update the tracking count
    npc.proactiveMessages.consecutiveUnreplied = consecutiveNPCMessages;
    
    // RULE: Max 3 unprompted messages before player must respond
    if (npc.proactiveMessages.consecutiveUnreplied >= 3) {
      return false;
    }
    
    // RULE: Once per in-game day per NPC
    // Check if NPC sent a proactive message in the last 24 game hours
    const gameTimeSinceLastProactive = gameTime - npc.proactiveMessages.lastSentTime;
    const gameHoursSinceLastProactive = gameTimeSinceLastProactive / (1000 * 60 * 60);
    
    if (gameHoursSinceLastProactive < 24) {
      return false;
    }
    
    // Also check real-time cooldown (min 30 minutes real time between proactive messages)
    const realTimeSinceLastProactive = now - npc.proactiveMessages.lastSentRealTime;
    const realMinutesSinceLastProactive = realTimeSinceLastProactive / (1000 * 60);
    
    if (realMinutesSinceLastProactive < 30) {
      return false;
    }
    
    // Get relationship stats
    const relationship = npc.relationships?.player || { level: 0, type: 'professional' };
    const intimacy = npc.intimacy || 0;
    const affection = npc.stats?.affection || 0;
    const trust = npc.stats?.trust || 0;
    
    // Higher intimacy/affection = more likely to message
    const baseChance = 0.05; // 5% base chance
    const relationshipBonus = (relationship.level / 100) * 0.15; // Up to +15%
    const intimacyBonus = (intimacy / 100) * 0.20; // Up to +20%
    const timeBonus = Math.min(hoursSinceLastMessage / 24, 0.10); // Up to +10% based on time
    
    const totalChance = baseChance + relationshipBonus + intimacyBonus + timeBonus;
    
    if (Math.random() > totalChance) return false;
    
    // Determine message reason and context
    const reasons = [];
    
    // Message count affects reason weighting
    const messageCount = (gameState.chatHistory[npc.id] || []).length;
    const isDevelopedRelationship = messageCount > 20;
    const isMidRelationship = messageCount > 10;
    
    // Work-related messages (lower weight for developed relationships)
    const workWeight = isDevelopedRelationship ? 1 : isMidRelationship ? 2 : 3;
    reasons.push({ reason: 'work_question', weight: workWeight, context: 'work' });
    reasons.push({ reason: 'work_update', weight: workWeight, context: 'work' });
    
    // Personal messages (MUCH higher weight for developed relationships)
    if (affection > 30) {
      const casualWeight = isDevelopedRelationship ? 5 : isMidRelationship ? 3 : 2;
      reasons.push({ reason: 'casual_chat', weight: casualWeight, context: 'casual' });
    }
    if (affection > 50) {
      const sharingWeight = isDevelopedRelationship ? 4 : 2;
      reasons.push({ reason: 'sharing_news', weight: sharingWeight, context: 'personal' });
    }
    if (trust > 60) {
      const adviceWeight = isDevelopedRelationship ? 3 : 1;
      reasons.push({ reason: 'asking_advice', weight: adviceWeight, context: 'personal' });
    }
    
    // Social media related
    const recentPosts = gameState.socialNetwork.posts
      .filter(p => p.authorId === npc.id && (now - p.timestamp) < 86400000) // Last 24h
      .slice(0, 3);
    if (recentPosts.length > 0) {
      reasons.push({ reason: 'post_followup', weight: 2, context: { type: 'social', post: recentPosts[0] } });
    }
    
    // Flirty/intimate messages (based on intimacy)
    if (intimacy > 40) {
      reasons.push({ reason: 'flirty_message', weight: 1, context: 'flirty' });
    }
    if (intimacy > 70) {
      reasons.push({ reason: 'booty_call', weight: 1, context: 'intimate' });
    }
    
    // MONEY REQUEST: Special handling - only if no unanswered request exists
    // REDUCED FREQUENCY: Now requires 7 game days (168 hours) instead of 1 day
    const gameTimeSinceLastMoneyRequest = gameTime - npc.proactiveMessages.lastMoneyRequestTime;
    const gameHoursSinceLastMoneyRequest = gameTimeSinceLastMoneyRequest / (1000 * 60 * 60);
    const gameDaysSinceLastMoneyRequest = gameHoursSinceLastMoneyRequest / 24;
    
    // Initialize financial tracking if needed
    if (!npc.bankBalance) npc.bankBalance = 0;
    if (!npc.spendingRate) {
      npc.spendingRate = 50 + Math.random() * 150; // $50-200 per day
    }
    
    // Calculate if they need money
    const isLowOnCash = npc.bankBalance < (npc.spendingRate * 14); // 2 weeks
    const isBroke = npc.bankBalance < (npc.spendingRate * 7); // 1 week
    
    // PLAYER FEEDBACK FIX: Money requests much less frequent now
    // Base requirement: 7 game days between requests (was 1 day)
    // Emergency requests (broke): 3 game days minimum
    // CRITICAL NEW RULE: NEVER send money request in first 30 messages
    const minDaysRequired = isBroke ? 3 : 7;
    const hasEstablishedRelationship = messageCount >= 30; // At least 30 messages exchanged
    
    if (!npc.proactiveMessages.hasUnrepliedMoneyRequest && 
        gameDaysSinceLastMoneyRequest >= minDaysRequired &&
        hasEstablishedRelationship) {  // NEW: Require established relationship
      // SIGNIFICANTLY REDUCED WEIGHTS - money requests should be rare
      // Target: ~3-5% of all proactive messages (was 15%)
      let moneyWeight = 2; // Base weight (reduced from 8) - now rare
      
      // Increase weight moderately if they actually need money
      if (isBroke) moneyWeight = 8; // High priority if broke (reduced from 20)
      else if (isLowOnCash) moneyWeight = 5; // Moderate priority if low on cash (reduced from 14)
      
      // Money requests only with high affection/trust
      if (affection > 50 && trust > 50) {
        reasons.push({ reason: 'money_request', weight: moneyWeight, context: 'money' });
      } else if (affection > 40 && isBroke) {
        // Even with lower trust, broke NPCs might still ask (but much lower weight)
        reasons.push({ reason: 'money_request', weight: Math.max(2, moneyWeight - 3), context: 'money' });
      }
    }
    
    // Recent events
    const recentEvents = (gameState.companyEvents || [])
      .filter(e => e.involvedEmployees?.includes(npc.id) && (now - e.timestamp) < 86400000)
      .slice(0, 2);
    if (recentEvents.length > 0) {
      reasons.push({ reason: 'event_reaction', weight: 2, context: { type: 'event', event: recentEvents[0] } });
    }
    
    // Weighted random selection
    const totalWeight = reasons.reduce((sum, r) => sum + r.weight, 0);
    let random = Math.random() * totalWeight;
    
    for (const reasonObj of reasons) {
      random -= reasonObj.weight;
      if (random <= 0) {
        return reasonObj;
      }
    }
    
    return reasons[0]; // Fallback
  }
  
  /**
   * Send a proactive message from NPC to player
   */
  async function sendProactiveNPCMessage(npc, reason, context) {
    try {
      // ğŸ’° SPECIAL HANDLING: Money requests should use the proper modal, not text
      if (reason === 'money_request') {
        // Calculate request amount based on financial situation
        const spendingRate = npc.spendingRate || calculateScaledSpendingRate();
        const bankBalance = npc.bankBalance || 0;
        const timeSinceLastRequest = Date.now() - (npc.lastMoneyRequest || 0);
        const daysSinceLastRequest = timeSinceLastRequest / (1000 * 60 * 60 * 24);
        
        // Financial situation analysis
        const isLowOnCash = bankBalance < (spendingRate * 7);
        const isBroke = bankBalance < (spendingRate * 2);
        
        // Calculate requested amount
        let requestedAmount;
        if (isBroke) {
          const weeksNeeded = 1 + Math.random();
          requestedAmount = Math.floor(spendingRate * 7 * weeksNeeded);
        } else if (isLowOnCash) {
          requestedAmount = Math.floor(spendingRate * 7);
        } else {
          const companyScale = Math.log10(gameState.cash + 1000);
          const baseAmount = Math.pow(10, companyScale - 2);
          const variation = 0.5 + Math.random() * 2;
          requestedAmount = Math.floor(baseAmount * variation);
        }
        
        // Ensure minimum and maximum
        const amount = Math.max(500, Math.min(requestedAmount, gameState.cash * 0.15));
        
        // Round to nice numbers
        const roundedAmount = Math.round(amount / 50) * 50;
        
        // Determine request category
        let requestCategory;
        if (isBroke) {
          requestCategory = 'desperate_need';
        } else if (isLowOnCash) {
          requestCategory = 'financial_trouble';
        } else if (bankBalance > spendingRate * 30) {
          requestCategory = 'luxury_want';
        } else {
          requestCategory = 'specific_purchase';
        }
        
        // Generate AI reason for money request
        const personality = npc.personality || {};
        const affection = npc.stats?.affection || 0;
        const desire = npc.stats?.desire || 0;
        const trust = npc.stats?.trust || 50;
        const obedience = npc.stats?.obedience || 50;
        
        const reasonPrompt = `${npc.name} wants to ask their boss for $${formatCash(roundedAmount)}.

PERSONALITY & STATS:
- Personality: Confidence ${personality.confidence || 50}/100, Flirty ${personality.flirty || 50}/100, Professional ${personality.professional || 50}/100
- Relationship: Affection ${affection}/100, Desire ${desire}/100, Trust ${trust}/100, Obedience ${obedience}/100

FINANCIAL CONTEXT:
- Current balance: $${formatCash(bankBalance)}
- Daily spending: $${formatCash(spendingRate)}/day
- Category: ${requestCategory}
${isBroke ? '- STATUS: Nearly broke! Urgent need.' : ''}
${isLowOnCash ? '- STATUS: Running low, getting worried.' : ''}

Request categories guide:
- desperate_need: Bills overdue, can't afford rent/food, emergency, very apologetic
- financial_trouble: Running low, stressed about money, expenses piling up
- specific_purchase: Want something specific (gadget, clothes, experience, date, hobby item)
- luxury_want: Not needed but would love to have, indulgent, aspirational

Write a natural, in-character message asking for this money (2-3 sentences). Be specific with details (brand names, stores, items, real reasons). Match their personality and relationship level.

EXAMPLES:
- Desperate: "Boss... I'm so sorry but I'm really struggling. Rent is due and I'm short $X. Could you help me out? ğŸ¥º"
- Financial trouble: "Hey, so my car died and I need $X to fix it. Kind of in a bind here... any chance you could help? ğŸ˜…"
- Specific purchase: "OMG there's this amazing [item] at [store] for $X and I NEED it... could you maybe help? ğŸ’•"
- Luxury want: "Saw the cutest designer bag for $X... I know it's indulgent but pretty please? I'll make it worth your while ğŸ˜˜"

${npc.name}'s message:`;

        try {
          const rawReason = await queuedGenerateText(reasonPrompt, {
            temperature: 0.9,
            max_tokens: 100,
            stopSequences: ['\n\n', 'Note:', '---', 'Amount:']
          }, `Generating money request message for ${npc.name}`);
          const requestMessage = sanitizeNpcResponse(rawReason, 3);
          
          // Add to chat history as a money request
          if (!gameState.chatHistory[npc.id]) {
            gameState.chatHistory[npc.id] = [];
          }
          
          const messageTimestamp = gameState.time?.currentTime || Date.now();
          const messageIndex = gameState.chatHistory[npc.id].length;
          
          // Add the money request to history (with special flag)
          gameState.chatHistory[npc.id].push({
            sender: npc.name,
            content: requestMessage,
            isPlayer: false,
            timestamp: messageTimestamp,
            proactive: true,
            isMoneyRequest: true,
            amount: roundedAmount,
            reason: requestMessage // Store the full message as the reason
          });
          
          // CRITICAL FIX: Save immediately after money request to prevent message loss
          saveGame(false);
          
          // Update money request tracking
          const gameTime = gameState.time?.currentTime || Date.now();
          npc.proactiveMessages.lastSentTime = gameTime;
          npc.proactiveMessages.lastSentRealTime = Date.now();
          npc.proactiveMessages.consecutiveUnreplied++;
          npc.proactiveMessages.lastMoneyRequestTime = gameTime;
          npc.proactiveMessages.hasUnrepliedMoneyRequest = true;
          npc.lastMoneyRequest = Date.now();
          
          // Mark as unread
          if (!npc.unreadMessages) npc.unreadMessages = 0;
          npc.unreadMessages++;
          
          console.log(`[Proactive Money Request] ${npc.name} requested $${formatCash(roundedAmount)}: "${requestMessage.substring(0, 50)}..."`);
          
          // Store in memory
          remember(npc, `I asked the boss for $${formatCash(roundedAmount)}: ${requestMessage}`, 'interaction', 1);
          
          // Update People tab if visible
          if (gameState.activeTab === 'people') {
            updatePeopleTab();
          }
          
          // If chat is currently open for this NPC, show the money request UI
          if (gameState.activeChat?.id === npc.id && chatMessages) {
            addMoneyRequestMessage(npc, roundedAmount, requestMessage, messageIndex);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            npc.unreadMessages = 0; // Already reading it
          }
        } catch (error) {
          console.error('[Proactive Money Request] Error generating message:', error);
          // Fallback to template message if AI fails
          const fallbackMessage = getMoneyRequestMessage(npc, 'bills', roundedAmount);
          
          if (!gameState.chatHistory[npc.id]) {
            gameState.chatHistory[npc.id] = [];
          }
          
          const messageTimestamp = gameState.time?.currentTime || Date.now();
          const messageIndex = gameState.chatHistory[npc.id].length;
          
          gameState.chatHistory[npc.id].push({
            sender: npc.name,
            content: fallbackMessage,
            isPlayer: false,
            timestamp: messageTimestamp,
            proactive: true,
            isMoneyRequest: true,
            amount: roundedAmount,
            reason: fallbackMessage
          });
          
          // CRITICAL FIX: Save immediately after money request to prevent message loss
          saveGame(false);
          
          npc.proactiveMessages.lastSentTime = gameState.time?.currentTime || Date.now();
          npc.proactiveMessages.lastSentRealTime = Date.now();
          npc.proactiveMessages.consecutiveUnreplied++;
          npc.proactiveMessages.lastMoneyRequestTime = gameState.time?.currentTime || Date.now();
          npc.proactiveMessages.hasUnrepliedMoneyRequest = true;
          npc.lastMoneyRequest = Date.now();
          
          if (!npc.unreadMessages) npc.unreadMessages = 0;
          npc.unreadMessages++;
          
          if (gameState.activeTab === 'people') {
            updatePeopleTab();
          }
          
          if (gameState.activeChat?.id === npc.id && chatMessages) {
            addMoneyRequestMessage(npc, roundedAmount, fallbackMessage, messageIndex);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            npc.unreadMessages = 0;
          }
        }
        
        return; // Exit early - money request handled
      }
      
      // Get personality and relationship info
      const personality = npc.personality || {};
      const relationship = npc.relationships?.player || { level: 0, type: 'professional' };
      const intimacy = npc.intimacy || 0;
      const affection = npc.stats?.affection || 0;
      
      // Build message prompt
      let messageContext = '';
      if (typeof context === 'string') {
        messageContext = context;
      } else if (context.type === 'social' && context.post) {
        messageContext = `Recent post: "${context.post.content || ''}"`;
      } else if (context.type === 'event' && context.event) {
        messageContext = `Recent event: ${context.event.description}`;
      }
      
      // Get conversation history with intelligent selection based on relationship depth
      const fullHistory = gameState.chatHistory[npc.id] || [];
      const messageCount = fullHistory.length;
      
      // Determine how much history to include based on relationship development
      let historyToShow = 3; // Default for new relationships
      if (affection > 60 && messageCount > 20) {
        historyToShow = 8; // Developed relationships get more context
      } else if (affection > 30 && messageCount > 10) {
        historyToShow = 5; // Mid-level relationships
      }
      
      // Get last few messages for immediate context
      const recentMessages = fullHistory.slice(-historyToShow);
      
      // Check if conversation ended on an open topic (question, statement needing follow-up)
      const lastPlayerMessage = [...fullHistory].reverse().find(msg => msg.isPlayer);
      const lastNPCMessage = [...fullHistory].reverse().find(msg => !msg.isPlayer);
      
      let conversationAnalysis = '';
      if (lastPlayerMessage && lastNPCMessage) {
        // Determine if there's an unresolved thread to pick up
        const hasQuestion = /\?|what|how|why|when|where|who|should|would|could/i.test(lastPlayerMessage.content);
        const isOpenStatement = lastPlayerMessage.content.length > 50 && !hasQuestion;
        
        if (hasQuestion && lastNPCMessage.timestamp < lastPlayerMessage.timestamp) {
          conversationAnalysis = 'âš ï¸ CONVERSATION STATE: Last player message asked something. You can follow up on that topic or acknowledge it naturally.';
        } else if (isOpenStatement) {
          conversationAnalysis = 'âš ï¸ CONVERSATION STATE: Last player message was substantial. You can respond to it, expand on it, or naturally continue that thread.';
        } else {
          conversationAnalysis = 'âš ï¸ CONVERSATION STATE: Conversation ended naturally. You\'re starting a new topic - make it interesting!';
        }
      }
      
      // Build chat history string
      let chatHistory = '';
      if (recentMessages.length > 0) {
        chatHistory = recentMessages
          .map(msg => `${msg.isPlayer ? 'Boss' : npc.name}: ${msg.content}`)
          .join('\n');
      }
      
      // NEW: Track recent message types for variety
      if (!npc.recentMessageTypes) npc.recentMessageTypes = [];
      const recentTypes = npc.recentMessageTypes.slice(0, 5).join(', ');
      
      // NEW: Get player description for context
      const playerDesc = getPlayerDescription('conversation');
      const playerContextNote = playerDesc !== 'the boss' ? `\n\nğŸ‘¤ BOSS INFO:\n${playerDesc}` : '';
      
      // NEW: Get gossip context for spicy conversations
      const gossipText = getGossipContext(npc.id, true);
      const gossipNote = gossipText ? `\n\n${gossipText}` : '';
      
      // NEW: Time of day affects message style
      const hour = new Date().getHours();
      let timeContext = '';
      if (hour >= 6 && hour < 12) {
        timeContext = 'It\'s morning. Messages can be about starting the day, morning mood, coffee, etc.';
      } else if (hour >= 12 && hour < 17) {
        timeContext = 'It\'s afternoon. Messages can be about work progress, lunch, midday thoughts.';
      } else if (hour >= 17 && hour < 22) {
        timeContext = 'It\'s evening. Messages can be about wrapping up work, evening plans, relaxing.';
      } else {
        timeContext = 'It\'s late night. Messages can be casual, personal, or about being up late.';
      }
      
      // MASSIVELY ENHANCED PROMPT with personality-driven variety
      const prompt = `You are ${npc.name}, initiating a conversation with your boss (@TheBoss).

YOUR PERSONALITY:
- Confidence: ${personality.confidence || 50}/100
- Flirtiness: ${personality.flirty || 50}/100
- Outgoing: ${personality.outgoing || 50}/100
- Professional: ${personality.professional || 50}/100
- Humor: ${personality.humor || 50}/100
${npc.hobbies ? `- Hobbies: ${npc.hobbies.join(', ')}` : ''}
${npc.position ? `- Job: ${npc.position}` : ''}

YOUR RELATIONSHIP:
- Affection: ${affection}/100 ${affection > 70 ? '(very close)' : affection > 40 ? '(friendly)' : '(professional)'}
- Intimacy: ${intimacy}/100 ${intimacy > 60 ? '(intimate/romantic)' : intimacy > 30 ? '(comfortable)' : '(reserved)'}
- Type: ${relationship.type || 'professional'}
- Messages exchanged: ${messageCount} ${messageCount > 20 ? '(well-developed relationship)' : messageCount > 10 ? '(getting to know each other)' : '(still new)'}${playerContextNote}${gossipNote}

CONTEXT:
- Reason for messaging: ${reason}
- ${messageContext || 'No specific context'}
- ${timeContext}
${chatHistory ? 
`
RECENT CONVERSATION:
${chatHistory}

${conversationAnalysis}` : 
`
No recent conversation - you're starting fresh`}
${recentTypes ? `

âš ï¸ VARIETY: Your recent message types: ${recentTypes}
Write something DIFFERENT this time - new angle, different tone, fresh approach!` : ''}

ğŸ“ MESSAGE STRATEGY FOR DEVELOPED RELATIONSHIPS (${messageCount}+ messages):

${affection > 70 && messageCount > 20 ? `âœ¨ YOU'RE VERY CLOSE - BE AUTHENTIC AND PERSONAL:
- Reference earlier conversations naturally ("Remember when we talked about...")  
- Pick up threads that were left hanging from your last chat
- Show you've been thinking about them/previous topics
- Be genuinely personal - you know each other well
- Can bring up inside jokes, shared experiences, ongoing situations
- If last conversation was intimate/personal, acknowledge it naturally
- Don't randomly shift to generic work talk unless there's a reason

ğŸ¯ PRIORITY: Personal > Work unless reason specifically work-related

AVOID:
- âŒ Generic "quick update" or "quick q" without substance
- âŒ Random work questions when your relationship is personal
- âŒ Ignoring what you last talked about
- âŒ Acting like strangers when you've had ${messageCount} meaningful exchanges

INSTEAD:
- âœ“ "Hey! Been thinking about [earlier topic]..."
- âœ“ "So about what we discussed last time..."
- âœ“ "Random but remember when [callback]?"
- âœ“ Continue natural threads from your last conversation
- âœ“ Reference specific moments or topics you've shared
- âœ“ Match the intimacy level of your relationship
` : affection > 40 && messageCount > 10 ? `ğŸŒ± YOU'RE FRIENDLY - BE MORE PERSONAL:
- You can reference earlier topics naturally  
- Show progression - you're getting more comfortable
- Mix personal and professional topics (lean more personal)
- Less formal than when you first met
- Can bring up non-work stuff you've discussed before
- Acknowledge previous conversations casually

ğŸ¯ PRIORITY: Balance Personal & Work (slightly favor personal)

EXAMPLES:
- âœ“ "Hey! So I've been thinking about [topic from before]..."
- âœ“ "Quick q but also curious about [personal thing]..."
- âœ“ Reference hobbies or interests you've discussed
` : affection > 20 && messageCount > 5 ? `ğŸ‘” YOU'RE PROFESSIONAL BUT WARMING UP:
- Mostly professional topics but can be friendly
- Reference past work conversations
- Can ask personal questions to build connection
- Keep it respectful but show personality

ğŸ¯ PRIORITY: Work-focused with friendly personal touches

EXAMPLES:
- âœ“ "Hey boss, quick work thing + how's your day?"
- âœ“ Professional questions with warm tone
- âœ“ Can mention non-work topics casually
` : `ğŸ†• RELATIONSHIP IS NEW - BUILD CONNECTION:
- Keep it professional but friendly
- Work topics are natural starters
- Can ask getting-to-know-you questions
- Show your personality without being too personal yet

ğŸ¯ PRIORITY: Professional with friendly openness
`}

ğŸ“ MESSAGE STYLE GUIDE BY REASON:

**work_question**: ${affection > 60 && messageCount > 15 ? 'CLOSE RELATIONSHIP - Work questions should connect to your history:' : 'Ask genuine questions that show personality:'}
${affection > 60 && messageCount > 15 ? `- "Hey, remember [earlier topic]? Had a thought about it..."
- "Quick q but it relates to [something we discussed]..."
- "Been thinking about what you said about [X]..."
- ONLY use generic work q's if they're genuinely time-sensitive
- Better to connect work stuff to your existing conversations` : `- "Quick q - what's your take on [specific thing]?"
- "Need your input when you have a sec"
- "Random work thought - [specific question]?"
- Show your personality in how you ask`}
${personality.humor > 60 ? '- Add humor if it fits your personality!' : ''}

**work_update**: ${affection > 60 && messageCount > 15 ? 'CLOSE RELATIONSHIP - Make updates relevant to your connection:' : 'Share updates like a real person:'}
${affection > 60 && messageCount > 15 ? `- "That thing we talked about? Just wrapped it up ğŸ’ª"
- "Update on [something you know they care about based on history]..."
- "Remember when you asked about [X]? Got news..."
- Connect updates to previous conversations when possible
- AVOID: Generic project updates to someone you're close with` : `- "Just crushed that deadline ğŸ’ª"
- "Update: thing you asked about is done!"
- "FYI - wrapped up early on [project]"
- "Quick win today ğŸ‰"`}
${affection > 50 ? '- Show enthusiasm if you like the boss!' : ''}

**casual_chat**: ${affection > 60 && messageCount > 15 ? 'CLOSE RELATIONSHIP - Be genuinely personal and connected:' : 'Be genuinely casual and varied:'}
${affection > 60 && messageCount > 15 ? `- "Been thinking about you lately ğŸ’­"
- "So I was remembering [specific earlier conversation topic]..."
- "You know what? [personal share that connects to your history]"
- "Miss talking to you - got a minute?"
- "Random but [callback to inside joke or shared moment]..."
- Reference specific things you've discussed before
- Can acknowledge your closeness naturally
- AVOID: Generic "how's your day" when you have real history` : `- "Hey! How's your day going?"
- "Random thought: [something interesting]"
- "Saw something that made me think of you"
- "Quick break from work - what are you up to?"`}
- Time-appropriate: morning coffee, afternoon check-in, evening plans
${personality.humor > 70 ? '- Share funny observations!' : ''}
${intimacy > 50 ? '- Can be more personal and warm' : ''}

**sharing_news**: ${messageCount > 20 ? 'Share in a way that acknowledges your relationship:' : 'Share something interesting:'}
${messageCount > 20 ? `- "Okay so remember [earlier topic]? Update on that..."
- "You'll appreciate this - [news related to shared context]"
- "Had to tell you - [something that connects to your conversations]"
- Reference your relationship naturally in how you share` : `- "Dude, you won't believe what just happened ğŸ˜…"
- "Okay so [specific thing] just went down"
- "Fun fact I just learned: [something relevant]"
- "This is wild - [share actual news/event]"`}
${npc.hobbies ? '- Reference your hobbies naturally' : ''}

**asking_advice**: NOT "Could I get your advice?" - Too formal!
INSTEAD: Ask naturally and specifically:
- "Quick dilemma - [specific situation]?"
- "Need a second opinion on something"
- "What would you do if [specific scenario]?"
- "Honest question: [actual question]"
${affection > 60 ? '- Can ask personal advice, not just work' : ''}

**post_followup**: Reference YOUR OWN post naturally:
- "Did you see my post about [topic]? ğŸ“±"
- "Posted something earlier that made me think of you"
- "That post got more attention than I expected lol"
- NOT: "I saw you liked my post" (unless context specifically says boss liked it!)

**flirty_message**: ${intimacy > 40 ? 'You can be subtly flirty' : 'Keep it light and playful'}:
- "Hey you ğŸ˜Š"
- "Been thinking about you"
- "Miss talking to you"
- ${intimacy > 60 ? 'Be playful with what they are doing' : 'Light compliments work well'}
${personality.flirty > 70 ? '- Be bolder based on your personality' : '- Keep it subtle and tasteful'}

**booty_call**: ${intimacy > 60 ? 'Be direct but playful' : 'Suggest hanging out casually'}:
- ${intimacy > 70 ? 'Can be direct about tonight' : 'Suggest drinks or hanging out'}
- ${intimacy > 80 ? 'Be flirty and suggestive' : 'Keep it casual'}
- ${intimacy > 60 ? 'Show interest romantically' : 'Friendly hangout vibes'}

**event_reaction**: React naturally to what happened:
- "So about [event] ğŸ˜…"
- "That was [emotion]!"
- "Can we talk about what just happened?"
- Be specific to the actual event

ğŸ¯ TONE GUIDELINES:
${personality.confidence > 70 ? 'âœ“ Be direct and bold' : 'âœ“ Be thoughtful and considerate'}
${personality.outgoing > 70 ? 'âœ“ Be enthusiastic and expressive' : 'âœ“ Be calm and measured'}
${personality.professional > 70 ? 'âœ“ Keep it polished but warm' : 'âœ“ Be casual and relaxed'}
${personality.humor > 70 ? 'âœ“ Add wit and humor' : 'âœ“ Keep it sincere'}
${intimacy > 60 ? 'âœ“ Can be personal and intimate' : intimacy > 30 ? 'âœ“ Friendly and comfortable' : 'âœ“ Professional but friendly'}
${affection > 70 ? 'âœ“ Show warmth and care' : affection > 40 ? 'âœ“ Be friendly' : 'âœ“ Keep it respectful'}

RULES:
- Max 200 characters
- Use 0-2 emojis (use naturally, not forced)
- NO quotation marks
- NO "I would say" or meta-commentary
- NO formal business-speak
- BE SPECIFIC not generic
- SHOW personality
- DON'T invent boss actions not in context
- Sound like an actual person texting

Write ONLY the message:`;

      // Generate message
      const rawMessage = await queuedGenerateText(prompt, {
        temperature: 0.9,
        max_tokens: 50,
        stopSequences: ['\n\n', '(Character', '(Emojis', '(Approach', 'Note:', '**Note', '---', 'Rating:']
      }, `Generating DM message for ${npc.name}`);
      let message = sanitizeNpcResponse(rawMessage, 2).trim();
      
      // Additional meta-commentary stripping for DMs
      message = message.split(/\(Character count:/)[0];
      message = message.split(/\(Emojis used:/)[0];
      message = message.split(/\(Approach:/)[0];
      message = message.trim();
      
      if (!message || message.length > 150) return; // Safety check
      
      // Track message type for variety
      npc.recentMessageTypes.unshift(reason);
      if (npc.recentMessageTypes.length > 10) {
        npc.recentMessageTypes = npc.recentMessageTypes.slice(0, 10);
      }
      
      // Add to chat history
      if (!gameState.chatHistory[npc.id]) {
        gameState.chatHistory[npc.id] = [];
      }
      
      const messageTimestamp = gameState.time?.currentTime || Date.now();
      
      gameState.chatHistory[npc.id].push({
        sender: npc.name,
        content: message,
        isPlayer: false,
        timestamp: messageTimestamp,
        proactive: true  // Mark as proactive message
      });
      
      // CRITICAL FIX: Save immediately after proactive message to prevent message loss
      saveGame(false);
      
      // Update proactive message tracking
      const gameTime = gameState.time?.currentTime || Date.now();
      npc.proactiveMessages.lastSentTime = gameTime;
      npc.proactiveMessages.lastSentRealTime = Date.now();
      npc.proactiveMessages.consecutiveUnreplied++;
      
      // If this is a money request, update money request tracking
      if (reason === 'money_request') {
        npc.proactiveMessages.lastMoneyRequestTime = gameTime;
        npc.proactiveMessages.hasUnrepliedMoneyRequest = true;
      }
      
      console.log(`[Proactive Message] ${npc.name} sent message (${npc.proactiveMessages.consecutiveUnreplied}/3 unreplied)`);
      
      // Mark as unread
      if (!npc.unreadMessages) npc.unreadMessages = 0;
      npc.unreadMessages++;
      
      // Store in memory
      remember(npc, `I messaged the boss: "${message}"`, 'interaction', 1);
      
      // Update People tab if visible
      if (gameState.activeTab === 'people') {
        updatePeopleTab();
      }
      
      // If chat is currently open for this NPC, show the message
      if (gameState.activeChat?.id === npc.id && chatMessages) {
        const messageIndex = gameState.chatHistory[npc.id].length - 1;
        addChatMessage(npc.name, message, false, null, messageIndex);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        npc.unreadMessages = 0; // Already reading it
      }
      
    } catch (error) {
      console.error('Error sending proactive NPC message:', error);
    }
  }
  
  // Update news feed
  function updateNewsFeed() {
    if (!newsFeed) return;
    
    // Ensure news array exists (backwards compatibility with old saves)
    if (!gameState.news || !Array.isArray(gameState.news)) {
      gameState.news = [
        "Tech startup raises $1M in seed funding",
        "New productivity app trends in office spaces",
        "Remote work policies reshape company cultures",
        "AI integration boosts efficiency across industries"
      ];
    }
    
    newsFeed.innerHTML = '';
    gameState.news.forEach((newsItem, index) => {
      const newsItemEl = document.createElement('div');
      newsItemEl.className = 'news-item';
      newsItemEl.style.cssText = 'background:#16213e; border-radius:8px; padding:12px; margin-bottom:10px;';
      
      newsItemEl.innerHTML = `
        <p style="margin:0;">${newsItem}</p>
        <p style="margin:5px 0 0 0; font-size:0.8rem; color:#aaa;">${new Date().toLocaleDateString()}</p>
      `;
      
      newsFeed.appendChild(newsItemEl);
    });
  }
  
  // Game tick - main update loop
  /**
   * Gradually adjust employee spending rates to match company growth
   * Called periodically from gameTick to simulate lifestyle creep
   */
  function adjustEmployeeLifestyles() {
    // Calculate target spending rate for company scale
    const targetBaseRate = 50 + Math.random() * 100; // Random base for reference
    const targetScaledRate = calculateScaledSpendingRate(targetBaseRate);
    const companyScale = targetScaledRate / targetBaseRate; // Get the multiplier
    
    gameState.employees.forEach(emp => {
      if (!emp.spendingRate) {
        // Initialize with company-scaled rate
        emp.spendingRate = calculateScaledSpendingRate();
        return;
      }
      
      // Calculate what their "natural" base rate would be (reverse engineer)
      const estimatedBaseRate = emp.spendingRate / Math.max(1, companyScale / 1.5);
      
      // Calculate new target rate for current company scale
      const newTargetRate = calculateScaledSpendingRate(estimatedBaseRate);
      
      // Gradually adjust toward target (move 5% closer each adjustment)
      // This creates smooth lifestyle creep as company grows
      const adjustment = (newTargetRate - emp.spendingRate) * 0.05;
      
      // Only adjust if difference is significant (> $1/day)
      if (Math.abs(adjustment) > 1) {
        emp.spendingRate += adjustment;
        
        // Ensure minimum and maximum bounds
        emp.spendingRate = Math.max(50, Math.min(50000, emp.spendingRate));
      }
    });
  }

  function gameTick() {
    const dt = GAME_TICK_INTERVAL;
    
    // PHASE 4: Update game time
    updateGameTime(dt);

    gameState.products.forEach(p => {
      // Only process unlocked products
      if (!p.unlocked) return;
      
      // Check if constant stream - optimize calculation
      const cycleTime = currentCycleTimeMs(p);
      const isConstantStream = cycleTime < 1000 && p.managerHired;
      
      if (isConstantStream) {
        // Constant stream optimization: direct cash calculation, no cycle tracking
        // Calculate earnings for this tick based on cycle rate
        const earningsPerMs = currentValue(p) / cycleTime;
        const tickEarnings = earningsPerMs * dt;
        
        // Prestige multiplier now applied in currentValue()
        gameState.cash += tickEarnings;
        gameState.totalEarnings += tickEarnings;
        gameState.lifetimeEarnings += tickEarnings; // Track for prestige
        gameState.currentLifetimeIncome = (gameState.currentLifetimeIncome || 0) + tickEarnings; // Track THIS prestige only
        
        // Keep running flag true but don't update timeRemaining (not needed)
        p.running = true;
        
        // Skip rest of normal processing
        return;
      }
      
      // Normal product processing (non-constant)
      if (p.running) {
        p.timeRemainingMs -= dt;

        if (p.timeRemainingMs <= 0) {
          // payout (prestige multiplier now applied in currentValue())
          const payout = currentValue(p);
          
          gameState.cash += payout;
          gameState.totalEarnings += payout;
          gameState.lifetimeEarnings += payout; // Track for prestige
          gameState.currentLifetimeIncome = (gameState.currentLifetimeIncome || 0) + payout; // Track THIS prestige only

          if (p.managerHired) {
            // keep cycling under manager
            p.running = true;
            p.timeRemainingMs = cycleTime;
          } else {
            // stop and instantly sync Sell label for responsiveness
            p.running = false;
            p.timeRemainingMs = 0;
            const sellTxt = $(`selltxt-${p.id}`);
            if (sellTxt) sellTxt.textContent = 'Sell';
          }
        }
      } else if (p.managerHired) {
        // manager auto-starts if idle
        p.running = true;
        p.timeRemainingMs = cycleTime;
      }
    });
    
    // Autonomous social feed generation (runs in background)
    autonomousPostGeneration().catch(err => {
      console.error('Autonomous post generation error:', err);
    });

    // Periodic lifestyle adjustment - employees gradually adopt company-scaled spending
    // Only update every ~10 ticks to avoid excessive calculations
    if (!gameState.lifestyleAdjustmentCounter) gameState.lifestyleAdjustmentCounter = 0;
    gameState.lifestyleAdjustmentCounter++;
    
    if (gameState.lifestyleAdjustmentCounter >= 10) {
      gameState.lifestyleAdjustmentCounter = 0;
      adjustEmployeeLifestyles();
    }

    // ========== CORPORATE HIERARCHY: PROMOTION CHECKING ==========
    // Check for promotions every ~30 ticks (roughly every 3 seconds)
    // Auto-promotion check disabled - promotions now manual via Corporate Pyramid
    // if (!gameState.promotionCheckCounter) gameState.promotionCheckCounter = 0;
    // gameState.promotionCheckCounter++;
    
    // if (gameState.promotionCheckCounter >= 30) {
    //   gameState.promotionCheckCounter = 0;
    //   checkForPromotions();
    // }

    // UI refresh (lightweight progress updates recommended)
    updateUI();
  }
  
  // Update UI elements
  function updateUI() {
    // top bar - enhanced cash display
    if (cashEl) {
      const cashStyle = formatCashDisplay(gameState.cash);
      cashEl.textContent = cashStyle.displayText;
      cashEl.style.fontSize = cashStyle.fontSize;
      cashEl.style.color = cashStyle.color;
      cashEl.style.textShadow = cashStyle.textShadow;
      cashEl.style.animation = cashStyle.animation;
      cashEl.style.fontWeight = 'bold';
      cashEl.style.transition = 'all 0.3s ease';
    } else {
      console.warn('cashEl is null in updateUI()');
    }
    if (cashPerSecEl) cashPerSecEl.textContent = formatNumber(calculateCashPerSecond());
    if (employeeCountEl) employeeCountEl.textContent = gameState.employees.length;

    const unlockedProducts = gameState.products.filter(p => p.unlocked).length;
    if (productCountEl) productCountEl.textContent = unlockedProducts;

    // only refresh progress bars/text in Business tab for smoothness
    if (gameState.activeTab === 'business') {
      updateProductProgressBars();
    }
    
    // Update prestige UI in real-time if on Invest tab
    if (gameState.activeTab === 'invest') {
      updatePrestigeUI();
    }
    
    // Update dashboard in real-time if on Dashboard tab
    if (gameState.activeTab === 'dashboard') {
      updateDashboard();
    }
  }
  
  // Calculate cash per second
  function calculateCashPerSecond() {
    let total = 0;
    gameState.products.forEach(p => {
      // Only count unlocked products
      if (!p.unlocked) return;
      
      const cycleTime = currentCycleTimeMs(p);
      // if running or managed, include it; otherwise 0
      if (p.running || p.managerHired) {
        total += currentValue(p) / (cycleTime / 1000);
      }
    });
    
    // Prestige multiplier now applied in currentValue()
    return total; // Return raw number, format at display time
  }

  // ============================================
  // GLOBAL UPGRADES (UPGRADES TAB)
  // ============================================
  
  function buyClickPower() {
    const level = gameState.globalUpgrades.clickPower;
    const baseCost = gameBalance.upgradeBaseCosts.clickPower;
    const cost = Math.floor(baseCost * Math.pow(2.0, level));
    
    if (gameState.cash < cost) return showNotification('Not enough cash!');
    
    gameState.cash -= cost;
    gameState.globalUpgrades.clickPower += 1;
    
    const newEffect = 1.0 + (gameState.globalUpgrades.clickPower * 0.1);
    showNotification(`Click Power upgraded! Now -${newEffect.toFixed(1)}s per click`);
    updateUpgradesTab();
    updateUI();
  }
  
  function buyIncomeBoost(locationId) {
    if (!gameState.globalUpgrades) gameState.globalUpgrades = {};
    if (!gameState.globalUpgrades.incomeBoost) gameState.globalUpgrades.incomeBoost = {};
    const level = gameState.globalUpgrades.incomeBoost[locationId] || 0;
    const baseCost = gameBalance.upgradeBaseCosts.incomeBoost[locationId];
    const cost = Math.floor(baseCost * Math.pow(2.5, level));
    
    if (gameState.cash < cost) return showNotification('Not enough cash!');
    
    gameState.cash -= cost;
    gameState.globalUpgrades.incomeBoost[locationId] = level + 1;
    
    // Calculate new bonus with linear formula
    const newBonus = (level + 1) * 10;
    const location = gameState.locations.find(loc => loc.id === locationId);
    showNotification(`${location.name} income boost upgraded! Now +${newBonus}%`);
    updateUpgradesTab();
    updateUI();
  }
  
  function buyCostReduction(locationId) {
    if (!gameState.globalUpgrades) gameState.globalUpgrades = {};
    if (!gameState.globalUpgrades.costReduction) gameState.globalUpgrades.costReduction = {};
    const level = gameState.globalUpgrades.costReduction[locationId] || 0;
    const baseCost = gameBalance.upgradeBaseCosts.costReduction[locationId];
    const cost = Math.floor(baseCost * Math.pow(3.0, level));
    
    if (gameState.cash < cost) return showNotification('Not enough cash!');
    
    gameState.cash -= cost;
    gameState.globalUpgrades.costReduction[locationId] = level + 1;
    
    // Calculate new reduction with linear formula (capped at 95%)
    const newReduction = Math.min(95, (level + 1) * 5);
    const location = gameState.locations.find(loc => loc.id === locationId);
    showNotification(`${location.name} cost reduction upgraded! Now -${newReduction}%`);
    updateUpgradesTab();
    updateUI();
  }
  
  // ============================================
  // ELITE GLOBAL UPGRADES (Late-game cash sinks)
  // ============================================
  
  function buyGoldenTouch() {
    if (!gameState.globalUpgrades) gameState.globalUpgrades = {};
    const level = gameState.globalUpgrades.goldenTouch || 0;
    // Starts at $1 Qi ($1,000,000,000,000,000,000), scales 10x per level
    const baseCost = 1e18;
    const cost = Math.floor(baseCost * Math.pow(10, level));
    
    if (gameState.cash < cost) return showNotification('Not enough cash!');
    
    gameState.cash -= cost;
    gameState.globalUpgrades.goldenTouch = (gameState.globalUpgrades.goldenTouch || 0) + 1;
    
    const newBonus = gameState.globalUpgrades.goldenTouch * 5;
    showNotification(`Golden Touch upgraded! All income +${newBonus}%`);
    updateUpgradesTab();
    updateUI();
  }
  
  function buyTimeDilation() {
    if (!gameState.globalUpgrades) gameState.globalUpgrades = {};
    const level = gameState.globalUpgrades.timeDilation || 0;
    // Starts at $5 Qi, scales 12x per level
    const baseCost = 5e18;
    const cost = Math.floor(baseCost * Math.pow(12, level));
    
    if (gameState.cash < cost) return showNotification('Not enough cash!');
    
    gameState.cash -= cost;
    gameState.globalUpgrades.timeDilation = (gameState.globalUpgrades.timeDilation || 0) + 1;
    
    const newBonus = gameState.globalUpgrades.timeDilation * 3;
    showNotification(`Time Dilation upgraded! Production speed +${newBonus}%`);
    updateUpgradesTab();
    updateUI();
  }
  
  function buyEmpireBuilder() {
    if (!gameState.globalUpgrades) gameState.globalUpgrades = {};
    const level = gameState.globalUpgrades.empireBuilder || 0;
    // Starts at $10 Qi, scales 15x per level
    const baseCost = 1e19;
    const cost = Math.floor(baseCost * Math.pow(15, level));
    
    if (gameState.cash < cost) return showNotification('Not enough cash!');
    
    gameState.cash -= cost;
    gameState.globalUpgrades.empireBuilder = (gameState.globalUpgrades.empireBuilder || 0) + 1;
    
    const newBonus = gameState.globalUpgrades.empireBuilder * 10;
    showNotification(`Empire Builder upgraded! Employee productivity +${newBonus}%`);
    updateUpgradesTab();
    updateUI();
  }
  
  // ============================================
  // BOSS FIGHT SYSTEM
  // ============================================
  
  let bossFightState = null;
  let bossFightInterval = null;
  
  // Boss image preloading system
  // Store preloaded images: { locationId: { attemptCount: number, imageUrl: string, isGenerating: boolean } }
  let preloadedBossImages = {};
  
  /**
   * Preload boss fight image for a location
   * Each attempt gets a unique image (attemptCount increments on defeat)
   */
  async function preloadBossImage(locationId) {
    const boss = bossFightConfig[locationId];
    if (!boss || typeof generateImage !== 'function') return;
    
    // Get attempt count for this boss
    const attemptCount = gameState.bossFights.history.filter(h => h.bossId === boss.id).length;
    
    // Check if already generating or already cached for this attempt
    const cached = preloadedBossImages[locationId];
    if (cached) {
      if (cached.isGenerating) {
        console.log(`Boss image for ${locationId} is already being generated`);
        return;
      }
      if (cached.attemptCount === attemptCount && cached.imageUrl) {
        console.log(`Using preloaded boss image for ${locationId} (attempt ${attemptCount})`);
        return;
      }
    }
    
    console.log(`Preloading boss image for ${locationId} (attempt ${attemptCount})...`);
    
    // Mark as generating to prevent duplicate calls
    if (!preloadedBossImages[locationId]) {
      preloadedBossImages[locationId] = {};
    }
    preloadedBossImages[locationId].isGenerating = true;
    
    try {
      // Add variety to prompt with attempt count
      const varietyModifiers = [
        '', // base prompt
        ', different angle',
        ', different lighting',
        ', different pose',
        ', alternative style',
        ', dramatic lighting',
        ', cinematic angle',
        ', professional photography'
      ];
      const modifier = varietyModifiers[attemptCount % varietyModifiers.length];
      const imageUrl = await queuedGenerateImage(applyImageStyle(boss.appearance.prompt + modifier), `Boss appearance image for ${locationId}`);
      
      if (imageUrl) {
        preloadedBossImages[locationId].attemptCount = attemptCount;
        preloadedBossImages[locationId].imageUrl = imageUrl;
        preloadedBossImages[locationId].isGenerating = false;
        console.log(`Boss image preloaded successfully for ${locationId}`);
      } else {
        preloadedBossImages[locationId].isGenerating = false;
      }
    } catch (error) {
      console.error(`Failed to preload boss image for ${locationId}:`, error);
      preloadedBossImages[locationId].isGenerating = false;
    }
  }
  
  /**
   * Get preloaded boss image or return null
   */
  function getPreloadedBossImage(locationId) {
    const boss = bossFightConfig[locationId];
    if (!boss) return null;
    
    const attemptCount = gameState.bossFights.history.filter(h => h.bossId === boss.id).length;
    const cached = preloadedBossImages[locationId];
    
    if (cached && cached.attemptCount === attemptCount && cached.imageUrl) {
      return cached.imageUrl;
    }
    return null;
  }
  
  /**
   * Check if we should preload boss image (when last product unlocked)
   * ONLY CALLED ONCE when unlocking products
   */
  function checkAndPreloadBossImage(locationId) {
    // Count unlocked products in this location
    const locationProducts = gameState.products.filter(p => p.locationId === locationId);
    const unlockedCount = locationProducts.filter(p => p.unlocked).length;
    
    // If all products unlocked, preload boss image ONCE
    if (unlockedCount === locationProducts.length && locationProducts.length > 0) {
      const boss = bossFightConfig[locationId];
      if (boss && !gameState.bossFights.defeated.includes(boss.id)) {
        const cached = preloadedBossImages[locationId];
        // Only preload if not already cached or generating
        if (!cached || (!cached.imageUrl && !cached.isGenerating)) {
          preloadBossImage(locationId);
        }
      }
    }
  }
  
  /**
   * Check if player meets requirements to attempt boss fight
   */
  function checkBossFightRequirements(locationId) {
    const boss = bossFightConfig[locationId];
    if (!boss) return { canAttempt: false, reasons: ['No boss configured for this location'] };
    
    // Check if already defeated
    if (gameState.bossFights.defeated.includes(boss.id)) {
      return { canAttempt: false, reasons: ['Boss already defeated'] };
    }
    
    const clickPowerLevel = gameState.globalUpgrades.clickPower;
    const incomePerSec = parseFloat(calculateCashPerSecond());
    
    // Always allow attempting, but show recommendations
    const warnings = [];
    
    if (clickPowerLevel < boss.recommendedClickPower) {
      warnings.push(`âš ï¸ Level ${boss.recommendedClickPower} Click Power recommended (you have ${clickPowerLevel})`);
    }
    
    if (incomePerSec < boss.recommendedIncome) {
      warnings.push(`âš ï¸ $${formatNumber(boss.recommendedIncome)}/sec recommended (you have $${formatNumber(incomePerSec)}/sec)`);
    }
    
    return { canAttempt: true, reasons: warnings, boss };
  }
  
  /**
   * Start a boss fight
   */
  async function startBossFight(locationId) {
    const check = checkBossFightRequirements(locationId);
    
    if (!check.canAttempt) {
      showNotification(`Cannot start boss fight: ${check.reasons.join(', ')}`);
      return;
    }
    
    const boss = check.boss;
    const clickPowerLevel = gameState.globalUpgrades.clickPower || 0;
    const incomePerSec = calculateCashPerSecond() || 0;
    
    console.log('[Boss Fight] Starting calculations:', {
      clickPowerLevel,
      incomePerSec,
      employeeCount: gameState.employees.length
    });
    
    // Calculate team power from employees
    const employees = gameState.employees || [];
    const employeeCount = employees.length;
    
    // Each employee contributes based on their relationship stats
    let teamPower = 0;
    employees.forEach(emp => {
      const trust = emp.trust || 0;
      const friendship = emp.friendship || 0;
      const desire = emp.desire || 0;
      const avgRelationship = (trust + friendship + desire) / 3;
      // Each employee adds a flat damage bonus based on their relationship (more impactful)
      // Base: Each employee = +2% damage
      // Relationship bonus: Up to +3% more at 100 relationship
      const employeeBonus = 2.0 + (avgRelationship * 0.03);
      teamPower += employeeBonus;
    });
    
    // Calculate player attack:
    // Base: Click power still matters (10 damage per level)
    // Income multiplier: Income/sec provides massive boost (0.5 damage per $/sec)
    // Team multiplier: Each employee provides ~2-5% damage bonus
    const baseAttack = 50 + (clickPowerLevel * 10); // Base + click power
    const incomeBonus = incomePerSec * 0.5; // 50% of income/sec as damage
    const teamMultiplier = 1.0 + (teamPower / 100); // Team power directly converts to % bonus
    
    // Apply Boss Warrior influence upgrade (if purchased)
    const bossWarriorLevel = gameState.influenceUpgrades?.bossWarrior || 0;
    const bossWarriorMultiplier = influenceUpgrades.bossWarrior.effect(bossWarriorLevel);
    
    const totalAttack = (baseAttack + incomeBonus) * teamMultiplier * bossWarriorMultiplier;
    
    console.log('[Boss Fight] Damage calculation:', {
      baseAttack,
      incomeBonus,
      teamPower,
      teamMultiplier,
      totalAttack
    });
    
    // Ensure totalAttack is a valid number
    if (isNaN(totalAttack) || !isFinite(totalAttack)) {
      console.error('[Boss Fight] Invalid total attack calculated!', {
        baseAttack,
        incomeBonus,
        teamMultiplier
      });
      showNotification('Error calculating combat stats. Please check console.', 'error');
      return;
    }
    
    // Scale boss health with prestige level for better balance
    // QUADRATIC SCALING: Much harder at high prestige
    // Formula: baseHealth * (1 + prestigeLevel + (prestigeLevel^2 * 0.5))
    // P0: 1x, P1: 2.5x, P2: 5x, P3: 8.5x, P4: 13x, P5: 18.5x, P10: 61x
    const prestigeLevel = gameState.prestigeLevel || 0;
    let prestigeHealthMultiplier;
    
    if (boss.healthScaling === 'quadratic') {
      // Quadratic scaling for challenging bosses
      prestigeHealthMultiplier = 1 + prestigeLevel + (Math.pow(prestigeLevel, 2) * 0.5);
    } else {
      // Legacy linear scaling (1.5x per prestige)
      prestigeHealthMultiplier = Math.pow(1.5, prestigeLevel);
    }
    
    const scaledBossHealth = Math.floor(boss.health * prestigeHealthMultiplier);
    
    console.log('[Boss Fight] Prestige scaling:', {
      prestigeLevel,
      prestigeHealthMultiplier,
      baseHealth: boss.health,
      scaledHealth: scaledBossHealth
    });
    
    // Initialize boss fight state
    bossFightState = {
      boss: boss,
      locationId: locationId,
      bossHealth: scaledBossHealth,
      bossMaxHealth: scaledBossHealth,
      playerStamina: 100,
      playerMaxStamina: 100,
      playerAttack: totalAttack,
      playerDefense: incomePerSec, // Income/sec acts as defense/regen
      teamPower: teamPower, // Store for display
      employeeCount: employeeCount,
      timeRemaining: 60, // 60 second fight
      combatLog: [],
      damageDealt: 0,
      damageReceived: 0
    };
    
    // Show modal
    const modal = document.getElementById('bossFightModal');
    console.log('Opening boss fight modal:', modal);
    console.log('Modal current state - hidden:', modal?.hidden, 'display:', modal?.style.display);
    
    if (modal) {
      modal.hidden = false;
      modal.style.display = 'flex';
      console.log('Modal new state - hidden:', modal.hidden, 'display:', modal.style.display);
    } else {
      console.error('Boss fight modal element not found!');
    }
    
    // Update UI elements
    document.getElementById('bossName').textContent = boss.name;
    document.getElementById('bossTitle').textContent = boss.title;
    document.getElementById('bossDescription').textContent = boss.description;
    document.getElementById('bossDialogue').textContent = `"${boss.dialogue.intro}"`;
    document.getElementById('playerAttack').textContent = Math.floor(bossFightState.playerAttack) || 0;
    document.getElementById('playerDefense').textContent = formatNumber(bossFightState.playerDefense);
    const teamBonusPct = (teamMultiplier - 1.0) * 100;
    document.getElementById('playerTeamPower').textContent = `+${teamBonusPct.toFixed(1)}%`;
    document.getElementById('playerTeamCount').textContent = employeeCount || 0;
    
    // Use preloaded image if available, otherwise show placeholder
    const preloadedImage = getPreloadedBossImage(locationId);
    const bossImageEl = document.getElementById('bossImage');
    const placeholderEl = document.getElementById('bossImagePlaceholder');
    
    if (preloadedImage) {
      // Use preloaded image immediately
      bossImageEl.src = preloadedImage;
      bossImageEl.style.display = 'block';
      placeholderEl.style.display = 'none';
      console.log('Using preloaded boss image');
    } else {
      // Show placeholder while generating
      placeholderEl.style.display = 'flex';
      bossImageEl.style.display = 'none';
      
      // Generate new image asynchronously
      if (typeof generateImage === 'function') {
        generateImage(applyImageStyle(boss.appearance.prompt)).then(imageUrl => {
          if (imageUrl && bossFightState) { // Only update if fight still active
            bossImageEl.src = imageUrl;
            bossImageEl.style.display = 'block';
            placeholderEl.style.display = 'none';
          }
        }).catch(error => {
          console.error('Boss image generation failed:', error);
        });
      }
    }
    
    // Clear combat log
    document.getElementById('combatLog').innerHTML = '<div style="color:#00d4ff;">âš”ï¸ Combat begins!</div>';
    
    // Add prestige scaling info if applicable
    if (prestigeLevel > 0) {
      addToCombatLog(`â­ Prestige ${prestigeLevel}: Boss health increased by ${Math.round((prestigeHealthMultiplier - 1) * 100)}%`, '#ffd700');
    }
    
    // Start fight timer (boss attacks every 3 seconds)
    let lastBossAttack = Date.now();
    bossFightInterval = setInterval(() => {
      if (!bossFightState) {
        clearInterval(bossFightInterval);
        return;
      }
      
      // Countdown timer
      bossFightState.timeRemaining -= 1;
      document.getElementById('bossTimeRemaining').textContent = bossFightState.timeRemaining;
      
      // Player regenerates stamina based on defense
      const regenAmount = (bossFightState.playerDefense / 100) * 0.5; // 0.5% of defense per second
      bossFightState.playerStamina = Math.min(100, bossFightState.playerStamina + regenAmount);
      updateBossFightUI();
      
      // Boss attacks every 3 seconds
      if (Date.now() - lastBossAttack >= 3000) {
        bossFightBossAttack();
        lastBossAttack = Date.now();
      }
      
      // Check time limit
      if (bossFightState.timeRemaining <= 0) {
        bossFightDefeat('Time ran out!');
      }
      
      // Check player stamina
      if (bossFightState.playerStamina <= 0) {
        bossFightDefeat('Your stamina depleted!');
      }
    }, 1000);
    
    // Log fight start
    addToCombatLog(`ğŸ¯ Facing ${boss.name}!`, '#00d4ff');
  }
  
  /**
   * Player attacks boss
   */
  function bossFightAttack() {
    if (!bossFightState) return;
    
    const damage = bossFightState.playerAttack + (Math.random() * 50 - 25); // Â±25 variance
    bossFightState.bossHealth -= damage;
    bossFightState.damageDealt += damage;
    
    // Occasionally show team support messages (20% chance)
    const showTeamSupport = Math.random() < 0.2 && bossFightState.employeeCount > 0;
    
    if (showTeamSupport) {
      const teamMessages = [
        `ğŸ’ª Your team rallies behind you! ${Math.floor(damage)} damage!`,
        `ğŸ¤ Your employees boost your attack! ${Math.floor(damage)} damage!`,
        `â­ Team synergy! ${Math.floor(damage)} damage!`,
        `ğŸ‘¥ Your staff empowers your strike! ${Math.floor(damage)} damage!`,
        `âœ¨ United effort! ${Math.floor(damage)} damage!`
      ];
      addToCombatLog(teamMessages[Math.floor(Math.random() * teamMessages.length)], '#ff6b9d');
    } else {
      // Normal attack message
      addToCombatLog(`âš”ï¸ You attack for ${Math.floor(damage)} damage!`, '#e94560');
    }
    
    // Update UI
    updateBossFightUI();
    
    // Check if boss defeated
    if (bossFightState.bossHealth <= 0) {
      bossFightVictory();
      return;
    }
    
    // Update dialogue at 50% health
    if (bossFightState.bossHealth <= bossFightState.bossMaxHealth * 0.5 && bossFightState.bossHealth + damage > bossFightState.bossMaxHealth * 0.5) {
      document.getElementById('bossDialogue').textContent = `"${bossFightState.boss.dialogue.mid}"`;
    }
  }
  
  /**
   * Boss attacks player
   */
  function bossFightBossAttack() {
    if (!bossFightState) return;
    
    const damage = 25 + (Math.random() * 15); // 25-40 stamina damage
    bossFightState.playerStamina -= damage;
    bossFightState.damageReceived += damage;
    
    addToCombatLog(`ğŸ’¥ ${bossFightState.boss.name} strikes! -${Math.floor(damage)} stamina`, '#ff6b9d');
    
    updateBossFightUI();
    
    // Check if player defeated
    if (bossFightState.playerStamina <= 0) {
      bossFightDefeat('Your stamina was depleted!');
    }
  }
  
  /**
   * Update boss fight UI
   */
  function updateBossFightUI() {
    if (!bossFightState) return;
    
    const bossHealthPct = Math.max(0, (bossFightState.bossHealth / bossFightState.bossMaxHealth) * 100);
    const playerStaminaPct = Math.max(0, bossFightState.playerStamina);
    
    document.getElementById('bossHealthBar').style.width = `${bossHealthPct}%`;
    document.getElementById('bossHealthText').textContent = `${Math.floor(bossHealthPct)}%`;
    
    document.getElementById('playerStaminaBar').style.width = `${playerStaminaPct}%`;
    document.getElementById('playerStaminaText').textContent = `${Math.floor(playerStaminaPct)}%`;
  }
  
  /**
   * Add message to combat log
   */
  function addToCombatLog(message, color = '#ddd') {
    const log = document.getElementById('combatLog');
    const entry = document.createElement('div');
    entry.style.color = color;
    entry.style.marginBottom = '5px';
    entry.textContent = message;
    log.appendChild(entry);
    
    // Auto-scroll to bottom
    log.scrollTop = log.scrollHeight;
    
    // Keep log reasonable size
    if (log.children.length > 20) {
      log.removeChild(log.firstChild);
    }
  }
  
  /**
   * Player defeats boss - Victory!
   */
  function bossFightVictory() {
    if (!bossFightState) return;
    
    // Prevent multiple victory calls
    if (bossFightState.isEnding) return;
    bossFightState.isEnding = true;
    
    clearInterval(bossFightInterval);
    
    const boss = bossFightState.boss;
    const reward = bossFightState.bossMaxHealth * boss.rewardMultiplier;
    
    // Record victory in history
    gameState.bossFights.history.push({
      bossId: boss.id,
      result: 'victory',
      timestamp: gameState.time?.currentTime || Date.now()
    });
    
    // Award rewards
    gameState.cash += reward;
    gameState.bossFights.defeated.push(boss.id);
    
    // Unlock location
    const location = gameState.locations.find(loc => loc.id === bossFightState.locationId);
    if (location) {
      location.unlocked = true;
      location.owned = true;
      
      // Unlock first product in location
      const firstProduct = gameState.products.find(p => p.locationId === location.id && p.unlockCost === 0);
      if (firstProduct) {
        firstProduct.unlocked = true;
      }
    }
    
    // Update UI
    document.getElementById('bossDialogue').textContent = `"${boss.dialogue.victory}"`;
    addToCombatLog(`ğŸ‰ VICTORY! Earned $${formatNumber(reward)}!`, '#FFD700');
    addToCombatLog(`âœ… ${location.name} unlocked!`, '#4ecca3');
    
    // Disable attack button
    document.getElementById('attackBtn').disabled = true;
    document.getElementById('attackBtn').textContent = 'âœ… VICTORY';
    document.getElementById('attackBtn').style.background = '#4ecca3';
    
    // Change retreat to close
    document.getElementById('retreatBtn').textContent = 'ğŸ‰ Continue';
    document.getElementById('retreatBtn').style.background = '#00d4ff';
    document.getElementById('retreatBtn').onclick = closeBossFight;
    
    // Save victory
    saveGame();
    
    // Refresh dashboard to show boss progress update
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
    
    showNotification(`${boss.name} defeated! ${location.name} unlocked!`);
  }
  
  /**
   * Boss defeats player
   */
  function bossFightDefeat(reason) {
    if (!bossFightState) return;
    
    // Prevent multiple defeat calls
    if (bossFightState.isEnding) return;
    bossFightState.isEnding = true;
    
    clearInterval(bossFightInterval);
    
    const boss = bossFightState.boss;
    const locationId = bossFightState.locationId;
    
    // Record defeat in history
    gameState.bossFights.history.push({
      bossId: boss.id,
      result: 'defeat',
      timestamp: gameState.time?.currentTime || Date.now()
    });
    
    addToCombatLog(`ğŸ’€ DEFEAT: ${reason}`, '#e94560');
    addToCombatLog('Try upgrading your Click Power and Income!', '#aaa');
    addToCombatLog('ğŸ’¡ A new challenger awaits your return...', '#ffa726');
    
    document.getElementById('attackBtn').disabled = true;
    document.getElementById('attackBtn').style.opacity = '0.5';
    document.getElementById('retreatBtn').textContent = 'Close';
    document.getElementById('retreatBtn').onclick = closeBossFight;
    
    // Clear cached image so a new one will be generated on retry
    if (preloadedBossImages[locationId]) {
      delete preloadedBossImages[locationId];
    }
    // Preload new image for retry ONCE (each defeat gets a different image)
    setTimeout(() => preloadBossImage(locationId), 1000);
    
    showNotification('Defeated! Upgrade and try again.');
  }
  
  /**
   * Player retreats from fight
   */
  function bossFightRetreat() {
    if (!bossFightState) return;
    
    // Prevent multiple retreat calls
    if (bossFightState.isEnding) return;
    
    if (confirm('Are you sure you want to retreat? No progress will be saved.')) {
      bossFightState.isEnding = true;
      clearInterval(bossFightInterval);
      addToCombatLog('ğŸƒ You retreated from battle.', '#aaa');
      
      setTimeout(closeBossFight, 1000);
    }
  }
  
  /**
   * Close boss fight modal
   */
  function closeBossFight() {
    const modal = document.getElementById('bossFightModal');
    if (modal) {
      modal.hidden = true;
      modal.style.display = 'none';
    }
    
    // Clear state
    bossFightState = null;
    if (bossFightInterval) {
      clearInterval(bossFightInterval);
      bossFightInterval = null;
    }
    
    // Reset button states
    const attackBtn = document.getElementById('attackBtn');
    attackBtn.disabled = false;
    attackBtn.textContent = 'âš”ï¸ ATTACK';
    attackBtn.style.background = '#e94560';
    attackBtn.style.opacity = '1';
    attackBtn.onclick = bossFightAttack; // Restore attack handler
    
    const retreatBtn = document.getElementById('retreatBtn');
    retreatBtn.textContent = 'ğŸƒ Retreat';
    retreatBtn.style.background = '#666';
    retreatBtn.onclick = bossFightRetreat;
    
    // Clear combat log
    document.getElementById('combatLog').innerHTML = '';
    
    // Refresh UI
    updateUI();
    updateBusinessTab();
  }

  // Employee actions
  /**
   * Emergency reset for stuck onboarding employees
   */
  function resetOnboarding(employeeId) {
    const onboardingEmployee = gameState.onboarding.find(e => e.id === employeeId);
    
    if (!onboardingEmployee) {
      showNotification('Employee not found in onboarding queue');
      return;
    }
    
    // Get refund amount (what was actually paid with discounts)
    const refundAmount = onboardingEmployee.hireCostPaid || 0;
    const refundText = refundAmount > 0 ? `\n- Refund $${formatNumber(refundAmount)}` : '';
    
    if (!confirm(`Reset onboarding for ${onboardingEmployee.name}?\n\nThis will:\n- Remove them from onboarding\n- Clear the manager slot${refundText}\n- Allow you to hire a new manager\n\nThis is an emergency fix for stuck employees.`)) {
      return;
    }
    
    // Find the product they were being hired for
    const product = gameState.products.find(p => p.managerOnboarding && p.name === onboardingEmployee.productManaged);
    
    // Refund the hiring cost
    if (refundAmount > 0) {
      gameState.cash += refundAmount;
      console.log(`Refunded $${refundAmount} for ${onboardingEmployee.name}`);
    }
    
    // Remove from onboarding array
    gameState.onboarding = gameState.onboarding.filter(e => e.id !== employeeId);
    
    // Clear product onboarding flag
    if (product) {
      product.managerOnboarding = false;
      product.managerHired = false;
      console.log(`Cleared onboarding flag for product: ${product.name}`);
    }
    
    // Update UI
    updatePeopleTab();
    updateProductsList();
    
    const refundNotification = refundAmount > 0 ? ` Refunded $${formatNumber(refundAmount)}.` : '';
    showNotification(`${onboardingEmployee.name}'s onboarding has been reset.${refundNotification} You can now hire a new employee.`);
    
    console.log(`Emergency reset completed for ${onboardingEmployee.name} (${employeeId})`);
  }

  function handleEmployeeAction(employeeId, action) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    switch (action) {
      case 'bio':
        openUnifiedProfile(employeeId, 'overview'); // Use new unified profile
        break;
      case 'gift':
        showNotification(`Gift given to ${employee.name}!`);
        // In a full implementation, this would open a gift selection
        break;
      case 'chat':
        openChat(employee);
        break;
      case 'flags':
        openFlagManagementModal(employee);
        break;
      case 'promote':
        // Open Corporate Pyramid modal with this employee pre-selected
        openCorporatePyramidModal(employeeId);
        break;
      case 'review':
        conductPerformanceReview(employeeId);
        break;
      case 'fire':
        if (confirm(`Are you sure you want to fire ${employee.name}?`)) {
          // Remove from corporate pyramid position
          const position = getEmployeePosition(employee.id);
          if (position) {
            position.employeeId = null;
            position.isVacant = true;
            console.log(`[Fire] Removed ${employee.name} from position: ${position.title}`);
          }
          
          // Remove manager from product and disable automation
          if (employee.productManaged) {
            const product = gameState.products.find(p => p.name === employee.productManaged);
            if (product) {
              product.managerHired = false;
              product.managerId = null;
              product.managerLevel = 0;
              product.managerOnboarding = false;
              product.running = false;
              product.timeRemainingMs = 0;
              console.log(`[Fire] Cleared product management for: ${product.name}`);
            }
          }
          
          // Change employment status to alumni (don't remove from array)
          employee.employmentStatus = 'alumni';
          employee.firedDate = Date.now();
          employee.productManaged = null;
          
          // Log fire event
          logCompanyEvent({
            type: 'fire',
            involvedEmployees: [employee.id],
            location: employee.locationId,
            description: `${employee.name} was let go`,
            sentiment: 'negative',
            importance: 8
          });
          
          // Add to recent fires
          if (!gameState.companyContext.recentFires) {
            gameState.companyContext.recentFires = [];
          }
          gameState.companyContext.recentFires.unshift({
            id: employee.id,
            name: employee.name,
            date: Date.now()
          });
          if (gameState.companyContext.recentFires.length > 5) {
            gameState.companyContext.recentFires = gameState.companyContext.recentFires.slice(0, 5);
          }
          
          // Update company awareness
          updateCompanyAwareness();
          
          showNotification(`${employee.name} has been fired.`);
          updatePeopleTab();
          updateProductsList();
        }
        break;
    }
  }
  
  // ========== MEETINGS / GROUP CHAT SYSTEM ==========
  
  /**
   * Edit a message inline (player or NPC)
   */
  function editMessageInline(meeting, message, contentEl, messageEl) {
    const isPlayer = message.speakerId === 'player';
    
    // Create textarea for editing
    const textarea = document.createElement('textarea');
    textarea.value = message.content;
    textarea.style.cssText = `
      width:100%;
      min-height:80px;
      background:#0f3460;
      color:white;
      border:1px solid #667eea;
      border-radius:8px;
      padding:8px;
      font-family:inherit;
      font-size:inherit;
      resize:vertical;
      margin-bottom:8px;
    `;
    
    // Create save/cancel buttons
    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = 'display:flex; gap:8px; justify-content:flex-end;';
    
    const saveBtn = document.createElement('button');
    saveBtn.innerHTML = 'âœ“ Save';
    saveBtn.style.cssText = `
      background:#4ecca3;
      color:#0f3460;
      border:none;
      padding:6px 12px;
      border-radius:6px;
      font-weight:600;
      cursor:pointer;
      transition:all 0.2s;
    `;
    saveBtn.onmouseenter = () => saveBtn.style.background = '#5efcb3';
    saveBtn.onmouseleave = () => saveBtn.style.background = '#4ecca3';
    saveBtn.onclick = () => {
      const newContent = textarea.value.trim();
      if (newContent) {
        // Find and update the message
        const msgIndex = message.id 
          ? meeting.messages.findIndex(m => m.id === message.id)
          : meeting.messages.findIndex(m => 
              m.speakerId === message.speakerId && 
              m.timestamp === message.timestamp
            );
        
        if (msgIndex !== -1) {
          meeting.messages[msgIndex].content = newContent;
          meeting.messages[msgIndex].edited = true;
          
          // Reload messages to show updated content
          loadMeetingMessages(meeting);
          showNotification('Message edited!', 'success');
        }
      }
    };
    
    const cancelBtn = document.createElement('button');
    cancelBtn.innerHTML = 'âœ• Cancel';
    cancelBtn.style.cssText = `
      background:#e94560;
      color:white;
      border:none;
      padding:6px 12px;
      border-radius:6px;
      font-weight:600;
      cursor:pointer;
      transition:all 0.2s;
    `;
    cancelBtn.onmouseenter = () => cancelBtn.style.background = '#f55570';
    cancelBtn.onmouseleave = () => cancelBtn.style.background = '#e94560';
    cancelBtn.onclick = () => {
      // Reload messages to cancel edit
      loadMeetingMessages(meeting);
    };
    
    buttonContainer.appendChild(saveBtn);
    buttonContainer.appendChild(cancelBtn);
    
    // Replace content with edit interface
    contentEl.innerHTML = '';
    contentEl.appendChild(textarea);
    contentEl.appendChild(buttonContainer);
    
    // Focus textarea and select all
    textarea.focus();
    textarea.select();
  }
  
  /**
   * Resend a player message (triggers new NPC replies)
   */
  async function resendMessage(meeting, message) {
    // Find the message in the array
    const msgIndex = message.id 
      ? meeting.messages.findIndex(m => m.id === message.id)
      : meeting.messages.findIndex(m => 
          m.speakerId === message.speakerId && 
          m.timestamp === message.timestamp && 
          m.content === message.content
        );
    
    if (msgIndex === -1) return;
    
    // Remove all messages after this one
    meeting.messages = meeting.messages.slice(0, msgIndex + 1);
    
    // Reload messages
    loadMeetingMessages(meeting);
    
    // Reset replies and trigger new responses
    meeting.repliesRemaining = meeting.replyLimit;
    meeting.lastSpeakers = [];
    meeting.activeReplyChainStartIndex = msgIndex;
    
    showNotification('Resending message...', 'info');
    await processMeetingReplies(meeting);
  }
  
  /**
   * Old function kept for compatibility - now redirects to inline edit
   */
  async function editAndResendMessage(meeting, message) {
    // This is now handled by separate edit and resend buttons
    // Keeping function for any old references
  }
  
  /**
   * Regenerate an NPC message
   */
  async function regenerateNPCMessage(meeting, message) {
    const npc = gameState.employees.find(e => e.id === message.speakerId);
    if (!npc) return;
    
    // Find the message in the array by ID or by matching content
    const msgIndex = message.id 
      ? meeting.messages.findIndex(m => m.id === message.id)
      : meeting.messages.findIndex(m => 
          m.speakerId === message.speakerId && 
          m.timestamp === message.timestamp
        );
    
    if (msgIndex === -1) return;
    
    // Get the last player message before this NPC message
    const playerMessages = meeting.messages.slice(0, msgIndex).filter(m => m.speakerId === 'player');
    const lastPlayerMessage = playerMessages[playerMessages.length - 1];
    
    if (!lastPlayerMessage) {
      showNotification('No player message found to respond to', 'error');
      return;
    }
    
    // Show loading indicator
    showNotification(`Regenerating ${npc.name}'s response...`, 'info');
    
    // Generate new response
    const newResponse = await generateMeetingResponse(npc, meeting, lastPlayerMessage.content);
    
    if (!newResponse) {
      showNotification(`${npc.name} declined to speak`, 'warning');
      return;
    }
    
    // Update the message
    meeting.messages[msgIndex].content = newResponse;
    meeting.messages[msgIndex].regenerated = true;
    
    // Remove all messages after this one
    meeting.messages = meeting.messages.slice(0, msgIndex + 1);
    
    // Reload messages
    loadMeetingMessages(meeting);
    
    showNotification('Message regenerated!', 'success');
  }
  
  /**
   * Stop the current NPC reply chain
   */
  function stopMeetingReplies() {
    if (!gameState.activeMeeting) return;
    
    const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
    if (!meeting) return;
    
    // Set replies to 0 to stop the loop
    meeting.repliesRemaining = 0;
    
    // Clear the active reply chain tracking
    meeting.activeReplyChainStartIndex = null;
    
    // Hide stop button
    const stopBtn = document.getElementById('stopMeetingRepliesBtn');
    if (stopBtn) stopBtn.style.display = 'none';
    
    // Update status
    const repliesLeft = document.getElementById('meetingRepliesLeft');
    if (repliesLeft) repliesLeft.textContent = '0';
    
    console.log('[Meeting] Reply chain stopped by player');
    showNotification('Reply chain stopped', 'info');
  }
  
  /**
   * Delete a message from a meeting
   */
  function deleteMeetingMessage(meeting, message) {
    // Find the message index
    const msgIndex = message.id 
      ? meeting.messages.findIndex(m => m.id === message.id)
      : meeting.messages.findIndex(m => 
          m.speakerId === message.speakerId && 
          m.timestamp === message.timestamp &&
          m.content === message.content
        );
    
    if (msgIndex === -1) {
      showNotification('Message not found', 'error');
      return;
    }
    
    // Determine if NPC generation is currently active
    const isGenerationActive = meeting.repliesRemaining > 0 && meeting.activeReplyChainStartIndex !== null;
    
    // Determine deletion behavior
    let shouldCascadeDelete = false;
    let shouldStopGeneration = false;
    
    if (isGenerationActive) {
      // Check if the message is part of the active reply chain
      // (at or after the chain start index)
      if (msgIndex >= meeting.activeReplyChainStartIndex) {
        shouldCascadeDelete = true;
        shouldStopGeneration = true;
      }
      // else: message is before the chain, isolated delete
    }
    // else: no active generation, always isolated delete
    
    // Build confirmation message
    const speaker = message.speakerId === 'player' ? 'your' : gameState.employees.find(e => e.id === message.speakerId)?.name + "'s";
    let confirmMessage = `Delete ${speaker} message?`;
    
    if (shouldCascadeDelete) {
      const messagesAfter = meeting.messages.length - msgIndex - 1;
      confirmMessage += `\n\nThis will stop NPC generation and remove this message`;
      if (messagesAfter > 0) {
        confirmMessage += ` plus ${messagesAfter} message${messagesAfter > 1 ? 's' : ''} below it`;
      }
      confirmMessage += `.`;
    } else {
      confirmMessage += `\n\nThis message will be removed (other messages will remain).`;
    }
    
    if (!confirm(confirmMessage)) {
      return;
    }
    
    // Stop generation if needed
    if (shouldStopGeneration) {
      meeting.repliesRemaining = 0;
      meeting.activeReplyChainStartIndex = null;
      
      const stopBtn = document.getElementById('stopMeetingRepliesBtn');
      if (stopBtn) stopBtn.style.display = 'none';
      
      const repliesLeft = document.getElementById('meetingRepliesLeft');
      if (repliesLeft) repliesLeft.textContent = '0';
      
      console.log('[Meeting] Reply chain stopped by deletion');
    }
    
    // Perform deletion
    let deletedCount;
    if (shouldCascadeDelete) {
      // Cascade delete: remove this message and everything after it
      deletedCount = meeting.messages.length - msgIndex;
      meeting.messages = meeting.messages.slice(0, msgIndex);
    } else {
      // Isolated delete: remove only this message
      meeting.messages.splice(msgIndex, 1);
      deletedCount = 1;
    }
    
    // Update last activity
    if (meeting.messages.length > 0) {
      meeting.lastActivity = meeting.messages[meeting.messages.length - 1].timestamp;
    } else {
      meeting.lastActivity = meeting.created;
    }
    
    // Reload the messages UI
    loadMeetingMessages(meeting);
    
    // Update meetings list to reflect changes
    updateMeetingsList();
    
    const deleteType = shouldCascadeDelete ? 'cascade' : 'isolated';
    console.log(`[Meeting] ${deleteType} deletion: removed ${deletedCount} message(s) from "${meeting.name}"`);
    showNotification(`ğŸ—‘ï¸ Deleted ${deletedCount} message${deletedCount > 1 ? 's' : ''}`, 'success');
  }
  
  /**
   * Create a new meeting with selected participants
   */
  function createMeeting(name, participantIds, replyLimit = 5, scenario = '') {
    const meeting = {
      id: `meeting_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      name: name || `Meeting ${gameState.meetings.length + 1}`,
      scenario: scenario || '', // Optional description of the setting/context
      participants: participantIds, // Array of employee IDs
      replyLimit: replyLimit,
      messages: [],
      created: gameState.time.currentTime,
      lastActivity: gameState.time.currentTime,
      repliesRemaining: replyLimit, // Tracks remaining replies for current turn
      lastSpeakers: [], // Track who spoke recently for round-robin
      unreadCount: 0,
      // Meeting statistics (Task #6)
      stats: {
        totalMessages: 0,
        playerMessages: 0,
        participantMessages: {},  // { employeeId: count }
        topics: [],               // Array of discussed topics
        mood: 'neutral',          // Overall meeting mood
        lastTopic: '',            // Last discussed topic
        imagesSent: 0,            // Count of images shared
        moneyGifted: 0            // Total money sent during meeting
      },
      // Meeting memory/context (Task #6)
      context: {
        summary: '',              // AI-generated summary of meeting
        keyPoints: [],            // Important points discussed
        decisions: [],            // Decisions made
        nextSteps: []             // Action items
      }
    };
    
    gameState.meetings.push(meeting);
    updateMeetingsList();
    
    // Auto-open the new meeting
    loadMeeting(meeting.id);
    
    return meeting;
  }
  
  /**
   * Load and display a meeting in the chat view
   */
  function loadMeeting(meetingId) {
    const meeting = gameState.meetings.find(m => m.id === meetingId);
    if (!meeting) return;
    
    // Mark as read
    meeting.unreadCount = 0;
    
    // Show chat container, hide placeholder
    const placeholder = document.getElementById('meetingPlaceholder');
    const container = document.getElementById('meetingChatContainer');
    if (placeholder) placeholder.style.display = 'none';
    if (container) container.style.display = 'flex';
    
    // Update header
    const title = document.getElementById('meetingTitle');
    if (title) title.textContent = meeting.name;
    
    // Update participants display
    const participantsEl = document.getElementById('meetingParticipants');
    if (participantsEl) {
      participantsEl.innerHTML = meeting.participants.map(empId => {
        const emp = gameState.employees.find(e => e.id === empId);
        if (!emp) return '';
        return `
          <button class="meeting-participant-btn" data-employee-id="${empId}" style="display:flex; align-items:center; gap:4px; background:#16213e; padding:4px 8px; border-radius:20px; border:2px solid transparent; cursor:pointer; transition:all 0.2s;" onmouseenter="this.style.borderColor='#667eea'" onmouseleave="this.style.borderColor='transparent'">
            <img src="${emp.profileImage}" style="width:28px; height:28px; border-radius:50%; object-fit:cover;">
            <span style="font-size:0.8rem; color:#fff;">${emp.name}</span>
          </button>
        `;
      }).join('');
    }
    
    // Update reply status
    const repliesLeft = document.getElementById('meetingRepliesLeft');
    if (repliesLeft) repliesLeft.textContent = meeting.repliesRemaining;
    
    // Load messages
    loadMeetingMessages(meeting);
    
    // Store active meeting
    gameState.activeMeeting = meeting.id;
    
    // Update meetings list to show active state
    updateMeetingsList();
  }
  
  /**
   * Load and display all messages in a meeting
   */
  function loadMeetingMessages(meeting) {
    const messagesContainer = document.getElementById('meetingMessages');
    if (!messagesContainer) return;
    
    messagesContainer.innerHTML = '';
    
    if (meeting.messages.length === 0) {
      messagesContainer.innerHTML = `
        <div style="text-align:center; color:#666; padding:40px 20px; font-style:italic;">
          No messages yet. Start the conversation!
        </div>
      `;
      return;
    }
    
    meeting.messages.forEach(msg => {
      addMeetingMessageToUI(msg, meeting);
    });
    
    // Scroll to bottom
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }
  
  /**
   * Add a message to the meeting UI
   */
  function addMeetingMessageToUI(message, meeting) {
    const messagesContainer = document.getElementById('meetingMessages');
    if (!messagesContainer) return;
    
    const isPlayer = message.speakerId === 'player';
    const isSystem = message.speakerId === 'system';
    
    const speaker = isPlayer ? { name: 'You', profileImage: 'https://placehold.co/80x80?text=You' } 
                             : isSystem ? { name: 'System', profileImage: 'https://placehold.co/80x80?text=ğŸ“·' }
                             : gameState.employees.find(e => e.id === message.speakerId);
    
    if (!speaker && !isPlayer && !isSystem) return;
    
    const messageEl = document.createElement('div');
    messageEl.setAttribute('data-message-id', message.id || `msg-${Date.now()}-${Math.random()}`);
    messageEl.style.cssText = `
      display:flex; 
      gap:12px; 
      align-items:flex-start;
      ${isPlayer ? 'flex-direction:row-reverse;' : ''}
      position:relative;
      padding:4px 0;
    `;
    
    // Avatar
    const avatar = document.createElement('img');
    avatar.src = speaker.profileImage || 'https://placehold.co/80x80';
    avatar.style.cssText = 'width:40px; height:40px; border-radius:50%; object-fit:cover; flex-shrink:0;';
    messageEl.appendChild(avatar);
    
    // Message bubble container
    const bubbleContainer = document.createElement('div');
    bubbleContainer.style.cssText = 'display:flex; flex-direction:column; gap:6px; max-width:70%;';
    
    // Message bubble
    const bubble = document.createElement('div');
    bubble.style.cssText = `
      background:${isPlayer ? '#e94560' : '#16213e'};
      padding:12px 16px;
      border-radius:18px;
      ${isPlayer ? 'border-bottom-right-radius:4px;' : 'border-bottom-left-radius:4px;'}
    `;
    
    // Speaker name
    const nameEl = document.createElement('div');
    nameEl.style.cssText = 'font-weight:600; margin-bottom:4px; font-size:0.9rem; opacity:0.8;';
    nameEl.textContent = speaker.name;
    bubble.appendChild(nameEl);
    
    // Message content
    const contentEl = document.createElement('div');
    contentEl.className = 'meeting-message-content';
    contentEl.style.cssText = 'line-height:1.4;';
    contentEl.innerHTML = styleActionText(message.content);
    bubble.appendChild(contentEl);
    
    // Image (if present)
    if (message.imageUrl) {
      const imageEl = document.createElement('img');
      imageEl.src = message.imageUrl;
      imageEl.style.cssText = 'max-width:100%; border-radius:12px; margin-top:8px; cursor:pointer; display:block;';
      imageEl.onclick = () => openImageViewer(message.imageUrl);
      bubble.appendChild(imageEl);
    }
    
    // Timestamp
    const timeEl = document.createElement('div');
    timeEl.style.cssText = 'font-size:0.7rem; opacity:0.5; margin-top:4px; font-style:italic;';
    timeEl.textContent = getContextAwareTimestamp(message.timestamp);
    bubble.appendChild(timeEl);
    
    bubbleContainer.appendChild(bubble);
    
    // Action buttons (not for system messages)
    const actionsEl = document.createElement('div');
    actionsEl.style.cssText = `
      display:flex; 
      gap:4px; 
      ${isPlayer ? 'justify-content:flex-end;' : 'justify-content:flex-start;'}
      opacity:0.7;
    `;
    
    if (!isSystem && isPlayer) {
      // Edit button for player messages
      const editBtn = document.createElement('button');
      editBtn.innerHTML = 'âœï¸';
      editBtn.title = 'Edit';
      editBtn.style.cssText = `
        background:#0f3460;
        border:1px solid #667eea;
        color:#667eea;
        padding:4px 8px;
        border-radius:4px;
        font-size:0.85rem;
        cursor:pointer;
        transition:all 0.2s;
        min-width:28px;
      `;
      editBtn.onmouseenter = () => {
        editBtn.style.background = '#667eea';
        editBtn.style.color = 'white';
      };
      editBtn.onmouseleave = () => {
        editBtn.style.background = '#0f3460';
        editBtn.style.color = '#667eea';
      };
      editBtn.onclick = () => editMessageInline(meeting, message, contentEl, messageEl);
      actionsEl.appendChild(editBtn);
      
      // Resend button for player messages
      const resendBtn = document.createElement('button');
      resendBtn.innerHTML = 'â†©ï¸';
      resendBtn.title = 'Resend (triggers new NPC replies)';
      resendBtn.style.cssText = `
        background:#0f3460;
        border:1px solid #4ecca3;
        color:#4ecca3;
        padding:4px 8px;
        border-radius:4px;
        font-size:0.85rem;
        cursor:pointer;
        transition:all 0.2s;
        min-width:28px;
      `;
      resendBtn.onmouseenter = () => {
        resendBtn.style.background = '#4ecca3';
        resendBtn.style.color = 'white';
      };
      resendBtn.onmouseleave = () => {
        resendBtn.style.background = '#0f3460';
        resendBtn.style.color = '#4ecca3';
      };
      resendBtn.onclick = () => resendMessage(meeting, message);
      actionsEl.appendChild(resendBtn);
    } else if (!isSystem) {
      // Edit button for NPC messages
      const editBtn = document.createElement('button');
      editBtn.innerHTML = 'âœï¸';
      editBtn.title = 'Edit';
      editBtn.style.cssText = `
        background:#0f3460;
        border:1px solid #667eea;
        color:#667eea;
        padding:4px 8px;
        border-radius:4px;
        font-size:0.85rem;
        cursor:pointer;
        transition:all 0.2s;
        min-width:28px;
      `;
      editBtn.onmouseenter = () => {
        editBtn.style.background = '#667eea';
        editBtn.style.color = 'white';
      };
      editBtn.onmouseleave = () => {
        editBtn.style.background = '#0f3460';
        editBtn.style.color = '#667eea';
      };
      editBtn.onclick = () => editMessageInline(meeting, message, contentEl, messageEl);
      actionsEl.appendChild(editBtn);
      
      // Regenerate button for NPC messages
      const regenBtn = document.createElement('button');
      regenBtn.innerHTML = 'ğŸ”„';
      regenBtn.title = 'Regenerate';
      regenBtn.style.cssText = `
        background:#0f3460;
        border:1px solid #4ecca3;
        color:#4ecca3;
        padding:4px 8px;
        border-radius:4px;
        font-size:0.85rem;
        cursor:pointer;
        transition:all 0.2s;
        min-width:28px;
      `;
      regenBtn.onmouseenter = () => {
        regenBtn.style.background = '#4ecca3';
        regenBtn.style.color = 'white';
      };
      regenBtn.onmouseleave = () => {
        regenBtn.style.background = '#0f3460';
        regenBtn.style.color = '#4ecca3';
      };
      regenBtn.onclick = () => regenerateNPCMessage(meeting, message);
      actionsEl.appendChild(regenBtn);
    }
    
    // Delete button for all messages (except system)
    if (!isSystem) {
      const deleteBtn = document.createElement('button');
      deleteBtn.innerHTML = 'ğŸ—‘ï¸';
      deleteBtn.title = 'Delete';
      deleteBtn.style.cssText = `
        background:#0f3460;
        border:1px solid #e94560;
        color:#e94560;
        padding:4px 8px;
        border-radius:4px;
        font-size:0.85rem;
        cursor:pointer;
        transition:all 0.2s;
        min-width:28px;
      `;
      deleteBtn.onmouseenter = () => {
        deleteBtn.style.background = '#e94560';
        deleteBtn.style.color = 'white';
      };
      deleteBtn.onmouseleave = () => {
        deleteBtn.style.background = '#0f3460';
        deleteBtn.style.color = '#e94560';
      };
      deleteBtn.onclick = () => deleteMeetingMessage(meeting, message);
      actionsEl.appendChild(deleteBtn);
    }
    
    if (!isSystem) {
      bubbleContainer.appendChild(actionsEl);
    }
    messageEl.appendChild(bubbleContainer);
    messagesContainer.appendChild(messageEl);
  }
  
  /**
   * Add a message to a meeting (helper function)
   */
  function addMeetingMessage({ sender, content, imageUrl = null, timestamp = null }) {
    if (!gameState.activeMeeting) return;
    
    const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
    if (!meeting) return;
    
    const message = {
      id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      speakerId: sender,
      content: content,
      imageUrl: imageUrl,
      timestamp: timestamp || gameState.time.currentTime
    };
    
    meeting.messages.push(message);
    meeting.lastActivity = gameState.time.currentTime;
    
    // CRITICAL FIX: Save immediately after meeting image to prevent message loss
    saveGame(false);
    
    // Update stats (Task #6)
    if (!meeting.stats) {
      meeting.stats = {
        totalMessages: 0,
        playerMessages: 0,
        participantMessages: {},
        topics: [],
        mood: 'neutral',
        lastTopic: '',
        imagesSent: 0,
        moneyGifted: 0
      };
    }
    
    if (imageUrl) {
      meeting.stats.imagesSent++;
    }
    
    if (sender !== 'system') {
      meeting.stats.totalMessages++;
      if (sender === 'player') {
        meeting.stats.playerMessages++;
      } else {
        if (!meeting.stats.participantMessages[sender]) {
          meeting.stats.participantMessages[sender] = 0;
        }
        meeting.stats.participantMessages[sender]++;
      }
    }
    
    // Add to UI
    addMeetingMessageToUI(message, meeting);
    
    // Scroll to bottom
    const messagesContainer = document.getElementById('meetingMessages');
    if (messagesContainer) {
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
  }
  
  /**
   * Player sends a message in a meeting
   */
  async function sendMeetingMessage(content) {
    if (!gameState.activeMeeting) return;
    
    const meeting = gameState.meetings.find(m => m.id === gameState.activeMeeting);
    if (!meeting) return;
    
    if (!content || content.trim() === '') return;
    
    // Add player message
    const playerMessage = {
      id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      speakerId: 'player',
      content: content.trim(),
      timestamp: gameState.time.currentTime
    };
    
    meeting.messages.push(playerMessage);
    meeting.lastActivity = gameState.time.currentTime;
    
    // CRITICAL FIX: Save immediately after meeting message to prevent message loss
    saveGame(false);
    
    // Update meeting stats (Task #6)
    if (!meeting.stats) {
      meeting.stats = {
        totalMessages: 0,
        playerMessages: 0,
        participantMessages: {},
        topics: [],
        mood: 'neutral',
        lastTopic: '',
        imagesSent: 0,
        moneyGifted: 0
      };
    }
    meeting.stats.totalMessages++;
    meeting.stats.playerMessages++;
    meeting.stats.lastTopic = content.substring(0, 50); // Store snippet of last topic
    
    // Reset replies remaining for this turn
    meeting.repliesRemaining = meeting.replyLimit;
    
    // Track the start of this reply chain for deletion logic
    meeting.activeReplyChainStartIndex = meeting.messages.length - 1;
    
    // NEW: Extract and track topics from player's message
    const extractedTopics = extractMeetingTopics(content);
    if (extractedTopics.length > 0) {
      if (!meeting.context) {
        meeting.context = { summary: '', keyPoints: [], decisions: [], nextSteps: [], rollingSummary: '', topics: [] };
      }
      if (!meeting.context.topics) meeting.context.topics = [];
      extractedTopics.forEach(topic => {
        if (!meeting.context.topics.includes(topic)) {
          meeting.context.topics.push(topic);
        }
      });
      // Keep only last 20 topics
      if (meeting.context.topics.length > 20) {
        meeting.context.topics = meeting.context.topics.slice(-20);
      }
    }
    
    // Add to UI
    addMeetingMessageToUI(playerMessage, meeting);
    
    // Clear input
    const input = document.getElementById('meetingInput');
    if (input) input.value = '';
    
    // Update reply status
    const repliesLeft = document.getElementById('meetingRepliesLeft');
    if (repliesLeft) repliesLeft.textContent = meeting.repliesRemaining;
    
    // Scroll to bottom
    const messagesContainer = document.getElementById('meetingMessages');
    if (messagesContainer) {
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    // Trigger NPC responses
    await processMeetingReplies(meeting);
  }
  
  /**
   * Process NPC replies to the last player message
   */
  async function processMeetingReplies(meeting) {
    console.log(`[Meeting] Processing replies for "${meeting.name}" (${meeting.repliesRemaining} remaining)`);
    
    // Show stop button
    const stopBtn = document.getElementById('stopMeetingRepliesBtn');
    if (stopBtn) stopBtn.style.display = 'block';
    
    // Get the last player message for context
    const lastPlayerMessage = meeting.messages.filter(m => m.speakerId === 'player').pop();
    if (!lastPlayerMessage) {
      if (stopBtn) stopBtn.style.display = 'none';
      return;
    }
    
    // Process replies one by one
    while (meeting.repliesRemaining > 0) {
      // Determine next speaker
      const nextSpeaker = selectNextSpeaker(meeting, lastPlayerMessage.content);
      
      if (!nextSpeaker) {
        console.log('[Meeting] No suitable speaker found, ending turn');
        break;
      }
      
      // Generate response
      const response = await generateMeetingResponse(nextSpeaker, meeting, lastPlayerMessage.content);
      
      if (!response) {
        console.log(`[Meeting] ${nextSpeaker.name} declined to speak`);
        meeting.repliesRemaining--;
        continue;
      }
      
      // Add NPC message
      const npcMessage = {
        id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        speakerId: nextSpeaker.id,
        content: response,
        timestamp: gameState.time.currentTime
      };
      
      meeting.messages.push(npcMessage);
      meeting.repliesRemaining--;
      
      // CRITICAL FIX: Save immediately after meeting response to prevent message loss
      saveGame(false);
      
      // Update meeting stats (Task #6)
      if (!meeting.stats) {
        meeting.stats = {
          totalMessages: 0,
          playerMessages: 0,
          participantMessages: {},
          topics: [],
          mood: 'neutral',
          lastTopic: '',
          imagesSent: 0,
          moneyGifted: 0
        };
      }
      meeting.stats.totalMessages++;
      if (!meeting.stats.participantMessages[nextSpeaker.id]) {
        meeting.stats.participantMessages[nextSpeaker.id] = 0;
      }
      meeting.stats.participantMessages[nextSpeaker.id]++;
      
      // Track who spoke
      meeting.lastSpeakers = meeting.lastSpeakers || [];
      meeting.lastSpeakers.push(nextSpeaker.id);
      if (meeting.lastSpeakers.length > 3) meeting.lastSpeakers.shift();
      
      // Add to UI
      addMeetingMessageToUI(npcMessage, meeting);
      
      // Update reply status
      const repliesLeft = document.getElementById('meetingRepliesLeft');
      if (repliesLeft) repliesLeft.textContent = meeting.repliesRemaining;
      
      // Scroll to bottom
      const messagesContainer = document.getElementById('meetingMessages');
      if (messagesContainer) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }
      
      console.log(`[Meeting] ${nextSpeaker.name} spoke (${meeting.repliesRemaining} replies left)`);
      
      // Small delay between responses for natural flow
      await new Promise(resolve => setTimeout(resolve, 800));
    }
    
    // NEW: Auto-compress meeting context if getting long
    // This runs in background after turn completes to not block UI
    autoCompressMeetingContext(meeting).catch(err => console.error('[Meeting] Auto-compress error:', err));
    
    // Hide stop button when done
    if (stopBtn) stopBtn.style.display = 'none';
    
    // Clear the active reply chain tracking
    meeting.activeReplyChainStartIndex = null;
    
    console.log('[Meeting] Turn complete, waiting for player');
  }
  
  /**
   * Delete a meeting
   */
  function deleteMeeting(meetingId) {
    const index = gameState.meetings.findIndex(m => m.id === meetingId);
    if (index === -1) return;
    
    gameState.meetings.splice(index, 1);
    
    // If this was the active meeting, clear it
    if (gameState.activeMeeting === meetingId) {
      gameState.activeMeeting = null;
      
      // Show placeholder
      const placeholder = document.getElementById('meetingPlaceholder');
      const container = document.getElementById('meetingChatContainer');
      if (placeholder) placeholder.style.display = 'flex';
      if (container) container.style.display = 'none';
    }
    
    updateMeetingsList();
  }
  
  /**
   * Generate AI summary of a meeting (Task #6)
   */
  async function generateMeetingSummary(meetingId) {
    const meeting = gameState.meetings.find(m => m.id === meetingId);
    if (!meeting || meeting.messages.length === 0) return;
    
    showNotification('ğŸ“ Generating meeting summary...', 'info');
    
    try {
      // Get all messages (exclude system messages)
      const transcript = meeting.messages
        .filter(msg => msg.speakerId !== 'system')
        .map(msg => {
          const speaker = msg.speakerId === 'player' ? 'TheBoss' : 
            gameState.employees.find(e => e.id === msg.speakerId)?.name || 'Unknown';
          return `${speaker}: ${msg.content}`;
        })
        .join('\n');
      
      if (!transcript) return;
      
      // Generate summary using AI
      const prompt = `Summarize this meeting transcript. Include:
1. Main topics discussed
2. Key decisions made
3. Action items/next steps
4. Overall mood/tone

Transcript:
${transcript.substring(0, 2000)}

Summary:`;
      
      const summary = await queuedGenerateText(prompt, {
        temperature: 0.7,
        max_tokens: 300
      }, `Generating meeting summary for ${meeting.title}`);
      
      if (summary && summary.trim()) {
        // Update meeting context
        if (!meeting.context) {
          meeting.context = {
            summary: '',
            keyPoints: [],
            decisions: [],
            nextSteps: [],
            rollingSummary: '',
            topics: []
          };
        }
        
        meeting.context.summary = summary.trim();
        
        showNotification('âœ… Meeting summary generated!', 'success');
        
        // Optionally show the summary in a modal or add to meeting UI
        console.log(`[Meeting Summary] ${meeting.name}:\n${summary}`);
        
        return summary.trim();
      }
    } catch (error) {
      console.error('[Meeting Summary] Error:', error);
      showNotification('âŒ Failed to generate summary', 'error');
    }
  }
  
  /**
   * AUTO-SUMMARIZATION: Compress old messages into rolling summary every N messages
   * This dramatically extends the effective context window for long meetings
   */
  async function autoCompressMeetingContext(meeting) {
    const COMPRESS_THRESHOLD = 10; // Compress every 10 messages
    const KEEP_RECENT = 15; // Keep last 15 messages raw
    
    // Only compress if we have enough messages
    if (meeting.messages.length < COMPRESS_THRESHOLD + KEEP_RECENT) return;
    
    // Check if we've already compressed recently (track by message count)
    const lastCompressedAt = meeting.context?.lastCompressedAtCount || 0;
    if (meeting.messages.length - lastCompressedAt < COMPRESS_THRESHOLD) return;
    
    // Get messages to compress (everything except the last KEEP_RECENT)
    const messagesToCompress = meeting.messages.slice(0, -KEEP_RECENT);
    if (messagesToCompress.length === 0) return;
    
    console.log(`[Meeting] Auto-compressing ${messagesToCompress.length} old messages into rolling summary...`);
    
    // Build transcript of old messages
    const oldTranscript = messagesToCompress
      .filter(msg => msg.speakerId !== 'system')
      .map(msg => {
        const speaker = msg.speakerId === 'player' ? getPlayerName() : 
          gameState.employees.find(e => e.id === msg.speakerId)?.name || 'Unknown';
        return `${speaker}: ${msg.content}`;
      })
      .join('\n');
    
    if (!oldTranscript) return;
    
    // Include previous rolling summary if exists
    const previousSummary = meeting.context?.rollingSummary || '';
    
    try {
      const prompt = `Compress this meeting conversation into a brief context summary (max 200 words). Focus on:
- Key topics discussed
- Important decisions or agreements
- Relevant emotional moments or relationship developments
- Who said what (attribute important points to speakers)

${previousSummary ? `PREVIOUS CONTEXT:\n${previousSummary}\n\n` : ''}NEW MESSAGES TO COMPRESS:\n${oldTranscript.substring(0, 2500)}

Compressed summary:`;
      
      const summary = await queuedGenerateText(prompt, {
        temperature: 0.5,
        max_tokens: 250
      }, 'Auto-compressing meeting context');
      
      if (summary && summary.trim()) {
        // Ensure context object exists
        if (!meeting.context) {
          meeting.context = {
            summary: '',
            keyPoints: [],
            decisions: [],
            nextSteps: [],
            rollingSummary: '',
            topics: []
          };
        }
        
        meeting.context.rollingSummary = summary.trim();
        meeting.context.lastCompressedAtCount = meeting.messages.length;
        
        console.log(`[Meeting] Rolling summary updated: ${summary.substring(0, 100)}...`);
      }
    } catch (error) {
      console.error('[Meeting] Auto-compression error:', error);
    }
  }
  
  /**
   * Extract and track topics from a message
   * Helps NPCs know what's been discussed and avoid repetition
   */
  function extractMeetingTopics(messageContent) {
    const topics = [];
    const lowerContent = messageContent.toLowerCase();
    
    // Topic keywords to detect
    const topicPatterns = {
      'work/projects': ['project', 'deadline', 'task', 'deliverable', 'milestone', 'launch', 'release'],
      'budget/money': ['budget', 'cost', 'expense', 'money', 'salary', 'raise', 'bonus', 'funding'],
      'hiring/hr': ['hire', 'recruit', 'interview', 'candidate', 'position', 'role', 'team'],
      'personal': ['weekend', 'family', 'kids', 'vacation', 'hobby', 'date', 'relationship'],
      'complaints': ['problem', 'issue', 'complaint', 'frustrated', 'annoyed', 'concern'],
      'ideas': ['idea', 'suggest', 'proposal', 'think we should', 'how about', 'what if'],
      'social': ['party', 'lunch', 'drinks', 'hangout', 'celebration', 'event'],
      'performance': ['performance', 'review', 'feedback', 'improvement', 'goals']
    };
    
    for (const [topic, keywords] of Object.entries(topicPatterns)) {
      if (keywords.some(kw => lowerContent.includes(kw))) {
        topics.push(topic);
      }
    }
    
    return topics;
  }
  
  /**
   * Store meeting memory for an NPC - what they learned/discussed in this meeting
   * Persists across sessions so NPCs remember past meetings
   */
  function storeMeetingMemoryForNPC(npc, meeting, theirMessage, playerMessage) {
    if (!npc || !meeting) return;
    
    // Initialize meeting memories array if not exists
    if (!npc.meetingMemories) {
      npc.meetingMemories = [];
    }
    
    // Find or create entry for this meeting
    let meetingMemory = npc.meetingMemories.find(m => m.meetingId === meeting.id);
    if (!meetingMemory) {
      meetingMemory = {
        meetingId: meeting.id,
        meetingName: meeting.name,
        firstAttended: Date.now(),
        lastUpdated: Date.now(),
        keyPoints: [],
        myContributions: [],
        topicsDiscussed: []
      };
      npc.meetingMemories.push(meetingMemory);
    }
    
    meetingMemory.lastUpdated = Date.now();
    
    // Store their contribution (what they said)
    if (theirMessage && theirMessage.length > 10) {
      const contribution = theirMessage.substring(0, 100);
      if (!meetingMemory.myContributions.includes(contribution)) {
        meetingMemory.myContributions.push(contribution);
        // Keep only last 10 contributions
        if (meetingMemory.myContributions.length > 10) {
          meetingMemory.myContributions.shift();
        }
      }
    }
    
    // Store key points from player message (what they heard)
    if (playerMessage && playerMessage.length > 15) {
      const keyPoint = `Boss said: ${playerMessage.substring(0, 80)}`;
      if (!meetingMemory.keyPoints.some(kp => kp.includes(playerMessage.substring(0, 30)))) {
        meetingMemory.keyPoints.push(keyPoint);
        // Keep only last 15 key points
        if (meetingMemory.keyPoints.length > 15) {
          meetingMemory.keyPoints.shift();
        }
      }
    }
    
    // Extract and store topics
    const topics = extractMeetingTopics(playerMessage || '');
    topics.forEach(topic => {
      if (!meetingMemory.topicsDiscussed.includes(topic)) {
        meetingMemory.topicsDiscussed.push(topic);
      }
    });
    
    // Keep only last 5 meetings per NPC to avoid bloat
    if (npc.meetingMemories.length > 5) {
      npc.meetingMemories.sort((a, b) => b.lastUpdated - a.lastUpdated);
      npc.meetingMemories = npc.meetingMemories.slice(0, 5);
    }
  }
  
  /**
   * Build context from NPC's past meeting memories
   * Helps NPCs reference things from previous meetings
   */
  function buildMeetingMemoryContext(npc, currentMeetingId) {
    if (!npc.meetingMemories || npc.meetingMemories.length === 0) return '';
    
    // Get memories from THIS meeting (current) and OTHER meetings (past)
    const currentMeetingMemory = npc.meetingMemories.find(m => m.meetingId === currentMeetingId);
    const pastMeetingMemories = npc.meetingMemories.filter(m => m.meetingId !== currentMeetingId).slice(0, 2);
    
    const lines = [];
    
    // Current meeting memory (what was discussed earlier in this meeting)
    if (currentMeetingMemory && currentMeetingMemory.keyPoints.length > 0) {
      const recentPoints = currentMeetingMemory.keyPoints.slice(-5);
      lines.push('Earlier in this meeting:');
      recentPoints.forEach(point => lines.push(`  - ${point}`));
    }
    
    // Past meeting memories (brief reference to previous meetings)
    if (pastMeetingMemories.length > 0) {
      lines.push('From previous meetings with this group:');
      pastMeetingMemories.forEach(mem => {
        if (mem.topicsDiscussed.length > 0) {
          lines.push(`  - Discussed: ${mem.topicsDiscussed.slice(0, 3).join(', ')}`);
        }
        if (mem.keyPoints.length > 0) {
          lines.push(`  - ${mem.keyPoints[mem.keyPoints.length - 1]}`);
        }
      });
    }
    
    return lines.length > 0 ? '\n--- MEETING MEMORIES ---\n' + lines.join('\n') + '\n--- END MEETING MEMORIES ---' : '';
  }
  
  /**
   * Build personality modifiers for meeting context (ported from 1-on-1 chat)
   * Makes NPCs feel consistent and alive in group settings
   */
  function buildMeetingPersonalityModifiers(npc) {
    ensureEmployeeMemory(npc);
    
    // Get stats
    const affection = npc.stats?.affection ?? npc.stats?.love ?? 0;
    const comfort = npc.stats?.comfort ?? 0;
    const desire = npc.stats?.desire ?? 0;
    const trust = npc.stats?.trust ?? 0;
    const obedience = npc.stats?.obedience ?? 50;
    
    // Get policy settings - default to professional for safety
    const policy = gameState.settings?.policy || 'professional';
    const atmosphere = gameState.settings?.atmosphere ?? 50;
    
    const lines = [];
    
    // Affection affects warmth toward boss
    const affectionTone = affection < 25 ? 'Polite but reserved with boss' :
      affection < 50 ? 'Friendly and respectful to boss' :
      affection < 75 ? 'Warm and supportive of boss' :
      'Deeply fond of boss, shows it subtly';
    lines.push(affectionTone);
    
    // Comfort affects how open they are in groups
    const comfortOpenness = comfort < 25 ? 'Guarded in group settings, speaks cautiously' :
      comfort < 50 ? 'Somewhat relaxed, participates when relevant' :
      comfort < 75 ? 'Comfortable sharing opinions openly' :
      'Very at ease, speaks freely and authentically';
    lines.push(comfortOpenness);
    
    // Trust affects how much they back the boss
    const trustLevel = trust < 25 ? 'Skeptical of boss\'s ideas, may push back' :
      trust < 50 ? 'Gives boss benefit of the doubt' :
      trust < 75 ? 'Trusts boss\'s judgment, supportive' :
      'Complete confidence in boss, loyal defender';
    lines.push(trustLevel);
    
    // Desire affects subtle flirtation - BUT ONLY if policy/atmosphere allows AND relationship is established
    // Requirements: desire > 60, comfort > 50, AND either open policy or high atmosphere
    const flirtingAllowed = (policy === 'open' || atmosphere > 66) && comfort > 50 && affection > 40;
    if (flirtingAllowed && desire > 60) {
      const desireHint = desire < 80 ? 'Subtle interest - may be slightly playful when comfortable' :
        'Noticeable attraction - occasionally flirtatious when appropriate';
      lines.push(desireHint);
    }
    
    // Obedience affects how they respond to boss in group
    const obedienceStyle = obedience < 30 ? 'Independent thinker, voices disagreement openly' :
      obedience < 60 ? 'Balanced - supports boss but has own opinions' :
      'Deferential to boss, rarely contradicts';
    lines.push(obedienceStyle);
    
    return lines.join('\n');
  }
  
  /**
   * Update the meetings list in the sidebar
   */
  function updateMeetingsList() {
    const listEl = document.getElementById('meetingsList');
    if (!listEl) return;
    
    if (gameState.meetings.length === 0) {
      listEl.innerHTML = `
        <div style="text-align:center; color:#666; padding:40px 20px; font-style:italic;">
          No meetings yet.<br>
          <span style="font-size:2rem; margin-top:10px; display:block;">ğŸ’¼</span>
          Click "Create New Meeting" to start!
        </div>
      `;
      return;
    }
    
    // Sort by last activity (most recent first)
    const sortedMeetings = [...gameState.meetings].sort((a, b) => b.lastActivity - a.lastActivity);
    
    listEl.innerHTML = sortedMeetings.map(meeting => {
      const isActive = gameState.activeMeeting === meeting.id;
      const lastMessage = meeting.messages[meeting.messages.length - 1];
      const lastSpeaker = lastMessage ? 
        (lastMessage.speakerId === 'player' ? 'You' : 
         gameState.employees.find(e => e.id === lastMessage.speakerId)?.name || 'Unknown') : 
        'No messages';
      
      return `
        <div onclick="loadMeeting('${meeting.id}')" 
             style="padding:15px; background:${isActive ? '#667eea' : '#0f3460'}; border-radius:10px; cursor:pointer; transition:all 0.2s; position:relative; border:2px solid ${isActive ? '#764ba2' : 'transparent'};"
             onmouseenter="if(!${isActive}) this.style.background='#16213e'"
             onmouseleave="if(!${isActive}) this.style.background='#0f3460'">
          
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <h4 style="margin:0; font-size:1rem;">${meeting.name}</h4>
            ${meeting.unreadCount > 0 ? `<span style="background:#e94560; color:white; padding:2px 8px; border-radius:12px; font-size:0.75rem; font-weight:bold;">${meeting.unreadCount}</span>` : ''}
          </div>
          
          <div style="display:flex; gap:4px; margin-bottom:8px; flex-wrap:wrap;">
            ${meeting.participants.slice(0, 3).map(empId => {
              const emp = gameState.employees.find(e => e.id === empId);
              return emp ? `<img src="${emp.profileImage}" style="width:24px; height:24px; border-radius:50%; object-fit:cover;" title="${emp.name}">` : '';
            }).join('')}
            ${meeting.participants.length > 3 ? `<span style="font-size:0.8rem; opacity:0.7;">+${meeting.participants.length - 3}</span>` : ''}
          </div>
          
          <div style="font-size:0.85rem; opacity:0.7; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
            ${lastSpeaker}: ${lastMessage ? lastMessage.content.substring(0, 40) + (lastMessage.content.length > 40 ? '...' : '') : 'Start the conversation'}
          </div>
        </div>
      `;
    }).join('');
  }
  
  /**
   * Select the next speaker based on intelligent priority
   */
  function selectNextSpeaker(meeting, lastMessageContent) {
    const participants = meeting.participants
      .map(id => gameState.employees.find(e => e.id === id))
      .filter(e => e); // Filter out any not found
    
    if (participants.length === 0) return null;
    
    // Calculate priority scores for each participant
    const scored = participants.map(emp => {
      let score = 0;
      const lowerContent = lastMessageContent.toLowerCase();
      const scoreBreakdown = [];
      
      // 1. DIRECT MENTION: Highest priority if their name is mentioned
      if (lowerContent.includes(emp.name.toLowerCase())) {
        score += 100;
        scoreBreakdown.push('mentioned:+100');
      }
      
      // 2. QUESTION DETECTION: Higher priority if message contains a question
      if (lowerContent.includes('?')) {
        score += 30;
        scoreBreakdown.push('question:+30');
      }
      
      // 3. RECENCY PENALTY: Reduce score if they spoke recently
      const lastSpeakers = meeting.lastSpeakers || [];
      const recentSpeechIndex = lastSpeakers.indexOf(emp.id);
      if (recentSpeechIndex !== -1) {
        // More recent = higher penalty
        const penalty = (3 - recentSpeechIndex) * 20;
        score -= penalty;
        scoreBreakdown.push(`recent:-${penalty}`);
      }
      
      // 4. SILENCE BONUS: Increase score if they haven't spoken at all
      const hasSpoken = meeting.messages.some(m => m.speakerId === emp.id);
      if (!hasSpoken) {
        score += 25;
        scoreBreakdown.push('first_time:+25');
      }
      
      // 5. CONTEXTUAL KEYWORDS: Check for job-related topics
      const keywords = {
        'budget': ['finance', 'cost', 'money', 'budget', 'expense'],
        'technical': ['system', 'code', 'server', 'technical', 'bug', 'software'],
        'creative': ['design', 'creative', 'visual', 'art', 'style'],
        'management': ['team', 'schedule', 'deadline', 'priority', 'manage'],
        'hr': ['hire', 'employee', 'staff', 'personnel', 'recruitment']
      };
      
      // Boost score if message topic matches their expertise (based on department/role)
      const empRole = emp.hierarchyLevel || 1;
      if (empRole >= 5 && keywords.management.some(kw => lowerContent.includes(kw))) {
        score += 15;
        scoreBreakdown.push('management_topic:+15');
      }
      
      // 6. RELATIONSHIP/ATTRACTION: Slight boost if high relationship
      const relationship = emp.relationshipLevel || 0;
      const relBonus = relationship * 0.5;
      if (relBonus > 0) {
        score += relBonus;
        scoreBreakdown.push(`relationship:+${relBonus.toFixed(1)}`);
      }
      
      // 7. RANDOM FACTOR: Add some randomness for natural variety
      const randomBonus = Math.random() * 10;
      score += randomBonus;
      scoreBreakdown.push(`random:+${randomBonus.toFixed(1)}`);
      
      return { emp, score, breakdown: scoreBreakdown.join(', ') };
    });
    
    // Sort by score descending
    scored.sort((a, b) => b.score - a.score);
    
    console.log('[Meeting] Speaker Selection:');
    scored.forEach((s, index) => {
      const prefix = index === 0 ? 'ğŸ¤ SELECTED' : '  ';
      console.log(`${prefix} ${s.emp.name}: ${s.score.toFixed(1)} (${s.breakdown})`);
    });
    
    // Return the highest scoring participant
    return scored[0].emp;
  }
  
  /**
   * Build recent 1-on-1 conversation context for an NPC in a meeting
   * This gives NPCs memory of their private conversations with the player
   */
  function buildPrivateConversationContext(npc, playerName) {
    // Get recent 1-on-1 chat history with this NPC
    const chatHistory = gameState.chatHistory[npc.id];
    if (!chatHistory || chatHistory.length === 0) {
      return ''; // No private conversations yet
    }
    
    // Get last 6-8 messages (3-4 exchanges) - enough for context, not too much for tokens
    const recentMessages = chatHistory.slice(-8);
    
    if (recentMessages.length === 0) return '';
    
    // Format as compact conversation summary
    const formattedHistory = recentMessages.map(msg => {
      const speaker = msg.sender === 'player' ? playerName : npc.name;
      // Truncate very long messages to save tokens
      const content = msg.content.length > 150 ? msg.content.substring(0, 147) + '...' : msg.content;
      return `${speaker}: ${content}`;
    }).join('\n');
    
    // Log that we found private context
    console.log(`[Meeting] ${npc.name} has ${recentMessages.length} messages of private conversation context`);
    
    // Return formatted context block
    return `\n--- RECENT PRIVATE CONVERSATIONS (you and ${playerName} only) ---
${formattedHistory}
--- END PRIVATE CONTEXT ---`;
  }
  
  /**
   * Generate an AI response for an NPC in a meeting
   * Enhanced with memory retrieval, personality injection, and rolling context
   */
  async function generateMeetingResponse(npc, meeting, lastPlayerMessage) {
    console.log(`[Meeting] Generating response for ${npc.name}...`);
    
    // Ensure NPC has memory system
    ensureEmployeeMemory(npc);
    
    // Get player's name - fallback to "Boss" if not set
    let playerName = getPlayerName();
    if (!playerName || playerName === 'the boss') {
      playerName = 'Boss'; // Use "Boss" as the default addressable name
    }
    
    // IMPROVED: Increased history depth - 35 for small groups, 30 for medium, 25 for large
    const participantCount = meeting.participants.length;
    const historyDepth = participantCount <= 3 ? 35 : participantCount === 4 ? 30 : 25;
    const recentMessages = meeting.messages.slice(-historyDepth);
    
    const conversationHistory = recentMessages.map(msg => {
      const speaker = msg.speakerId === 'player' ? playerName :
                      gameState.employees.find(e => e.id === msg.speakerId)?.name || 'Unknown';
      return `${speaker}: ${msg.content}`;
    }).join('\n');
    
    // Extract overused phrases/topics to avoid
    const recentContent = recentMessages.slice(-5).map(m => m.content.toLowerCase()).join(' ');
    const overusedPhrases = [];
    
    // Detect repetitive phrases (mentioned 2+ times in last 5 messages)
    const checkPhrases = [
      'cleanup crew', 'waterproof', 'flood', 'overflow', 'hydration', 
      'trembling', 'choking', 'slumping', 'leaning forward', 'coffee',
      'breeding room', 'drainage', 'bapti', 'biblical', 'tsunami',
      'absolutely', 'honestly', 'literally', 'basically'
    ];
    
    checkPhrases.forEach(phrase => {
      const count = (recentContent.match(new RegExp(phrase, 'g')) || []).length;
      if (count >= 2) overusedPhrases.push(phrase);
    });
    
    // Build participant list with rich context
    const participantObjs = meeting.participants
      .map(id => gameState.employees.find(e => e.id === id))
      .filter(e => e);
    
    // Build relationship map (compact format)
    const relationshipMap = buildRelationshipMap(npc, participantObjs, playerName);
    
    // Build individual perspective context
    const perspectiveContext = buildParticipantPerspective(npc, meeting);
    
    // Build private conversation context (recent 1-on-1 chats with player)
    const privateContext = buildPrivateConversationContext(npc, playerName);
    
    // NEW: Retrieve relevant memories based on current topic
    const relevantMemories = retrieveMemories(npc, lastPlayerMessage, 8);
    let memoryContext = '';
    if (relevantMemories && relevantMemories.length > 0) {
      const memorySnippets = relevantMemories
        .filter(m => m.text && m.text.length > 10)
        .slice(0, 5)
        .map(m => `- ${m.text.substring(0, 100)}`)
        .join('\n');
      if (memorySnippets) {
        memoryContext = `\n--- RELEVANT MEMORIES ---\n${memorySnippets}\n--- END MEMORIES ---`;
      }
    }
    
    // NEW: Build meeting-specific memories (past meetings + earlier in this meeting)
    const meetingMemoryContext = buildMeetingMemoryContext(npc, meeting.id);
    
    // NEW: Include rolling summary if exists (compressed earlier conversation)
    let rollingSummaryContext = '';
    if (meeting.context?.rollingSummary) {
      rollingSummaryContext = `\n--- EARLIER IN THIS MEETING (SUMMARY) ---\n${meeting.context.rollingSummary}\n--- END SUMMARY ---`;
    }
    
    // NEW: Build personality modifiers (stat-based personality from 1-on-1 system)
    const personalityModifiers = buildMeetingPersonalityModifiers(npc);
    
    // NEW: Topic tracking for this meeting
    let topicsContext = '';
    if (meeting.context?.topics && meeting.context.topics.length > 0) {
      const uniqueTopics = [...new Set(meeting.context.topics)].slice(-8);
      topicsContext = `\nTopics already discussed: ${uniqueTopics.join(', ')}`;
    }
    
    // Determine if NPC should respond based on relevance
    const shouldRespond = await checkShouldRespond(npc, lastPlayerMessage, meeting);
    if (!shouldRespond) {
      console.log(`[Meeting] ${npc.name} has nothing to add right now`);
      return null;
    }
    
    // Build anti-repetition guidance
    let freshGuidance = '';
    if (overusedPhrases.length > 0) {
      freshGuidance = `\nAVOID: ${overusedPhrases.join(', ')} (overused). Bring a NEW angle.`;
      console.log(`[Meeting] ${npc.name} avoiding overused: ${overusedPhrases.join(', ')}`);
    }
    
    // Add guidance about using private context if available
    const contextGuidance = privateContext ? '\n\nNOTE: You have recent private conversations with ' + playerName + '. You can reference or allude to topics from those private chats naturally if relevant to the current discussion.' : '';
    
    // Build scenario context - use custom scenario if provided, otherwise default to generic
    let scenarioContext = '';
    if (meeting.scenario && meeting.scenario.trim()) {
      scenarioContext = `SCENARIO: ${meeting.scenario}`;
    } else {
      scenarioContext = `You are in a group gathering with ${playerName} and ${participantObjs.map(e => e.name).join(', ')}.`;
    }
    
    // === WORKPLACE CULTURE CONTEXT (CRITICAL FOR CONTENT APPROPRIATENESS) ===
    const policy = gameState.settings?.policy || 'professional';
    const atmosphere = gameState.settings?.atmosphere ?? 50;
    const guidelines = gameState.settings?.guidelines ?? 50;
    
    // Calculate average relationship level with boss
    const avgRelationship = (npc.stats?.affection || 0 + npc.stats?.comfort || 0 + npc.stats?.trust || 0) / 3;
    
    // Build workplace culture guidance based on settings
    let workplaceCultureRules = '';
    if (policy === 'professional') {
      workplaceCultureRules = `WORKPLACE CULTURE: Professional environment.
- Maintain workplace-appropriate behavior at all times
- NO flirting, sexual innuendo, or suggestive comments
- NO references to wardrobe malfunctions, HR violations, or inappropriate clothing
- Keep conversation focused on work, polite small talk, or the meeting topic
- Even playful banter should remain completely PG and work-appropriate`;
    } else if (policy === 'open' && atmosphere > 66) {
      workplaceCultureRules = `WORKPLACE CULTURE: Relaxed, adult-friendly environment.
- Casual banter and playful flirting is acceptable IF relationship warrants it
- Still match your actual comfort/affection levels with each person`;
    } else {
      // Default/casual
      workplaceCultureRules = `WORKPLACE CULTURE: Balanced professional environment.
- Friendly and casual but maintain basic professionalism
- Mild teasing is okay with established relationships, but nothing sexual or suggestive
- Keep it workplace-appropriate`;
    }
    
    // Add relationship-appropriate behavior rules
    let relationshipBehaviorRules = '';
    if (avgRelationship < 30) {
      relationshipBehaviorRules = `\nRELATIONSHIP STATUS: New/unfamiliar with boss (avg: ${Math.round(avgRelationship)})
- Be polite and professional - you don't know them well yet
- No personal comments, teasing about appearance, or inside jokes
- Focus on work topics and neutral conversation`;
    } else if (avgRelationship < 60) {
      relationshipBehaviorRules = `\nRELATIONSHIP STATUS: Building rapport with boss (avg: ${Math.round(avgRelationship)})
- Friendly but still professional
- Light workplace humor is fine, but nothing too personal`;
    }
    
    // Build AI prompt with richer context including race/species
    const raceInfo = npc.race && npc.race !== 'human' ? `, ${npc.race}` : '';
    const raceFeatures = npc.physical?.raceFeatures?.description || '';
    const raceContext = raceFeatures ? ` (${raceFeatures})` : '';
    
    const prompt = `You are ${npc.name}. ${scenarioContext}

CHARACTER: ${npc.gender}${raceInfo}${raceContext}, ${npc.personality || 'Professional'}
PERSONALITY IN GROUPS:
${personalityModifiers}

${workplaceCultureRules}${relationshipBehaviorRules}

RELATIONSHIPS:
${relationshipMap}
${perspectiveContext}${topicsContext}${rollingSummaryContext}${meetingMemoryContext}${memoryContext}${privateContext}${contextGuidance}

CONVERSATION (last ${historyDepth} messages):
${conversationHistory}

CONTENT SAFETY RULES:
- NO references to suicide, self-harm, or death
- NO references to terminal illness, hospices, or medical trauma
- NO exploitation of vulnerable people (sick, dying, imprisoned, etc.)
- NO extreme violence, gore, or morbid content
- NO illegal activities (murder, terrorism, child exploitation, etc.)
- Keep suggestions ethical, legal, and reasonable
- If topic is dark/morbid, redirect to something constructive

WRITING RULES:
- 1-2 sentences only. Be concise.
- Match the tone/vibe of the scenario.
- Add something NEWâ€”don't repeat what others said.
- You can reference things from your memories or past conversations if relevant.
- Vary your physical actions. Use *asterisks* for actions.
- Talk like a real person, not a character in a novel.${freshGuidance}

${npc.name}:`;
    
    try {
      const response = await queuedGenerateText(prompt, {
        temperature: 0.85, // Slightly lower for more coherent memory usage
        max_tokens: 150, // Enough to complete thoughts, but encourages brevity
        stop: ['\n\n', `${playerName}:`, '\n---', '\nNote:'] // Stop at natural breaks
      }, `Generating meeting response for ${npc.name}`);
      
      if (!response || response.trim() === '') {
        return null;
      }
      
      // NEW: Store this interaction in NPC's meeting memory
      storeMeetingMemoryForNPC(npc, meeting, response.trim(), lastPlayerMessage);
      
      console.log(`[Meeting] ${npc.name}: ${response.substring(0, 60)}...`);
      return response.trim();
      
    } catch (error) {
      console.error(`[Meeting] Error generating response for ${npc.name}:`, error);
      return null;
    }
  }
  
  /**
   * Get relationship strength between two employees
   */
  function getRelationshipLevel(emp1Id, emp2Id) {
    const emp1 = gameState.employees.find(e => e.id === emp1Id);
    if (!emp1 || !emp1.relationships || !emp1.relationships[emp2Id]) {
      return 0;
    }
    return emp1.relationships[emp2Id].strength || 0;
  }
  
  /**
   * Build compact relationship map for meeting context
   */
  function buildRelationshipMap(npc, participants, playerName) {
    const lines = [];
    
    // Player relationship (always first, most important)
    const playerRel = npc.relationshipLevel || 0;
    const playerAttr = npc.attractionLevel || 0;
    const flags = getActiveFlags(npc);
    const children = getEmployeeChildren(npc.id);
    
    let playerLine = `â†’ ${playerName}: ${playerRel}â™¥`;
    if (playerAttr > 50) playerLine += ` ${playerAttr}ğŸ”¥`;
    if (children && children.length > 0) playerLine += ` [${children.length} kid${children.length > 1 ? 's' : ''}]`;
    if (flags.length > 0) {
      const topFlag = flags[0].value || flags[0].key || String(flags[0]);
      if (topFlag) playerLine += ` "${topFlag}"`;
    }
    lines.push(playerLine);
    
    // Other participants (compact format)
    participants.forEach(emp => {
      if (emp.id === npc.id) return; // Skip self
      
      const theirRel = getRelationshipLevel(npc.id, emp.id) || 0;
      if (theirRel < 20) return; // Skip strangers/acquaintances (save tokens)
      
      let line = `â†’ ${emp.name}: ${Math.round(theirRel)}â™¥`;
      
      // Check if they know about any special relationship status
      const theirFlags = getActiveFlags(emp);
      const publicFlags = theirFlags.filter(f => {
        const val = (f.value || f.key || '').toLowerCase();
        return !val.includes('secret') && !val.includes('private');
      });
      
      if (publicFlags.length > 0) {
        const flag = publicFlags[0].value || publicFlags[0].key;
        if (flag && flag.length < 20) line += ` "${flag}"`;
      }
      
      lines.push(line);
    });
    
    return lines.join('\n');
  }
  
  /**
   * Build perspective-specific context for an NPC
   */
  function buildParticipantPerspective(npc, meeting) {
    const context = [];
    
    // Add role/hierarchy (compact)
    const level = npc.hierarchyLevel || 1;
    const hierarchyInfo = gameState.hierarchyLevels[level];
    if (hierarchyInfo) {
      context.push(`Role: ${hierarchyInfo.title}`);
    }
    
    // Add recent memory/context (very compact)
    if (npc.memory && npc.memory.recentTopics && npc.memory.recentTopics.length > 0) {
      const topics = npc.memory.recentTopics.slice(0, 2).join(', ');
      context.push(`Recent private topics: ${topics}`);
    }
    
    // Add perspective mode note (if secrets exist)
    if (gameState.meetingSettings.perspectiveMode) {
      const otherParticipants = meeting.participants.filter(id => id !== npc.id);
      const hasSecrets = otherParticipants.some(id => {
        const emp = gameState.employees.find(e => e.id === id);
        if (!emp) return false;
        const theirFlags = getActiveFlags(emp);
        return theirFlags.some(f => {
          const flagValue = (f.value || f.key || '').toLowerCase();
          return flagValue.includes('secret') || flagValue.includes('private');
        });
      });
      
      if (hasSecrets) {
        context.push(`âš ï¸ Some relationships here may be unknown to you`);
      }
    }
    
    return context.length > 0 ? '\n' + context.join('\n') : '';
  }
  
  /**
   * Determine if an NPC should respond based on context
   */
  async function checkShouldRespond(npc, lastMessage, meeting) {
    // Always respond if mentioned by name
    if (lastMessage.toLowerCase().includes(npc.name.toLowerCase())) {
      return true;
    }
    
    // Always respond if this is their first time speaking
    const hasSpoken = meeting.messages.some(m => m.speakerId === npc.id);
    if (!hasSpoken) {
      return true;
    }
    
    // Check if message is a question - higher response chance
    if (lastMessage.includes('?')) {
      return Math.random() > 0.2; // 80% chance
    }
    
    // Check if they spoke recently - lower response chance
    const lastSpeakers = meeting.lastSpeakers || [];
    if (lastSpeakers.includes(npc.id)) {
      return Math.random() > 0.7; // 30% chance
    }
    
    // Default: 60% chance to respond
    return Math.random() > 0.4;
  }
  
  /**
   * Populate the participant selection grid in create meeting modal
   */
  function populateParticipantGrid(searchTerm = '') {
    const grid = document.getElementById('participantGrid');
    if (!grid) return;
    
    const filteredEmployees = gameState.employees.filter(emp => {
      if (searchTerm) {
        return emp.name.toLowerCase().includes(searchTerm.toLowerCase());
      }
      return true;
    });
    
    if (filteredEmployees.length === 0) {
      grid.innerHTML = '<div style="grid-column:1/-1; text-align:center; color:#666; padding:20px;">No employees found</div>';
      return;
    }
    
    grid.innerHTML = filteredEmployees.map(emp => {
      return `
        <div class="participant-card" 
             data-employee-id="${emp.id}"
             style="background:#16213e; border-radius:8px; padding:12px; cursor:pointer; transition:all 0.2s; border:2px solid transparent; text-align:center;"
             onmouseenter="this.style.background='#1e2a47'"
             onmouseleave="if(!this.classList.contains('selected')) this.style.background='#16213e'">
          <img src="${emp.profileImage}" style="width:60px; height:60px; border-radius:50%; object-fit:cover; margin-bottom:8px;">
          <div style="font-size:0.9rem; font-weight:600;">${emp.name}</div>
          <div style="font-size:0.75rem; color:#aaa; margin-top:4px;">${gameState.hierarchyLevels[emp.hierarchyLevel || 1]?.title || 'Staff'}</div>
          <div class="selection-indicator" style="display:none; margin-top:8px; color:#4ecca3; font-weight:bold;">âœ“ Selected</div>
        </div>
      `;
    }).join('');
    
    // Add click handlers
    grid.querySelectorAll('.participant-card').forEach(card => {
      card.addEventListener('click', () => {
        const selectedCards = grid.querySelectorAll('.participant-card.selected');
        
        // Toggle selection
        if (card.classList.contains('selected')) {
          card.classList.remove('selected');
          card.style.border = '2px solid transparent';
          card.style.background = '#16213e';
          card.querySelector('.selection-indicator').style.display = 'none';
        } else {
          // Check if already at max
          if (selectedCards.length >= 5) {
            showNotification('âš ï¸ Maximum 5 participants allowed', 'error');
            return;
          }
          
          card.classList.add('selected');
          card.style.border = '2px solid #4ecca3';
          card.style.background = '#1e2a47';
          card.querySelector('.selection-indicator').style.display = 'block';
        }
        
        // Update count
        const selectedCount = $('selectedCount');
        const newCount = grid.querySelectorAll('.participant-card.selected').length;
        if (selectedCount) selectedCount.textContent = `${newCount}/5`;
      });
    });
  }
  
  // Open chat with employee
  function openChat(employee) {
    // If passed an ID string, look up the employee object
    if (typeof employee === 'string') {
      employee = gameState.employees.find(e => e.id === employee);
      if (!employee) {
        console.error('Employee not found');
        return;
      }
    }
    
    gameState.activeChat = employee;
    ensureEmployeeMemory(employee);
    
    // Clear unread messages when opening chat
    employee.unreadMessages = 0;
    
    // Check if this NPC is currently generating a response
    const chatTypingIndicator = $('chatTypingIndicator');
    const chatTypingName = $('chatTypingName');
    if (chatTypingIndicator && chatTypingName) {
      if (gameState.typingStates && gameState.typingStates[employee.id]) {
        // This NPC is generating - show typing indicator
        chatTypingIndicator.style.display = 'block';
        chatTypingName.textContent = employee.name;
      } else {
        // Not generating - hide typing indicator
        chatTypingIndicator.style.display = 'none';
      }
    }
    
    if (chatModal) {
      chatModal.hidden = false;
      chatModal.style.display = 'flex';
      chatModal.style.pointerEvents = 'auto';
      // Apply chat customization styles when opening
      if (typeof applyChatStyles === 'function') {
        applyChatStyles();
      }
    }
    if (chatName) chatName.textContent = employee.name;
    if (chatAvatar) chatAvatar.src = employee.profileImage || 'https://placehold.co/80x80';
    
    // Initialize chat history if not exists
    if (!gameState.chatHistory[employee.id]) {
      gameState.chatHistory[employee.id] = [];
    }
    
    // Load chat history
    loadChatHistory(employee.id);
    
    // Render NPC action buttons for this employee
    renderNpcActionButtons(employee);
    
    // Update People tab to remove unread badge
    if (gameState.activeTab === 'people') {
      updatePeopleTab();
    }
  }
  
  // -------- BIO MODAL --------
  // Open detailed bio modal with edit capabilities
  // Helper function to create stat control buttons
  function createStatControls(elementId, currentValue, min = 0, max = 100) {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    const container = element.parentElement;
    const originalHTML = container.innerHTML;
    
    container.innerHTML = `
      <div style="display:flex; flex-direction:column; gap:6px; align-items:center;">
        <div style="font-size:1.5rem; font-weight:bold; color:inherit;">
          <span id="${elementId}">${Math.round(currentValue)}</span>%
        </div>
        <div style="display:flex; gap:2px; flex-wrap:wrap; justify-content:center;">
          <button class="stat-btn" data-change="-10" style="padding:2px 6px; background:#e94560; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&lt;&lt;&lt;</button>
          <button class="stat-btn" data-change="-5" style="padding:2px 6px; background:#ff6b9d; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&lt;&lt;</button>
          <button class="stat-btn" data-change="-1" style="padding:2px 6px; background:#ffa7c4; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&lt;</button>
          <button class="stat-btn" data-change="1" style="padding:2px 6px; background:#4ecca3; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&gt;</button>
          <button class="stat-btn" data-change="5" style="padding:2px 6px; background:#00d4ff; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&gt;&gt;</button>
          <button class="stat-btn" data-change="10" style="padding:2px 6px; background:#0096c7; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&gt;&gt;&gt;</button>
        </div>
      </div>
    `;
    
    // Add event listeners to buttons
    container.querySelectorAll('.stat-btn').forEach(btn => {
      btn.onclick = (e) => {
        e.stopPropagation();
        const change = parseInt(btn.dataset.change);
        const statElement = document.getElementById(elementId);
        let newValue = parseInt(statElement.textContent) + change;
        newValue = Math.max(min, Math.min(max, newValue));
        statElement.textContent = newValue;
      };
    });
    
    return originalHTML;
  }
  
  // Helper function to create dropdown control
  function createDropdownControl(elementId, currentValue, options) {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    const container = element.parentElement;
    const originalHTML = container.innerHTML;
    
    const optionsHTML = options.map(opt => 
      `<option value="${opt.value}" ${opt.value === currentValue ? 'selected' : ''}>${opt.label}</option>`
    ).join('');
    
    container.innerHTML = `
      <select id="${elementId}" style="width:100%; padding:6px; background:#16213e; border:1px solid #ffd700; border-radius:4px; color:#ffd700; font-weight:600;">
        ${optionsHTML}
      </select>
    `;
    
    return originalHTML;
  }

  // === PHASE 7C: UNIFIED NPC PROFILE SYSTEM ===
  
  // Global state for profile editing (needed for inline handlers)
  window.profileEditState = {
    isEditMode: false,
    hasUnsavedChanges: false,
    editedData: null
  };
  
  function openUnifiedProfile(employeeId, initialTab = 'overview') {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    // Initialize missing data structures
    if (!employee.skills) {
      initializeEmployeeSocialData(employee);
    }
    
    // Edit mode state (local for logic, synced to global for inline handlers)
    let isEditMode = false;
    let hasUnsavedChanges = false;
    let editedData = JSON.parse(JSON.stringify(employee)); // Deep copy for editing
    
    // Sync to global state for inline handlers
    window.profileEditState.isEditMode = isEditMode;
    window.profileEditState.hasUnsavedChanges = hasUnsavedChanges;
    window.profileEditState.editedData = editedData;
    
    const modal = document.createElement('div');
    modal.id = 'unifiedProfileModal';
    modal.style.background = 'rgba(0,0,0,0.85)';
    
    // Helper to render tabs (Overview and Bio merged)
    const renderTabs = (active) => {
      const tabs = [
        { id: 'overview', label: 'ğŸ“Š Overview', emoji: 'ğŸ“Š' },
        { id: 'stats', label: 'ğŸ“ˆ Stats', emoji: 'ğŸ“ˆ' },
        { id: 'skills', label: 'â­ Skills', emoji: 'â­' },
        { id: 'possessions', label: 'ğŸ Possessions', emoji: 'ğŸ' },
        { id: 'flags', label: 'ğŸ·ï¸ Flags', emoji: 'ğŸ·ï¸' },
        { id: 'schedule', label: 'ğŸ“… Schedule', emoji: 'ğŸ“…' },
        { id: 'social', label: 'ğŸ“± Social', emoji: 'ğŸ“±' },
        { id: 'relationship', label: 'ğŸ’• Relationship', emoji: 'ğŸ’•' },
        { id: 'children', label: 'ğŸ‘¶ Children', emoji: 'ğŸ‘¶' },
        { id: 'appearance', label: 'ğŸ‘¤ Appearance', emoji: 'ğŸ‘¤' },
        { id: 'gallery', label: 'ğŸ“· Gallery', emoji: 'ğŸ“·' }
      ];
      
      return tabs.map(tab => `
        <button class="profile-tab ${active === tab.id ? 'active' : ''}" data-tab="${tab.id}" 
          style="background:${active === tab.id ? '#00d4ff' : '#16213e'}; 
                 color:${active === tab.id ? '#0f1419' : '#fff'}; 
                 border:none; padding:8px 12px; border-radius:8px 8px 0 0; 
                 cursor:pointer; font-weight:600; transition:all 0.2s; font-size:0.9rem;
                 border-bottom:${active === tab.id ? '3px solid #ffd700' : 'none'}; white-space:nowrap;">
          ${tab.emoji} ${tab.label.split(' ')[1]}
        </button>
      `).join('');
    };
    
    // Tab content renderers (Overview now includes Bio content)
    const renderOverview = () => {
      // IMPORTANT: Always get fresh employee data from gameState
      const freshEmployee = gameState.employees.find(e => e.id === employee.id);
      if (!freshEmployee) return '<p style="color:#e94560;">Employee not found</p>';
      
      const data = isEditMode ? editedData : freshEmployee;
      
      return `
        <div style="display:flex; gap:20px; margin-bottom:20px; flex-wrap:wrap;">
          <img src="${freshEmployee.profileImage || 'https://placehold.co/150x150'}" 
            style="width:120px; height:120px; border-radius:10px; object-fit:cover; flex-shrink:0;">
          <div style="flex:1; min-width:250px;">
            ${window.profileEditState.isEditMode ? `
              <input type="text" 
                value="${data.name || ''}" 
                onchange="window.profileEditState.editedData.name = this.value.trim(); markProfileChange();"
                style="margin:0 0 8px 0; font-size:1.5rem; font-weight:600; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px 12px; border-radius:6px; width:100%; font-family:inherit;"
                placeholder="Enter name..."
                maxlength="50">
            ` : `
              <h2 style="margin:0 0 8px 0;">${getColoredName(freshEmployee)}</h2>
            `}
            <p style="margin:0; color:#aaa;">${freshEmployee.age || 'N/A'} â€¢ ${freshEmployee.gender || 'Female'}</p>
            <p style="margin:4px 0 0 0; color:#00d4ff; font-weight:600;">${freshEmployee.position || 'Employee'}</p>
            ${freshEmployee.productManaged ? `<p style="margin:4px 0 0 0; color:#aaa;">Managing: ${freshEmployee.productManaged}</p>` : ''}
          </div>
        </div>
        
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Quick Stats</h4>
          <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(120px, 1fr)); gap:10px;">
            <div><span style="color:#aaa;">Affection:</span> <strong style="color:#e94560;">${Math.round(freshEmployee.stats?.affection || 0)}%</strong></div>
            <div><span style="color:#aaa;">Trust:</span> <strong style="color:#00d4ff;">${Math.round(freshEmployee.stats?.trust || 0)}%</strong></div>
            <div><span style="color:#aaa;">Productivity:</span> <strong style="color:#ffd700;">${Math.round(freshEmployee.stats?.productivity || 0)}%</strong></div>
          </div>
        </div>
        
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Biography</h4>
          ${window.profileEditState.isEditMode ? `
            <textarea onchange="window.profileEditState.editedData.bio = this.value; markProfileChange();"
              style="width:100%; min-height:150px; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:10px; border-radius:4px; resize:vertical; line-height:1.6; font-family:inherit;"
              placeholder="Enter biography...">${data.bio || ''}</textarea>
          ` : `
            <p style="margin:0; line-height:1.6;">${data.bio || '<em style="color:#aaa;">No biography set</em>'}</p>
          `}
        </div>
        
        ${freshEmployee.personalityTraits ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">Personality Traits</h4>
            <div style="display:flex; flex-wrap:wrap; gap:8px;">
              ${freshEmployee.personalityTraits.map(trait => `
                <span style="background:#16213e; padding:6px 12px; border-radius:6px; color:#00d4ff;">
                  ${trait}
                </span>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${freshEmployee.hobbies ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">Hobbies & Interests</h4>
            <div style="display:flex; flex-wrap:wrap; gap:8px;">
              ${freshEmployee.hobbies.map(hobby => `
                <span style="background:#16213e; padding:6px 12px; border-radius:6px; color:#4ecca3;">
                  ${hobby}
                </span>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${freshEmployee.personalLife?.livingSituation?.pets?.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">ğŸ¾ Pets</h4>
            <div style="display:flex; flex-wrap:wrap; gap:10px;">
              ${freshEmployee.personalLife.livingSituation.pets.map(pet => `
                <div style="background:#16213e; padding:10px 15px; border-radius:8px; border-left:3px solid #4ecca3;">
                  <strong style="color:#4ecca3;">${pet.name}</strong>
                  <span style="color:#aaa; margin-left:8px;">â€¢ ${pet.type}</span>
                  ${pet.giftedBy === 'boss' ? '<span style="color:#ffd700; margin-left:8px;">ğŸ</span>' : ''}
                </div>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${freshEmployee.personalLife?.livingSituation?.type ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">ğŸ  Living Situation</h4>
            <p style="margin:0; color:#00d4ff;">
              <strong>${freshEmployee.personalLife.livingSituation.type.charAt(0).toUpperCase() + freshEmployee.personalLife.livingSituation.type.slice(1)}</strong>
              ${freshEmployee.personalLife.livingSituation.hasRoommate ? ' (has roommate)' : ''}
            </p>
            ${freshEmployee.giftedPossessions?.homeUpgrades?.length > 0 ? `
              <div style="margin-top:8px; padding-top:8px; border-top:1px solid #16213e;">
                <small style="color:#aaa;">Gifted upgrades:</small>
                ${freshEmployee.giftedPossessions.homeUpgrades.map(upgrade => `
                  <div style="margin-top:4px; color:#ffd700;">ğŸ ${upgrade.item}</div>
                `).join('')}
              </div>
            ` : ''}
          </div>
        ` : ''}
        
        ${freshEmployee.giftedPossessions?.vehicles?.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">ğŸš— Vehicles</h4>
            ${freshEmployee.giftedPossessions.vehicles.map(vehicle => `
              <div style="background:#16213e; padding:10px; border-radius:6px; margin-bottom:8px; border-left:3px solid #e94560;">
                <strong style="color:#e94560;">${vehicle.item}</strong>
                <span style="color:#aaa; margin-left:8px;">â€¢ ${vehicle.type}</span>
                <span style="color:#ffd700; margin-left:8px;">ğŸ $${vehicle.price.toLocaleString()}</span>
              </div>
            `).join('')}
          </div>
        ` : ''}
      `;
    };
    
    const renderStats = () => {
      const stats = isEditMode ? (editedData.stats || {}) : (employee.stats || {});
      const statDefs = {
        affection: { label: 'Affection', color: '#e94560', icon: 'â¤ï¸', desc: 'How much they like you personally' },
        comfort: { label: 'Comfort', color: '#4ecca3', icon: 'ğŸ˜Š', desc: 'How relaxed they feel around you' },
        trust: { label: 'Trust', color: '#00d4ff', icon: 'ğŸ¤', desc: 'How much they believe in you' },
        desire: { label: 'Desire', color: '#ff6b9d', icon: 'ğŸ’•', desc: 'Romantic/sexual attraction level' },
        obedience: { label: 'Obedience', color: '#c77dff', icon: 'ğŸ”—', desc: 'Willingness to follow directions' },
        productivity: { label: 'Productivity', color: '#ffd700', icon: 'ğŸ’¼', desc: 'Work efficiency and output' }
      };
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Relationship Statistics</h3>
        <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(280px, 1fr)); gap:15px;">
          ${Object.entries(statDefs).map(([key, info]) => `
            <div style="background:#0f3460; padding:15px; border-radius:8px;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                <span style="color:#aaa;">${info.icon} ${info.label}</span>
                ${isEditMode ? `
                  <div style="display:flex; align-items:center; gap:5px;">
                    <button onclick="
                      const val = Math.max(0, (window.profileEditState.editedData.stats.${key} || 0) - 5);
                      window.profileEditState.editedData.stats.${key} = val;
                      this.nextElementSibling.value = val;
                      markProfileChange();
                    " style="background:#16213e; border:none; color:#fff; padding:4px 8px; border-radius:4px; cursor:pointer;">âˆ’</button>
                    <input type="number" value="${Math.round(stats[key] || 0)}" min="0" max="100" 
                      onchange="window.profileEditState.editedData.stats.${key} = Math.min(100, Math.max(0, parseFloat(this.value) || 0)); markProfileChange();"
                      style="width:60px; background:#16213e; border:1px solid ${info.color}; color:${info.color}; padding:4px 8px; border-radius:4px; text-align:center; font-size:1.1rem; font-weight:600;">
                    <button onclick="
                      const val = Math.min(100, (window.profileEditState.editedData.stats.${key} || 0) + 5);
                      window.profileEditState.editedData.stats.${key} = val;
                      this.previousElementSibling.value = val;
                      markProfileChange();
                    " style="background:#16213e; border:none; color:#fff; padding:4px 8px; border-radius:4px; cursor:pointer;">+</button>
                  </div>
                ` : `
                  <strong style="color:${info.color}; font-size:1.3rem;">${Math.round(stats[key] || 0)}%</strong>
                `}
              </div>
              <div style="background:#16213e; height:8px; border-radius:4px; overflow:hidden;">
                <div style="background:${info.color}; height:100%; width:${stats[key] || 0}%; transition:width 0.3s;"></div>
              </div>
              <p style="margin:8px 0 0 0; font-size:0.85rem; color:#aaa;">${info.desc}</p>
            </div>
          `).join('')}
        </div>
        
        <!-- Intimacy Level (calculated field) -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-top:15px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <span style="color:#aaa;">ğŸ”¥ Overall Intimacy Level</span>
            ${isEditMode ? `
              <div style="display:flex; align-items:center; gap:5px;">
                <button onclick="
                  if (!window.profileEditState.editedData.memory) window.profileEditState.editedData.memory = {};
                  const val = Math.max(0, (window.profileEditState.editedData.memory.intimacyLevel || 0) - 5);
                  window.profileEditState.editedData.memory.intimacyLevel = val;
                  this.nextElementSibling.value = val;
                  markProfileChange();
                " style="background:#16213e; border:none; color:#fff; padding:4px 8px; border-radius:4px; cursor:pointer;">âˆ’</button>
                <input type="number" value="${Math.round((employee.memory && employee.memory.intimacyLevel) || 0)}" min="0" max="100" 
                  onchange="
                    if (!window.profileEditState.editedData.memory) window.profileEditState.editedData.memory = {};
                    window.profileEditState.editedData.memory.intimacyLevel = Math.min(100, Math.max(0, parseFloat(this.value) || 0));
                    markProfileChange();
                  "
                  style="width:60px; background:#16213e; border:1px solid #ff6b9d; color:#ff6b9d; padding:4px 8px; border-radius:4px; text-align:center; font-size:1.1rem; font-weight:600;">
                <button onclick="
                  if (!window.profileEditState.editedData.memory) window.profileEditState.editedData.memory = {};
                  const val = Math.min(100, (window.profileEditState.editedData.memory.intimacyLevel || 0) + 5);
                  window.profileEditState.editedData.memory.intimacyLevel = val;
                  this.previousElementSibling.value = val;
                  markProfileChange();
                " style="background:#16213e; border:none; color:#fff; padding:4px 8px; border-radius:4px; cursor:pointer;">+</button>
              </div>
            ` : `
              <strong style="color:#ff6b9d; font-size:1.3rem;">${Math.round((employee.memory && employee.memory.intimacyLevel) || 0)}%</strong>
            `}
          </div>
          <div style="background:#16213e; height:8px; border-radius:4px; overflow:hidden;">
            <div style="background:#ff6b9d; height:100%; width:${((employee.memory && employee.memory.intimacyLevel) || 0)}%; transition:width 0.3s;"></div>
          </div>
          <p style="margin:8px 0 0 0; font-size:0.85rem; color:#aaa;">Combined measure of emotional and physical closeness (calculated from affection, comfort, desire)</p>
        </div>
      `;
    };
    
    const renderSkills = () => {
      const skills = isEditMode ? (editedData.skills || {}) : (employee.skills || {});
      const skillInfo = {
        technical: { icon: 'ğŸ’»', color: '#00d4ff', label: 'Technical' },
        creative: { icon: 'ğŸ¨', color: '#e94560', label: 'Creative' },
        social: { icon: 'ğŸ¤', color: '#4ecca3', label: 'Social' },
        management: { icon: 'ğŸ“Š', color: '#ffd700', label: 'Management' },
        intimate: { icon: 'ğŸ’‹', color: '#ff6b9d', label: 'Intimate' },
        cooking: { icon: 'ğŸ³', color: '#ff9f1c', label: 'Cooking' },
        fitness: { icon: 'ğŸ’ª', color: '#2ec4b6', label: 'Fitness' }
      };
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Skills & Progression</h3>
        <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(250px, 1fr)); gap:15px;">
          ${Object.entries(skillInfo).map(([key, info]) => {
            const skill = skills[key] || { level: 0, xp: 0, maxXp: 500 };
            const progress = skill.maxXp > 0 ? (skill.xp / skill.maxXp * 100) : 0;
            return `
              <div style="background:#0f3460; padding:15px; border-radius:8px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                  <span style="color:#aaa;">${info.icon} ${info.label}</span>
                  ${isEditMode ? `
                    <div style="display:flex; align-items:center; gap:5px;">
                      <button onclick="
                        if (!window.profileEditState.editedData.skills.${key}) window.profileEditState.editedData.skills.${key} = {level:0, xp:0, maxXp:500};
                        window.profileEditState.editedData.skills.${key}.level = Math.max(0, window.profileEditState.editedData.skills.${key}.level - 1);
                        this.nextElementSibling.textContent = 'Lv ' + window.profileEditState.editedData.skills.${key}.level;
                        markProfileChange();
                      " style="background:#16213e; border:none; color:#fff; padding:4px 8px; border-radius:4px; cursor:pointer;">âˆ’</button>
                      <span style="color:${info.color}; font-size:1.2rem; font-weight:600; min-width:50px; text-align:center;">Lv ${skill.level}</span>
                      <button onclick="
                        if (!window.profileEditState.editedData.skills.${key}) window.profileEditState.editedData.skills.${key} = {level:0, xp:0, maxXp:500};
                        window.profileEditState.editedData.skills.${key}.level = Math.min(10, window.profileEditState.editedData.skills.${key}.level + 1);
                        this.previousElementSibling.textContent = 'Lv ' + window.profileEditState.editedData.skills.${key}.level;
                        markProfileChange();
                      " style="background:#16213e; border:none; color:#fff; padding:4px 8px; border-radius:4px; cursor:pointer;">+</button>
                    </div>
                  ` : `
                    <strong style="color:${info.color}; font-size:1.2rem;">Lv ${skill.level}</strong>
                  `}
                </div>
                ${isEditMode ? `
                  <div style="margin-bottom:8px;">
                    <label style="font-size:0.8rem; color:#aaa; display:block; margin-bottom:4px;">XP:</label>
                    <input type="number" value="${skill.xp}" min="0" max="${skill.maxXp}"
                      onchange="
                        if (!window.profileEditState.editedData.skills.${key}) window.profileEditState.editedData.skills.${key} = {level:0, xp:0, maxXp:500};
                        window.profileEditState.editedData.skills.${key}.xp = Math.min(${skill.maxXp}, Math.max(0, parseFloat(this.value) || 0));
                        markProfileChange();
                      "
                      style="width:100%; background:#16213e; border:1px solid ${info.color}; color:#fff; padding:6px; border-radius:4px;">
                  </div>
                ` : `
                  <div style="background:#16213e; height:8px; border-radius:4px; overflow:hidden; margin-bottom:4px;">
                    <div style="background:${info.color}; height:100%; width:${progress}%; transition:width 0.3s;"></div>
                  </div>
                  <p style="margin:0; font-size:0.8rem; color:#aaa;">${skill.xp} / ${skill.maxXp} XP</p>
                `}
              </div>
            `;
          }).join('')}
        </div>
        
        ${employee.specializations && employee.specializations.length > 0 ? `
          <div style="margin-top:20px; background:#0f3460; padding:15px; border-radius:8px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">ğŸŒŸ Specializations</h4>
            <div style="display:flex; flex-wrap:wrap; gap:8px;">
              ${employee.specializations.map(spec => `
                <span style="background:#16213e; padding:6px 12px; border-radius:6px; border:1px solid #ffd700; color:#ffd700; font-size:0.9rem;">
                  ${spec}
                </span>
              `).join('')}
            </div>
          </div>
        ` : ''}
      `;
    };
    
    const renderFlags = () => {
      // IMPORTANT: Always get fresh employee data from gameState
      const freshEmployee = gameState.employees.find(e => e.id === employee.id);
      if (!freshEmployee) return '<p style="color:#e94560;">Employee not found</p>';
      
      const flags = getActiveFlags(freshEmployee);
      return `
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
          <h3 style="margin:0; color:#00d4ff;">Active Flags</h3>
          <button onclick="openFlagManagementModal(gameState.employees.find(function(emp) { return emp.id === '${freshEmployee.id}'; }))" 
            style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; padding:10px 20px; border-radius:8px; color:white; cursor:pointer; font-weight:600; font-size:0.95rem; box-shadow:0 2px 8px rgba(102,126,234,0.3); transition:all 0.2s;"
            onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(102,126,234,0.5)';"
            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(102,126,234,0.3)';">
            ğŸ·ï¸ Manage Flags
          </button>
        </div>
        ${flags.length > 0 ? `
          <div style="display:grid; gap:10px;">
            ${flags.map(flag => `
              <div style="background:#0f3460; padding:12px; border-radius:8px; border-left:4px solid ${getPriorityColor(flag.priority || 'medium')};">
                <div style="display:flex; justify-content:space-between; align-items:start;">
                  <div style="flex:1;">
                    <div style="font-weight:600; margin-bottom:4px;">
                      ${flag.emoji || 'ğŸ·ï¸'} ${flag.description || flag.playerDescription || flag.key || 'Unnamed Flag'}
                    </div>
                    <div style="font-size:0.85rem; color:#aaa;">
                      Priority: ${flag.priority || 'medium'} â€¢ 
                      ${flag.playerSet || flag.source === 'player' ? 'Player-set' : 'System'} â€¢ 
                      ${flag.timestamp ? new Date(flag.timestamp).toLocaleDateString() : 'Unknown date'}
                    </div>
                    ${flag.details || flag.aiGuidance ? `<p style="margin:8px 0 0 0; color:#ddd; font-size:0.9rem;">${flag.details || flag.aiGuidance || ''}</p>` : ''}
                  </div>
                  ${isEditMode ? `
                    <button onclick="removeFlag('${freshEmployee.id}', '${flag.id || flag.key}'); openUnifiedProfile('${freshEmployee.id}', 'flags');" 
                      style="background:#e94560; border:none; padding:6px 12px; border-radius:4px; color:white; cursor:pointer; font-size:0.9rem; margin-left:10px; flex-shrink:0;">
                      âœ• Remove
                    </button>
                  ` : ''}
                </div>
              </div>
            `).join('')}
          </div>
        ` : '<p style="color:#aaa; text-align:center; padding:40px 0;">No active flags. Click "Manage Flags" to add some!</p>'}
      `;
    };
    
    const renderPossessions = () => {
      // IMPORTANT: Always get fresh employee data from gameState
      const freshEmployee = gameState.employees.find(e => e.id === employee.id);
      if (!freshEmployee) return '<p style="color:#e94560;">Employee not found</p>';
      
      const poss = freshEmployee.giftedPossessions || {};
      const recentGifts = freshEmployee.giftPreferences?.recentGifts || [];
      
      const hasAny = (poss.wardrobe?.length || 0) + (poss.jewelry?.length || 0) + 
                     (poss.vehicles?.length || 0) + (poss.homeUpgrades?.length || 0) +
                     (poss.experiences?.length || 0) + (poss.tech?.length || 0) + 
                     (poss.other?.length || 0) + recentGifts.length > 0;
      
      if (!hasAny) {
        return `
          <div style="text-align:center; padding:60px 20px; color:#aaa;">
            <div style="font-size:4rem; margin-bottom:20px;">ğŸ</div>
            <h3 style="color:#00d4ff; margin-bottom:10px;">No Gifts Yet</h3>
            <p style="margin:0;">Gifts you give to ${freshEmployee.name} will appear here and affect their life!</p>
            <p style="margin-top:10px; color:#ffd700;">Try gifting clothing, vehicles, or even a pet!</p>
          </div>
        `;
      }
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">ğŸ Gifted Possessions</h3>
        
        ${recentGifts.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">ğŸ“œ All Gifts Received</h4>
            <p style="margin:0 0 10px 0; color:#aaa; font-size:0.85rem;">
              Total: ${recentGifts.length} gift${recentGifts.length !== 1 ? 's' : ''} â€¢ 
              Worth: $${recentGifts.reduce((sum, g) => sum + (g.price || 0), 0).toLocaleString()}
            </p>
            <div style="display:grid; gap:8px; max-height:400px; overflow-y:auto;">
              ${recentGifts.slice().reverse().map(gift => {
                const categoryInfo = GIFT_CATEGORIES[gift.category];
                const categoryEmoji = categoryInfo?.emoji || 'ğŸ';
                const categoryName = categoryInfo?.name || gift.category;
                const date = new Date(gift.timestamp).toLocaleDateString();
                
                // Color based on reaction
                const reactionColor = gift.reaction === 'delighted' ? '#4ecca3' :
                                     gift.reaction === 'grateful' ? '#00d4ff' :
                                     gift.reaction === 'confused' ? '#ffd700' :
                                     gift.reaction === 'underwhelmed' ? '#ff9f1c' :
                                     gift.reaction === 'suspicious' ? '#e94560' :
                                     gift.reaction === 'overwhelmed' ? '#c77dff' : '#aaa';
                
                const reactionText = gift.reaction ? gift.reaction.charAt(0).toUpperCase() + gift.reaction.slice(1) : 'Neutral';
                
                return `
                  <div style="background:#16213e; padding:10px; border-radius:6px; border-left:3px solid ${reactionColor};">
                    <div style="display:flex; justify-content:space-between; align-items:start; flex-wrap:wrap; gap:8px;">
                      <div style="flex:1; min-width:200px;">
                        <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
                          <span style="font-size:1.2rem;">${categoryEmoji}</span>
                          <strong style="color:#fff;">${gift.name}</strong>
                        </div>
                        <div style="font-size:0.8rem; color:#aaa;">
                          ${categoryName} â€¢ ${date} â€¢ 
                          <span style="color:${reactionColor};">${reactionText}</span>
                        </div>
                      </div>
                      <span style="color:#ffd700; font-weight:600; white-space:nowrap;">$${gift.price.toLocaleString()}</span>
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        ` : ''}
        
        ${(poss.wardrobe?.length || 0) + (poss.jewelry?.length || 0) + (poss.vehicles?.length || 0) + 
          (poss.homeUpgrades?.length || 0) + (poss.experiences?.length || 0) + (poss.tech?.length || 0) + 
          (poss.other?.length || 0) > 0 ? `
          <h4 style="margin:20px 0 15px 0; color:#00d4ff;">ğŸ“¦ Categorized Possessions</h4>
        ` : ''}
        
        ${poss.wardrobe?.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">ğŸ‘— Wardrobe</h4>
            <div style="display:grid; gap:10px;">
              ${poss.wardrobe.map(item => `
                <div style="background:#16213e; padding:12px; border-radius:6px; border-left:3px solid #ff6b9d;">
                  <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px;">
                    <div>
                      <strong style="color:#ff6b9d;">${item.item}</strong>
                      <span style="color:#aaa; margin-left:10px;">Wears ${(item.wearChance * 100).toFixed(0)}% of the time</span>
                    </div>
                    <span style="color:#ffd700;">$${item.price.toLocaleString()}</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${poss.jewelry?.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">ğŸ’ Jewelry</h4>
            <div style="display:grid; gap:10px;">
              ${poss.jewelry.map(item => `
                <div style="background:#16213e; padding:12px; border-radius:6px; border-left:3px solid #e94560;">
                  <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px;">
                    <div>
                      <strong style="color:#e94560;">${item.item}</strong>
                      <span style="color:#aaa; margin-left:10px;">â€¢ ${item.type}</span>
                      <span style="color:#aaa; margin-left:10px;">Wears ${(item.wearChance * 100).toFixed(0)}% of the time</span>
                    </div>
                    <span style="color:#ffd700;">$${item.price.toLocaleString()}</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${poss.vehicles?.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">ğŸš— Vehicles</h4>
            <div style="display:grid; gap:10px;">
              ${poss.vehicles.map(item => `
                <div style="background:#16213e; padding:12px; border-radius:6px; border-left:3px solid #00d4ff;">
                  <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px;">
                    <div>
                      <strong style="color:#00d4ff;">${item.item}</strong>
                      <span style="color:#aaa; margin-left:10px;">â€¢ ${item.type}</span>
                    </div>
                    <span style="color:#ffd700;">$${item.price.toLocaleString()}</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${poss.tech?.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">ğŸ“± Tech & Gadgets</h4>
            <div style="display:grid; gap:10px;">
              ${poss.tech.map(item => `
                <div style="background:#16213e; padding:12px; border-radius:6px; border-left:3px solid #4ecca3;">
                  <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px;">
                    <div>
                      <strong style="color:#4ecca3;">${item.item}</strong>
                      <span style="color:#aaa; margin-left:10px;">â€¢ ${item.type}</span>
                      ${item.inUse ? '<span style="color:#4ecca3; margin-left:10px;">âœ“ In use</span>' : ''}
                    </div>
                    <span style="color:#ffd700;">$${item.price.toLocaleString()}</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${poss.experiences?.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">âœˆï¸ Experiences & Memories</h4>
            <div style="display:grid; gap:10px;">
              ${poss.experiences.map(item => `
                <div style="background:#16213e; padding:12px; border-radius:6px; border-left:3px solid #c77dff;">
                  <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px;">
                    <div>
                      <strong style="color:#c77dff;">${item.item}</strong>
                      <span style="color:#aaa; margin-left:10px;">Memory strength: ${'â­'.repeat(Math.min(5, item.memoryStrength))}</span>
                    </div>
                    <span style="color:#ffd700;">$${item.price.toLocaleString()}</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${poss.other?.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">ğŸ Other Gifts</h4>
            <div style="display:grid; gap:10px;">
              ${poss.other.map(item => `
                <div style="background:#16213e; padding:12px; border-radius:6px;">
                  <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px;">
                    <div>
                      <strong style="color:#fff;">${item.item}</strong>
                      <span style="color:#aaa; margin-left:10px;">â€¢ ${item.category}</span>
                    </div>
                    <span style="color:#ffd700;">$${item.price.toLocaleString()}</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-top:20px; border:2px dashed #00d4ff;">
          <p style="margin:0; color:#aaa; text-align:center;">
            <strong style="color:#00d4ff;">Pro Tip:</strong> Gifts affect more than just stats! 
            Clothing items may appear in their descriptions, vehicles change their lifestyle, 
            and pets become part of their family!
          </p>
        </div>
      `;
    };
    
    const renderSchedule = () => {
      const schedule = isEditMode ? (editedData.schedule || {}) : (employee.schedule || {});
      const time = gameState.time || {};
      const currentHour = timeHelpers ? timeHelpers.getHour() : 12;
      const isWorkDay = timeHelpers ? !timeHelpers.isWeekend() : true;
      const isWorking = schedule.isCurrentlyWorking || false;
      
      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const workDays = schedule.workDays || [1,2,3,4,5];
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Work Schedule</h3>
        
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Current Status</h4>
          <div style="font-size:1.2rem; margin-bottom:8px;">
            ${isWorking ? 'âœ… <strong style="color:#4ecca3;">At Work</strong>' : 'ğŸ  <strong style="color:#aaa;">Off Duty</strong>'}
          </div>
          <p style="margin:0; color:#aaa; font-size:0.9rem;">
            Current time: ${timeHelpers ? timeHelpers.getFormattedTime() : '12:00 PM'} â€¢ 
            ${isWorkDay ? 'Weekday' : 'Weekend'}
          </p>
        </div>
        
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Work Hours</h4>
          ${isEditMode ? `
            <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
              <div style="flex:1;">
                <label style="font-size:0.85rem; color:#aaa; display:block; margin-bottom:4px;">Start Time:</label>
                <select onchange="window.profileEditState.editedData.schedule.workStartHour = parseInt(this.value); markProfileChange();"
                  style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px; border-radius:4px;">
                  ${Array.from({length:13}, (_, i) => i + 6).map(h => `
                    <option value="${h}" ${(schedule.workStartHour || 9) === h ? 'selected' : ''}>${h}:00</option>
                  `).join('')}
                </select>
              </div>
              <div style="flex:1;">
                <label style="font-size:0.85rem; color:#aaa; display:block; margin-bottom:4px;">End Time:</label>
                <select onchange="window.profileEditState.editedData.schedule.workEndHour = parseInt(this.value); markProfileChange();"
                  style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px; border-radius:4px;">
                  ${Array.from({length:11}, (_, i) => i + 14).map(h => `
                    <option value="${h}" ${(schedule.workEndHour || 17) === h ? 'selected' : ''}>${h}:00</option>
                  `).join('')}
                </select>
              </div>
            </div>
          ` : `
            <p style="margin:0; font-size:1.1rem;">
              ${schedule.workStartHour || 9}:00 - ${schedule.workEndHour || 17}:00
            </p>
          `}
          
          ${isEditMode ? `
            <div style="margin-top:15px;">
              <label style="font-size:0.85rem; color:#aaa; display:block; margin-bottom:8px;">Work Days:</label>
              <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:8px;">
                ${dayNames.map((day, idx) => `
                  <label style="display:flex; align-items:center; gap:6px; cursor:pointer; padding:6px; background:${workDays.includes(idx) ? '#16213e' : 'transparent'}; border-radius:4px; border:1px solid ${workDays.includes(idx) ? '#00d4ff' : '#666'};">
                    <input type="checkbox" 
                      ${workDays.includes(idx) ? 'checked' : ''}
                      onchange="
                        if (!editedData.schedule.workDays) editedData.schedule.workDays = [1,2,3,4,5];
                        if (this.checked) {
                          if (!editedData.schedule.workDays.includes(${idx})) editedData.schedule.workDays.push(${idx});
                        } else {
                          editedData.schedule.workDays = editedData.schedule.workDays.filter(d => d !== ${idx});
                        }
                        markProfileChange();
                        openUnifiedProfile('${employee.id}', 'schedule');
                      "
                      style="cursor:pointer;">
                    <span style="font-size:0.9rem; color:${workDays.includes(idx) ? '#00d4ff' : '#aaa'};">${day.substring(0,3)}</span>
                  </label>
                `).join('')}
              </div>
            </div>
          ` : `
            <p style="margin:8px 0 0 0; color:#aaa; font-size:0.9rem;">
              ${workDays.length} days per week
            </p>
          `}
        </div>
        
        ${schedule.hoursWorkedToday !== undefined ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">Today's Progress</h4>
            <div style="background:#16213e; height:12px; border-radius:6px; overflow:hidden; margin-bottom:8px;">
              <div style="background:#4ecca3; height:100%; width:${(schedule.hoursWorkedToday / 8 * 100)}%; transition:width 0.3s;"></div>
            </div>
            <p style="margin:0; color:#aaa;">${schedule.hoursWorkedToday || 0} / 8 hours worked</p>
          </div>
        ` : ''}
      `;
    };
    
    const renderSocial = () => {
      const social = employee.social || {};
      const posts = gameState.socialNetwork?.posts?.filter(p => p.authorId === employee.id).slice(0, 10) || [];
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Social Activity</h3>
        
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Profile Stats</h4>
          <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px; text-align:center;">
            <div>
              <div style="font-size:1.5rem; color:#00d4ff;">${social.postCount || 0}</div>
              <div style="font-size:0.8rem; color:#aaa;">Posts</div>
            </div>
            <div>
              <div style="font-size:1.5rem; color:#e94560;">${social.totalLikesReceived || 0}</div>
              <div style="font-size:0.8rem; color:#aaa;">Likes</div>
            </div>
            <div>
              <div style="font-size:1.5rem; color:#4ecca3;">${social.totalCommentsReceived || 0}</div>
              <div style="font-size:0.8rem; color:#aaa;">Comments</div>
            </div>
          </div>
        </div>
        
        <h4 style="margin:0 0 10px 0; color:#ffd700;">Recent Posts (${posts.length})</h4>
        ${posts.length > 0 ? posts.map(post => `
          <div onclick="openPostModal('${post.id}')" 
            style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:12px; cursor:pointer; transition:all 0.2s; border:2px solid transparent;"
            onmouseover="this.style.borderColor='#00d4ff'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,212,255,0.3)';"
            onmouseout="this.style.borderColor='transparent'; this.style.transform='translateY(0)'; this.style.boxShadow='none';">
            
            <!-- Post Content -->
            <p style="margin:0 0 ${post.imageUrl ? '12px' : '8px'} 0; line-height:1.6; color:#fff;">${post.content || ''}</p>
            
            <!-- Post Image (if exists) -->
            ${post.imageUrl ? `
              <div style="margin-bottom:12px; border-radius:8px; overflow:hidden; max-height:400px; display:flex; align-items:center; justify-content:center; background:#000;">
                <img src="${post.imageUrl}" 
                  style="width:100%; height:auto; max-height:400px; object-fit:contain; display:block;"
                  alt="Post image">
              </div>
            ` : ''}
            
            <!-- Post Metadata -->
            <div style="display:flex; justify-content:space-between; align-items:center; font-size:0.85rem; color:#8899a6;">
              <div>
                ${new Date(post.timestamp).toLocaleDateString()} ${new Date(post.timestamp).toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}
              </div>
              <div style="display:flex; gap:15px; align-items:center;">
                <span style="display:flex; align-items:center; gap:4px;">
                  â¤ï¸ <strong style="color:#e94560;">${post.likes?.length || 0}</strong>
                </span>
                <span style="display:flex; align-items:center; gap:4px;">
                  ğŸ’¬ <strong style="color:#4ecca3;">${post.comments?.length || 0}</strong>
                </span>
              </div>
            </div>
            
            <!-- Click hint -->
            <div style="margin-top:8px; text-align:center; font-size:0.75rem; color:#00d4ff; opacity:0.7;">
              Click to view, like, or comment
            </div>
          </div>
        `).join('') : '<p style="color:#aaa; text-align:center; padding:20px 0;">No posts yet</p>'}
        
        ${posts.length >= 10 ? `
          <div style="text-align:center; margin-top:15px;">
            <button onclick="switchTab('social')" 
              style="padding:10px 20px; background:#00d4ff; border:none; border-radius:8px; color:#0f1419; font-weight:600; cursor:pointer; font-size:0.9rem;">
              ğŸ“± View All Posts in Social Feed
            </button>
          </div>
        ` : ''}
      `;
    };
    
    const renderRelationship = () => {
      // Get relationships with other employees
      const relationships = gameState.employees
        .filter(e => e.id !== employee.id && e.relationships && e.relationships[employee.id])
        .map(e => {
          const rel = e.relationships[employee.id];
          return {
            name: e.name,
            type: rel.type || 'coworker',
            strength: Math.round(rel.strength || 0),
            color: getColoredName(e)
          };
        })
        .sort((a, b) => b.strength - a.strength)
        .slice(0, 10);
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Office Relationships</h3>
        
        ${relationships.length > 0 ? `
          <div style="display:grid; gap:10px;">
            ${relationships.map(rel => `
              <div style="background:#0f3460; padding:12px; border-radius:8px; display:flex; justify-content:space-between; align-items:center;">
                <div style="flex:0 0 auto;">
                  ${rel.color}
                  <div style="color:#888; font-size:0.8rem; margin-top:2px;">${rel.type}</div>
                </div>
                <div style="flex:1; margin:0 15px;">
                  <div style="background:#16213e; height:8px; border-radius:4px; overflow:hidden;">
                    <div style="background:${rel.strength >= 70 ? '#4ecca3' : rel.strength >= 40 ? '#00d4ff' : '#aaa'}; height:100%; width:${rel.strength}%; transition:width 0.3s;"></div>
                  </div>
                </div>
                <strong style="color:${rel.strength >= 70 ? '#4ecca3' : rel.strength >= 40 ? '#00d4ff' : '#aaa'};">${rel.strength}</strong>
              </div>
            `).join('')}
          </div>
        ` : '<p style="color:#aaa; text-align:center; padding:40px 0;">No relationships yet</p>'}
        
        <div style="margin-top:20px; background:#0f3460; padding:15px; border-radius:8px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Relationship Levels</h4>
          <div style="font-size:0.9rem; color:#aaa; line-height:1.8;">
            <div>0-20: ğŸ˜ Strangers</div>
            <div>20-40: ğŸ™‚ Acquaintances</div>
            <div>40-60: ğŸ˜Š Friends</div>
            <div>60-80: ğŸ¤— Close Friends</div>
            <div>80-100: ğŸ’– Best Friends</div>
          </div>
        </div>
      `;
    };
    
    const renderChildren = () => {
      // Defensive check: ensure children array exists
      if (!gameState.children) {
        gameState.children = [];
      }
      
      const children = getEmployeeChildren(employee.id);
      
      if (children.length === 0) {
        return `
          <h3 style="margin:0 0 15px 0; color:#00d4ff;">Children</h3>
          <p style="color:#aaa; text-align:center; padding:40px 0;">No children yet</p>
        `;
      }
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Children (${children.length})</h3>
        <div style="display:grid; gap:15px;">
          ${children.map(child => {
            const father = child.fatherID === 'player' 
              ? { name: gameState.player?.name || 'You', color: '#ffd700' }
              : gameState.employees.find(e => e.id === child.fatherID);
            const fatherName = father ? father.name : 'Unknown';
            const fatherColor = father?.color || '#aaa';
            
            const ageDays = child.age;
            const ageText = ageDays < 1 
              ? 'Newborn' 
              : ageDays < 30 
                ? `${ageDays} day${ageDays > 1 ? 's' : ''} old`
                : ageDays < 365
                  ? `${Math.floor(ageDays / 30)} month${Math.floor(ageDays / 30) > 1 ? 's' : ''} old`
                  : `${Math.floor(ageDays / 365)} year${Math.floor(ageDays / 365) > 1 ? 's' : ''} old`;
            
            return `
              <div style="background:#0f3460; padding:15px; border-radius:8px;">
                <div style="display:flex; gap:15px; align-items:center; margin-bottom:10px;">
                  <div style="font-size:3rem; flex-shrink:0;">${child.photo || (child.gender === 'boy' ? 'ğŸ‘¶' : 'ğŸ‘§')}</div>
                  <div style="flex:1;">
                    <h4 style="margin:0 0 4px 0; color:#ffd700;">${child.name}</h4>
                    <div style="color:#aaa; font-size:0.9rem;">${ageText}</div>
                    <div style="color:#aaa; font-size:0.9rem; margin-top:4px;">
                      ${child.gender === 'boy' ? 'â™‚ï¸' : 'â™€ï¸'} ${child.gender === 'boy' ? 'Boy' : 'Girl'}
                    </div>
                  </div>
                </div>
                
                <div style="background:#16213e; padding:12px; border-radius:6px; margin-bottom:10px;">
                  <div style="color:#888; font-size:0.85rem; margin-bottom:6px;">PARENTS</div>
                  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                    <span style="color:#aaa;">Mother:</span>
                    <span style="color:${getColoredName(employee).match(/color:([^;]+)/)?.[1] || '#fff'}; font-weight:600;">${employee.name}</span>
                  </div>
                  <div style="display:flex; justify-content:space-between; align-items:center;">
                    <span style="color:#aaa;">Father:</span>
                    <span style="color:${fatherColor}; font-weight:600;">${fatherName}</span>
                  </div>
                </div>
                
                <div style="background:#16213e; padding:12px; border-radius:6px;">
                  <div style="color:#888; font-size:0.85rem; margin-bottom:6px;">GENETICS</div>
                  <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; font-size:0.85rem;">
                    <div>
                      <span style="color:#aaa;">Hair:</span> 
                      <span style="color:#fff;">${child.genetics.hairColor || 'brown'}</span>
                    </div>
                    <div>
                      <span style="color:#aaa;">Eyes:</span> 
                      <span style="color:#fff;">${child.genetics.eyeColor || 'brown'}</span>
                    </div>
                    <div>
                      <span style="color:#aaa;">Skin:</span> 
                      <span style="color:#fff;">${child.genetics.skinTone || 'fair'}</span>
                    </div>
                    <div>
                      <span style="color:#aaa;">Height:</span> 
                      <span style="color:#fff;">${child.genetics.height || 'average'}</span>
                    </div>
                  </div>
                </div>
                
                ${child.traits && child.traits.length > 0 ? `
                  <div style="margin-top:10px;">
                    <div style="color:#888; font-size:0.85rem; margin-bottom:6px;">PERSONALITY TRAITS</div>
                    <div style="display:flex; flex-wrap:wrap; gap:6px;">
                      ${child.traits.map(trait => `
                        <span style="background:#16213e; color:#00d4ff; padding:4px 10px; border-radius:4px; font-size:0.8rem;">
                          ${trait}
                        </span>
                      `).join('')}
                    </div>
                  </div>
                ` : ''}
              </div>
            `;
          }).join('')}
        </div>
      `;
    };
    
    const renderAppearance = () => {
      const data = isEditMode ? window.profileEditState.editedData : employee;
      const physical = data.physical || {};
      const hair = physical.hair || {};
      const eyes = physical.eyes || {};
      const face = physical.face || {};
      const skin = physical.skin || {};
      const body = physical.body || {};
      const genitals = physical.genitals || {};
      
      // Helper to generate complete description from parts
      const generateCompleteDescription = () => {
        const p = window.profileEditState.editedData.physical;
        if (!p) return '';
        
        const parts = [];
        
        // Basic info
        if (p.heightBuild || (p.height && p.build)) {
          parts.push(`${p.heightBuild || (p.height + ', ' + p.build)}`);
        }
        
        // Hair
        if (p.hair && (p.hair.color || p.hair.style || p.hair.length)) {
          const hairParts = [];
          if (p.hair.length) hairParts.push(p.hair.length);
          if (p.hair.color) hairParts.push(p.hair.color);
          if (p.hair.style) hairParts.push(p.hair.style);
          if (p.hair.texture) hairParts.push(p.hair.texture);
          if (hairParts.length) parts.push(`Hair: ${hairParts.join(', ')}`);
        }
        
        // Eyes & Face
        if (p.eyes?.color) parts.push(`${p.eyes.color} eyes`);
        if (p.face) {
          const faceParts = [];
          if (p.face.shape) faceParts.push(`${p.face.shape} face`);
          if (p.face.lips) faceParts.push(`${p.face.lips} lips`);
          if (p.face.nose) faceParts.push(`${p.face.nose} nose`);
          if (p.face.cheekbones) faceParts.push(`${p.face.cheekbones} cheekbones`);
          if (p.face.jawline) faceParts.push(`${p.face.jawline} jawline`);
          if (faceParts.length) parts.push(faceParts.join(', '));
        }
        
        // Skin
        if (p.skin?.tone || p.skinTone) parts.push(`${p.skin?.tone || p.skinTone} skin`);
        if (p.skin?.texture) parts.push(`${p.skin.texture} texture`);
        
        // Body
        if (p.body?.shape || p.bodyShape) parts.push(`${p.body?.shape || p.bodyShape} body shape`);
        if (p.body) {
          if (p.body.chestSize || p.body.breastSize) {
            const size = p.body.chestSize || p.body.breastSize;
            const descriptor = p.body.chestDescriptor === 'chest' ? 'chest' : 'breasts';
            parts.push(`${size} ${descriptor}`);
          }
          if (p.body.buttSize) parts.push(`${p.body.buttSize} butt`);
          if (p.body.legs) parts.push(`${p.body.legs} legs`);
        }
        
        // Intimate
        if (p.genitals) {
          const genParts = [];
          if (p.genitals.type) genParts.push(p.genitals.type);
          if (p.genitals.size) genParts.push(`${p.genitals.size} size`);
          if (p.genitals.characteristics) genParts.push(p.genitals.characteristics);
          if (genParts.length) parts.push(`Intimate: ${genParts.join(', ')}`);
        }
        
        // Style
        if (p.fashion) parts.push(`Fashion: ${p.fashion}`);
        if (p.accessories) parts.push(`Accessories: ${p.accessories}`);
        if (p.distinguishingFeature) parts.push(`Distinguishing feature: ${p.distinguishingFeature}`);
        
        return parts.join('. ') + '.';
      };
      
      // Auto-update description function
      const updateDescriptionPreview = `
        const desc = (${generateCompleteDescription.toString()})();
        const preview = document.getElementById('appearanceDescPreview');
        if (preview) preview.textContent = desc;
        if (!window.profileEditState.editedData.physical) window.profileEditState.editedData.physical = {};
        window.profileEditState.editedData.physical.fullDescription = desc;
        markProfileChange();
      `;
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Physical Appearance ${isEditMode ? '<span style="color:#ffd700; font-size:0.8rem;">(Edit Mode)</span>' : ''}</h3>
        
        <div style="text-align:center; margin-bottom:20px;">
          <img src="${employee.profileImage || 'https://placehold.co/200x200'}" 
            style="width:200px; height:200px; border-radius:10px; object-fit:cover; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <div style="margin-top:10px;">
            <button onclick="openGalleryForProfileUpdate('${employee.id}')" 
              style="padding:8px 16px; background:#00d4ff; border:none; border-radius:6px; color:#0f1419; font-weight:600; cursor:pointer;">
              ğŸ“· Update Profile Picture
            </button>
          </div>
        </div>
        
        <!-- Basic Information -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Basic Info</h4>
          ${isEditMode ? `
            <div style="display:grid; gap:10px;">
              <div>
                <label style="color:#aaa; font-size:0.85rem; display:block; margin-bottom:4px;">Height & Build:</label>
                <input type="text" value="${physical.heightBuild || (physical.height && physical.build ? physical.height + ', ' + physical.build : '')}" 
                  onchange="if (!window.profileEditState.editedData.physical) window.profileEditState.editedData.physical = {}; window.profileEditState.editedData.physical.heightBuild = this.value; ${updateDescriptionPreview}"
                  style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px; border-radius:4px;"
                  placeholder="e.g., 5'7&quot;, athletic build">
              </div>
              <div>
                <label style="color:#aaa; font-size:0.85rem; display:block; margin-bottom:4px;">Gender:</label>
                <input type="text" value="${employee.gender || ''}" 
                  onchange="window.profileEditState.editedData.gender = this.value; ${updateDescriptionPreview}"
                  style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px; border-radius:4px;"
                  placeholder="e.g., Female, Male, Non-binary, Trans Woman, Trans Man">
              </div>
              <div>
                <label style="color:#aaa; font-size:0.85rem; display:block; margin-bottom:4px;">Age (18+):</label>
                <input type="number" min="18" max="99" value="${employee.age || 18}" 
                  onchange="const age = Math.max(18, Math.min(99, parseInt(this.value) || 18)); this.value = age; window.profileEditState.editedData.age = age; ${updateDescriptionPreview}"
                  style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px; border-radius:4px;"
                  placeholder="Minimum age 18">
              </div>
            </div>
          ` : `
            <div style="display:grid; gap:8px;">
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#aaa;">Height & Build:</span>
                <span style="color:#fff; font-weight:600;">${physical.heightBuild || (physical.height && physical.build ? physical.height + ', ' + physical.build : 'Not specified')}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#aaa;">Gender:</span>
                <span style="color:#fff; font-weight:600;">${employee.gender || 'Not specified'}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#aaa;">Age:</span>
                <span style="color:#fff; font-weight:600;">${employee.age || 'Not specified'}</span>
              </div>
            </div>
          `}
        </div>
        
        <!-- Hair Details -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Hair</h4>
          ${isEditMode ? `
            <div style="display:grid; gap:10px;">
              <div>
                <label style="color:#aaa; font-size:0.85rem; display:block; margin-bottom:4px;">Color:</label>
                <input type="text" value="${hair.color || ''}" 
                  onchange="if (!window.profileEditState.editedData.physical.hair) window.profileEditState.editedData.physical.hair = {}; window.profileEditState.editedData.physical.hair.color = this.value; ${updateDescriptionPreview}"
                  style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px; border-radius:4px;"
                  placeholder="e.g., dark brown, blonde">
              </div>
              <div>
                <label style="color:#aaa; font-size:0.85rem; display:block; margin-bottom:4px;">Style:</label>
                <input type="text" value="${hair.style || ''}" 
                  onchange="if (!window.profileEditState.editedData.physical.hair) window.profileEditState.editedData.physical.hair = {}; window.profileEditState.editedData.physical.hair.style = this.value; ${updateDescriptionPreview}"
                  style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px; border-radius:4px;"
                  placeholder="e.g., wavy, straight, curly">
              </div>
              <div>
                <label style="color:#aaa; font-size:0.85rem; display:block; margin-bottom:4px;">Length:</label>
                <input type="text" value="${hair.length || ''}" 
                  onchange="if (!window.profileEditState.editedData.physical.hair) window.profileEditState.editedData.physical.hair = {}; window.profileEditState.editedData.physical.hair.length = this.value; ${updateDescriptionPreview}"
                  style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px; border-radius:4px;"
                  placeholder="e.g., shoulder-length, long">
              </div>
              <div>
                <label style="color:#aaa; font-size:0.85rem; display:block; margin-bottom:4px;">Texture:</label>
                <input type="text" value="${hair.texture || ''}" 
                  onchange="if (!window.profileEditState.editedData.physical.hair) window.profileEditState.editedData.physical.hair = {}; window.profileEditState.editedData.physical.hair.texture = this.value; ${updateDescriptionPreview}"
                  style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:8px; border-radius:4px;"
                  placeholder="e.g., silky, thick">
              </div>
            </div>
          ` : `
            <div style="display:grid; gap:8px;">
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#aaa;">Color:</span>
                <span style="color:#fff; font-weight:600;">${hair.color || 'Not specified'}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#aaa;">Style:</span>
                <span style="color:#fff; font-weight:600;">${hair.style || 'Not specified'}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#aaa;">Length:</span>
                <span style="color:#fff; font-weight:600;">${hair.length || 'Not specified'}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#aaa;">Texture:</span>
                <span style="color:#fff; font-weight:600;">${hair.texture || 'Not specified'}</span>
              </div>
            </div>
          `}
        </div>
        
        <!-- Face & Eyes -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Face & Eyes</h4>
          ${isEditMode ? `
            <div style="display:grid; gap:10px; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));">
              <div><label style="color:#aaa; font-size:0.85rem;">Eye Color:</label><input type="text" value="${eyes.color || ''}" onchange="if (!window.profileEditState.editedData.physical.eyes) window.profileEditState.editedData.physical.eyes = {}; window.profileEditState.editedData.physical.eyes.color = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Eye Shape:</label><input type="text" value="${eyes.shape || ''}" onchange="if (!window.profileEditState.editedData.physical.eyes) window.profileEditState.editedData.physical.eyes = {}; window.profileEditState.editedData.physical.eyes.shape = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Face Shape:</label><input type="text" value="${face.shape || ''}" onchange="if (!window.profileEditState.editedData.physical.face) window.profileEditState.editedData.physical.face = {}; window.profileEditState.editedData.physical.face.shape = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Nose:</label><input type="text" value="${face.nose || ''}" onchange="if (!window.profileEditState.editedData.physical.face) window.profileEditState.editedData.physical.face = {}; window.profileEditState.editedData.physical.face.nose = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Lips:</label><input type="text" value="${face.lips || ''}" onchange="if (!window.profileEditState.editedData.physical.face) window.profileEditState.editedData.physical.face = {}; window.profileEditState.editedData.physical.face.lips = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Cheekbones:</label><input type="text" value="${face.cheekbones || ''}" onchange="if (!window.profileEditState.editedData.physical.face) window.profileEditState.editedData.physical.face = {}; window.profileEditState.editedData.physical.face.cheekbones = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Jawline:</label><input type="text" value="${face.jawline || ''}" onchange="if (!window.profileEditState.editedData.physical.face) window.profileEditState.editedData.physical.face = {}; window.profileEditState.editedData.physical.face.jawline = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
            </div>
          ` : `
            <div style="display:grid; gap:8px;">
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Eye Color:</span><span style="color:#fff; font-weight:600;">${eyes.color || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Eye Shape:</span><span style="color:#fff; font-weight:600;">${eyes.shape || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Face Shape:</span><span style="color:#fff; font-weight:600;">${face.shape || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Nose:</span><span style="color:#fff; font-weight:600;">${face.nose || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Lips:</span><span style="color:#fff; font-weight:600;">${face.lips || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Cheekbones:</span><span style="color:#fff; font-weight:600;">${face.cheekbones || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Jawline:</span><span style="color:#fff; font-weight:600;">${face.jawline || 'Not specified'}</span></div>
            </div>
          `}
        </div>
        
        <!-- Skin, Body, Intimate, Style all editable... -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Skin & Body</h4>
          ${isEditMode ? `
            <div style="display:grid; gap:10px; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));">
              <div><label style="color:#aaa; font-size:0.85rem;">Skin Tone:</label><input type="text" value="${skin.tone || physical.skinTone || ''}" onchange="if (!window.profileEditState.editedData.physical.skin) window.profileEditState.editedData.physical.skin = {}; window.profileEditState.editedData.physical.skin.tone = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Body Shape:</label><input type="text" value="${body.shape || physical.bodyShape || ''}" onchange="if (!window.profileEditState.editedData.physical.body) window.profileEditState.editedData.physical.body = {}; window.profileEditState.editedData.physical.body.shape = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Chest/Breast Size:</label><input type="text" value="${body.chestSize || body.breastSize || ''}" onchange="if (!window.profileEditState.editedData.physical.body) window.profileEditState.editedData.physical.body = {}; window.profileEditState.editedData.physical.body.chestSize = this.value; window.profileEditState.editedData.physical.body.breastSize = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Butt Size:</label><input type="text" value="${body.buttSize || ''}" onchange="if (!window.profileEditState.editedData.physical.body) window.profileEditState.editedData.physical.body = {}; window.profileEditState.editedData.physical.body.buttSize = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Legs:</label><input type="text" value="${body.legs || ''}" onchange="if (!window.profileEditState.editedData.physical.body) window.profileEditState.editedData.physical.body = {}; window.profileEditState.editedData.physical.body.legs = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Genitals Type:</label><input type="text" value="${genitals.type || ''}" onchange="if (!window.profileEditState.editedData.physical.genitals) window.profileEditState.editedData.physical.genitals = {}; window.profileEditState.editedData.physical.genitals.type = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Genitals Size:</label><input type="text" value="${genitals.size || ''}" onchange="if (!window.profileEditState.editedData.physical.genitals) window.profileEditState.editedData.physical.genitals = {}; window.profileEditState.editedData.physical.genitals.size = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Grooming:</label><input type="text" value="${genitals.characteristics || ''}" onchange="if (!window.profileEditState.editedData.physical.genitals) window.profileEditState.editedData.physical.genitals = {}; window.profileEditState.editedData.physical.genitals.characteristics = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div><label style="color:#aaa; font-size:0.85rem;">Fashion Style:</label><input type="text" value="${physical.fashion || ''}" onchange="if (!window.profileEditState.editedData.physical) window.profileEditState.editedData.physical = {}; window.profileEditState.editedData.physical.fashion = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
              <div style="grid-column: 1 / -1;"><label style="color:#aaa; font-size:0.85rem;">Distinguishing Feature:</label><input type="text" value="${physical.distinguishingFeature || ''}" onchange="if (!window.profileEditState.editedData.physical) window.profileEditState.editedData.physical = {}; window.profileEditState.editedData.physical.distinguishingFeature = this.value; ${updateDescriptionPreview}" style="width:100%; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:6px; border-radius:4px;"></div>
            </div>
          ` : `
            <div style="display:grid; gap:8px;">
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Skin Tone:</span><span style="color:#fff; font-weight:600;">${skin.tone || physical.skinTone || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Body Shape:</span><span style="color:#fff; font-weight:600;">${body.shape || physical.bodyShape || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Chest/Breast Size:</span><span style="color:#fff; font-weight:600;">${body.chestSize || body.breastSize || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Butt Size:</span><span style="color:#fff; font-weight:600;">${body.buttSize || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Legs:</span><span style="color:#fff; font-weight:600;">${body.legs || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Genitals:</span><span style="color:#fff; font-weight:600;">${genitals.type || 'Not specified'}, ${genitals.size || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Grooming:</span><span style="color:#fff; font-weight:600;">${genitals.characteristics || 'Not specified'}</span></div>
              <div style="display:flex; justify-content:space-between;"><span style="color:#aaa;">Fashion:</span><span style="color:#fff; font-weight:600;">${physical.fashion || 'Not specified'}</span></div>
              ${physical.distinguishingFeature ? `<div style="padding-top:8px; border-top:1px solid rgba(255,255,255,0.1);"><div style="color:#aaa; font-size:0.85rem;">Distinguishing Feature:</div><div style="color:#00d4ff; font-style:italic;">${physical.distinguishingFeature}</div></div>` : ''}
            </div>
          `}
        </div>
        
        <!-- Auto-Generated Complete Description -->
        <div style="background:#0f3460; padding:15px; border-radius:8px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Complete Description ${isEditMode ? '<span style="color:#4ecca3; font-size:0.75rem;">(Auto-Updates)</span>' : ''}</h4>
          <p id="appearanceDescPreview" style="margin:0; line-height:1.6; color:#ddd;">${physical.fullDescription || 'Edit fields above to generate description'}</p>
        </div>
      `;
    };
    
    const renderBio = () => {
      const data = isEditMode ? editedData : employee;
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Biography & Personality</h3>
        
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">About</h4>
          ${isEditMode ? `
            <textarea onchange="window.profileEditState.editedData.bio = this.value; markProfileChange();"
              style="width:100%; min-height:150px; background:#16213e; border:1px solid #00d4ff; color:#fff; padding:10px; border-radius:4px; resize:vertical; line-height:1.6; font-family:inherit;"
              placeholder="Enter biography...">${data.bio || ''}</textarea>
          ` : `
            <p style="margin:0; line-height:1.6;">${data.bio || '<em style="color:#aaa;">No biography set</em>'}</p>
          `}
        </div>
        
        ${employee.personalityTraits ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">Personality Traits</h4>
            <div style="display:flex; flex-wrap:wrap; gap:8px;">
              ${employee.personalityTraits.map(trait => `
                <span style="background:#16213e; padding:6px 12px; border-radius:6px; color:#00d4ff;">
                  ${trait}
                </span>
              `).join('')}
            </div>
          </div>
        ` : ''}
        
        ${employee.hobbies ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">Hobbies & Interests</h4>
            <div style="display:flex; flex-wrap:wrap; gap:8px;">
              ${employee.hobbies.map(hobby => `
                <span style="background:#16213e; padding:6px 12px; border-radius:6px; color:#4ecca3;">
                  ${hobby}
                </span>
              `).join('')}
            </div>
          </div>
        ` : ''}
      `;
    };
    
    const renderGallery = () => {
      // IMPORTANT: Always get fresh employee data from gameState
      const freshEmployee = gameState.employees.find(e => e.id === employee.id);
      if (!freshEmployee) return '<p style="color:#e94560;">Employee not found</p>';
      
      // Collect all photos from different sources
      const employeePhotos = freshEmployee.photos || [];
      
      // Get photos from social feed posts (using imageUrl, not image)
      const socialPhotos = [];
      if (gameState.socialNetwork && gameState.socialNetwork.posts) {
        gameState.socialNetwork.posts
          .filter(post => post.authorId === freshEmployee.id && post.imageUrl)
          .forEach(post => {
            if (!socialPhotos.find(p => p.url === post.imageUrl)) {
              socialPhotos.push({
                url: post.imageUrl,
                source: 'social',
                caption: post.caption || '',
                timestamp: post.timestamp,
                likes: post.likes || 0
              });
            }
          });
      }
      
      // Get photos from chat history (check gameState.chatHistory)
      const chatPhotos = [];
      const chatHistory = gameState.chatHistory[freshEmployee.id] || [];
      chatHistory
        .filter(msg => msg.imageUrl)
        .forEach(msg => {
          if (!chatPhotos.find(p => p.url === msg.imageUrl)) {
            chatPhotos.push({
              url: msg.imageUrl,
              source: 'chat',
              caption: msg.caption || msg.content || '',
              timestamp: msg.timestamp
            });
          }
        });
      
      // Also check if employee has a generatedImages array
      const generatedImages = freshEmployee.generatedImages || [];
      const employeeImages = generatedImages.map(img => ({
        url: typeof img === 'string' ? img : img.url,
        source: 'generated',
        caption: typeof img === 'object' ? img.caption : '',
        timestamp: typeof img === 'object' ? img.timestamp : Date.now()
      }));
      
      // Combine all photos (remove duplicates by URL)
      const allPhotoObjects = [...employeeImages, ...socialPhotos, ...chatPhotos];
      const uniquePhotos = [];
      const seenUrls = new Set();
      
      allPhotoObjects.forEach(photo => {
        if (!seenUrls.has(photo.url)) {
          seenUrls.add(photo.url);
          uniquePhotos.push(photo);
        }
      });
      
      // Sort by timestamp (newest first)
      uniquePhotos.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
      
      const currentProfile = freshEmployee.profileImage;
      
      return `
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">Photo Gallery</h3>
        
        <!-- Current Profile Picture -->
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:20px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">Current Profile Picture</h4>
          <div style="text-align:center;">
            <img src="${currentProfile || 'https://placehold.co/200x200'}" 
              style="width:200px; height:200px; border-radius:10px; object-fit:cover; box-shadow:0 4px 15px rgba(0,0,0,0.3); border:3px solid #ffd700;">
            <div style="margin-top:10px; color:#aaa; font-size:0.9rem;">
              Click any photo below to set as profile picture
            </div>
          </div>
        </div>
        
        <!-- Photo Collection -->
        <div style="background:#0f3460; padding:15px; border-radius:8px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">
            All Photos (${uniquePhotos.length})
            ${uniquePhotos.length > 0 ? `
              <span style="font-size:0.8rem; color:#aaa; margin-left:10px;">
                (${socialPhotos.length} from social, ${chatPhotos.length} from chat, ${employeeImages.length} generated)
              </span>
            ` : ''}
          </h4>
          
          ${uniquePhotos.length > 0 ? `
            <div style="display:grid; grid-template-columns:repeat(auto-fill,minmax(150px,1fr)); gap:12px;">
              ${uniquePhotos.map((photo, index) => {
                const sourceEmoji = photo.source === 'social' ? 'ğŸ“±' : photo.source === 'chat' ? 'ğŸ’¬' : 'ğŸ–¼ï¸';
                const sourceColor = photo.source === 'social' ? '#00d4ff' : photo.source === 'chat' ? '#ff6b9d' : '#4ecca3';
                return `
                <div style="position:relative; aspect-ratio:1; border-radius:8px; overflow:hidden; cursor:pointer; transition:transform 0.2s, box-shadow 0.2s; border:${photo.url === currentProfile ? '3px solid #ffd700' : '2px solid transparent'};"
                  onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 20px rgba(0,212,255,0.4)';"
                  onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                  onclick="setProfilePicture('${freshEmployee.id}', '${photo.url}')">
                  <img src="${photo.url}" 
                    style="width:100%; height:100%; object-fit:cover;">
                  ${photo.url === currentProfile ? `
                    <div style="position:absolute; top:5px; right:5px; background:rgba(255,215,0,0.9); color:#0f1419; padding:4px 8px; border-radius:4px; font-size:0.75rem; font-weight:700;">
                      âœ“ CURRENT
                    </div>
                  ` : `
                    <div style="position:absolute; inset:0; background:rgba(0,0,0,0.7); display:flex; align-items:center; justify-content:center; opacity:0; transition:opacity 0.2s;"
                      onmouseover="this.style.opacity='1';"
                      onmouseout="this.style.opacity='0';">
                      <span style="color:#fff; font-size:0.85rem; font-weight:600;">Set as Profile</span>
                    </div>
                  `}
                  <div style="position:absolute; top:5px; left:5px; background:${sourceColor}; color:#fff; padding:3px 6px; border-radius:4px; font-size:0.7rem; font-weight:600;">
                    ${sourceEmoji} ${photo.source}
                  </div>
                  <div style="position:absolute; bottom:0; left:0; right:0; background:linear-gradient(to top, rgba(0,0,0,0.9), transparent); padding:8px; color:#fff; font-size:0.75rem;">
                    ${photo.caption ? `<div style="margin-bottom:4px; font-weight:500; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${photo.caption}</div>` : ''}
                    ${photo.likes ? `<div style="color:#ffd700; font-size:0.7rem;">â¤ï¸ ${photo.likes}</div>` : ''}
                    ${photo.timestamp ? `<div style="color:#aaa; font-size:0.7rem;">${new Date(photo.timestamp).toLocaleDateString()}</div>` : ''}
                  </div>
                </div>
              `;
              }).join('')}
            </div>
          ` : `
            <div style="text-align:center; padding:40px 20px; color:#aaa;">
              <div style="font-size:3rem; margin-bottom:10px;">ğŸ“·</div>
              <p style="margin:0;">No photos yet</p>
              <p style="margin:5px 0 0 0; font-size:0.85rem;">Photos will appear here as they are generated through chats, social posts, and other interactions</p>
            </div>
          `}
        </div>
        
        <!-- Stats -->
        ${uniquePhotos.length > 0 ? `
          <div style="background:#0f3460; padding:15px; border-radius:8px; margin-top:15px;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">Gallery Stats</h4>
            <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px; text-align:center;">
              <div>
                <div style="font-size:1.5rem; color:#4ecca3;">${employeeImages.length}</div>
                <div style="font-size:0.8rem; color:#aaa;">Generated</div>
              </div>
              <div>
                <div style="font-size:1.5rem; color:#00d4ff;">${socialPhotos.length}</div>
                <div style="font-size:0.8rem; color:#aaa;">Social Posts</div>
              </div>
              <div>
                <div style="font-size:1.5rem; color:#ff6b9d;">${chatPhotos.length}</div>
                <div style="font-size:0.8rem; color:#aaa;">Chat Photos</div>
              </div>
            </div>
          </div>
        ` : ''}
      `;
    };
    
    // Render initial content
    const renderContent = (tab) => {
      switch(tab) {
        case 'overview': return renderOverview();
        case 'stats': return renderStats();
        case 'skills': return renderSkills();
        case 'possessions': return renderPossessions();
        case 'flags': return renderFlags();
        case 'schedule': return renderSchedule();
        case 'social': return renderSocial();
        case 'relationship': return renderRelationship();
        case 'children': return renderChildren();
        case 'appearance': return renderAppearance();
        case 'gallery': return renderGallery();
        case 'bio': return renderOverview(); // Bio merged into Overview
        default: return renderOverview();
      }
    };
    
    modal.innerHTML = `
      <div style="background:#0f1419; width:95%; max-width:1000px; max-height:90vh; border-radius:15px; box-shadow:0 5px 30px rgba(0,0,0,0.5); display:flex; flex-direction:column; overflow:hidden; margin:20px auto; position:relative;">
        <!-- Header -->
        <div style="padding:15px 20px; border-bottom:2px solid #00d4ff; display:flex; justify-content:space-between; align-items:center; background:#16213e; flex-shrink:0;">
          <h2 style="margin:0; color:#fff; font-size:1.3rem;">ğŸ‘¤ ${employee.name}'s Profile</h2>
          <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
            <button id="saveProfileBtn" style="background:#4ecca3; border:none; padding:8px 16px; border-radius:8px; color:#0f1419; font-weight:600; cursor:pointer; display:none; font-size:0.9rem;">
              ğŸ’¾ Save
            </button>
            <button id="toggleEditBtn" style="background:#00d4ff; border:none; padding:8px 16px; border-radius:8px; color:#0f1419; font-weight:600; cursor:pointer; font-size:0.9rem;">
              âœï¸ Edit
            </button>
            <button id="closeUnifiedProfile" style="background:transparent; border:none; color:white; font-size:1.8rem; cursor:pointer; padding:0 8px; line-height:1;">âœ•</button>
          </div>
        </div>
        
        <!-- Tabs (Sticky with shadow on scroll) -->
        <div id="tabsContainer" style="display:flex; gap:2px; padding:8px 10px 0 10px; background:#0f1419; overflow-x:auto; flex-shrink:0; position:sticky; top:0; z-index:10; border-bottom:1px solid transparent; transition:all 0.2s; scrollbar-width:thin;">
          ${renderTabs(initialTab)}
        </div>
        
        <!-- Content -->
        <div id="profileContent" style="flex:1; overflow-y:auto; padding:20px; background:#16213e; min-height:0; -webkit-overflow-scrolling:touch;">
          ${renderContent(initialTab)}
        </div>
      </div>
      
      <style>
        /* Mobile-friendly scrollbars */
        #profileContent::-webkit-scrollbar {
          width:8px;
        }
        #profileContent::-webkit-scrollbar-track {
          background:#16213e;
        }
        #profileContent::-webkit-scrollbar-thumb {
          background:#00d4ff;
          border-radius:4px;
        }
        #profileContent::-webkit-scrollbar-thumb:hover {
          background:#0099cc;
        }
        
        #tabsContainer::-webkit-scrollbar {
          height:6px;
        }
        #tabsContainer::-webkit-scrollbar-track {
          background:#0f1419;
        }
        #tabsContainer::-webkit-scrollbar-thumb {
          background:#00d4ff;
          border-radius:3px;
        }
        
        /* Mobile responsive adjustments - PORTRAIT OPTIMIZED */
        @media (max-width: 768px) {
          #unifiedProfileModal > div {
            width:100% !important;
            height:100vh !important;
            max-height:100vh !important;
            border-radius:0 !important;
            margin:0 !important;
          }
          
          #profileContent {
            padding:12px !important;
          }
          
          .profile-tab {
            font-size:0.8rem !important;
            padding:6px 8px !important;
          }
          
          /* Portrait-specific optimizations */
          #unifiedProfileModal h2 {
            font-size:1.1rem !important;
          }
          
          #unifiedProfileModal button {
            font-size:0.85rem !important;
            padding:6px 12px !important;
          }
        }
        
        /* PORTRAIT MODE: Max vertical space, minimal horizontal waste */
        @media (max-width: 768px) and (orientation: portrait) {
          /* Header more compact */
          #unifiedProfileModal > div > div:first-child {
            padding:10px 12px !important;
          }
          
          /* Tabs even more compact */
          #tabsContainer {
            padding:6px 8px 0 8px !important;
          }
          
          .profile-tab {
            font-size:0.75rem !important;
            padding:5px 7px !important;
          }
          
          /* Content takes maximum space */
          #profileContent {
            padding:10px !important;
          }
          
          /* Single column layouts for portrait */
          #profileContent > div > div[style*="grid-template-columns"] {
            grid-template-columns: 1fr !important;
          }
          
          /* Overview profile section - stack vertically */
          #profileContent > div > div[style*="display:flex"][style*="gap:20px"] {
            flex-direction: column !important;
            gap: 12px !important;
          }
          
          /* Profile image centered in portrait */
          #profileContent img[style*="width:120px"] {
            margin: 0 auto !important;
            display: block !important;
          }
          
          /* Text sections more compact */
          #profileContent h3 {
            font-size: 1.1rem !important;
            margin-bottom: 10px !important;
          }
          
          #profileContent h4 {
            font-size: 1rem !important;
          }
          
          /* Reduce gaps in portrait */
          #profileContent > div > div[style*="gap:15px"],
          #profileContent > div > div[style*="gap:20px"] {
            gap: 10px !important;
          }
        }
        
        /* LANDSCAPE MODE: Utilize horizontal space better */
        @media (max-width: 768px) and (orientation: landscape) {
          /* Keep 2 columns in landscape if space allows */
          #profileContent > div > div[style*="grid-template-columns"][style*="auto-fit"] {
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)) !important;
          }
          
          /* Tabs can be slightly larger */
          .profile-tab {
            font-size:0.85rem !important;
            padding:6px 10px !important;
          }
        }
        
        /* Sticky tab shadow effect */
        .tabs-scrolled {
          border-bottom:1px solid #00d4ff !important;
          box-shadow:0 2px 8px rgba(0,0,0,0.3) !important;
        }
      </style>
    `;
    
    ModalManager.show(modal, 'unifiedProfileModal');
    
    // Get UI elements
    const tabs = modal.querySelectorAll('.profile-tab');
    const content = modal.querySelector('#profileContent');
    const tabsContainer = modal.querySelector('#tabsContainer');
    const editBtn = modal.querySelector('#toggleEditBtn');
    const saveBtn = modal.querySelector('#saveProfileBtn');
    const closeBtn = modal.querySelector('#closeUnifiedProfile');
    
    let currentTab = initialTab;
    
    // Add scroll shadow effect to tabs
    content.addEventListener('scroll', () => {
      if (content.scrollTop > 10) {
        tabsContainer.classList.add('tabs-scrolled');
      } else {
        tabsContainer.classList.remove('tabs-scrolled');
      }
    });
    
    // Function to update content (respects edit mode)
    const updateContent = (tabId) => {
      currentTab = tabId;
      content.innerHTML = renderContent(tabId);
    };
    
    // Toggle edit mode
    editBtn.addEventListener('click', () => {
      isEditMode = !isEditMode;
      window.profileEditState.isEditMode = isEditMode;
      editBtn.textContent = isEditMode ? 'ğŸ‘ï¸ View' : 'âœï¸ Edit';
      editBtn.style.background = isEditMode ? '#e94560' : '#00d4ff';
      updateContent(currentTab);
    });
    
    // Save changes
    saveBtn.addEventListener('click', () => {
      // ========== NAME VALIDATION ==========
      if (window.profileEditState.editedData.name) {
        const newName = window.profileEditState.editedData.name.trim();
        const oldName = employee.name;
        
        // Validate name changes
        if (newName !== oldName) {
          // Check if name is empty
          if (!newName || newName.length === 0) {
            showNotification('âŒ Name cannot be empty!', 'error');
            return;
          }
          
          // Check if name is too short
          if (newName.length < 2) {
            showNotification('âŒ Name must be at least 2 characters!', 'error');
            return;
          }
          
          // Check for duplicate names (case-insensitive)
          const duplicateEmployee = gameState.employees.find(e => 
            e.id !== employee.id && 
            e.name.toLowerCase() === newName.toLowerCase()
          );
          
          if (duplicateEmployee) {
            showNotification(`âŒ Name "${newName}" is already taken by another employee!`, 'error');
            return;
          }
          
          // Check onboarding queue for duplicates
          if (gameState.onboardingQueue) {
            const duplicateOnboarding = gameState.onboardingQueue.find(c => 
              c.name.toLowerCase() === newName.toLowerCase()
            );
            if (duplicateOnboarding) {
              showNotification(`âŒ Name "${newName}" is already used in onboarding!`, 'error');
              return;
            }
          }
          
          // Update usedEmployeeNames Set
          if (gameState.usedEmployeeNames) {
            gameState.usedEmployeeNames.delete(oldName);
            gameState.usedEmployeeNames.add(newName);
          }
          
          console.log(`[Name Change] Renamed "${oldName}" â†’ "${newName}"`);
          showNotification(`âœ… Renamed employee: ${oldName} â†’ ${newName}`, 'success');
        }
      }
      
      // Apply edited data to actual employee
      Object.assign(employee, editedData);
      Object.assign(employee, window.profileEditState.editedData); // Also apply from global state
      hasUnsavedChanges = false;
      window.profileEditState.hasUnsavedChanges = false;
      saveBtn.style.display = 'none';
      showNotification('âœ… Profile updated successfully!', 'success');
      updateUI(); // Refresh any displays that show employee data
    });
    
    // Tab switching
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const tabId = tab.dataset.tab;
        tabs.forEach(t => {
          t.classList.remove('active');
          t.style.background = '#16213e';
          t.style.color = '#fff';
          t.style.borderBottom = 'none';
        });
        tab.classList.add('active');
        tab.style.background = '#00d4ff';
        tab.style.color = '#0f1419';
        tab.style.borderBottom = '3px solid #ffd700';
        updateContent(tabId);
      });
    });
    
    // Close button
    closeBtn.addEventListener('click', () => {
      if (hasUnsavedChanges) {
        if (!confirm('You have unsaved changes. Are you sure you want to close?')) {
          return;
        }
      }
      ModalManager.close('unifiedProfileModal');
    });
    
    // Promote button (from overview tab)
    const promoteBtn = modal.querySelector(`#profilePromoteBtn_${employeeId}`);
    if (promoteBtn && !promoteBtn.disabled) {
      promoteBtn.addEventListener('click', () => {
        ModalManager.close('unifiedProfileModal');
        setTimeout(() => {
          openCorporatePyramidModal(employeeId);
        }, 150);
      });
    }
    
    // Helper function to mark changes
    window.markProfileChange = () => {
      hasUnsavedChanges = true;
      window.profileEditState.hasUnsavedChanges = true;
      saveBtn.style.display = 'block';
    };
    
    // Helper function to refresh current tab content (callable from outside)
    window.refreshUnifiedProfileTab = (employeeId) => {
      // Only refresh if this is the currently open profile
      if (employee.id === employeeId && content) {
        updateContent(currentTab);
      }
    };
  }

  // Function to set profile picture from gallery
  function setProfilePicture(employeeId, photoUrl) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    employee.profileImage = photoUrl;
    showNotification(`ğŸ“· Profile picture updated for ${employee.name}!`);
    saveGame();
    
    // Refresh the current tab to show the change
    const modal = document.getElementById('unifiedProfileModal');
    if (modal) {
      const contentDiv = modal.querySelector('[id^="profileContent"]');
      if (contentDiv) {
        // Find current active tab
        const activeTab = modal.querySelector('.profile-tab.active');
        if (activeTab && activeTab.dataset.tab === 'gallery') {
          // Re-render the gallery tab
          openUnifiedProfile(employeeId, 'gallery');
        } else if (activeTab && activeTab.dataset.tab === 'appearance') {
          // Re-render the appearance tab
          openUnifiedProfile(employeeId, 'appearance');
        }
      }
    }
    
    // Also update the people tab if it's visible
    updatePeopleTab();
  }

  // Function to open the unified profile modal to the gallery tab for updating profile picture
  function openGalleryForProfileUpdate(employeeId) {
    openUnifiedProfile(employeeId, 'gallery');
  }

  function openBioModal(employee) {
    // Initialize photos array if not exists
    if (!employee.photos) employee.photos = [];
    
    const modal = document.createElement('div');
    modal.id = 'bioModal';
    // Don't set inline styles - ModalManager will handle it
    modal.style.background = 'rgba(0,0,0,0.8)';
    
    const isEditing = false; // Toggle state
    
    // Helper to safely get nested values
    const getNestedValue = (obj, path, defaultVal = '') => {
      const parts = path.split('.');
      let current = obj;
      for (const part of parts) {
        if (current && current[part] !== undefined) {
          current = current[part];
        } else {
          return defaultVal;
        }
      }
      return current;
    };
    
    modal.innerHTML = `
      <div class="bio-modal-content" style="background:#16213e; width:92%; max-width:900px; max-height:90vh; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); display:flex; flex-direction:column; overflow:hidden;">
        <!-- Header -->
        <div style="padding:20px; border-bottom:1px solid #0f3460; display:flex; justify-content:space-between; align-items:center;">
          <h2 style="margin:0; color:#fff;">Employee Profile</h2>
          <div style="display:flex; gap:10px; align-items:center;">
            <button id="bioEditToggle" style="background:#00d4ff; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; color:#0f1419; font-weight:600; display:flex; align-items:center; gap:6px;">
              <span style="font-size:1.1rem;">âœï¸</span> Edit
            </button>
            <button id="closeBioModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âœ•</button>
          </div>
        </div>
        
        <!-- Content -->
        <div style="flex:1; overflow-y:auto; padding:20px;">
          <!-- Profile Header -->
          <div style="display:flex; gap:20px; margin-bottom:25px; align-items:start;">
            <img src="${employee.profileImage || 'https://placehold.co/150x150'}" style="width:120px; height:120px; border-radius:10px; object-fit:cover; box-shadow:0 2px 10px rgba(0,0,0,0.3);">
            <div style="flex:1;">
              <h3 id="bioName" contenteditable="false" style="margin:0 0 8px 0; font-size:1.8rem; outline:none; padding:4px; border-radius:4px;" data-field="name">${getColoredName(employee)}</h3>
              <p style="margin:0 0 6px 0; color:#aaa;">
                <span id="bioAge" contenteditable="false" style="outline:none; padding:2px 4px; border-radius:4px;" data-field="age">${employee.age || 'N/A'}</span> years old â€¢ 
                <span id="bioGender" contenteditable="false" style="outline:none; padding:2px 4px; border-radius:4px; color:${getGenderColor(employee.gender)};" data-field="gender">${employee.gender || 'Female'}</span>
                <span id="bioRace" contenteditable="false" style="outline:none; padding:2px 4px; border-radius:4px;" data-field="race">${(() => {
                  const race = employee.race || 'human';
                  if (race === 'human') return '';
                  const raceInfo = {
                    elf: { emoji: 'ğŸ§', color: '#90ee90', name: 'Elf' },
                    orc: { emoji: 'ğŸ’ª', color: '#7ccd7c', name: 'Orc' },
                    demon: { emoji: 'ğŸ˜ˆ', color: '#b83b5e', name: 'Demon' },
                    foxkin: { emoji: 'ğŸ¦Š', color: '#ff6b35', name: 'Foxkin' },
                    wolfkin: { emoji: 'ğŸº', color: '#a8dadc', name: 'Wolfkin' },
                    catkin: { emoji: 'ğŸ˜º', color: '#ff9ff3', name: 'Catkin' },
                    rabbitkin: { emoji: 'ğŸ°', color: '#ffc2d1', name: 'Rabbitkin' }
                  };
                  const info = raceInfo[race.toLowerCase()] || { emoji: 'âœ¨', color: '#9d4edd', name: race };
                  return ` â€¢ <span style="color:${info.color};">${info.emoji} ${info.name}</span>`;
                })()}</span>
              </p>
              ${(() => {
                const race = employee.race || 'human';
                if (race === 'human' || !employee.physical?.raceFeatures) return '';
                const features = [];
                if (employee.physical.raceFeatures.ears) features.push(employee.physical.raceFeatures.ears);
                if (employee.physical.raceFeatures.tail) features.push(employee.physical.raceFeatures.tail);
                if (employee.physical.raceFeatures.horns) features.push(employee.physical.raceFeatures.horns);
                if (employee.physical.raceFeatures.fur) features.push(employee.physical.raceFeatures.fur);
                if (employee.physical.raceFeatures.wings) features.push(employee.physical.raceFeatures.wings);
                if (employee.physical.raceFeatures.skin) features.push(employee.physical.raceFeatures.skin);
                if (features.length === 0) return '';
                return `<p id="bioRaceFeatures" style="margin:4px 0 6px 0; color:#aaa; font-size:0.85rem;">âœ¨ ${features.join(', ')}</p>`;
              })()}
              <p style="margin:0; color:#00d4ff; font-weight:600;">
                <span id="bioPosition" contenteditable="false" style="outline:none; padding:2px 4px; border-radius:4px;" data-field="position">${employee.position || 'Employee'}</span>
              </p>
              ${employee.productManaged ? `<p style="margin:4px 0 0 0; color:#aaa;">Product: <span id="bioProduct" contenteditable="false" style="outline:none; padding:2px 4px; border-radius:4px;" data-field="productManaged">${employee.productManaged}</span></p>` : ''}
            </div>
          </div>
          
          <!-- Bio Section -->
          <div style="margin-bottom:25px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">Biography</h4>
            <p id="bioBio" contenteditable="false" style="margin:0; color:#ddd; line-height:1.6; padding:12px; background:#0f3460; border-radius:6px; outline:none; min-height:60px;" data-field="bio">${employee.bio || 'No biography available.'}</p>
          </div>
          
          <!-- Main Stats Section -->
          <div style="margin-bottom:25px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">Primary Statistics</h4>
            <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Affection
                  <span style="cursor:help; font-size:0.9rem;" title="How much they like you personally. Affects conversation warmth, willingness to chat, and proactive messages. Increases with compliments and positive interactions.">â„¹ï¸</span>
                </div>
                <div style="color:#e94560; font-weight:600; font-size:1.2rem;">
                  <span id="bioAffection" contenteditable="false" style="outline:none;" data-field="stats.affection">${Math.round(employee.stats?.affection ?? 0)}</span>%
                </div>
              </div>
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Comfort
                  <span style="cursor:help; font-size:0.9rem;" title="How relaxed they feel around you. Affects openness in conversations, photo sharing willingness, and memory formation. Low comfort reduces productivity. Build with consistent positive interactions.">â„¹ï¸</span>
                </div>
                <div style="color:#4ecca3; font-weight:600; font-size:1.2rem;">
                  <span id="bioComfort" contenteditable="false" style="outline:none;" data-field="stats.comfort">${Math.round(employee.stats?.comfort ?? 0)}</span>%
                </div>
              </div>
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Trust
                  <span style="cursor:help; font-size:0.9rem;" title="How much they believe in you. CRITICAL STAT: Directly boosts manager efficiency (up to +30% speed at 100 trust). Required for promotions. Build with consistent actions and keeping promises.">â„¹ï¸</span>
                </div>
                <div style="color:#00d4ff; font-weight:600; font-size:1.2rem;">
                  <span id="bioTrust" contenteditable="false" style="outline:none;" data-field="stats.trust">${Math.round(employee.stats?.trust ?? 0)}</span>%
                </div>
              </div>
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Desire
                  <span style="cursor:help; font-size:0.9rem;" title="Romantic/sexual attraction level. Affects conversation flavor and flirtiness. Unlocks intimate content at higher levels (60+ for suggestive, 75+ for intimate). Build with flirting and compliments.">â„¹ï¸</span>
                </div>
                <div style="color:#ff6b9d; font-weight:600; font-size:1.2rem;">
                  <span id="bioDesire" contenteditable="false" style="outline:none;" data-field="stats.desire">${Math.round(employee.stats?.desire ?? 0)}</span>%
                </div>
              </div>
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Obedience
                  <span style="cursor:help; font-size:0.9rem;" title="Willingness to follow directions. Increases request success rate (posts, photos, favors). Improves manager consistency (+8% at 100). Balance is key - too high/low can reduce productivity.">â„¹ï¸</span>
                </div>
                <div style="color:#c77dff; font-weight:600; font-size:1.2rem;">
                  <span id="bioObedience" contenteditable="false" style="outline:none;" data-field="stats.obedience">${Math.round(employee.stats?.obedience ?? 0)}</span>%
                </div>
              </div>
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Productivity
                  <span style="cursor:help; font-size:0.9rem;" title="Work efficiency. CRITICAL STAT: Directly boosts manager speed (+15% at 100) AND income (+20% at 100). Affected by comfort and trust. Essential for maximizing earnings.">â„¹ï¸</span>
                </div>
                <div style="color:#ffd700; font-weight:600; font-size:1.2rem;">
                  <span id="bioProductivity" contenteditable="false" style="outline:none;" data-field="stats.productivity">${Math.round(employee.stats?.productivity ?? 0)}</span>%
                </div>
              </div>
            </div>
          </div>
          
          <!-- Hidden Stats Section (only visible in edit mode) -->
          <div id="hiddenStatsSection" style="margin-bottom:25px; display:none;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">ğŸ”“ Advanced Stats (Sandbox Mode)</h4>
            
            <!-- Personality Attributes (AI uses these!) -->
            <div style="margin-bottom:15px;">
              <div style="font-size:.9rem; color:#ffd700; margin-bottom:8px; font-weight:600;">Personality Attributes (0-100)</div>
              <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Confidence</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioConfidence" contenteditable="false" style="outline:none;" data-field="personality.confidence">${Math.round(employee.personality?.confidence ?? 50)}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Outgoing</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioOutgoing" contenteditable="false" style="outline:none;" data-field="personality.outgoing">${Math.round(employee.personality?.outgoing ?? 50)}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Flirty</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioFlirty" contenteditable="false" style="outline:none;" data-field="personality.flirty">${Math.round(employee.personality?.flirty ?? 50)}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Professional</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioProfessional" contenteditable="false" style="outline:none;" data-field="personality.professional">${Math.round(employee.personality?.professional ?? 50)}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Humor</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioHumor" contenteditable="false" style="outline:none;" data-field="personality.humor">${Math.round(employee.personality?.humor ?? 50)}</span>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- System Stats -->
            <div style="margin-bottom:15px;">
              <div style="font-size:.9rem; color:#ffd700; margin-bottom:8px; font-weight:600;">System Stats</div>
              <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Intimacy Level</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioIntimacy" contenteditable="false" style="outline:none;" data-field="intimacy">${Math.round(employee.memory?.intimacyLevel ?? 0)}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Memory Cap <span style="cursor:help;" title="Max memories this NPC can store. Increasing this allows them to remember more context in conversations.">â„¹ï¸</span></div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioMemoryCap" contenteditable="false" style="outline:none;" data-field="memory.cap">${employee.memory?.cap ?? 300}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Conversation Phase</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioConversationPhase" contenteditable="false" style="outline:none;" data-field="memory.conversationPhase">${employee.memory?.conversationPhase ?? 'early'}</span>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Career Stats -->
            <div>
              <div style="font-size:.9rem; color:#ffd700; margin-bottom:8px; font-weight:600;">Career Stats</div>
              <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Loyalty Bonus</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioLoyaltyBonus" contenteditable="false" style="outline:none;" data-field="loyaltyBonus">${((employee.loyaltyBonus ?? 0) * 100).toFixed(0)}</span>%
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Times Rehired</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioTimesRehired" contenteditable="false" style="outline:none;" data-field="timesRehired">${employee.timesRehired ?? 0}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Employment Status</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioEmploymentStatus" contenteditable="false" style="outline:none;" data-field="employmentStatus">${employee.employmentStatus ?? 'active'}</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Personality & Traits -->
          <div style="margin-bottom:25px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">Personality & Interests</h4>
            <div style="background:#0f3460; padding:15px; border-radius:6px;">
              <div style="margin-bottom:12px;">
                <div style="font-size:.85rem; color:#aaa; margin-bottom:6px;">Personality Traits</div>
                <div id="bioPersonality" contenteditable="false" style="outline:none; padding:4px; border-radius:4px;" data-field="personalityTraits">${(() => {
                  if (Array.isArray(employee.personalityTraits)) {
                    return employee.personalityTraits.join(', ');
                  } else if (employee.personality && typeof employee.personality === 'object') {
                    return Object.entries(employee.personality).map(([key, val]) => `${key}: ${val}`).join(', ');
                  } else if (Array.isArray(employee.personality)) {
                    return employee.personality.join(', ');
                  }
                  return 'None listed';
                })()}</div>
              </div>
              <div style="margin-bottom:12px;">
                <div style="font-size:.85rem; color:#aaa; margin-bottom:6px;">Hobbies</div>
                <div id="bioHobbies" contenteditable="false" style="outline:none; padding:4px; border-radius:4px;" data-field="hobbies">${Array.isArray(employee.hobbies) ? employee.hobbies.join(', ') : 'None listed'}</div>
              </div>
              <div style="margin-bottom:12px;">
                <div style="font-size:.85rem; color:#aaa; margin-bottom:6px;">Preferences</div>
                <div id="bioKinks" contenteditable="false" style="outline:none; padding:4px; border-radius:4px;" data-field="kinks">${Array.isArray(employee.kinks) ? employee.kinks.join(', ') : 'None listed'}</div>
              </div>
              <div>
                <div style="font-size:.85rem; color:#aaa; margin-bottom:6px;">Key Trait</div>
                <div id="bioKeyTrait" contenteditable="false" style="outline:none; padding:4px; border-radius:4px;" data-field="keyTrait">${employee.keyTrait || employee.traits?.[0] || 'None listed'}</div>
              </div>
            </div>
          </div>
          
          <!-- Physical Appearance -->
          <div style="margin-bottom:25px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">Physical Appearance</h4>
            <div style="background:#0f3460; padding:15px; border-radius:6px;">
              ${employee.physical?.fullDescription ? `
              <div style="margin-bottom:15px; padding:12px; background:rgba(0,212,255,0.1); border-left:3px solid #00d4ff; border-radius:4px;">
                <div style="font-size:.85rem; color:#00d4ff; margin-bottom:6px; font-weight:600;">âœ¨ Full Description</div>
                <div id="bioPhysicalFull" contenteditable="false" style="color:#ddd; line-height:1.6; font-size:.95rem; outline:none;" data-field="physical.fullDescription">${employee.physical.fullDescription}</div>
              </div>
              ` : ''}
              
              <!-- Detailed Breakdown -->
              <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:12px;">
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Height & Build</div>
                  <div id="bioHeightBuild" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.heightBuild">${getNestedValue(employee, 'physical.heightBuild', 'Average')}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Body Shape</div>
                  <div id="bioBodyShape" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.body.shape">${getNestedValue(employee, 'physical.body.shape', getNestedValue(employee, 'physical.bodyShape', 'Average'))}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Hair</div>
                  <div id="bioHair" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.hair.full">${getNestedValue(employee, 'physical.hair.full', 'Not specified')}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Eyes</div>
                  <div id="bioEyes" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.eyes.full">${getNestedValue(employee, 'physical.eyes.full', 'Not specified')}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Face</div>
                  <div id="bioFace" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.face.full">${getNestedValue(employee, 'physical.face.full', getNestedValue(employee, 'physical.face.shape', 'Not specified'))}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Skin</div>
                  <div id="bioSkin" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.skin.full">${getNestedValue(employee, 'physical.skin.full', getNestedValue(employee, 'physical.skin.tone', getNestedValue(employee, 'physical.skinTone', 'Not specified')))}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Fashion Style</div>
                  <div id="bioFashion" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.fashion">${getNestedValue(employee, 'physical.fashion', 'Casual')}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Distinguishing Feature</div>
                  <div id="bioDistinguishing" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.distinguishingFeature">${getNestedValue(employee, 'physical.distinguishingFeature', 'None noted')}</div>
                </div>
              </div>
              
              <!-- Genital Information (for image generation) -->
              <div style="margin-top:15px; padding-top:15px; border-top:1px solid rgba(255,215,0,0.2);">
                <div style="font-size:.9rem; color:#ffd700; margin-bottom:8px; font-weight:600;">ğŸ” Genital Information</div>
                <div style="font-size:.75rem; color:#aaa; margin-bottom:10px; font-style:italic;">Used for accurate image generation</div>
                <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:12px;">
                  <div>
                    <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Type</div>
                    <div id="bioGenitalType" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.genitals.type">${getNestedValue(employee, 'physical.genitals.type', 'Not specified')}</div>
                  </div>
                  <div>
                    <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Size</div>
                    <div id="bioGenitalSize" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.genitals.size">${getNestedValue(employee, 'physical.genitals.size', 'Not specified')}</div>
                  </div>
                  <div>
                    <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Characteristics</div>
                    <div id="bioGenitalCharacteristics" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.genitals.characteristics">${getNestedValue(employee, 'physical.genitals.characteristics', 'Not specified')}</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Gift Preferences -->
          <div style="margin-bottom:25px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">ğŸ Gift Preferences</h4>
            <div style="background:#0f3460; padding:15px; border-radius:6px;">
              <div style="margin-bottom:15px;">
                <div style="font-size:.85rem; color:#4ecca3; margin-bottom:8px; font-weight:600; display:flex; align-items:center; gap:6px;">
                  ğŸ’• Loves
                  <span style="color:#aaa; font-weight:normal; font-size:0.8rem;">(2-3x stat bonus!)</span>
                </div>
                <div style="display:flex; flex-wrap:wrap; gap:8px;">
                  ${(() => {
                    const prefs = employee.giftPreferences || { loves: [] };
                    if (!prefs.loves || prefs.loves.length === 0) return '<span style="color:#aaa;">None</span>';
                    return prefs.loves.map(cat => {
                      const category = GIFT_CATEGORIES[cat];
                      if (!category) return '';
                      return `<span style="background:rgba(78,204,163,0.2); border:1px solid #4ecca3; padding:6px 12px; border-radius:20px; color:#4ecca3; font-size:0.9rem;">${category.emoji} ${category.name}</span>`;
                    }).join('');
                  })()}
                </div>
              </div>
              <div style="margin-bottom:15px;">
                <div style="font-size:.85rem; color:#aaa; margin-bottom:8px; font-weight:600;">
                  ğŸ‘ Neutral
                  <span style="font-weight:normal; font-size:0.8rem;">(Normal stats)</span>
                </div>
                <div style="display:flex; flex-wrap:wrap; gap:8px;">
                  ${(() => {
                    const prefs = employee.giftPreferences || { neutral: [] };
                    if (!prefs.neutral || prefs.neutral.length === 0) return '<span style="color:#aaa;">None</span>';
                    return prefs.neutral.map(cat => {
                      const category = GIFT_CATEGORIES[cat];
                      if (!category) return '';
                      return `<span style="background:rgba(170,170,170,0.1); border:1px solid #aaa; padding:6px 12px; border-radius:20px; color:#aaa; font-size:0.9rem;">${category.emoji} ${category.name}</span>`;
                    }).join('');
                  })()}
                </div>
              </div>
              <div>
                <div style="font-size:.85rem; color:#e94560; margin-bottom:8px; font-weight:600; display:flex; align-items:center; gap:6px;">
                  ğŸ’” Hates
                  <span style="color:#aaa; font-weight:normal; font-size:0.8rem;">(Negative stats!)</span>
                </div>
                <div style="display:flex; flex-wrap:wrap; gap:8px;">
                  ${(() => {
                    const prefs = employee.giftPreferences || { hates: [] };
                    if (!prefs.hates || prefs.hates.length === 0) return '<span style="color:#aaa;">None</span>';
                    return prefs.hates.map(cat => {
                      const category = GIFT_CATEGORIES[cat];
                      if (!category) return '';
                      return `<span style="background:rgba(233,69,96,0.2); border:1px solid #e94560; padding:6px 12px; border-radius:20px; color:#e94560; font-size:0.9rem;">${category.emoji} ${category.name}</span>`;
                    }).join('');
                  })()}
                </div>
              </div>
              
              <!-- Gift History -->
              <div style="margin-top:15px; padding-top:15px; border-top:1px solid rgba(255,255,255,0.1);">
                <div style="font-size:.85rem; color:#aaa; margin-bottom:8px; font-weight:600;">ğŸ“Š Gift History</div>
                <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
                  <div>
                    <div style="font-size:.75rem; color:#aaa; margin-bottom:2px;">Total Gifts</div>
                    <div style="color:#4ecca3; font-weight:600;">${(employee.giftPreferences?.totalCount || 0)}</div>
                  </div>
                  <div>
                    <div style="font-size:.75rem; color:#aaa; margin-bottom:2px;">Total Value</div>
                    <div style="color:#4ecca3; font-weight:600;">$${formatCash(employee.giftPreferences?.totalValue || 0)}</div>
                  </div>
                  <div>
                    <div style="font-size:.75rem; color:#aaa; margin-bottom:2px;">Recent Gifts</div>
                    <div style="color:#4ecca3; font-weight:600;">${(() => {
                      const recentGifts = employee.giftPreferences?.recentGifts || [];
                      const last7Days = recentGifts.filter(g => {
                        const daysSince = (Date.now() - g.timestamp) / (1000 * 60 * 60 * 24);
                        return daysSince <= 7;
                      }).length;
                      return last7Days;
                    })()}</div>
                  </div>
                </div>
                
                <!-- Favorite Gifts -->
                ${(() => {
                  const favGifts = employee.giftPreferences?.favoriteGifts || [];
                  if (favGifts.length === 0) return '';
                  return `
                    <div style="margin-top:10px;">
                      <div style="font-size:.75rem; color:#aaa; margin-bottom:6px;">ğŸ’ Favorite Gifts:</div>
                      <div style="display:flex; flex-wrap:wrap; gap:6px;">
                        ${favGifts.slice(0, 5).map(gift => `
                          <span style="background:rgba(255,107,157,0.1); border:1px solid #ff6b9d; padding:4px 10px; border-radius:15px; color:#ff6b9d; font-size:0.85rem;">${gift.name}</span>
                        `).join('')}
                      </div>
                    </div>
                  `;
                })()}
              </div>
            </div>
          </div>
          
          <!-- Photo Gallery -->
          <div style="margin-bottom:20px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">Photo Gallery</h4>
            <div id="bioPhotoGallery" style="display:grid; grid-template-columns:repeat(auto-fill,minmax(150px,1fr)); gap:10px; background:#0f3460; padding:15px; border-radius:6px; min-height:100px;">
              ${employee.photos && employee.photos.length > 0 
                ? employee.photos.map(photo => `<img src="${photo}" style="width:100%; aspect-ratio:1; object-fit:cover; border-radius:6px; cursor:pointer;" onclick="window.open('${photo}', '_blank')">`).join('')
                : '<p style="color:#aaa; margin:0;">No photos yet. Photos will appear here as they are generated.</p>'}
            </div>
          </div>
        </div>
        
        <!-- Footer -->
        <div style="padding:15px; border-top:1px solid #0f3460; display:flex; justify-content:flex-end; gap:10px;">
          <button id="bioSaveBtn" style="display:none; padding:10px 20px; background:#4ecca3; border:none; border-radius:6px; color:#0f1419; font-weight:600; cursor:pointer;">ğŸ’¾ Save Changes</button>
          <button id="bioCancelBtn" style="display:none; padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:#fff; font-weight:600; cursor:pointer;">âœ–ï¸ Cancel</button>
        </div>
      </div>
    `;
    
    // Use ModalManager to show the modal with proper z-index management
    ModalManager.show(modal, 'bioModal');
    
    // Edit toggle functionality
    let editMode = false;
    let originalHTMLs = new Map(); // Store original HTML for restoration
    const editToggle = modal.querySelector('#bioEditToggle');
    const saveBtn = modal.querySelector('#bioSaveBtn');
    const cancelBtn = modal.querySelector('#bioCancelBtn');
    const editableElements = modal.querySelectorAll('[contenteditable]');
    const hiddenStatsSection = modal.querySelector('#hiddenStatsSection');
    
    editToggle.onclick = () => {
      editMode = !editMode;
      
      if (editMode) {
        // Enter edit mode (SANDBOX MODE)
        editToggle.innerHTML = '<span style="font-size:1.1rem;">ğŸ”’</span> View';
        editToggle.style.background = '#ffd700';
        editToggle.style.color = '#0f1419';
        saveBtn.style.display = 'block';
        cancelBtn.style.display = 'block';
        
        // Show hidden stats section
        if (hiddenStatsSection) {
          hiddenStatsSection.style.display = 'block';
        }
        
        // Make text fields editable
        editableElements.forEach(el => {
          // Skip stat values - they get buttons instead
          // Skip fields that get special controls (dropdowns, buttons, etc.)
          if (!el.id || !el.id.startsWith('bio') || el.id.includes('Name') || el.id.includes('Bio') || el.id.includes('Personality') || el.id.includes('Hobbies') || el.id.includes('Kinks') || el.id.includes('KeyTrait') || el.id.includes('Position') || el.id.includes('Age') || el.id.includes('Gender') || el.id.includes('Race') || el.id.includes('Product') || el.id.includes('Physical') || el.id.includes('Height') || el.id.includes('Body') || el.id.includes('Hair') || el.id.includes('Eyes') || el.id.includes('Face') || el.id.includes('Skin') || el.id.includes('Fashion') || el.id.includes('Distinguishing') || el.id.includes('Genital')) {
            el.contentEditable = 'true';
            el.style.background = 'rgba(255, 215, 0, 0.15)';
            el.style.border = '1px dashed #ffd700';
            el.style.padding = '4px';
          }
        });
        
        // Add increment controls for primary stats
        originalHTMLs.set('bioAffection', createStatControls('bioAffection', employee.stats?.affection ?? 0));
        originalHTMLs.set('bioComfort', createStatControls('bioComfort', employee.stats?.comfort ?? 0));
        originalHTMLs.set('bioTrust', createStatControls('bioTrust', employee.stats?.trust ?? 0));
        originalHTMLs.set('bioDesire', createStatControls('bioDesire', employee.stats?.desire ?? 0));
        originalHTMLs.set('bioObedience', createStatControls('bioObedience', employee.stats?.obedience ?? 0));
        originalHTMLs.set('bioProductivity', createStatControls('bioProductivity', employee.stats?.productivity ?? 0));
        
        // Add increment controls for hidden stats
        originalHTMLs.set('bioIntimacy', createStatControls('bioIntimacy', employee.memory?.intimacyLevel ?? 0));
        originalHTMLs.set('bioMemoryCap', createStatControls('bioMemoryCap', employee.memory?.cap ?? 300, 50, 1000));
        originalHTMLs.set('bioTimesRehired', createStatControls('bioTimesRehired', employee.timesRehired ?? 0, 0, 100));
        originalHTMLs.set('bioLoyaltyBonus', createStatControls('bioLoyaltyBonus', (employee.loyaltyBonus ?? 0) * 100, 0, 50));
        
        // Add increment controls for personality attributes
        originalHTMLs.set('bioConfidence', createStatControls('bioConfidence', employee.personality?.confidence ?? 50, 0, 100));
        originalHTMLs.set('bioOutgoing', createStatControls('bioOutgoing', employee.personality?.outgoing ?? 50, 0, 100));
        originalHTMLs.set('bioFlirty', createStatControls('bioFlirty', employee.personality?.flirty ?? 50, 0, 100));
        originalHTMLs.set('bioProfessional', createStatControls('bioProfessional', employee.personality?.professional ?? 50, 0, 100));
        originalHTMLs.set('bioHumor', createStatControls('bioHumor', employee.personality?.humor ?? 50, 0, 100));
        
        // Add dropdowns for enum fields
        originalHTMLs.set('bioConversationPhase', createDropdownControl('bioConversationPhase', employee.memory?.conversationPhase ?? 'early', [
          { value: 'early', label: 'Early (Getting to know you)' },
          { value: 'familiar', label: 'Familiar (Comfortable)' },
          { value: 'intimate', label: 'Intimate (Very close)' }
        ]));
        
        originalHTMLs.set('bioEmploymentStatus', createDropdownControl('bioEmploymentStatus', employee.employmentStatus ?? 'active', [
          { value: 'active', label: 'Active (Working)' },
          { value: 'candidate', label: 'Candidate (Not hired yet)' },
          { value: 'onboarding', label: 'Onboarding (In training)' },
          { value: 'former', label: 'Former (Left company)' }
        ]));
        
        // Add dropdown for race selection
        originalHTMLs.set('bioRace', createDropdownControl('bioRace', employee.race ?? 'human', [
          { value: 'human', label: 'Human' },
          { value: 'elf', label: 'ğŸ§ Elf' },
          { value: 'orc', label: 'ğŸ’ª Orc' },
          { value: 'demon', label: 'ğŸ˜ˆ Demon' },
          { value: 'foxkin', label: 'ğŸ¦Š Foxkin' },
          { value: 'wolfkin', label: 'ğŸº Wolfkin' },
          { value: 'catkin', label: 'ğŸ˜º Catkin' },
          { value: 'rabbitkin', label: 'ğŸ° Rabbitkin' }
        ]));
        
        // Add dropdowns for genital information (gender-specific options)
        const gender = employee.gender || 'Female';
        
        // Genital Type options based on gender
        let typeOptions = [];
        if (gender === 'Male') {
          typeOptions = [
            { value: 'penis', label: 'Penis' }
          ];
        } else if (gender === 'Trans Man') {
          typeOptions = [
            { value: 'enlarged clitoris', label: 'Enlarged Clitoris (Pre-HRT)' },
            { value: 'post-op penis', label: 'Post-Op Penis (Phalloplasty)' },
            { value: 'pre-op anatomy', label: 'Pre-Op Anatomy' }
          ];
        } else if (gender === 'Female Futa') {
          typeOptions = [
            { value: 'penis and vagina', label: 'Penis and Vagina (Dual)' }
          ];
        } else if (gender === 'Trans Woman') {
          typeOptions = [
            { value: 'vagina (post-op)', label: 'Vagina (Post-Op)' },
            { value: 'penis (pre-op)', label: 'Penis (Pre-Op)' },
            { value: 'tucked', label: 'Tucked (HRT)' }
          ];
        } else { // Female
          typeOptions = [
            { value: 'vagina', label: 'Vagina' }
          ];
        }
        
        // Genital Size options based on gender and type
        let sizeOptions = [];
        const currentType = employee.physical?.genitals?.type || typeOptions[0]?.value || 'vagina';
        
        if (currentType.includes('penis') && !currentType.includes('vagina')) {
          if (gender === 'Trans Man' && currentType === 'post-op penis') {
            sizeOptions = [
              { value: 'small', label: 'Small (Typical for phalloplasty)' },
              { value: 'modest', label: 'Modest' },
              { value: 'average', label: 'Average' }
            ];
          } else {
            sizeOptions = [
              { value: 'small', label: 'Small' },
              { value: 'modest', label: 'Modest' },
              { value: 'average', label: 'Average' },
              { value: 'above average', label: 'Above Average' },
              { value: 'large', label: 'Large' },
              { value: 'very large', label: 'Very Large' }
            ];
          }
        } else if (currentType === 'penis and vagina') {
          sizeOptions = [
            { value: 'average', label: 'Average' },
            { value: 'above average', label: 'Above Average' },
            { value: 'large', label: 'Large' },
            { value: 'very large', label: 'Very Large' },
            { value: 'impressive', label: 'Impressive' }
          ];
        } else if (currentType.includes('vagina') || currentType === 'pre-op anatomy') {
          sizeOptions = [
            { value: 'tight', label: 'Tight' },
            { value: 'snug', label: 'Snug' },
            { value: 'average', label: 'Average' },
            { value: 'relaxed', label: 'Relaxed' },
            { value: 'accommodating', label: 'Accommodating' }
          ];
        } else if (currentType === 'enlarged clitoris') {
          sizeOptions = [
            { value: 'slightly enlarged', label: 'Slightly Enlarged' },
            { value: 'noticeably enlarged', label: 'Noticeably Enlarged' },
            { value: 'significantly enlarged', label: 'Significantly Enlarged' }
          ];
        } else {
          sizeOptions = [
            { value: 'average', label: 'Average' }
          ];
        }
        
        // Characteristics options based on gender and type
        let characteristicsOptions = [];
        
        if (currentType.includes('penis') && !currentType.includes('vagina')) {
          characteristicsOptions = [
            { value: 'circumcised', label: 'Circumcised' },
            { value: 'uncircumcised', label: 'Uncircumcised' }
          ];
        } else if (currentType === 'penis and vagina') {
          characteristicsOptions = [
            { value: 'fully functional dual anatomy', label: 'Fully Functional Dual Anatomy' },
            { value: 'prominent dual features', label: 'Prominent Dual Features' }
          ];
        } else if (currentType.includes('vagina') || currentType === 'pre-op anatomy') {
          characteristicsOptions = [
            { value: 'waxed smooth', label: 'Waxed Smooth' },
            { value: 'neatly trimmed', label: 'Neatly Trimmed' },
            { value: 'natural', label: 'Natural' },
            { value: 'fully shaved', label: 'Fully Shaved' },
            { value: 'landing strip', label: 'Landing Strip' },
            { value: 'shaped', label: 'Shaped' }
          ];
        } else if (currentType === 'enlarged clitoris') {
          characteristicsOptions = [
            { value: 'sensitive and prominent', label: 'Sensitive and Prominent' },
            { value: 'HRT-enhanced', label: 'HRT-Enhanced' }
          ];
        } else if (currentType === 'tucked') {
          characteristicsOptions = [
            { value: 'carefully tucked', label: 'Carefully Tucked' },
            { value: 'HRT-softened', label: 'HRT-Softened' }
          ];
        } else {
          characteristicsOptions = [
            { value: 'natural', label: 'Natural' }
          ];
        }
        
        originalHTMLs.set('bioGenitalType', createDropdownControl('bioGenitalType', employee.physical?.genitals?.type ?? typeOptions[0]?.value, typeOptions));
        originalHTMLs.set('bioGenitalSize', createDropdownControl('bioGenitalSize', employee.physical?.genitals?.size ?? sizeOptions[0]?.value, sizeOptions));
        originalHTMLs.set('bioGenitalCharacteristics', createDropdownControl('bioGenitalCharacteristics', employee.physical?.genitals?.characteristics ?? characteristicsOptions[0]?.value, characteristicsOptions));
        
      } else {
        // Exit edit mode without saving - restore original HTML
        editToggle.innerHTML = '<span style="font-size:1.1rem;">âœï¸</span> Edit';
        editToggle.style.background = '#00d4ff';
        editToggle.style.color = '#0f1419';
        saveBtn.style.display = 'none';
        cancelBtn.style.display = 'none';
        
        // Hide hidden stats section
        if (hiddenStatsSection) {
          hiddenStatsSection.style.display = 'none';
        }
        
        // Restore original HTML for all modified elements
        originalHTMLs.forEach((html, elementId) => {
          const element = document.getElementById(elementId);
          if (element && element.parentElement) {
            element.parentElement.innerHTML = html;
          }
        });
        originalHTMLs.clear();
        
        editableElements.forEach(el => {
          el.contentEditable = 'false';
          el.style.background = '';
          el.style.border = '';
          el.style.padding = '';
        });
      }
    };
    
    // Save changes
    saveBtn.onclick = () => {
      // ========== NAME VALIDATION (PLAYER FEATURE REQUEST) ==========
      const bioNameEl = document.getElementById('bioName');
      if (bioNameEl) {
        const newName = bioNameEl.textContent.trim();
        const oldName = employee.name;
        
        // Validate name changes
        if (newName !== oldName) {
          // Check if name is empty
          if (!newName || newName.length === 0) {
            showNotification('âŒ Name cannot be empty!', 'error');
            bioNameEl.textContent = oldName; // Revert
            return;
          }
          
          // Check if name is too short
          if (newName.length < 2) {
            showNotification('âŒ Name must be at least 2 characters!', 'error');
            bioNameEl.textContent = oldName; // Revert
            return;
          }
          
          // Check for duplicate names (case-insensitive)
          const duplicateEmployee = gameState.employees.find(e => 
            e.id !== employee.id && 
            e.name.toLowerCase() === newName.toLowerCase()
          );
          
          if (duplicateEmployee) {
            showNotification(`âŒ Name "${newName}" is already taken by another employee!`, 'error');
            bioNameEl.textContent = oldName; // Revert
            return;
          }
          
          // Check onboarding queue for duplicates
          if (gameState.onboardingQueue) {
            const duplicateOnboarding = gameState.onboardingQueue.find(c => 
              c.name.toLowerCase() === newName.toLowerCase()
            );
            if (duplicateOnboarding) {
              showNotification(`âŒ Name "${newName}" is already used in onboarding!`, 'error');
              bioNameEl.textContent = oldName; // Revert
              return;
            }
          }
          
          // Update usedEmployeeNames Set
          if (gameState.usedEmployeeNames) {
            gameState.usedEmployeeNames.delete(oldName);
            gameState.usedEmployeeNames.add(newName);
          }
          
          // Update employee name
          employee.name = newName;
          
          console.log(`[Name Change] Renamed "${oldName}" â†’ "${newName}"`);
          showNotification(`âœ… Renamed employee: ${oldName} â†’ ${newName}`, 'success');
        }
      }
      
      // Read from stat buttons/dropdowns first
      const statIds = ['bioAffection', 'bioComfort', 'bioTrust', 'bioDesire', 'bioObedience', 'bioProductivity'];
      statIds.forEach(id => {
        const el = document.getElementById(id);
        if (el && employee.stats) {
          const statName = id.replace('bio', '').toLowerCase();
          employee.stats[statName] = parseInt(el.textContent) || 0;
        }
      });
      
      // Read hidden stats
      const intimacyEl = document.getElementById('bioIntimacy');
      if (intimacyEl && employee.memory) employee.memory.intimacyLevel = parseInt(intimacyEl.textContent) || 0;
      
      const memoryCapEl = document.getElementById('bioMemoryCap');
      if (memoryCapEl && employee.memory) {
        employee.memory.cap = parseInt(memoryCapEl.textContent) || 300;
      }
      
      const timesRehiredEl = document.getElementById('bioTimesRehired');
      if (timesRehiredEl) employee.timesRehired = parseInt(timesRehiredEl.textContent) || 0;
      
      const loyaltyBonusEl = document.getElementById('bioLoyaltyBonus');
      if (loyaltyBonusEl) employee.loyaltyBonus = (parseInt(loyaltyBonusEl.textContent) || 0) / 100;
      
      // Read personality attributes - FIXED: Ensure personality object exists
      if (!employee.personality) employee.personality = {};
      
      const confidenceEl = document.getElementById('bioConfidence');
      if (confidenceEl) employee.personality.confidence = parseInt(confidenceEl.textContent) || 50;
      
      const outgoingEl = document.getElementById('bioOutgoing');
      if (outgoingEl) employee.personality.outgoing = parseInt(outgoingEl.textContent) || 50;
      
      const flirtyEl = document.getElementById('bioFlirty');
      if (flirtyEl) employee.personality.flirty = parseInt(flirtyEl.textContent) || 50;
      
      const professionalEl = document.getElementById('bioProfessional');
      if (professionalEl) employee.personality.professional = parseInt(professionalEl.textContent) || 50;
      
      const humorEl = document.getElementById('bioHumor');
      if (humorEl) employee.personality.humor = parseInt(humorEl.textContent) || 50;
      
      // Read dropdowns - FIXED: Ensure memory object exists for conversationPhase
      const conversationPhaseEl = document.getElementById('bioConversationPhase');
      if (conversationPhaseEl) {
        if (!employee.memory) employee.memory = {};
        employee.memory.conversationPhase = conversationPhaseEl.value || 'early';
      }
      
      const employmentStatusEl = document.getElementById('bioEmploymentStatus');
      if (employmentStatusEl) {
        employee.employmentStatus = employmentStatusEl.value || 'active';
      }
      
      // Read race dropdown and regenerate physical appearance if changed
      const raceEl = document.getElementById('bioRace');
      if (raceEl) {
        const oldRace = employee.race || 'human';
        const newRace = raceEl.value || 'human';
        
        if (oldRace !== newRace) {
          employee.race = newRace;
          
          // Regenerate physical appearance with new race
          if (typeof generateDetailedPhysicalAppearance === 'function') {
            employee.physical = generateDetailedPhysicalAppearance(employee.gender || 'female', newRace);
            console.log(`[Race Change] Updated ${employee.name}'s race: ${oldRace} â†’ ${newRace}`);
            showNotification(`âœ¨ ${employee.name}'s race changed to ${newRace}! Physical appearance regenerated.`, 'success');
          } else {
            console.log(`[Race Change] Updated ${employee.name}'s race: ${oldRace} â†’ ${newRace} (appearance not regenerated - function unavailable)`);
          }
        }
      }
      
      // Read genital information dropdowns
      const genitalTypeEl = document.getElementById('bioGenitalType');
      const genitalSizeEl = document.getElementById('bioGenitalSize');
      const genitalCharacteristicsEl = document.getElementById('bioGenitalCharacteristics');
      
      if (genitalTypeEl || genitalSizeEl || genitalCharacteristicsEl) {
        if (!employee.physical) employee.physical = {};
        if (!employee.physical.genitals) employee.physical.genitals = {};
        
        if (genitalTypeEl) {
          employee.physical.genitals.type = genitalTypeEl.value || 'Not specified';
        }
        if (genitalSizeEl) {
          employee.physical.genitals.size = genitalSizeEl.value || 'Not specified';
        }
        if (genitalCharacteristicsEl) {
          employee.physical.genitals.characteristics = genitalCharacteristicsEl.value || 'Not specified';
        }
        
        // Update the full description
        if (employee.physical.genitals.type && employee.physical.genitals.size && employee.physical.genitals.characteristics) {
          employee.physical.genitals.full = `${employee.physical.genitals.size} ${employee.physical.genitals.type}, ${employee.physical.genitals.characteristics}`;
          
          // Also update fullDescription if it exists
          if (employee.physical.fullDescription) {
            // Replace the genitals line in fullDescription
            const genitalLine = `Genitals: ${employee.physical.genitals.full}`;
            const genitalRegex = /Genitals:.*?(?=\n|$)/;
            if (genitalRegex.test(employee.physical.fullDescription)) {
              employee.physical.fullDescription = employee.physical.fullDescription.replace(genitalRegex, genitalLine);
            } else {
              // Add it if not present
              employee.physical.fullDescription += `\nGenitals: ${employee.physical.genitals.full}`;
            }
          }
        }
      }
      
      // Read from text fields
      editableElements.forEach(el => {
        const field = el.dataset.field;
        const value = el.textContent.trim();
        
        if (field) {
          // Handle nested fields (e.g., "stats.affection", "physical.hair.full")
          const parts = field.split('.');
          let target = employee;
          
          for (let i = 0; i < parts.length - 1; i++) {
            if (!target[parts[i]]) target[parts[i]] = {};
            target = target[parts[i]];
          }
          
          const lastPart = parts[parts.length - 1];
          
          // Special handling for different field types
          if (field === 'personalityTraits' || field === 'hobbies' || field === 'kinks') {
            // Arrays - split by comma
            target[lastPart] = value.split(',').map(s => s.trim()).filter(Boolean);
          } 
          else if (field === 'age') {
            // Integer
            target[lastPart] = parseInt(value) || 0;
          }
          else if (!field.startsWith('stats.') && field !== 'intimacy' && field !== 'memory.cap' && field !== 'timesRehired' && field !== 'loyaltyBonus' && field !== 'memory.conversationPhase' && field !== 'employmentStatus' && field !== 'name') {
            // String fields (skip the ones we already handled above, including name which is validated separately)
            target[lastPart] = value;
          }
        }
      });
      
      // Ensure stats are clamped to valid ranges
      if (employee.stats) {
        Object.keys(employee.stats).forEach(key => {
          employee.stats[key] = Math.max(0, Math.min(100, employee.stats[key]));
        });
      }
      
      // Ensure personality stats are clamped
      if (employee.personality) {
        ['confidence', 'outgoing', 'flirty', 'professional', 'humor'].forEach(key => {
          if (employee.personality[key] !== undefined) {
            employee.personality[key] = Math.max(0, Math.min(100, employee.personality[key]));
          }
        });
      }
      
      // Ensure intimacy is clamped
      if (employee.memory && employee.memory.intimacyLevel !== undefined) {
        employee.memory.intimacyLevel = Math.max(0, Math.min(100, employee.memory.intimacyLevel));
      }
      
      // Ensure memory cap is reasonable
      if (employee.memory && employee.memory.cap !== undefined) {
        employee.memory.cap = Math.max(50, Math.min(1000, employee.memory.cap));
      }
      
      // CRITICAL: Ensure memory structure is valid after all changes
      ensureEmployeeMemory(employee);
      ensureEmployeeStats(employee);
      ensureEmployeePersonality(employee);
      
      showNotification('ğŸ’¾ Bio updated successfully! All changes saved.');
      saveGame(); // Save the game state
      updatePeopleTab(); // Refresh the people list
      
      // CRITICAL FIX: Refresh the modal display with updated values
      // This ensures when you toggle back to view mode or reopen, you see the saved values
      ModalManager.close('bioModal');
      
      // Small delay to allow modal to close, then reopen with fresh data
      setTimeout(() => {
        openBioModal(employee);
      }, 100);
    };
    
    // Cancel changes
    cancelBtn.onclick = () => {
      if (confirm('Discard changes?')) {
        ModalManager.close('bioModal');
      }
    };
    
    // Close modal
    modal.querySelector('#closeBioModal').onclick = () => {
      if (editMode) {
        if (confirm('You have unsaved changes. Close anyway?')) {
          ModalManager.close('bioModal');
        }
      } else {
        ModalManager.close('bioModal');
      }
    };
    
    // Click outside to close
    modal.onclick = (e) => {
      if (e.target === modal) {
        if (editMode) {
          if (confirm('You have unsaved changes. Close anyway?')) {
            ModalManager.close('bioModal');
          }
        } else {
          ModalManager.close('bioModal');
        }
      }
    };
  }
  
  // Load chat history
  function loadChatHistory(employeeId) {
    if (!chatMessages) return;
    
    chatMessages.innerHTML = '';
    const history = gameState.chatHistory[employeeId] || [];
    
    history.forEach((msg, index) => {
      // Handle money requests specially
      if (msg.isMoneyRequest && !msg.isPlayer) {
        const employee = gameState.employees.find(e => e.id === employeeId);
        if (employee) {
          // SAFETY CHECK: Ensure amount is defined (backwards compatibility with old saves)
          const amount = msg.amount || 100; // Default to $100 if amount is missing
          // Pass settled status to the render function
          addMoneyRequestMessage(employee, amount, msg.reason, index, msg.settled);
        }
      }
      // Handle scene visualizations specially
      else if (msg.imageType === 'scene') {
        const messageEl = document.createElement('div');
        messageEl.style.cssText = 'max-width:80%; padding:10px; margin:10px auto; text-align:center; position:relative;';
        
        const imageContainer = document.createElement('div');
        imageContainer.style.cssText = 'position:relative; display:inline-block; max-width:400px; width:100%;';
        
        const img = document.createElement('img');
        img.src = msg.imageUrl;
        img.style.cssText = 'width:100%; border-radius:10px; cursor:pointer; box-shadow:0 2px 10px rgba(0,0,0,0.3); display:block;';
        img.onclick = () => {
          const viewer = document.createElement('div');
          viewer.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:99999; display:flex; justify-content:center; align-items:center; cursor:pointer;';
          viewer.innerHTML = `<img src="${msg.imageUrl}" style="max-width:90%; max-height:90%; border-radius:10px;">`;
          viewer.onclick = () => viewer.remove();
          document.body.appendChild(viewer);
        };
        imageContainer.appendChild(img);
        
        // Add regenerate button for scene images if we have the prompt
        if (msg.imagePrompt) {
          const imgRegenBtn = document.createElement('button');
          imgRegenBtn.innerHTML = 'ğŸ”„';
          imgRegenBtn.style.cssText = 'position:absolute; top:5px; right:5px; background:rgba(0,0,0,0.6); border:none; border-radius:50%; width:28px; height:28px; color:white; cursor:pointer; font-size:1rem; opacity:0; transition:opacity 0.2s; display:flex; align-items:center; justify-content:center;';
          imgRegenBtn.title = 'Regenerate image';
          
          imageContainer.appendChild(imgRegenBtn);
          
          // Show/hide on hover
          imageContainer.addEventListener('mouseenter', () => {
            imgRegenBtn.style.opacity = '1';
          });
          imageContainer.addEventListener('mouseleave', () => {
            imgRegenBtn.style.opacity = '0';
          });
          
          // Handle image regeneration
          imgRegenBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            await regenerateImage(index, msg.imagePrompt);
          });
        }
        
        const caption = document.createElement('p');
        caption.style.cssText = 'margin:8px 0 0 0; color:#aaa; font-size:0.85rem; font-style:italic;';
        caption.textContent = msg.content;
        
        messageEl.appendChild(imageContainer);
        messageEl.appendChild(caption);
        chatMessages.appendChild(messageEl);
      } else if (msg.giftData) {
        // Render gift message specially
        addGiftMessage(msg.sender, msg.content, msg.giftData, msg.isPlayer);
      } else {
        // Pass timestamp so it's preserved when reopening chats
        addChatMessage(msg.sender, msg.content, msg.isPlayer, msg.imageUrl, index, msg.imagePrompt, msg.timestamp);
      }
    });
    
    // Scroll to bottom
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }
  
  // Helper function to style action text (enclosed in asterisks)
  function styleActionText(text) {
    if (!text) return '';
    
    // Escape HTML first to prevent XSS
    const escaped = text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
    
    // Replace *action text* with styled span
    // Match text between asterisks, but not standalone asterisks
    const styled = escaped.replace(/\*([^*]+)\*/g, (match, content) => {
      return `<span style="color:#888; font-style:italic; opacity:0.85;">${content}</span>`;
    });
    
    return styled;
  }
  
  /**
   * Generate a context-aware timestamp for chat messages
   * Shows in-game time in a natural, NPC-aware format
   * @param {number} timestamp - Optional timestamp to format (defaults to current game time)
   */
  function getContextAwareTimestamp(timestamp = null) {
    // Use provided timestamp or current game time
    const timeToUse = timestamp || (gameState.time?.currentTime) || Date.now();
    
    const gameTime = new Date(timeToUse);
    const hour = gameTime.getHours();
    const minute = gameTime.getMinutes();
    const dayOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][gameTime.getDay()];
    const month = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][gameTime.getMonth()];
    const day = gameTime.getDate();
    
    // Format time with AM/PM
    const period = hour >= 12 ? 'PM' : 'AM';
    const displayHour = hour % 12 || 12;
    const displayMinute = minute.toString().padStart(2, '0');
    const timeStr = `${displayHour}:${displayMinute} ${period}`;
    
    // Add contextual descriptor based on time of day
    let timeContext = '';
    if (hour >= 5 && hour < 12) {
      timeContext = 'Morning';
    } else if (hour >= 12 && hour < 17) {
      timeContext = 'Afternoon';
    } else if (hour >= 17 && hour < 21) {
      timeContext = 'Evening';
    } else {
      timeContext = 'Night';
    }
    
    // Return format: "Wednesday Evening, Oct 31 â€¢ 7:45 PM"
    return `${dayOfWeek} ${timeContext}, ${month} ${day} â€¢ ${timeStr}`;
  }
  
  // Add chat message to UI
  function addChatMessage(sender, content, isPlayer, imageUrl = null, messageIndex = null, imagePrompt = null, storedTimestamp = null) {
    if (!chatMessages) return;
    
    // Calculate max-width: if there's an image, make room for it; otherwise use 80%
    const imageSize = gameState.settings.imagePreviewSize || 300;
    const messageMaxWidth = imageUrl ? `${imageSize + 40}px` : '80%'; // +40px for padding
    
    const messageEl = document.createElement('div');
    messageEl.style.cssText = `max-width:${messageMaxWidth}; padding:10px 15px; border-radius:18px; margin-bottom:10px; word-wrap:break-word; position:relative; ${isPlayer ? 'background:#e94560; align-self:flex-end;' : 'background:#0f3460; align-self:flex-start;'}`;
    
    // Add in-game timestamp (use stored timestamp if provided, otherwise current time)
    const timestamp = document.createElement('div');
    timestamp.style.cssText = 'font-size:0.7rem; opacity:0.6; margin-bottom:6px; font-style:italic;';
    timestamp.textContent = storedTimestamp ? getContextAwareTimestamp(storedTimestamp) : getContextAwareTimestamp();
    messageEl.appendChild(timestamp);
    
    // Add edit/resend buttons for PLAYER messages
    if (isPlayer && messageIndex !== null) {
      const actionContainer = document.createElement('div');
      actionContainer.style.cssText = 'position:absolute; top:5px; right:5px; display:flex; gap:4px; opacity:0.01; transition:opacity 0.2s;';
      actionContainer.className = 'message-action-buttons';
      
      // Edit button
      const editBtn = document.createElement('button');
      editBtn.innerHTML = 'âœï¸';
      editBtn.className = 'edit-msg-btn';
      editBtn.style.cssText = 'background:rgba(255,152,0,0.8); border:none; border-radius:50%; width:24px; height:24px; color:white; cursor:pointer; font-size:0.8rem; display:flex; align-items:center; justify-content:center; padding:0;';
      editBtn.setAttribute('data-message-index', messageIndex);
      editBtn.title = 'Edit message';
      editBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        editPlayerMessage(messageIndex);
      });
      
      // Resend button
      const resendBtn = document.createElement('button');
      resendBtn.innerHTML = 'ğŸ”„';
      resendBtn.className = 'resend-msg-btn';
      resendBtn.style.cssText = 'background:rgba(76,175,80,0.8); border:none; border-radius:50%; width:24px; height:24px; color:white; cursor:pointer; font-size:0.8rem; display:flex; align-items:center; justify-content:center; padding:0;';
      resendBtn.setAttribute('data-message-index', messageIndex);
      resendBtn.title = 'Resend message';
      resendBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        resendPlayerMessage(messageIndex);
      });
      
      actionContainer.appendChild(editBtn);
      actionContainer.appendChild(resendBtn);
      messageEl.appendChild(actionContainer);
      
      // Show/hide on hover
      messageEl.addEventListener('mouseenter', () => {
        actionContainer.style.opacity = '1';
      });
      messageEl.addEventListener('mouseleave', () => {
        actionContainer.style.opacity = '0.01';
      });
    }
    
    // Add regenerate button for NPC messages
    if (!isPlayer && messageIndex !== null) {
      const regenBtn = document.createElement('button');
      regenBtn.innerHTML = 'â™»ï¸';
      regenBtn.className = 'regenerate-btn';
      regenBtn.style.cssText = 'position:absolute; top:5px; right:5px; background:rgba(33,150,243,0.8); border:none; border-radius:50%; width:24px; height:24px; color:white; cursor:pointer; font-size:0.9rem; opacity:0.01; transition:opacity 0.2s; display:flex; align-items:center; justify-content:center; padding:0;';
      regenBtn.setAttribute('data-message-index', messageIndex);
      regenBtn.title = 'Regenerate response (click for new variation)';
      
      messageEl.appendChild(regenBtn);
      
      // Show/hide on hover
      messageEl.addEventListener('mouseenter', () => {
        regenBtn.style.opacity = '1';
      });
      messageEl.addEventListener('mouseleave', () => {
        regenBtn.style.opacity = '0.01';
      });
      
      // Handle regeneration
      regenBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        await regenerateMessage(messageIndex);
      });
    }
    
    // Add image if present
    if (imageUrl) {
      const imageContainer = document.createElement('div');
      const imageSize = gameState.settings.imagePreviewSize || 300;
      imageContainer.style.cssText = `position:relative; display:inline-block; width:100%; max-width:${imageSize}px;`;
      
      const img = document.createElement('img');
      img.src = imageUrl;
      img.style.cssText = 'width:100%; border-radius:10px; margin-bottom:8px; cursor:pointer; display:block;';
      img.onclick = () => {
        // Open image in larger view
        const viewer = document.createElement('div');
        viewer.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:99999; display:flex; justify-content:center; align-items:center; cursor:pointer;';
        viewer.innerHTML = `<img src="${imageUrl}" style="max-width:90%; max-height:90%; border-radius:10px;">`;
        viewer.onclick = () => viewer.remove();
        document.body.appendChild(viewer);
      };
      imageContainer.appendChild(img);
      
      // Add regenerate button for images if we have the prompt and messageIndex
      if (imagePrompt && messageIndex !== null) {
        const imgRegenBtn = document.createElement('button');
        imgRegenBtn.innerHTML = 'ğŸ”„';
        imgRegenBtn.style.cssText = 'position:absolute; top:5px; right:5px; background:rgba(0,0,0,0.6); border:none; border-radius:50%; width:28px; height:28px; color:white; cursor:pointer; font-size:1rem; opacity:0; transition:opacity 0.2s; display:flex; align-items:center; justify-content:center;';
        imgRegenBtn.title = 'Regenerate image';
        
        imageContainer.appendChild(imgRegenBtn);
        
        // Show/hide on hover
        imageContainer.addEventListener('mouseenter', () => {
          imgRegenBtn.style.opacity = '1';
        });
        imageContainer.addEventListener('mouseleave', () => {
          imgRegenBtn.style.opacity = '0';
        });
        
        // Handle image regeneration
        imgRegenBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          await regenerateImage(messageIndex, imagePrompt);
        });
      }
      
      messageEl.appendChild(imageContainer);
    }
    
    const textEl = document.createElement('p');
    textEl.style.margin = '0';
    textEl.style.marginBottom = !isPlayer ? '8px' : '0'; // Add margin for vote buttons
    
    // Process content to style asterisk-enclosed text (actions/thoughts)
    const processedContent = styleActionText(content);
    textEl.innerHTML = processedContent;
    
    messageEl.appendChild(textEl);
    
    // Add vote buttons for NPC messages (not player messages)
    if (!isPlayer && messageIndex !== null) {
      const voteContainer = document.createElement('div');
      voteContainer.style.cssText = 'display:flex; align-items:center; gap:4px; background:#0a0e14; border-radius:12px; padding:2px 4px; width:fit-content; margin-top:6px;';
      
      // Get the current message to check vote status
      // activeChat can be either an ID string or an employee object, so handle both
      const employeeId = typeof gameState.activeChat === 'string' ? gameState.activeChat : gameState.activeChat?.id;
      const history = gameState.chatHistory[employeeId] || [];
      const message = history[messageIndex];
      
      // Create upvote button
      const upvoteBtn = document.createElement('button');
      upvoteBtn.style.cssText = `background:${message?.playerVote === 'up' ? 'rgba(255, 69, 0, 0.2)' : 'transparent'}; border:${message?.playerVote === 'up' ? '1px solid #ff4500' : '1px solid transparent'}; padding:4px 6px; border-radius:6px; cursor:pointer; display:flex; align-items:center; transition:all 0.2s;`;
      upvoteBtn.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="${message?.playerVote === 'up' ? '#ff4500' : '#8899a6'}"><path d="M12 4l8 8h-6v8h-4v-8H4z"/></svg>`;
      upvoteBtn.addEventListener('mouseenter', () => upvoteBtn.style.transform = 'scale(1.15)');
      upvoteBtn.addEventListener('mouseleave', () => upvoteBtn.style.transform = 'scale(1)');
      upvoteBtn.addEventListener('click', () => voteOnChatMessage(employeeId, messageIndex, 'up'));
      
      // Create downvote button
      const downvoteBtn = document.createElement('button');
      downvoteBtn.style.cssText = `background:${message?.playerVote === 'down' ? 'rgba(113, 147, 255, 0.2)' : 'transparent'}; border:${message?.playerVote === 'down' ? '1px solid #7193ff' : '1px solid transparent'}; padding:4px 6px; border-radius:6px; cursor:pointer; display:flex; align-items:center; transition:all 0.2s;`;
      downvoteBtn.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="${message?.playerVote === 'down' ? '#7193ff' : '#8899a6'}"><path d="M12 20l-8-8h6V4h4v8h6z"/></svg>`;
      downvoteBtn.addEventListener('mouseenter', () => downvoteBtn.style.transform = 'scale(1.15)');
      downvoteBtn.addEventListener('mouseleave', () => downvoteBtn.style.transform = 'scale(1)');
      downvoteBtn.addEventListener('click', () => voteOnChatMessage(employeeId, messageIndex, 'down'));
      
      voteContainer.appendChild(upvoteBtn);
      voteContainer.appendChild(downvoteBtn);
      messageEl.appendChild(voteContainer);
    }
    
    chatMessages.appendChild(messageEl);
  }
  
  // Add a gift message with rich display
  function addGiftMessage(sender, content, giftData, isPlayer) {
    if (!chatMessages) return;
    
    const messageEl = document.createElement('div');
    messageEl.style.cssText = `max-width:80%; padding:12px; border-radius:15px; margin-bottom:10px; ${isPlayer ? 'background:#16213e; align-self:flex-end; border:2px solid #e94560;' : 'background:#0f3460; align-self:flex-start;'}`;
    
    // Add timestamp
    const timestamp = document.createElement('div');
    timestamp.style.cssText = 'font-size:0.7rem; opacity:0.6; margin-bottom:6px; font-style:italic;';
    timestamp.textContent = getContextAwareTimestamp();
    messageEl.appendChild(timestamp);
    
    // Gift header
    const header = document.createElement('div');
    header.style.cssText = 'display:flex; align-items:center; gap:8px; margin-bottom:10px;';
    header.innerHTML = `<span style="font-size:1.5rem;">${giftData.categoryEmoji || 'ğŸ'}</span><strong style="color:#4ecca3;">Gift Given</strong>`;
    messageEl.appendChild(header);
    
    // Gift details card
    const detailsCard = document.createElement('div');
    detailsCard.style.cssText = 'background:rgba(0,0,0,0.3); padding:10px; border-radius:10px; margin-bottom:10px;';
    
    // Gift name
    const nameEl = document.createElement('div');
    nameEl.style.cssText = 'font-size:1.1rem; font-weight:600; color:white; margin-bottom:5px;';
    nameEl.textContent = giftData.name;
    detailsCard.appendChild(nameEl);
    
    // Category and price
    const metaEl = document.createElement('div');
    metaEl.style.cssText = 'display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;';
    metaEl.innerHTML = `
      <span style="color:#aaa; font-size:0.9rem;">${giftData.categoryEmoji} ${giftData.categoryName}</span>
      <span style="color:#4ecca3; font-weight:600; font-size:1.1rem;">$${formatCash(giftData.price)}</span>
    `;
    detailsCard.appendChild(metaEl);
    
    // Description
    if (giftData.description) {
      const descEl = document.createElement('div');
      descEl.style.cssText = 'color:#ccc; font-size:0.85rem; line-height:1.4; margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.1);';
      descEl.textContent = giftData.description;
      detailsCard.appendChild(descEl);
    }
    
    messageEl.appendChild(detailsCard);
    
    // Optional personal message from player
    if (content && content !== 'ğŸ Gave a gift') {
      const msgEl = document.createElement('div');
      msgEl.style.cssText = `
        margin-top: 12px;
        padding: 10px 12px;
        background: linear-gradient(135deg, rgba(255,105,180,0.15), rgba(147,112,219,0.15));
        border-left: 3px solid #ff69b4;
        border-radius: 8px;
        position: relative;
      `;
      
      // Message icon
      const iconEl = document.createElement('span');
      iconEl.textContent = 'ğŸ’Œ';
      iconEl.style.cssText = 'font-size:1.2rem; margin-right:6px; vertical-align:middle;';
      msgEl.appendChild(iconEl);
      
      // Message text
      const textEl = document.createElement('span');
      textEl.style.cssText = 'color:#fff; font-size:0.95rem; line-height:1.5; font-style:italic;';
      textEl.innerHTML = `"${styleActionText(content)}"`;
      msgEl.appendChild(textEl);
      
      messageEl.appendChild(msgEl);
    }
    
    chatMessages.appendChild(messageEl);
  }
  
  // Add a money request message with Accept/Deny/Counter buttons
  /**
   * Convert money request reason code to human-readable message
   */
  function getMoneyRequestMessage(emp, reason, amount) {
    const name = emp.name.split(' ')[0]; // First name only
    
    const messages = {
      rent: [
        `Hey boss, rent's due and I'm a bit short this month... Could really use some help ğŸ `,
        `Rent is coming up and I'm not quite there yet. Any chance you could help me out? ğŸ¢`,
        `My landlord's not gonna be happy if I'm late again... Could you spot me for rent? ğŸ™`,
        `Struggling to make rent this month. Would really appreciate the help! ğŸ `
      ],
      bills: [
        `Bills are piling up and I'm getting stressed... Could you help me out? ğŸ’³`,
        `Got hit with some unexpected bills this month. Any way you could help? ğŸ“„`,
        `My utilities are overdue and I'm worried they'll cut service... Help? ğŸ’¡`,
        `Credit card bill is brutal this month. Could really use some assistance ğŸ’³`
      ],
      emergency: [
        `Boss, I have an emergency situation and really need your help ğŸš¨`,
        `Something urgent came up and I need money ASAP. Can you help? ğŸ˜°`,
        `I'm in a bit of an emergency here... Could really use your support ğŸ†˜`,
        `This is urgent - I really need financial help right now ğŸš¨`
      ],
      car_repair: [
        `My car broke down and the repair is expensive... Could you help me out? ğŸš—`,
        `Mechanic quoted me way more than expected for the repair. Any chance you could help? ğŸ”§`,
        `Car's in the shop and I can't afford to get it out. Help? ğŸš™`,
        `Need to fix my car or I can't get to work... Could you spot me? ğŸš—ğŸ’¨`
      ],
      medical: [
        `Medical bills are killing me... Could you help cover some of it? ğŸ¥`,
        `Had to see the doctor and the bill is brutal. Any way you could help? ğŸ’Š`,
        `Health insurance didn't cover everything... Could really use help with medical costs ğŸ¥`,
        `These medical expenses are way more than I expected. Help? ğŸ’‰`
      ],
      help_family: [
        `My family needs help and I'm trying to support them... Could you spare something? ğŸ‘¨â€ğŸ‘©â€ğŸ‘§`,
        `Family emergency - need to send money home. Can you help me out? â¤ï¸`,
        `My parents need financial help and I want to be there for them... ğŸ™`,
        `Trying to help my family through a tough time. Could you contribute? ğŸ‘ª`
      ],
      special_occasion: [
        `There's a special event coming up and I want to make it memorable... Help? ğŸ‰`,
        `Got something important to celebrate but I'm broke... Could you help? ğŸŠ`,
        `Want to do something nice for [occasion] but need financial help ğŸ`,
        `Special occasion coming up and I'm short on cash... Any chance you could help? ğŸ¥³`
      ],
      treat_myself: [
        `I've been working so hard lately... Think I could get a little something to treat myself? ğŸ›ï¸`,
        `Been feeling stressed and want to do something nice for myself... Help me out? ğŸ’†`,
        `I deserve a little treat after everything, right? Could you help? âœ¨`,
        `Want to pamper myself a bit but money's tight... Could you spare some? ğŸ’…`,
        `Thinking of treating myself to something nice... Would you help make that happen? ğŸ`
      ]
    };
    
    const reasonMessages = messages[reason] || messages.bills;
    const selectedMessage = reasonMessages[Math.floor(Math.random() * reasonMessages.length)];
    
    return selectedMessage;
  }
  
  function addMoneyRequestMessage(emp, amount, reason, messageIndex, isSettled = false) {
    if (!chatMessages) return;
    
    // SAFETY CHECK: Ensure amount is a valid number (backwards compatibility)
    amount = typeof amount === 'number' && !isNaN(amount) ? amount : 100;
    
    const messageEl = document.createElement('div');
    messageEl.style.cssText = 'max-width:80%; padding:10px 15px; border-radius:18px; margin-bottom:10px; word-wrap:break-word; position:relative; background:#0f3460; align-self:flex-start; border:2px solid #4ecca3;';
    
    // Message content
    // Reason can be either an AI-generated message or a template key
    // If it's a template key (like 'rent', 'bills'), generate the message
    // If it's already a full message, use it directly
    const textEl = document.createElement('p');
    textEl.style.margin = '0 0 10px 0';
    
    let requestMessage;
    const templateKeys = ['rent', 'bills', 'emergency', 'car_repair', 'medical', 'help_family', 'special_occasion', 'treat_myself'];
    
    if (templateKeys.includes(reason)) {
      // It's a template key, generate message
      requestMessage = getMoneyRequestMessage(emp, reason, amount);
    } else {
      // It's already a full message (AI-generated or otherwise)
      requestMessage = reason;
    }
    
    textEl.innerHTML = styleActionText(requestMessage);
    messageEl.appendChild(textEl);
    
    // Money request badge
    const badge = document.createElement('div');
    badge.style.cssText = 'display:inline-block; background:#4ecca3; color:#16213e; padding:5px 10px; border-radius:8px; font-weight:600; margin-bottom:10px;';
    badge.textContent = `ğŸ’° $${formatCash(amount)}`;
    messageEl.appendChild(badge);
    
    // Only show buttons if request is NOT settled
    if (!isSettled) {
      // Button container
      const btnContainer = document.createElement('div');
      btnContainer.style.cssText = 'display:flex; gap:8px; margin-top:10px;';
      btnContainer.id = `money-request-${messageIndex}`;
      
      // Accept button
      const acceptBtn = document.createElement('button');
      acceptBtn.style.cssText = 'flex:1; padding:8px 12px; background:#4ecca3; border:none; border-radius:6px; color:#16213e; cursor:pointer; font-weight:600; transition:all 0.2s;';
      acceptBtn.textContent = 'âœ“ Accept';
      acceptBtn.addEventListener('mouseenter', () => {
        acceptBtn.style.background = '#5efcb3';
      });
      acceptBtn.addEventListener('mouseleave', () => {
        acceptBtn.style.background = '#4ecca3';
      });
      acceptBtn.addEventListener('click', async () => {
        await handleMoneyRequestResponse(emp, amount, reason, messageIndex, 'accept');
      });
      
      // Counter button (new!)
      const counterBtn = document.createElement('button');
      counterBtn.style.cssText = 'flex:1; padding:8px 12px; background:#ff9800; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; transition:all 0.2s;';
      counterBtn.textContent = 'â†”ï¸ Counter';
      counterBtn.addEventListener('mouseenter', () => {
        counterBtn.style.background = '#ffa726';
      });
      counterBtn.addEventListener('mouseleave', () => {
        counterBtn.style.background = '#ff9800';
      });
      counterBtn.addEventListener('click', () => {
        openCounterOfferModal(emp, amount, reason, messageIndex);
      });
      
      // Deny button
      const denyBtn = document.createElement('button');
      denyBtn.style.cssText = 'flex:1; padding:8px 12px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; transition:all 0.2s;';
      denyBtn.textContent = 'âœ— Deny';
      denyBtn.addEventListener('mouseenter', () => {
        denyBtn.style.background = '#ff5570';
      });
      denyBtn.addEventListener('mouseleave', () => {
        denyBtn.style.background = '#e94560';
      });
      denyBtn.addEventListener('click', async () => {
        await handleMoneyRequestResponse(emp, amount, reason, messageIndex, 'deny');
      });
      
      btnContainer.appendChild(acceptBtn);
      btnContainer.appendChild(counterBtn);
      btnContainer.appendChild(denyBtn);
      messageEl.appendChild(btnContainer);
    }
    
    chatMessages.appendChild(messageEl);
  }
  
  // Handle money request response (Accept/Deny/Counter)
  async function handleMoneyRequestResponse(emp, amount, reason, messageIndex, action) {
    // Remove the buttons
    const btnContainer = document.getElementById(`money-request-${messageIndex}`);
    if (btnContainer) {
      btnContainer.remove();
    }
    
    // CRITICAL FIX: Mark the original money request message as settled in chatHistory
    if (gameState.chatHistory[emp.id] && gameState.chatHistory[emp.id][messageIndex]) {
      gameState.chatHistory[emp.id][messageIndex].settled = true;
      gameState.chatHistory[emp.id][messageIndex].settlementAction = action;
      gameState.chatHistory[emp.id][messageIndex].settlementTimestamp = gameState.time?.currentTime || Date.now();
      // Save immediately so the settled state persists
      saveGame(false);
    }
    
    if (action === 'accept') {
      // Check if player has enough money
      if (gameState.cash < amount) {
        addChatMessage('You', `[Insufficient funds - need $${formatCash(amount)}]`, true);
        
        // NPC reaction to rejection due to no money
        const response = await queuedGenerateText(`${emp.name} (${emp.personality}) asked you for $${formatCash(amount)} but you don't have enough money. Respond to being told you can't afford it (2-3 sentences, conversational).`, {}, `Generating insufficient funds response for ${emp.name}`);
        const sanitized = sanitizeNpcResponse(response, 3);
        
        gameState.chatHistory[emp.id].push({
          sender: emp.name,
          content: sanitized,
          isPlayer: false,
          timestamp: gameState.time?.currentTime || Date.now()
        });
        
        const newIndex = gameState.chatHistory[emp.id].length - 1;
        addChatMessage(emp.name, sanitized, false, null, newIndex);
        
        return;
      }
      
      // Mark NPC as typing
      if (!gameState.typingStates) gameState.typingStates = {};
      gameState.typingStates[emp.id] = true;
      
      // Show typing indicator (only if this is the active chat)
      if (chatTypingIndicator && chatTypingName && gameState.activeChat?.id === emp.id) {
        chatTypingIndicator.style.display = 'block';
        chatTypingName.textContent = emp.name;
      }
      
      // Update bank balance
      if (!emp.bankBalance) emp.bankBalance = 0;
      emp.bankBalance += amount;
      
      // Clear money request flag - request was answered
      if (emp.proactiveMessages) {
        emp.proactiveMessages.hasUnrepliedMoneyRequest = false;
        console.log(`[Money Request] ${emp.name}: Request accepted - flag cleared`);
      }
      
      // Deduct money
      gameState.cash = Math.max(0, gameState.cash - amount);
      updateUI();
      
      // Add acceptance message
      addChatMessage('You', `âœ“ Accepted - Sent $${formatCash(amount)}`, true);
      
      // Add to history
      gameState.chatHistory[emp.id].push({
        sender: 'You',
        content: `âœ“ Accepted money request - Sent $${formatCash(amount)}`,
        isPlayer: true,
        isMoneyRequest: true,
        accepted: true,
        amount: amount,
        timestamp: gameState.time?.currentTime || Date.now()
      });
      
      // Generate grateful response
      const conversationHistory = gameState.chatHistory[emp.id]
        .slice(-10)
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      const responsePrompt = `${buildChatPrompt(emp, conversationHistory, '').prompt}

You just asked the player for $${formatCash(amount)} (reason: "${reason}") and they ACCEPTED and sent you the money!

Respond with gratitude and acknowledgment (3-8 sentences). Consider:
- Your personality (${emp.personality})
- Your relationship with them (Affection: ${emp.stats?.affection || 0}, Obedience: ${emp.obedience}, Desire: ${emp.desire}, Trust: ${emp.trust})
- What you asked the money for
- How this makes you feel about them

${emp.name}'s response:`;
      
      const raw = await queuedGenerateText(responsePrompt, {}, `Generating money grant response for ${emp.name}`);
      const response = sanitizeNpcResponse(raw, 10);
      
      // Clear typing state
      gameState.typingStates[emp.id] = false;
      
      // Hide typing indicator (only if this is still the active chat)
      if (chatTypingIndicator && gameState.activeChat?.id === emp.id) {
        chatTypingIndicator.style.display = 'none';
      }
      
      gameState.chatHistory[emp.id].push({
        sender: emp.name,
        content: response,
        isPlayer: false,
        timestamp: gameState.time?.currentTime || Date.now()
      });
      
      // Only add message to UI if this is still the active chat
      if (gameState.activeChat?.id === emp.id && chatMessages) {
        const newIndex = gameState.chatHistory[emp.id].length - 1;
        addChatMessage(emp.name, response, false, null, newIndex);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Update stats - accepting requests increases favor
      emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 8);
      emp.trust = Math.min(100, (emp.trust || 0) + 8);
      emp.obedience = Math.min(100, (emp.obedience || 0) + 5);
      emp.desire = Math.min(100, (emp.desire || 0) + 3);
      
      showNotification(`ğŸ’° Gave ${emp.name} $${formatCash(amount)}\n+8 Affection, +8 Trust, +5 Obedience, +3 Desire`, 'success');
      
      // Memory
      remember(emp, `Boss accepted my request for $${formatCash(amount)} (${reason})`, 'event', 2.0);
      
      updateUI();
      
    } else if (action === 'deny') {
      // Denied
      addChatMessage('You', `âœ— Denied money request`, true);
      
      gameState.chatHistory[emp.id].push({
        sender: 'You',
        content: `âœ— Denied money request for $${formatCash(amount)}`,
        isPlayer: true,
        isMoneyRequest: true,
        accepted: false,
        amount: amount,
        timestamp: gameState.time?.currentTime || Date.now()
      });
      
      // Clear money request flag - request was answered
      if (emp.proactiveMessages) {
        emp.proactiveMessages.hasUnrepliedMoneyRequest = false;
        console.log(`[Money Request] ${emp.name}: Request denied - flag cleared`);
      }
      
      // Mark NPC as typing
      if (!gameState.typingStates) gameState.typingStates = {};
      gameState.typingStates[emp.id] = true;
      
      // Show typing indicator (only if this is the active chat)
      if (chatTypingIndicator && chatTypingName && gameState.activeChat?.id === emp.id) {
        chatTypingIndicator.style.display = 'block';
        chatTypingName.textContent = emp.name;
      }
      
      // Generate disappointed response
      const conversationHistory = gameState.chatHistory[emp.id]
        .slice(-10)
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      const responsePrompt = `${buildChatPrompt(emp, conversationHistory, '').prompt}

You just asked the player for $${formatCash(amount)} (reason: "${reason}") and they DENIED your request.

Respond with disappointment but stay in character (3-6 sentences). Consider:
- Your personality (${emp.personality})
- Your relationship with them (Affection: ${emp.stats?.affection || 0}, Obedience: ${emp.obedience}, Desire: ${emp.desire}, Trust: ${emp.trust})
- What you asked the money for
- How this rejection makes you feel

${emp.name}'s response:`;
      
      const raw = await queuedGenerateText(responsePrompt, {}, `Generating money rejection response for ${emp.name}`);
      const response = sanitizeNpcResponse(raw, 8);
      
      // Clear typing state
      gameState.typingStates[emp.id] = false;
      
      // Hide typing indicator (only if this is still the active chat)
      if (chatTypingIndicator && gameState.activeChat?.id === emp.id) {
        chatTypingIndicator.style.display = 'none';
      }
      
      gameState.chatHistory[emp.id].push({
        sender: emp.name,
        content: response,
        isPlayer: false,
        timestamp: gameState.time?.currentTime || Date.now()
      });
      
      // Only add message to UI if this is still the active chat
      if (gameState.activeChat?.id === emp.id && chatMessages) {
        const newIndex = gameState.chatHistory[emp.id].length - 1;
        addChatMessage(emp.name, response, false, null, newIndex);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Update stats - denying requests decreases favor slightly
      emp.stats.affection = Math.max(0, (emp.stats.affection || 0) - 3);
      emp.trust = Math.max(0, (emp.trust || 0) - 3);
      emp.desire = Math.max(0, (emp.desire || 0) - 2);
      
      showNotification(`${emp.name} was denied\n-3 Affection, -3 Trust, -2 Desire`, 'warning');
      
      // Memory
      remember(emp, `Boss denied my request for $${formatCash(amount)} (${reason})`, 'event', 1.5);
      
      updateUI();
    }
    
    // Scroll to bottom
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }
  
  // Open counter offer modal
  function openCounterOfferModal(emp, requestedAmount, reason, messageIndex) {
    // Store context for later
    window.counterOfferContext = { emp, requestedAmount, reason, messageIndex };
    
    // Populate modal
    document.getElementById('counterOriginalAmount').textContent = '$' + formatCash(requestedAmount);
    document.getElementById('counterYourBalance').textContent = '$' + formatCash(gameState.cash);
    document.getElementById('counterAmount').value = '';
    document.getElementById('counterJustification').value = '';
    
    // Show modal
    document.getElementById('counterOfferModal').style.display = 'flex';
  }
  
  // Handle counter offer submission
  async function submitCounterOffer() {
    const context = window.counterOfferContext;
    if (!context) return;
    
    const { emp, requestedAmount, reason, messageIndex } = context;
    
    const counterAmount = parseInt(document.getElementById('counterAmount').value) || 0;
    const justification = document.getElementById('counterJustification').value.trim();
    
    if (counterAmount <= 0) {
      showNotification('âŒ Please enter a valid amount', 'error');
      return;
    }
    
    if (counterAmount > gameState.cash) {
      showNotification('âŒ Insufficient funds!', 'error');
      return;
    }
    
    // Close modal
    document.getElementById('counterOfferModal').style.display = 'none';
    
    // Remove the buttons from the original request
    const btnContainer = document.getElementById(`money-request-${messageIndex}`);
    if (btnContainer) {
      btnContainer.remove();
    }
    
    // CRITICAL FIX: Mark the original money request message as settled in chatHistory
    if (gameState.chatHistory[emp.id] && gameState.chatHistory[emp.id][messageIndex]) {
      gameState.chatHistory[emp.id][messageIndex].settled = true;
      gameState.chatHistory[emp.id][messageIndex].settlementAction = 'counter';
      gameState.chatHistory[emp.id][messageIndex].counterAmount = counterAmount;
      gameState.chatHistory[emp.id][messageIndex].settlementTimestamp = gameState.time?.currentTime || Date.now();
      // Save immediately so the settled state persists
      saveGame(false);
    }
    
    // Show typing indicator while NPC thinks about counter
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = emp.name;
    }
    
    // Update bank balance
    if (!emp.bankBalance) emp.bankBalance = 0;
    emp.bankBalance += counterAmount;
    
    // Clear money request flag - request was answered
    if (emp.proactiveMessages) {
      emp.proactiveMessages.hasUnrepliedMoneyRequest = false;
      console.log(`[Money Request] ${emp.name}: Counter offer sent - flag cleared`);
    }
    
    // Deduct money
    gameState.cash = Math.max(0, gameState.cash - counterAmount);
    updateUI();
    
    // Add counter offer message
    const counterMessage = justification
      ? `ğŸ’° Counter: Sending $${formatCash(counterAmount)} instead\n"${justification}"`
      : `ğŸ’° Counter: Sending $${formatCash(counterAmount)} instead of requested $${formatCash(requestedAmount)}`;
    
    addChatMessage('You', counterMessage, true);
    
    gameState.chatHistory[emp.id].push({
      sender: 'You',
      content: counterMessage,
      isPlayer: true,
      isCounterOffer: true,
      requestedAmount: requestedAmount,
      counterAmount: counterAmount,
      justification: justification,
      timestamp: gameState.time?.currentTime || Date.now()
    });
    
    // Generate NPC reaction to counter offer
    const conversationHistory = gameState.chatHistory[emp.id]
      .slice(-10)
      .map(msg => `${msg.sender}: ${msg.content}`)
      .join('\n');
    
    const diff = counterAmount - requestedAmount;
    const diffPercent = Math.round((diff / requestedAmount) * 100);
    const isMore = diff > 0;
    const isLess = diff < 0;
    const isSame = diff === 0;
    
    const responsePrompt = `${buildChatPrompt(emp, conversationHistory, '').prompt}

You asked the boss for $${formatCash(requestedAmount)} (reason: "${reason}").
Instead of accepting or denying, they made a COUNTER OFFER: $${formatCash(counterAmount)} (${diffPercent > 0 ? '+' : ''}${diffPercent}% ${isMore ? 'MORE' : isLess ? 'LESS' : 'same'}!)
${justification ? `\nTheir justification: "${justification}"` : ''}

Respond to this counter offer naturally (3-8 sentences). Consider:
- Your personality (${emp.personality})
- The difference: ${isMore ? `They're giving you MORE than you asked for!` : isLess ? `They're offering LESS than you need` : `They agreed to the exact amount`}
- Your relationship with them (Affection: ${emp.stats?.affection || 0}, Trust: ${emp.trust}, Desire: ${emp.desire})
- What you asked the money for originally
${justification ? `- Their explanation for the amount` : ''}

Possible reactions:
${isMore ? `- Surprised, grateful, maybe a bit suspicious or excited
- "Wait, you're giving me MORE? Seriously? Thank you so much!"` : ''}
${isLess ? `- Disappointed but understanding, or frustrated depending on your personality
- "I appreciate it but... I really needed the full amount"
- Or: "That helps, thanks. I'll make it work"` : ''}
${isSame ? `- A bit confused why they didn't just accept, but grateful
- "Okay... so that's the same as I asked? Thanks I guess!"` : ''}

${emp.name}'s response:`;
    
    const raw = await queuedGenerateText(responsePrompt, {}, `Generating custom amount response for ${emp.name}`);
    const response = sanitizeNpcResponse(raw, 10);
    
    // Hide typing indicator
    if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
    
    gameState.chatHistory[emp.id].push({
      sender: emp.name,
      content: response,
      isPlayer: false,
      timestamp: gameState.time?.currentTime || Date.now()
    });
    
    // Only add message to UI if this is still the active chat
    if (gameState.activeChat?.id === emp.id && chatMessages) {
      const newIndex = gameState.chatHistory[emp.id].length - 1;
      addChatMessage(emp.name, response, false, null, newIndex);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    // Update stats based on counter offer
    let favorChange = 0;
    let trustChange = 0;
    let desireChange = 0;
    
    if (isMore) {
      // Gave MORE - big bonus!
      favorChange = 12;
      trustChange = 10;
      desireChange = 6;
    } else if (isSame) {
      // Same amount - standard acceptance
      favorChange = 8;
      trustChange = 8;
      desireChange = 3;
    } else {
      // Gave LESS - small bonus but some disappointment
      const lessPenalty = Math.min(5, Math.abs(diffPercent) / 20);
      favorChange = Math.max(2, 8 - lessPenalty);
      trustChange = Math.max(2, 8 - lessPenalty);
      desireChange = Math.max(1, 3 - lessPenalty / 2);
    }
    
    emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + favorChange);
    emp.trust = Math.min(100, (emp.trust || 0) + trustChange);
    emp.desire = Math.min(100, (emp.desire || 0) + desireChange);
    emp.obedience = Math.min(100, (emp.obedience || 0) + Math.floor(favorChange / 2));
    
    showNotification(`ğŸ’° Counter sent: $${formatCash(counterAmount)}\n+${favorChange} Affection, +${trustChange} Trust, +${desireChange} Desire`, 'success');
    
    // Memory
    remember(emp, `Boss countered my $${formatCash(requestedAmount)} request with $${formatCash(counterAmount)}${justification ? ` - "${justification}"` : ''}`, 'event', 2.0);
    
    updateUI();
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }
  
  // ============================================
  // NPC ACTION BUTTONS SYSTEM
  // ============================================
  
  /**
   * Default action buttons available for all NPCs
   * Can be customized per-employee via employee.actionButtons array
   */
  const DEFAULT_NPC_ACTION_BUTTONS = [
    {
      id: 'continue',
      name: 'â–¶ï¸ Continue',
      instruction: 'Continue the conversation naturally. Add more detail or action to the scene.',
      autoSend: true,
      emoji: 'â–¶ï¸',
      enabled: true // DEFAULT ENABLED
    },
    {
      id: 'action',
      name: 'ğŸ¬ Action',
      instruction: '{{char}} does NOT speak or say anything. Output ONLY a highly-detailed physical action. Describe what {{char}} does with their body - movement, gestures, positioning, physical interaction with the environment or other characters. Focus purely on showing, not telling.',
      autoSend: true,
      emoji: 'ğŸ¬',
      enabled: true // DEFAULT ENABLED
    },
    {
      id: 'thoughts',
      name: 'ğŸ’­ Thoughts',
      instruction: 'Write internal thoughts. What is {{char}} thinking right now? Show inner monologue.',
      autoSend: true,
      emoji: 'ğŸ’­',
      enabled: false // Disabled by default - enable in settings
    },
    {
      id: 'flirt',
      name: 'ğŸ’• Flirt',
      instruction: '{{char}} flirts or shows romantic/sexual interest. Be playful and suggestive.',
      autoSend: true,
      emoji: 'ğŸ’•',
      enabled: false, // Disabled by default
      minDesire: 20 // Only show if desire >= 20
    },
    {
      id: 'react',
      name: 'ğŸ˜® React',
      instruction: 'Show emotional reaction to the current situation. Express feelings through words and actions.',
      autoSend: true,
      emoji: 'ğŸ˜®',
      enabled: false // Disabled by default
    },
    {
      id: 'tease',
      name: 'ğŸ˜ Tease',
      instruction: '{{char}} teases or playfully challenges. Be cheeky and mischievous.',
      autoSend: true,
      emoji: 'ğŸ˜',
      enabled: false, // Disabled by default
      minFlirty: 30 // Only show if personality flirty >= 30
    },
    {
      id: 'comply',
      name: 'âœ… Comply',
      instruction: '{{char}} agrees and complies with what was just said or requested.',
      autoSend: true,
      emoji: 'âœ…',
      enabled: false // Disabled by default
    },
    {
      id: 'resist',
      name: 'â›” Resist',
      instruction: '{{char}} pushes back, resists, or expresses reluctance. Stay in character.',
      autoSend: true,
      emoji: 'â›”',
      enabled: false // Disabled by default
    },
    {
      id: 'change_subject',
      name: 'ğŸ”„ Topic',
      instruction: '{{char}} smoothly changes the subject to something else.',
      autoSend: true,
      emoji: 'ğŸ”„',
      enabled: false // Disabled by default
    },
    {
      id: 'custom',
      name: 'âœï¸ Custom',
      instruction: '', // Will be filled by player
      autoSend: false, // Opens input for custom instruction
      emoji: 'âœï¸',
      enabled: false // Disabled by default
    }
  ];
  
  // Track action bar collapsed state
  let npcActionBarCollapsed = false;
  
  /**
   * Toggle the NPC action bar collapsed state
   */
  function toggleNpcActionBar() {
    npcActionBarCollapsed = !npcActionBarCollapsed;
    const container = document.getElementById('npcActionButtonsContainer');
    const icon = document.getElementById('npcActionToggleIcon');
    
    if (container) {
      if (npcActionBarCollapsed) {
        container.style.maxHeight = '0';
        container.style.padding = '0 15px';
        container.style.opacity = '0';
        container.style.overflow = 'hidden';
      } else {
        container.style.maxHeight = '200px';
        container.style.padding = '4px 15px 10px 15px';
        container.style.opacity = '1';
        container.style.overflow = 'auto';
      }
    }
    
    if (icon) {
      icon.style.transform = npcActionBarCollapsed ? 'rotate(-90deg)' : 'rotate(0deg)';
    }
    
    // Save preference
    if (gameState.settings) {
      gameState.settings.npcActionBarCollapsed = npcActionBarCollapsed;
    }
  }
  
  /**
   * Render NPC action buttons for the current chat
   */
  function renderNpcActionButtons(employee) {
    const container = document.getElementById('npcActionButtonsContainer');
    if (!container) return;
    
    // Clear existing buttons
    container.innerHTML = '';
    
    // Restore collapsed state if saved
    if (gameState.settings?.npcActionBarCollapsed) {
      npcActionBarCollapsed = true;
      container.style.maxHeight = '0';
      container.style.padding = '0 15px';
      container.style.opacity = '0';
      container.style.overflow = 'hidden';
      const icon = document.getElementById('npcActionToggleIcon');
      if (icon) icon.style.transform = 'rotate(-90deg)';
    }
    
    // Get available action buttons for this employee
    const actionButtons = getAvailableActionButtons(employee);
    
    // Create button wrapper - mobile-friendly with flex-wrap
    const buttonWrapper = document.createElement('div');
    buttonWrapper.style.cssText = `
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      align-items:center;
      width:100%;
    `;
    
    // Render each button - compact for mobile
    actionButtons.forEach(action => {
      const btn = document.createElement('button');
      btn.className = 'npc-action-btn';
      btn.dataset.actionId = action.id;
      btn.style.cssText = `
        padding:6px 10px;
        background:${action.id === 'custom' ? '#555' : '#0f3460'};
        border:1px solid ${action.id === 'custom' ? '#777' : '#4ecca3'};
        border-radius:16px;
        color:white;
        cursor:pointer;
        font-size:0.75rem;
        font-weight:500;
        transition:all 0.2s;
        display:inline-flex;
        align-items:center;
        gap:3px;
        white-space:nowrap;
        flex-shrink:0;
        min-height:28px;
        touch-action:manipulation;
      `;
      btn.innerHTML = `${action.emoji} <span class="action-btn-text">${action.name.replace(action.emoji + ' ', '')}</span>`;
      btn.title = action.instruction || 'Custom action';
      
      // Touch/hover effects
      btn.addEventListener('mouseenter', () => {
        btn.style.background = action.id === 'custom' ? '#666' : '#4ecca3';
        btn.style.color = action.id === 'custom' ? 'white' : '#0f1419';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.background = action.id === 'custom' ? '#555' : '#0f3460';
        btn.style.color = 'white';
      });
      
      // Click handler
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        handleNpcActionButtonClick(employee, action);
      });
      
      buttonWrapper.appendChild(btn);
    });
    
    // Add edit/configure button
    const editBtn = document.createElement('button');
    editBtn.style.cssText = `
      padding:6px 10px;
      background:transparent;
      border:1px dashed #555;
      border-radius:16px;
      color:#777;
      cursor:pointer;
      font-size:0.7rem;
      min-height:28px;
      touch-action:manipulation;
    `;
    editBtn.textContent = 'âš™ï¸';
    editBtn.title = 'Configure action buttons';
    editBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      showActionButtonConfigModal(employee);
    });
    buttonWrapper.appendChild(editBtn);
    
    container.appendChild(buttonWrapper);
  }
  
  /**
   * Get available action buttons for an employee based on their stats/personality
   */
  function getAvailableActionButtons(employee) {
    // Use custom buttons if defined, otherwise use defaults
    const buttons = employee.actionButtons || DEFAULT_NPC_ACTION_BUTTONS;
    
    // Filter based on conditions
    return buttons.filter(action => {
      // Check if action is enabled (default to true for backwards compatibility)
      if (action.enabled === false) return false;
      
      // Check minimum desire requirement
      if (action.minDesire !== undefined) {
        const desire = employee.stats?.desire || 0;
        if (desire < action.minDesire) return false;
      }
      
      // Check minimum flirty personality requirement
      if (action.minFlirty !== undefined) {
        const flirty = employee.personality?.flirty || 0;
        if (flirty < action.minFlirty) return false;
      }
      
      // Check minimum affection requirement
      if (action.minAffection !== undefined) {
        const affection = employee.stats?.affection || 0;
        if (affection < action.minAffection) return false;
      }
      
      return true;
    });
  }
  
  /**
   * Handle click on an NPC action button
   */
  async function handleNpcActionButtonClick(employee, action) {
    if (action.id === 'custom') {
      // Insert /do prefix into chat input for custom actions
      const chatInput = document.getElementById('chatInput');
      if (chatInput) {
        chatInput.value = '/do ';
        chatInput.focus();
        // Set cursor at end
        chatInput.setSelectionRange(chatInput.value.length, chatInput.value.length);
      }
      return;
    }
    
    if (!action.autoSend) {
      // Put instruction in chat input for player to modify (with /do prefix)
      const chatInput = document.getElementById('chatInput');
      if (chatInput) {
        chatInput.value = `/do ${action.instruction.replace(/\{\{char\}\}/gi, employee.name)}`;
        chatInput.focus();
      }
      return;
    }
    
    // Auto-send: Generate NPC action immediately
    await triggerNpcAction(employee, action.instruction);
  }
  
  /**
   * Trigger an unprompted NPC action
   */
  async function triggerNpcAction(employee, instruction) {
    const employeeId = employee.id;
    const employeeName = employee.name;
    
    // Show typing indicator
    const chatTypingIndicator = $('chatTypingIndicator');
    const chatTypingName = $('chatTypingName');
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = employeeName;
    }
    
    // Mark as typing
    if (!gameState.typingStates) gameState.typingStates = {};
    gameState.typingStates[employeeId] = true;
    
    try {
      // Build conversation history
      const conversationHistory = (gameState.chatHistory[employeeId] || [])
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      ensureEmployeeMemory(employee);
      
      // Build special prompt for action
      const actionPrompt = buildActionPrompt(employee, conversationHistory, instruction);
      
      // Generate response
      const raw = await queuedGenerateText(actionPrompt, {}, `NPC Action for ${employeeName}`);
      const response = sanitizeNpcResponse(raw, 10);
      
      const responseTimestamp = gameState.time?.currentTime || Date.now();
      
      // Add to chat history (mark as action-triggered)
      gameState.chatHistory[employeeId].push({
        sender: employeeName,
        content: response,
        isPlayer: false,
        timestamp: responseTimestamp,
        isActionTriggered: true // Mark this was triggered by action button
      });
      
      // Save
      saveGame(false);
      
      // Clear typing state
      gameState.typingStates[employeeId] = false;
      
      // Hide typing indicator
      if (chatTypingIndicator) {
        chatTypingIndicator.style.display = 'none';
      }
      
      // Update chat display if still viewing this chat
      if (gameState.activeChat?.id === employeeId) {
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages) {
          const messageIndex = gameState.chatHistory[employeeId].length - 1;
          addChatMessage(employeeName, response, false, null, messageIndex, null, responseTimestamp);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      } else {
        // Increment unread if chat closed
        if (!employee.unreadMessages) employee.unreadMessages = 0;
        employee.unreadMessages++;
      }
      
      // Update stats based on interaction
      await updateEmployeeStatsFromChat(employee, '', response);
      
      // Analyze for flags
      analyzeConversationForFlags(employee, response);
      
    } catch (error) {
      console.error('Error triggering NPC action:', error);
      gameState.typingStates[employeeId] = false;
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      showNotification('Failed to generate action. Please try again.', 'error');
    }
  }
  
  /**
   * Build a prompt specifically for action button triggers
   */
  function buildActionPrompt(employee, conversationHistory, instruction) {
    const { prompt } = buildChatPrompt(employee, conversationHistory, '');
    
    // Replace {{char}} placeholder
    const processedInstruction = instruction.replace(/\{\{char\}\}/gi, employee.name);
    
    return `${prompt}

[SYSTEM INSTRUCTION - UNPROMPTED ACTION]
The player has triggered an action button. You should now respond with the following:
${processedInstruction}

This is NOT a message from the player. You are performing this action/thought unprompted.
Write ONLY as ${employee.name}. Do not write for the player.
Keep the response natural and in-character.`;
  }
  
  /**
   * Show modal for custom action input
   */
  function showCustomActionInputModal(employee) {
    const modal = document.createElement('div');
    modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:999999; display:flex; justify-content:center; align-items:center;';
    
    modal.innerHTML = `
      <div style="background:#16213e; padding:25px; border-radius:12px; max-width:500px; width:90%;">
        <h3 style="margin:0 0 15px 0; color:#4ecca3;">âœï¸ Custom Action for ${employee.name}</h3>
        <p style="color:#aaa; margin:0 0 15px 0; font-size:0.9rem;">
          Describe what ${employee.name} should do or say. This won't show as a player message.
        </p>
        <textarea id="customActionInput" placeholder="e.g., 'Lean in closer and whisper something suggestive' or 'Express worry about the upcoming deadline'" 
          style="width:100%; min-height:100px; padding:12px; background:#0f3460; border:1px solid #4ecca3; border-radius:8px; color:white; font-size:0.95rem; resize:vertical; font-family:inherit;"></textarea>
        <div style="display:flex; gap:10px; margin-top:15px; justify-content:flex-end;">
          <button id="cancelCustomAction" style="padding:10px 20px; background:#555; border:none; border-radius:6px; color:white; cursor:pointer;">Cancel</button>
          <button id="triggerCustomAction" style="padding:10px 20px; background:linear-gradient(135deg, #4ecca3 0%, #00d4ff 100%); border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">
            âœ¨ Trigger Action
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    const input = modal.querySelector('#customActionInput');
    input.focus();
    
    // Cancel button
    modal.querySelector('#cancelCustomAction').addEventListener('click', () => {
      modal.remove();
    });
    
    // Click outside to close
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });
    
    // Trigger button
    modal.querySelector('#triggerCustomAction').addEventListener('click', async () => {
      const instruction = input.value.trim();
      if (!instruction) {
        showNotification('Please enter an action instruction', 'error');
        return;
      }
      
      modal.remove();
      await triggerNpcAction(employee, instruction);
    });
    
    // Enter key to submit
    input.addEventListener('keydown', async (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        const instruction = input.value.trim();
        if (instruction) {
          modal.remove();
          await triggerNpcAction(employee, instruction);
        }
      }
    });
  }
  
  /**
   * Show configuration modal for action buttons
   */
  function showActionButtonConfigModal(employee) {
    const modal = document.createElement('div');
    modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:999999; display:flex; justify-content:center; align-items:center; overflow-y:auto;';
    
    // Get current buttons (use default if none set)
    const currentButtons = employee.actionButtons || [...DEFAULT_NPC_ACTION_BUTTONS];
    
    modal.innerHTML = `
      <div style="background:#16213e; padding:25px; border-radius:12px; max-width:600px; width:90%; max-height:90vh; overflow-y:auto; margin:20px;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
          <h3 style="margin:0; color:#4ecca3;">âš™ï¸ Configure Action Buttons</h3>
          <button id="closeActionConfig" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">âœ•</button>
        </div>
        
        <p style="color:#aaa; margin:0 0 20px 0; font-size:0.9rem;">
          Customize the action buttons for ${employee.name}. These let you guide the AI without sending a message.
        </p>
        
        <div id="actionButtonsList" style="display:flex; flex-direction:column; gap:10px; margin-bottom:20px;">
          ${currentButtons.map((btn, i) => `
            <div class="action-btn-config" data-index="${i}" style="background:#0f3460; padding:12px; border-radius:8px; display:flex; align-items:center; gap:10px;">
              <input type="checkbox" ${btn.enabled !== false ? 'checked' : ''} data-field="enabled" style="width:18px; height:18px;">
              <span style="font-size:1.2rem;">${btn.emoji}</span>
              <div style="flex:1;">
                <input type="text" value="${btn.name.replace(/"/g, '&quot;')}" data-field="name" 
                  style="width:100%; padding:4px 8px; background:#16213e; border:1px solid #555; border-radius:4px; color:white; font-weight:600; margin-bottom:4px;">
                <input type="text" value="${btn.instruction.replace(/"/g, '&quot;')}" data-field="instruction" placeholder="Instruction for AI..."
                  style="width:100%; padding:4px 8px; background:#16213e; border:1px solid #555; border-radius:4px; color:#aaa; font-size:0.85rem;">
              </div>
            </div>
          `).join('')}
        </div>
        
        <div style="background:#0f3460; padding:15px; border-radius:8px; margin-bottom:20px;">
          <h4 style="margin:0 0 10px 0; color:#ffd700;">â• Add Custom Action</h4>
          <div style="display:flex; gap:10px; flex-wrap:wrap;">
            <input type="text" id="newActionEmoji" placeholder="Emoji" maxlength="2" style="width:60px; padding:8px; background:#16213e; border:1px solid #555; border-radius:4px; color:white; text-align:center; font-size:1.2rem;">
            <input type="text" id="newActionName" placeholder="Button Name" style="flex:1; min-width:100px; padding:8px; background:#16213e; border:1px solid #555; border-radius:4px; color:white;">
          </div>
          <input type="text" id="newActionInstruction" placeholder="Instruction (e.g., 'Show nervousness' or '{{char}} blushes')" 
            style="width:100%; padding:8px; background:#16213e; border:1px solid #555; border-radius:4px; color:white; margin-top:10px;">
          <button id="addNewActionBtn" style="margin-top:10px; padding:8px 16px; background:#4ecca3; border:none; border-radius:6px; color:#0f1419; cursor:pointer; font-weight:600;">
            Add Action
          </button>
        </div>
        
        <div style="display:flex; gap:10px; justify-content:flex-end;">
          <button id="resetToDefaultActions" style="padding:10px 20px; background:#555; border:none; border-radius:6px; color:white; cursor:pointer;">
            Reset to Defaults
          </button>
          <button id="saveActionConfig" style="padding:10px 20px; background:linear-gradient(135deg, #4ecca3 0%, #00d4ff 100%); border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">
            ğŸ’¾ Save Changes
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Close button
    modal.querySelector('#closeActionConfig').addEventListener('click', () => {
      modal.remove();
    });
    
    // Click outside to close
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });
    
    // Add new action
    modal.querySelector('#addNewActionBtn').addEventListener('click', () => {
      const emoji = modal.querySelector('#newActionEmoji').value.trim() || 'ğŸ¯';
      const name = modal.querySelector('#newActionName').value.trim();
      const instruction = modal.querySelector('#newActionInstruction').value.trim();
      
      if (!name || !instruction) {
        showNotification('Please enter a name and instruction', 'error');
        return;
      }
      
      const newAction = {
        id: `custom_${Date.now()}`,
        name: `${emoji} ${name}`,
        instruction: instruction,
        autoSend: true,
        emoji: emoji,
        enabled: true
      };
      
      currentButtons.push(newAction);
      
      // Re-render list
      const listEl = modal.querySelector('#actionButtonsList');
      const newEl = document.createElement('div');
      newEl.className = 'action-btn-config';
      newEl.dataset.index = currentButtons.length - 1;
      newEl.style.cssText = 'background:#0f3460; padding:12px; border-radius:8px; display:flex; align-items:center; gap:10px;';
      newEl.innerHTML = `
        <input type="checkbox" checked data-field="enabled" style="width:18px; height:18px;">
        <span style="font-size:1.2rem;">${emoji}</span>
        <div style="flex:1;">
          <input type="text" value="${name}" data-field="name" 
            style="width:100%; padding:4px 8px; background:#16213e; border:1px solid #555; border-radius:4px; color:white; font-weight:600; margin-bottom:4px;">
          <input type="text" value="${instruction}" data-field="instruction" placeholder="Instruction for AI..."
            style="width:100%; padding:4px 8px; background:#16213e; border:1px solid #555; border-radius:4px; color:#aaa; font-size:0.85rem;">
        </div>
      `;
      listEl.appendChild(newEl);
      
      // Clear inputs
      modal.querySelector('#newActionEmoji').value = '';
      modal.querySelector('#newActionName').value = '';
      modal.querySelector('#newActionInstruction').value = '';
      
      showNotification('Action added!', 'success');
    });
    
    // Reset to defaults
    modal.querySelector('#resetToDefaultActions').addEventListener('click', () => {
      employee.actionButtons = undefined; // Remove custom, use defaults
      modal.remove();
      renderNpcActionButtons(employee);
      showNotification('Reset to default actions', 'success');
    });
    
    // Save changes
    modal.querySelector('#saveActionConfig').addEventListener('click', () => {
      const configItems = modal.querySelectorAll('.action-btn-config');
      const updatedButtons = [];
      
      configItems.forEach((item, i) => {
        const enabled = item.querySelector('[data-field="enabled"]')?.checked ?? true;
        const name = item.querySelector('[data-field="name"]')?.value || currentButtons[i]?.name;
        const instruction = item.querySelector('[data-field="instruction"]')?.value || currentButtons[i]?.instruction;
        
        if (enabled) {
          updatedButtons.push({
            ...currentButtons[i],
            name: name,
            instruction: instruction,
            enabled: true
          });
        }
      });
      
      employee.actionButtons = updatedButtons;
      modal.remove();
      renderNpcActionButtons(employee);
      saveGame();
      showNotification('Action buttons saved!', 'success');
    });
  }
  
  // Send chat message
  async function sendChatMessage() {
    if (!chatInput || !chatMessages) return;
    
    const message = chatInput.value.trim();
    if (!message || !gameState.activeChat) return;
    
    // Store employee ID for async operations
    const employeeId = gameState.activeChat.id;
    const employeeName = gameState.activeChat.name;
    
    // Check for /do command - triggers NPC action without showing player message
    // Syntax: /do <instruction> - e.g., "/do lean in closer" or "/do express nervousness"
    if (message.toLowerCase().startsWith('/do ')) {
      const instruction = message.slice(4).trim();
      if (instruction) {
        chatInput.value = '';
        const employee = gameState.employees.find(e => e.id === employeeId);
        if (employee) {
          await triggerNpcAction(employee, instruction);
        }
      }
      return;
    }
    
    const messageTimestamp = gameState.time?.currentTime || Date.now();
    
    // Add player message with timestamp
    addChatMessage('You', message, true, null, null, null, messageTimestamp);
    
    // Add to history
    if (!gameState.chatHistory[employeeId]) {
      gameState.chatHistory[employeeId] = [];
    }
    gameState.chatHistory[employeeId].push({
      sender: 'You',
      content: message,
      isPlayer: true,
      timestamp: messageTimestamp
    });
    
    // CRITICAL FIX: Save immediately after player sends message to prevent loss
    saveGame(false);
    
    // AI Optimization: Clear blocked status when player sends a message
    aiOptimization.blockedProactiveMessages.delete(employeeId);
    
    // Reset proactive message counter - player responded!
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (employee && employee.proactiveMessages) {
      employee.proactiveMessages.consecutiveUnreplied = 0;
      console.log(`[Proactive Message] ${employee.name}: Counter reset - Player responded`);
    }
    
    // Extract salient facts from user's message
    const facts = extractSalientFacts(message, gameState.activeChat);
    for (const f of facts) remember(gameState.activeChat, `Player ${f.text}`, f.type, f.importance);
    
    // Clear input
    chatInput.value = '';
    
    // Mark this NPC as typing
    if (!gameState.typingStates) gameState.typingStates = {};
    gameState.typingStates[employeeId] = true;
    
    // Show typing indicator (only if this is the active chat)
    if (chatTypingIndicator && chatTypingName && gameState.activeChat?.id === employeeId) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = employeeName;
    }
    
    // Generate AI response (async - continues even if chat closes)
    try {
      const conversationHistory = gameState.chatHistory[employeeId]
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');

      const emp = gameState.employees.find(e => e.id === employeeId);
      if (!emp) {
        // Clear typing state if employee not found
        gameState.typingStates[employeeId] = false;
        return;
      }
      
      ensureEmployeeMemory(emp);
      const { prompt, personalAllowed } = buildChatPrompt(emp, conversationHistory, message);
      const raw = await queuedGenerateText(prompt, {}, `Generating chat response for ${emp.name}`);
      const response = sanitizeNpcResponse(raw, 10);
      
      const responseTimestamp = gameState.time?.currentTime || Date.now();
      
      // Add to history first (works even if chat is closed)
      gameState.chatHistory[employeeId].push({
        sender: employeeName,
        content: response,
        isPlayer: false,
        timestamp: responseTimestamp
      });
      
      // CRITICAL FIX: Save immediately after AI response to prevent message loss
      saveGame(false);
      
      // Clear typing state for this NPC
      gameState.typingStates[employeeId] = false;
      
      // Mark as unread if chat is now closed
      if (!gameState.activeChat || gameState.activeChat.id !== employeeId) {
        if (!emp.unreadMessages) emp.unreadMessages = 0;
        emp.unreadMessages++;
      }
      
      // Hide typing indicator (only if still showing this chat)
      if (chatTypingIndicator && gameState.activeChat?.id === employeeId) {
        chatTypingIndicator.style.display = 'none';
      }
      
      // Add AI response to UI (only if chat is still open for this employee)
      if (gameState.activeChat?.id === employeeId && chatMessages) {
        const messageIndex = gameState.chatHistory[employeeId].length - 1;
        addChatMessage(employeeName, response, false, null, messageIndex, null, responseTimestamp);
        // Scroll to bottom
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Memory: capture key NPC claims minimally
      const respFacts = extractSalientFacts(response, emp);
      for (const f of respFacts) remember(emp, `${emp.name} ${f.text}`, f.type, f.importance);
      
      // Style counters: detect personal detail usage
      const mentionedHobby = (emp.hobbies || []).some(h => new RegExp(`\\b${h}\\b`, 'i').test(response));
      const mentionedJob = emp.productManaged && new RegExp(`\\b${emp.productManaged}\\b`, 'i').test(response);
      const mentionedPosition = emp.position && new RegExp(`\\b${emp.position}\\b`, 'i').test(response);
      
      emp.memory.styleCounters.total += 1;
      emp.memory.styleCounters.sincePersonal = (mentionedHobby || mentionedJob || mentionedPosition) ? 0 : Math.min(10, (emp.memory.styleCounters.sincePersonal || 0) + 1);
      
      // Track specific mention types
      if (mentionedJob || mentionedPosition) {
        emp.memory.styleCounters.jobMentions += 1;
        emp.memory.styleCounters.lastJobMention = emp.memory.styleCounters.total;
      }
      if (mentionedHobby) {
        emp.memory.styleCounters.hobbyMentions += 1;
        emp.memory.styleCounters.lastHobbyMention = emp.memory.styleCounters.total;
      }
      
      // Check if player is requesting a social post
      await detectPostRequest(emp, message, response);
      
      // Check if player is requesting an image/photo
      await detectImageRequest(emp, message, response);
      
      // Occasionally, NPC might request money (5% chance if certain conditions met)
      await considerMoneyRequest(emp, message, response);
      
      // Update employee stats based on conversation
      await updateEmployeeStatsFromChat(emp, message, response);
      
      // ========== FLAG DETECTION (NEW!) ==========
      // Analyze the AI response for flag patterns
      analyzeConversationForFlags(emp, response);
      
      // ========== SKILL XP GAINS (Phase 3) ==========
      // Process skill gains from chat interaction
      processSkillGainsFromChat(emp, message, response);
      
      // Log significant boss interactions as events (for potential social posts)
      const isSignificant = 
        /\b(date|dinner|coffee|love|cute|beautiful|sexy|promotion|raise|fire|bonus)\b/i.test(message) ||
        /\b(date|dinner|coffee|love|cute|beautiful|sexy|thank|appreciate)\b/i.test(response);
      
      if (isSignificant) {
        logCompanyEvent({
          type: 'boss_interaction',
          involvedEmployees: [employeeId],
          location: emp.locationId,
          description: `Boss chat with ${employeeName}: "${message.slice(0, 50)}${message.length > 50 ? '...' : ''}"`,
          sentiment: 'neutral',
          importance: 5
        });
      }
      
      // Update People tab if visible (to show unread badge)
      if (gameState.activeTab === 'people') {
        updatePeopleTab();
      }
      
      // Refresh dashboard to show new messages
      if (gameState.activeTab === 'dashboard') {
        refreshDashboardSections();
      }
      
    } catch (error) {
      console.error('Error generating chat response:', error);
      // Clear typing state for this NPC
      if (gameState.typingStates) {
        gameState.typingStates[employeeId] = false;
      }
      // Hide typing indicator if chat still open for this employee
      if (chatTypingIndicator && gameState.activeChat?.id === employeeId) {
        chatTypingIndicator.style.display = 'none';
      }
      // Only show error message if chat is still open for this employee
      if (gameState.activeChat?.id === employeeId && chatMessages) {
        addChatMessage(employeeName, "Sorry, I'm having trouble responding right now.", false);
      }
    }
  }
  
  // -------- PLAYER MESSAGE EDITING FUNCTIONS --------
  
  /**
   * Edit a previously sent player message
   */
  function editPlayerMessage(messageIndex) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    const history = gameState.chatHistory[emp.id];
    
    if (!history || messageIndex < 0 || messageIndex >= history.length) return;
    
    const message = history[messageIndex];
    if (!message.isPlayer) return; // Only edit player messages
    
    // Populate chat input with existing message
    if (chatInput) {
      chatInput.value = message.content;
      chatInput.focus();
      
      // Store the message index we're editing
      chatInput.dataset.editingIndex = messageIndex;
      
      // Change the send button to indicate we're editing
      const sendBtn = document.getElementById('chatSendBtn');
      if (sendBtn) {
        sendBtn.textContent = 'âœï¸ Update';
        sendBtn.style.backgroundColor = '#ff9800';
      }
      
      // Show a visual indicator
      showNotification('ğŸ’¬ Editing message. Press Update to replace it and regenerate response.', 3000);
    }
  }
  
  /**
   * Resend a player message (regenerates AI response without editing)
   */
  async function resendPlayerMessage(messageIndex) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    const history = gameState.chatHistory[emp.id];
    
    if (!history || messageIndex < 0 || messageIndex >= history.length) return;
    
    const message = history[messageIndex];
    if (!message.isPlayer) return; // Only resend player messages
    
    // Update timestamp to show it was resent
    history[messageIndex].timestamp = Date.now();
    
    // Delete all messages after this one
    gameState.chatHistory[emp.id] = history.slice(0, messageIndex + 1);
    
    // Reload chat to show truncated conversation
    loadChatHistory(emp.id);
    
    // Show typing indicator
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = emp.name;
    }
    
    // Show feedback
    showNotification('ğŸ”„ Resending message and generating new response...', 2000);
    
    // Generate new AI response with the same message
    try {
      const conversationHistory = gameState.chatHistory[emp.id]
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      ensureEmployeeMemory(emp);
      const { prompt } = buildChatPrompt(emp, conversationHistory, message.content);
      const raw = await queuedGenerateText(prompt, {}, `Generating auto chat response for ${emp.name}`);
      const response = sanitizeNpcResponse(raw, 5);
      
      // Add new response to history
      gameState.chatHistory[emp.id].push({
        sender: emp.name,
        content: response,
        isPlayer: false,
        timestamp: gameState.time?.currentTime || Date.now()
      });
      
      // Hide typing indicator
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      
      // Reload chat to show new response
      loadChatHistory(emp.id);
      
      // Update stats
      await updateEmployeeStatsFromChat(emp, message.content, response);
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
      
      showNotification('âœ… Message resent and new response generated!', 2000);
      
    } catch (error) {
      console.error('Error generating response after resend:', error);
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      showNotification('Failed to generate new response. Please try again.');
    }
  }
  
  /**
   * Modified send function to handle edits
   */
  async function sendOrUpdateChatMessage() {
    if (!chatInput || !chatMessages) return;
    
    const message = chatInput.value.trim();
    if (!message || !gameState.activeChat) return;
    
    const editingIndex = chatInput.dataset.editingIndex;
    
    // If we're editing, update the message and regenerate
    if (editingIndex !== undefined && editingIndex !== null) {
      const messageIndex = parseInt(editingIndex);
      const emp = gameState.activeChat;
      const history = gameState.chatHistory[emp.id];
      
      if (history && messageIndex >= 0 && messageIndex < history.length) {
        // Update the player message
        history[messageIndex].content = message;
        history[messageIndex].timestamp = gameState.time?.currentTime || Date.now();
        
        // Delete all messages after this one
        gameState.chatHistory[emp.id] = history.slice(0, messageIndex + 1);
        
        // CRITICAL FIX: Save immediately after editing message to prevent message loss
        saveGame(false);
        
        // Clear editing state
        delete chatInput.dataset.editingIndex;
        const sendBtn = document.getElementById('chatSendBtn');
        if (sendBtn) {
          sendBtn.textContent = 'Send';
          sendBtn.style.backgroundColor = '#4CAF50';
        }
        
        // Reload chat to show updated message
        loadChatHistory(emp.id);
        
        // Clear input
        chatInput.value = '';
        
        // Show typing indicator
        if (chatTypingIndicator && chatTypingName) {
          chatTypingIndicator.style.display = 'block';
          chatTypingName.textContent = emp.name;
        }
        
        // Generate new AI response
        try {
          const conversationHistory = gameState.chatHistory[emp.id]
            .map(msg => `${msg.sender}: ${msg.content}`)
            .join('\n');
          
          ensureEmployeeMemory(emp);
          const { prompt } = buildChatPrompt(emp, conversationHistory, message);
          const raw = await queuedGenerateText(prompt, {}, `Generating regenerated response for ${emp.name}`);
          const response = sanitizeNpcResponse(raw, 5);
          
          // Add new response to history
          gameState.chatHistory[emp.id].push({
            sender: emp.name,
            content: response,
            isPlayer: false,
            timestamp: gameState.time?.currentTime || Date.now()
          });
          
          // CRITICAL FIX: Save immediately after regenerated response to prevent message loss
          saveGame(false);
          
          // Hide typing indicator
          if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
          
          // Reload chat to show new response
          loadChatHistory(emp.id);
          
          // Update stats
          await updateEmployeeStatsFromChat(emp, message, response);
          
          // Scroll to bottom
          chatMessages.scrollTop = chatMessages.scrollHeight;
          
          showNotification('âœ… Message updated and response regenerated!', 2000);
          
        } catch (error) {
          console.error('Error generating response after edit:', error);
          if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
          showNotification('Failed to generate new response. Please try again.');
        }
        
        return; // Don't execute normal send logic
      }
    }
    
    // Normal send (not editing)
    await sendChatMessage();
  }
  
  // -------- POST REQUEST DETECTION AND HANDLING --------
  
  /**
   * Detect if player is requesting NPC to make a social post
   */
  async function detectPostRequest(employee, playerMessage, npcResponse) {
    // Keywords that suggest a post request
    const postKeywords = /\b(post|share|put.*on.*feed|upload|publish|make.*post|dare.*you.*to.*post)\b/i;
    const socialKeywords = /\b(social|feed|instagram|twitter|snap)\b/i;
    const contentKeywords = /\b(picture|photo|selfie|video|nude|naked|masturbat|explicit|sexy|hot|revealing)\b/i;
    
    // Check if player message looks like a post request
    const looksLikeRequest = postKeywords.test(playerMessage) && 
                             (socialKeywords.test(playerMessage) || contentKeywords.test(playerMessage));
    
    if (!looksLikeRequest) return;
    
    // Determine requested post type (prioritize explicit content detection)
    let requestedType = 'text';
    let requestContent = playerMessage;
    
    // IMPROVED: Better explicit content detection
    if (/\b(masturbat|dildo|vibrator|toy|finger.*yourself|play.*with.*yourself|touch.*yourself|spread|cum|orgasm|penetrat|squirt)\b/i.test(playerMessage)) {
      requestedType = 'explicit';
    } else if (/\b(nude|naked|full.*nude|nothing.*on|completely.*nude)\b/i.test(playerMessage)) {
      // Check if it's just "nude" or truly "explicit sexual"
      if (/\b(masturbat|touching|playing|spreading)\b/i.test(playerMessage)) {
        requestedType = 'explicit';
      } else {
        requestedType = 'nude';
      }
    } else if (/\b(thirst.*trap|sexy|hot.*pic|revealing|underwear|lingerie)\b/i.test(playerMessage)) {
      requestedType = 'thirst_trap';
    } else if (/\b(selfie|picture.*of.*you|photo.*of.*you)\b/i.test(playerMessage)) {
      requestedType = 'selfie';
    }
    
    // IMPROVED: Better agreement detection (catches hesitant agreement too)
    const strongAgree = /\b(okay|sure|alright|fine|will.*do|i'll.*post|i'll.*share)\b/i.test(npcResponse);
    const noRefusal = !/\b(don't|not|can't|won't|shouldn't|uncomfortable|not.*ready|too.*much)\b/i.test(npcResponse);
    const hesitantAgree = /\b(i.*guess|fine|okay.*okay)\b/i.test(npcResponse);
    
    const agreedInResponse = (strongAgree && noRefusal) || hesitantAgree;
    
    if (agreedInResponse) {
      // Send "working on it" message
      setTimeout(() => {
        if (gameState.activeChat?.id === employee.id && chatMessages) {
          const workingMessages = [
            "Give me a sec...",
            "Working on it",
            "One moment...",
            "Let me set this up..."
          ];
          const workingMsg = workingMessages[Math.floor(Math.random() * workingMessages.length)];
          
          gameState.chatHistory[employee.id].push({
            sender: employee.name,
            content: workingMsg,
            isPlayer: false,
            timestamp: gameState.time?.currentTime || Date.now()
          });
          
          const messageIndex = gameState.chatHistory[employee.id].length - 1;
          addChatMessage(employee.name, workingMsg, false, null, messageIndex);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }, 1000 + Math.random() * 1000);
      
      // NPC agreed! Generate and post it
      setTimeout(async () => {
        await generateRequestedPost(employee, requestedType, requestContent);
      }, 3000 + Math.random() * 4000); // 3-7 seconds delay
    }
  }
  
  /**
   * Detect if player is requesting NPC to send an image/photo
   */
  async function detectImageRequest(employee, playerMessage, npcResponse) {
    // Keywords that suggest an image request (but NOT a post request)
    const imageKeywords = /\b(send|show|picture|photo|selfie|pic|image|snap)\b/i;
    const meKeywords = /\b(me|to.*me)\b/i;
    const contentKeywords = /\b(nude|naked|lewd|sexy|revealing|underwear|lingerie|body|yourself|masturbat|dildo|toy|finger)\b/i;
    
    // Must NOT look like a post request (those are handled separately)
    const postKeywords = /\b(post|share|put.*on.*feed|upload|publish|make.*post)\b/i;
    const socialKeywords = /\b(social|feed|instagram|twitter|snap.*chat)\b/i;
    
    // Check if this looks like a post request - if so, skip (handled by detectPostRequest)
    const looksLikePostRequest = postKeywords.test(playerMessage) || socialKeywords.test(playerMessage);
    if (looksLikePostRequest) {
      console.log('[Image Detection] Skipping - looks like post request');
      return;
    }
    
    // Check if player message looks like an image request
    const looksLikeImageRequest = imageKeywords.test(playerMessage) && 
                                  (meKeywords.test(playerMessage) || contentKeywords.test(playerMessage));
    
    if (!looksLikeImageRequest) {
      console.log('[Image Detection] No image request detected');
      return;
    }
    
    console.log('[Image Detection] Image request detected in:', playerMessage.substring(0, 60));
    
    // Determine requested image type (prioritize explicit)
    let requestedType = 'casual';
    let requestContent = playerMessage;
    
    // IMPROVED: Better detection for explicit content
    if (/\b(masturbat|dildo|vibrator|toy|finger.*yourself|play.*with.*yourself|spread|touch.*yourself|cum|orgasm|penetrat|squirt|body.*writing|degradation)\b/i.test(playerMessage)) {
      requestedType = 'explicit';
    } else if (/\b(nude|naked|nothing.*on|completely.*nude|full.*nude|fully.*nude|bare|uncovered)\b/i.test(playerMessage)) {
      requestedType = 'nude';
    } else if (/\b(lewd|sexy|revealing|underwear|lingerie|bra|panties|topless|partially.*clothed|see.*through)\b/i.test(playerMessage)) {
      requestedType = 'lewd';
    } else if (/\b(work|office|professional)\b/i.test(playerMessage)) {
      requestedType = 'work';
    } else if (/\b(selfie|picture|photo)\b/i.test(playerMessage)) {
      requestedType = 'casual';
    }
    
    console.log('[Image Detection] Requested type:', requestedType);
    
    // PLAYER FEEDBACK FIX: Better agreement detection - catch when NPC describes sending image
    const strongAgree = /\b(okay|sure|alright|fine|here|sending|sent|check.*this|for.*you|attaching|attached)\b/i.test(npcResponse);
    const describingSending = /\b(send|sent|sending|here.*is|this.*is|look.*at|check.*out)\b/i.test(npcResponse);
    const imageDescribed = /\b(picture|photo|selfie|image|pic|snap)\b/i.test(npcResponse);
    const noRefusal = !/\b(don't|not|can't|won't|shouldn't|uncomfortable|not.*ready|too.*much|inappropriate|no)\b/i.test(npcResponse);
    const hesitantAgree = /\b(i.*guess|fine|okay.*okay|alright.*alright)\b/i.test(npcResponse);
    
    // Consider it agreed if they described sending/showing an image
    const agreedInResponse = ((strongAgree || describingSending) && noRefusal) || 
                            (describingSending && imageDescribed && noRefusal) ||
                            hesitantAgree;
    
    if (agreedInResponse) {
      console.log('[Image Detection] âœ… NPC agreed to send image:', employee.name);
      // NPC agreed! Generate and send the image
      setTimeout(async () => {
        await generateAndSendRequestedImage(employee, requestedType, requestContent);
      }, 2000 + Math.random() * 4000); // 2-6 seconds delay
    } else {
      console.log('[Image Detection] âŒ NPC did not agree to send image');
      console.log('[Image Detection] Response:', npcResponse.substring(0, 100));
    }
  }
  
  /**
   * Consider if NPC should request money from player
   * Happens occasionally based on relationship, personality, and conversation context
   */
  async function considerMoneyRequest(employee, playerMessage, npcResponse) {
    // ========================================================================
    // DISABLED: Reactive money request system
    // ========================================================================
    // This function was triggering money requests on EVERY player message during
    // active chats, causing excessive interruptions. The issues were:
    //
    // Problems with this reactive system:
    // - Only 1 hour real-time cooldown (way too frequent)
    // - Up to 20% chance PER MESSAGE (extremely high)
    // - No minimum message requirement
    // - Interrupting active, immersive conversations
    // - Separate tracking from proactive system (confusing)
    //
    // The proactive message system already handles money requests properly with:
    // - Minimum 30 messages before first request
    // - 7-14 game days between requests (much longer cooldown)
    // - Only 2-5% weight in message selection (very rare)
    // - Proper game-time tracking
    // - Blocks if player recently responded
    //
    // Solution: Disable this entirely. Money requests now ONLY come from the
    // proactive message system (generateProactiveMessage) which is properly
    // balanced and doesn't interrupt conversations.
    // ========================================================================
    return;
  }
  
  /**
   * Request a post from NPC via attachment menu
   */
  async function requestPostFromNPC(preset = null, customPrompt = null) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    let requestType = preset || 'text';
    let requestDescription = '';
    
    // Build request description based on preset or custom
    if (customPrompt) {
      requestDescription = customPrompt;
      // Try to detect type from custom prompt (prioritize explicit)
      if (/\b(masturbat|dildo|toy|vibrator|orgasm|cum|ejaculat|finger.*yourself|play.*with.*yourself|spread.*legs|degradation|body.*writing|explicit.*act)\b/i.test(customPrompt)) {
        requestType = 'explicit';
      } else if (/\b(nude|naked|full.*nude|completely.*nude|nothing.*on)\b/i.test(customPrompt)) {
        requestType = 'nude';
      } else if (/\b(thirst.*trap|sexy|revealing|underwear|lingerie|hot)\b/i.test(customPrompt)) {
        requestType = 'thirst_trap';
      } else if (/\b(selfie|picture)\b/i.test(customPrompt)) {
        requestType = 'selfie';
      }
    } else {
      // Use preset descriptions
      const presetDescriptions = {
        text: 'post a status update',
        selfie: 'post a selfie',
        thirst_trap: 'post a thirst trap (sexy/revealing photo)',
        nude: 'post a nude photo',
        explicit: 'post explicit sexual content (masturbation, toys, etc.)'
      };
      requestDescription = presetDescriptions[requestType] || 'make a post';
    }
    
    // Add request message to chat
    const requestMessage = customPrompt || `Could you ${requestDescription}?`;
    if (chatInput) chatInput.value = requestMessage;
    
    // Simulate clicking send
    await sendChatMessage();
    
    // Wait a moment, then check if NPC will agree
    setTimeout(async () => {
      await evaluateAndExecutePostRequest(emp, requestType, requestDescription);
    }, 3000);
  }
  
  /**
   * Evaluate if NPC agrees to post request and execute
   */
  async function evaluateAndExecutePostRequest(employee, requestType, requestDescription) {
    const intimacy = employee.memory?.intimacyLevel || 0;
    const affection = employee.stats?.affection || 0;
    const comfort = employee.stats?.comfort || 0;
    const desire = employee.stats?.desire || 0;
    const personality = employee.personality || {};
    
    // Determine comfort level with request
    let comfortThreshold = 0;
    
    switch (requestType) {
      case 'text':
        comfortThreshold = 10; // Almost always okay
        break;
      case 'selfie':
        comfortThreshold = 20; // Pretty easy
        break;
      case 'thirst_trap':
        comfortThreshold = 50; // Need some comfort/attraction
        break;
      case 'nude':
        comfortThreshold = 72; // Need high intimacy
        break;
      case 'explicit':
        comfortThreshold = 88; // Need very high intimacy + desire for explicit content
        break;
    }
    
    // Calculate willingness score (desire matters more for explicit)
    const desireWeight = (requestType === 'explicit' || requestType === 'nude') ? 0.3 : 0.1;
    const flirtyBonus = (personality.flirty || 50) * 0.1;
    const willingnessScore = (intimacy * 0.35) + (affection * 0.25) + (comfort * (0.3 - desireWeight)) + (desire * desireWeight) + flirtyBonus;
    
    // Determine if they'll do it
    const willDo = willingnessScore >= comfortThreshold || (willingnessScore >= comfortThreshold * 0.85 && Math.random() < 0.25);
    
    // LOG DECISION PROCESS
    console.log(`\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
    console.log(`ğŸ“± SOCIAL POST REQUEST EVALUATION: ${employee.name}`);
    console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
    console.log(`Post Type: ${requestType.toUpperCase()}`);
    console.log(`Description: "${requestDescription}"`);
    console.log(`\nğŸ“Š Stats:`);
    console.log(`  â€¢ Intimacy: ${intimacy.toFixed(1)}`);
    console.log(`  â€¢ Affection: ${affection.toFixed(1)}`);
    console.log(`  â€¢ Comfort: ${comfort.toFixed(1)}`);
    console.log(`  â€¢ Desire: ${desire.toFixed(1)}`);
    console.log(`  â€¢ Flirty Personality: ${(personality.flirty || 50).toFixed(1)}`);
    console.log(`\nğŸ§® Calculation:`);
    console.log(`  â€¢ Intimacy Ã— 0.35 = ${(intimacy * 0.35).toFixed(2)}`);
    console.log(`  â€¢ Affection Ã— 0.25 = ${(affection * 0.25).toFixed(2)}`);
    console.log(`  â€¢ Comfort Ã— ${(0.3 - desireWeight).toFixed(2)} = ${(comfort * (0.3 - desireWeight)).toFixed(2)}`);
    console.log(`  â€¢ Desire Ã— ${desireWeight} = ${(desire * desireWeight).toFixed(2)}`);
    console.log(`  â€¢ Flirty Ã— 0.1 = ${flirtyBonus.toFixed(2)}`);
    console.log(`  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`);
    console.log(`  â€¢ Willingness Score: ${willingnessScore.toFixed(2)}`);
    console.log(`  â€¢ Required Threshold: ${comfortThreshold}`);
    console.log(`  â€¢ Grace Threshold (85%): ${(comfortThreshold * 0.85).toFixed(2)}`);
    console.log(`\nğŸ² Decision:`);
    if (willingnessScore >= comfortThreshold) {
      console.log(`  âœ… ACCEPTED - Score meets threshold`);
    } else if (willingnessScore >= comfortThreshold * 0.85) {
      console.log(`  ğŸ² GRACE ZONE - 25% chance (rolled: ${willDo ? 'SUCCESS' : 'FAIL'})`);
    } else {
      console.log(`  âŒ REJECTED - Score too low (${(comfortThreshold - willingnessScore).toFixed(2)} points short)`);
    }
    console.log(`\nğŸ“ Final Result: ${willDo ? 'âœ… WILL POST' : 'âŒ WILL REFUSE'}`);
    console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`);
    
    if (willDo) {
      // Send agreement message first
      setTimeout(() => {
        if (gameState.activeChat?.id === employee.id && chatMessages) {
          const agreeMessages = {
            text: ["Sure, I can post something", "Okay, I'll write something"],
            selfie: ["Okay! Let me take a selfie", "Sure, give me a sec", "Fine, one sec..."],
            thirst_trap: ["Alright... let me find something sexy ğŸ˜", "Okay okay... give me a minute", "Fine... but only because it's you ğŸ˜˜"],
            nude: ["Omg... okay. Give me a moment ğŸ˜³", "I can't believe I'm doing this... one sec", "Fuck it, why not ğŸ˜"],
            explicit: ["Holy shit... okay. This is so fucking hot ğŸ¥µ", "God, you make me so fucking wet... gimme a minute", "Fuck yes... this is so dirty ğŸ˜ˆ", "Can't believe you're making me do this... one sec ğŸ’¦"]
          };
          
          const messages = agreeMessages[requestType] || ["Okay"];
          const agreeMessage = messages[Math.floor(Math.random() * messages.length)];
          
          gameState.chatHistory[employee.id].push({
            sender: employee.name,
            content: agreeMessage,
            isPlayer: false,
            timestamp: gameState.time?.currentTime || Date.now()
          });
          
          const messageIndex = gameState.chatHistory[employee.id].length - 1;
          addChatMessage(employee.name, agreeMessage, false, null, messageIndex);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }, 1500 + Math.random() * 1500);
      
      // Generate and post it after a delay
      setTimeout(async () => {
        await generateRequestedPost(employee, requestType, requestDescription);
      }, 4000 + Math.random() * 6000); // 4-10 seconds
    } else {
      // Send a rejection message
      const rejectionMessages = {
        explicit: ["That's way too much for me", "I'm not comfortable posting that", "That's too explicit, sorry"],
        nude: ["I'm not ready to post nudes yet", "That's a bit too much for social media", "Maybe in private, but not on the feed"],
        thirst_trap: ["I don't think I'm comfortable with that", "That's a bit much for me", "Not really my style"],
        selfie: ["Not really feeling it right now", "Maybe later"],
        text: ["I don't really have anything to say", "Not in the mood to post"]
      };
      
      const messages = rejectionMessages[requestType] || ["I don't think so"];
      const rejection = messages[Math.floor(Math.random() * messages.length)];
      
      setTimeout(() => {
        if (gameState.activeChat?.id === employee.id && chatMessages) {
          gameState.chatHistory[employee.id].push({
            sender: employee.name,
            content: rejection,
            isPlayer: false,
            timestamp: gameState.time?.currentTime || Date.now()
          });
          
          const messageIndex = gameState.chatHistory[employee.id].length - 1;
          addChatMessage(employee.name, rejection, false, null, messageIndex);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }, 1500 + Math.random() * 1500);
    }
  }
  
  /**
   * Generate a requested post from NPC
   */
  async function generateRequestedPost(employee, postType, requestContext) {
    try {
      // Get context for post generation
      const context = getEmployeeAwarenessForPost(employee.id);
      if (!context) return;
      
      // Add request context to the generation
      context.requestedByBoss = true;
      context.requestContext = requestContext;
      context.mustIncludeImage = true; // CRITICAL: Force image generation for requests
      
      // Generate the post - ALWAYS with image for requests
      const generated = await generateOrganicPost(employee, postType, context);
      
      if (!generated || !generated.content) return;
      
      // ALWAYS generate image for requested posts (unless it's pure text request)
      let imageUrl = null;
      if (postType !== 'text') {
        // Make sure we have an image prompt
        if (!generated.imagePrompt) {
          // Build one based on the request type and context
          const promptParts = [];
          promptParts.push(getPhysicalDescriptionForPrompt(employee));
          
          if (postType === 'explicit') {
            promptParts.push(`${requestContext || 'explicit sexual content, masturbation'}`);
          } else if (postType === 'nude') {
            promptParts.push(`${requestContext || 'full nude photo, completely naked, revealing everything'}`);
          } else if (postType === 'thirst_trap') {
            promptParts.push(`${requestContext || 'sexy revealing photo, seductive pose, thirst trap'}`);
          } else if (postType === 'selfie') {
            promptParts.push(`${requestContext || 'selfie photo'}`);
          }
          
          generated.imagePrompt = promptParts.join(', ');
        }
        
        try {
          imageUrl = await queuedGenerateImage(applyImageStyle(generated.imagePrompt), `Requested post image for ${employee.name}`);
          console.log(`[Request Post] Generated image for ${employee.name}'s ${postType} post`);
        } catch (error) {
          console.error('Image generation failed for requested post:', error);
          // Retry once on failure
          try {
            imageUrl = await queuedGenerateImage(applyImageStyle(generated.imagePrompt), `Requested post image retry for ${employee.name}`);
          } catch (retryError) {
            console.error('Image retry failed:', retryError);
          }
        }
      }
      
      // Create and add the post
      const post = createPost({
        authorId: employee.id,
        content: generated.content,
        type: postType,
        imageUrl: imageUrl,
        imagePrompt: generated.imagePrompt,
        explicitLevel: generated.explicitLevel || 0,
        tags: generated.tags || [],
        location: employee.locationId || 'headquarters'
      });
      
      gameState.socialNetwork.posts.unshift(post);
      
      // Refresh dashboard to show new posts/mentions
      if (gameState.activeTab === 'dashboard') {
        refreshDashboardSections();
      }
      
      // Track this post type
      if (!gameState.socialNetwork.recentPostTypes) {
        gameState.socialNetwork.recentPostTypes = [];
      }
      gameState.socialNetwork.recentPostTypes.unshift(postType);
      if (gameState.socialNetwork.recentPostTypes.length > 20) {
        gameState.socialNetwork.recentPostTypes = gameState.socialNetwork.recentPostTypes.slice(0, 20);
      }
      
      // Store in employee's awareness
      remember(employee, `I posted on social media: "${generated.content}"`, 'action', 2);
      remember(employee, `The boss requested I make this post`, 'interaction', 2);
      
      // Send them a chat message about it
      if (gameState.activeChat?.id === employee.id && chatMessages) {
        const followUpMessages = [
          "Done! Check the feed ğŸ˜Š",
          "Posted! Hope you like it ğŸ˜",
          "There you go... posted",
          "Okay, it's up now",
          "Posted as requested ğŸ˜³"
        ];
        const followUp = followUpMessages[Math.floor(Math.random() * followUpMessages.length)];
        
        gameState.chatHistory[employee.id].push({
          sender: employee.name,
          content: followUp,
          isPlayer: false,
          timestamp: gameState.time?.currentTime || Date.now()
        });
        
        const messageIndex = gameState.chatHistory[employee.id].length - 1;
        addChatMessage(employee.name, followUp, false, null, messageIndex);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Refresh feed if on social tab
      if (gameState.activeTab === 'social') {
        renderSocialFeed();
      }
      
    } catch (error) {
      console.error('Error generating requested post:', error);
    }
  }
  
  // -------- MESSAGE REGENERATION --------
  async function regenerateMessage(messageIndex) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    const history = gameState.chatHistory[emp.id];
    
    if (!history || messageIndex < 1 || messageIndex >= history.length) return;
    
    // Get the message before the one we're regenerating (the player's prompt)
    const playerMessage = history[messageIndex - 1]?.content;
    if (!playerMessage) return;
    
    // Show typing indicator
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = emp.name;
    }
    
    try {
      // Build conversation history up to this point
      const conversationHistory = history.slice(0, messageIndex)
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      // IMPROVED REGENERATION: Add variation strategies (avoid words like "variation", "alternative", "different response" that trigger meta-commentary)
      const variationStrategies = [
        '\n\nIMPORTANT: Use a completely new tone and approach. Include details you didn\'t mention before. Take this in a fresh direction.',
        '\n\nIMPORTANT: If you were formal before, be casual now. If you were brief, elaborate more. If you were serious, add personality. Show another side of yourself.',
        '\n\nIMPORTANT: Focus on aspects you haven\'t explored yet. Use new examples and emotions. Structure your sentences in a new way.',
        '\n\nIMPORTANT: Shift your emotional tone. If you were playful before, be thoughtful now. If you were enthusiastic, try subtle. Reveal a new facet of your personality.',
        '\n\nIMPORTANT: Include information or reactions you haven\'t shared yet. Use significantly varied word choices. Take this conversation somewhere new.'
      ];
      
      // Randomly select a variation strategy
      const strategy = variationStrategies[Math.floor(Math.random() * variationStrategies.length)];
      
      // Track regeneration count to increase temperature
      if (!history[messageIndex].regenerationCount) {
        history[messageIndex].regenerationCount = 0;
      }
      history[messageIndex].regenerationCount++;
      
      // Build prompt with variation instruction
      const { prompt } = buildChatPrompt(emp, conversationHistory, playerMessage);
      const enhancedPrompt = prompt + strategy;
      
      // Increase temperature for more variation (0.7 + 0.1 per regeneration, max 1.2)
      const temperature = Math.min(1.2, 0.7 + (history[messageIndex].regenerationCount * 0.1));
      
      // Generate with enhanced variation
      const raw = await queuedGenerateText(enhancedPrompt, {
        temperature: temperature,
        top_p: 0.95, // Slightly higher for more diversity
        frequency_penalty: 0.3 // Reduce repetition
      }, `Regenerating chat message with variation for ${emp.name}`);
      
      const response = sanitizeNpcResponse(raw, 5);
      
      // Hide typing indicator
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      
      // Update the message in history
      history[messageIndex].content = response;
      
      // Delete all messages after this one (truncate the conversation)
      gameState.chatHistory[emp.id] = history.slice(0, messageIndex + 1);
      
      // Reload chat to show updated message
      loadChatHistory(emp.id);
      
      // NOTE: Stat changes are NOT evaluated on regeneration to avoid penalties for re-rolling responses
      // Stats were already updated when the original message was sent
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
      
      // Show feedback to user
      showNotification(`â™»ï¸ Response regenerated with new variation (${history[messageIndex].regenerationCount}x)`, 2000);
      
    } catch (error) {
      console.error('Error regenerating message:', error);
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      showNotification('Failed to regenerate message. Please try again.');
    }
  }
  
  // Regenerate an image in the chat history
  async function regenerateImage(messageIndex, imagePrompt) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    const history = gameState.chatHistory[emp.id];
    
    if (!history || messageIndex < 0 || messageIndex >= history.length) return;
    
    const message = history[messageIndex];
    if (!message.imageUrl) return; // Not an image message
    
    try {
      // Show loading indicator on the image
      const loadingMsg = document.createElement('div');
      loadingMsg.textContent = 'ğŸ¨ Regenerating image...';
      loadingMsg.style.cssText = 'text-align:center; padding:10px; opacity:0.7; font-style:italic;';
      if (chatMessages) {
        chatMessages.appendChild(loadingMsg);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Generate new image using the same prompt
      const newImageUrl = await queuedGenerateImage(applyImageStyle(imagePrompt), `Regenerating player image`);
      
      // Remove loading message
      if (loadingMsg && loadingMsg.parentElement) {
        loadingMsg.remove();
      }
      
      // Update the image URL in history
      message.imageUrl = newImageUrl;
      
      // Reload chat to show updated image
      loadChatHistory(emp.id);
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
    } catch (error) {
      console.error('Error regenerating image:', error);
      showNotification('Failed to regenerate image');
    }
  }
  
  // -------- IMAGE SYSTEM --------
  // Build comprehensive image prompt using NPC bio and context
  async function buildImagePrompt(emp, requestType, customPrompt = null) {
    // Get consistent physical description using the new system
    const physicalDesc = getPhysicalDescriptionForPrompt(emp);
    
    // Get player description for [PLAYER] token
    const playerBio = getPlayerDescription('image'); // Uses new profile system
    
    // Get recent conversation context
    const recentContext = gameState.chatHistory[emp.id]
      ?.slice(-10)
      .map(msg => `${msg.sender}: ${msg.content}`)
      .join('\n') || '';
    
    // Determine intimacy level for appropriate image type
    const affection = emp.stats?.affection || 0;
    const desire = emp.stats?.desire || 0;
    const intimacyLevel = (affection + desire) / 2;
    
    let imagePrompt = '';
    
    // PRIORITY: If there's a custom prompt, ALWAYS use it (don't use generic presets)
    if (customPrompt) {
      // Replace [PLAYER] token with player bio (escape to prevent Perchance interpretation)
      let processedPrompt = customPrompt.replace(/\[PLAYER\]/gi, playerBio);
      
      // For custom prompts, AI analyzes and builds comprehensive prompt
      // Note: Use "the player" or actual bio instead of [PLAYER] to avoid Perchance list conflicts
      const playerDescription = playerBio !== 'the player' ? `Player description: ${playerBio}` : '';
      
      // Build conversation context section
      let conversationSection = '';
      if (recentContext) {
        conversationSection = `\n\nRECENT CONVERSATION:\n${recentContext}\n(The image request is related to this conversation. Pay close attention to details like clothing, costumes, location, activities, or specific descriptions mentioned.)`;
      }
      
      const analysisPrompt = `Character: ${emp.name}
Appearance: ${physicalDesc}
${playerDescription ? `Player: ${playerDescription}` : ''}
${conversationSection}

PLAYER'S IMAGE REQUEST: "${processedPrompt}"

TASK:
Generate a detailed image prompt that EXACTLY matches what the player is asking for. Consider:
1. What is the player's request asking for? (Be specific about "how you are right now", "exactly as described", etc.)
2. What was just discussed in the conversation? (Costumes, clothing, activities, locations, poses)
3. What details were explicitly mentioned? (Use EXACT descriptions from conversation)
4. Is this explicit/NSFW? (Don't shy away from explicit details if contextually appropriate)

CRITICAL RULES:
- If request says "exactly how you are right now" or "as you are" â†’ use conversation context for current state
- If costume/clothing was just described â†’ include EXACT costume details
- If location was mentioned â†’ use that location
- If activity was described â†’ show that activity
- Include: pose, expression, clothing (or lack thereof), setting, lighting, camera angle
- Use technical/specific tags for image generation
- For explicit content: use anatomical descriptions

Generate ONLY the detailed image prompt - no explanations:`;

      try {
        imagePrompt = await queuedGenerateText(analysisPrompt, {
          temperature: 0.7,
          max_tokens: 200,
          stopSequences: ['\n\n\n', 'Note:', 'Example:', 'Camera angle:', 'Mood:', '---', 'IMAGE PROMPT:', 'Explanation:']
        }, `Generating AI image prompt analysis`);
        // Clean up any quotes or extra text
        imagePrompt = imagePrompt.replace(/^["']|["']$/g, '').trim();
        // Remove any remaining meta-commentary
        imagePrompt = imagePrompt.split(/\n\s*\n/)[0]; // Take only first paragraph
        imagePrompt = imagePrompt.split(/\(Note:/i)[0]; // Remove notes
        
        console.log(`[Custom Image Request] AI-generated prompt: ${imagePrompt.substring(0, 100)}...`);
      } catch (error) {
        console.error('Error building custom image prompt:', error);
        imagePrompt = `${processedPrompt}, ${physicalDesc}`;
      }
    }
    // FALLBACK: Only use generic presets if NO custom prompt was provided
    else if (requestType === 'casual') {
      imagePrompt = `casual selfie, ${physicalDesc}, friendly smile, relaxed setting, natural lighting, smartphone photo quality`;
    } else if (requestType === 'work') {
      imagePrompt = `professional workplace selfie, ${physicalDesc}, ${emp.position || 'office worker'}, office environment, professional attire, confident expression`;
    } else if (requestType === 'lewd') {
      if (intimacyLevel < 40) {
        imagePrompt = `suggestive selfie, ${physicalDesc}, flirty expression, casual clothing, teasing pose, playful atmosphere`;
      } else {
        imagePrompt = `seductive selfie, ${physicalDesc}, alluring expression, revealing clothing, intimate pose, bedroom or private setting`;
      }
    } else if (requestType === 'nude') {
      if (intimacyLevel < 60) {
        imagePrompt = `artistic nude selfie, ${physicalDesc}, tasteful pose, soft lighting, partial nudity, intimate setting`;
      } else {
        imagePrompt = `explicit nude selfie, ${physicalDesc}, seductive pose, full nudity, intimate bedroom setting, aroused expression`;
      }
    } else if (requestType === 'explicit') {
      // Sexually explicit content - variety of acts
      const explicitVariations = [
        `explicit sexual content, ${physicalDesc}, masturbating with hand, intense pleasure expression, legs spread, intimate bedroom setting, aroused and exposed`,
        `explicit sexual content, ${physicalDesc}, using sex toy, dildo or vibrator, eyes closed in ecstasy, intimate bedroom setting, very aroused`,
        `explicit sexual content, ${physicalDesc}, self-pleasure, fingers inside, intense orgasm expression, intimate bedroom setting, completely exposed`,
        `explicit sexual content, ${physicalDesc}, degrading body writing, marked with text, submissive expression, intimate setting, fully nude`,
        `explicit sexual content, ${physicalDesc}, masturbating, very aroused expression, touching self intimately, bedroom setting, explicit pose`,
        `explicit sexual content, ${physicalDesc}, anal play with toy, intense pleasure face, intimate bedroom setting, very exposed and aroused`,
        `explicit sexual content, ${physicalDesc}, using multiple toys, overwhelmed with pleasure, intimate bedroom setting, extremely explicit`,
        `explicit sexual content, ${physicalDesc}, squirting orgasm, intense climax expression, legs spread wide, intimate bedroom setting, very wet`
      ];
      imagePrompt = explicitVariations[Math.floor(Math.random() * explicitVariations.length)];
    }
    
    return imagePrompt;
  }
  
  // Handle sending an image (player to NPC)
  async function sendImageToNPC(imagePrompt) {
    if (!gameState.activeChat || !imagePrompt.trim()) return;
    
    const emp = gameState.activeChat;
    
    // Expand @mentions to include physical descriptions
    const expandedPrompt = expandImageMentions(imagePrompt);
    if (expandedPrompt !== imagePrompt) {
      console.log('[Send Image] ğŸ”„ Expanded @mentions in image prompt');
      console.log('[Send Image] Original:', imagePrompt);
      console.log('[Send Image] Expanded:', expandedPrompt);
    }
    
    // Show typing indicator
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = emp.name;
    }
    
    try {
      // Show loading message
      const loadingMsg = addChatMessage('You', 'ğŸ¨ Generating image...', true);
      
      // Generate image using Perchance generateImage plugin (use expanded prompt)
      const imageUrl = await queuedGenerateImage(applyImageStyle(expandedPrompt), `Player custom image request`);
      
      // Remove loading message and add actual image message
      if (loadingMsg && loadingMsg.parentElement) {
        loadingMsg.remove();
      }
      
      // Add to history first to get the message index
      if (!gameState.chatHistory[emp.id]) {
        gameState.chatHistory[emp.id] = [];
      }
      gameState.chatHistory[emp.id].push({
        sender: 'You',
        content: imagePrompt,
        isPlayer: true,
        imageUrl: imageUrl,
        imagePrompt: imagePrompt,
        imageType: 'sent',
        timestamp: gameState.time?.currentTime || Date.now()
      });
      
      // Add image message with index for regenerate button
      const sentImageIndex = gameState.chatHistory[emp.id].length - 1;
      addChatMessage('You', imagePrompt, true, imageUrl, sentImageIndex, imagePrompt);
      
      // Build AI response prompt - NPC "sees" and responds to image
      const conversationHistory = gameState.chatHistory[emp.id]
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      const playerBio = gameState.settings?.playerBio || '';
      const playerContext = playerBio ? `\nPlayer description: ${playerBio}` : '';
      
      const responsePrompt = `${buildChatPrompt(emp, conversationHistory, '').prompt}${playerContext}

The player just sent you an image. Based on this description: "${imagePrompt}", respond naturally to what they sent. Consider:
- What the image shows (understand the CONTEXT and meaning, not just literal technical tags)
- Your relationship with the player
- The context of your conversation
- Your personality and current mood

Respond as if you actually saw the image. Keep it conversational (3-5 sentences, completing your thought).

${emp.name}'s response:`;

      const raw = await queuedGenerateText(responsePrompt, {}, `Generating image response for ${emp.name}`);
      const response = sanitizeNpcResponse(raw, 5);
      
      // Hide typing indicator
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      
      // Add to history first to get the correct index
      gameState.chatHistory[emp.id].push({
        sender: emp.name,
        content: response,
        isPlayer: false,
        timestamp: gameState.time?.currentTime || Date.now()
      });
      
      // Only add message to UI if this is still the active chat
      if (gameState.activeChat?.id === emp.id && chatMessages) {
        const messageIndex = gameState.chatHistory[emp.id].length - 1;
        addChatMessage(emp.name, response, false, null, messageIndex);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Memory: remember the image
      remember(emp, `Player sent image: ${imagePrompt}`, 'event', 1.5);
      
      // Update stats
      await updateEmployeeStatsFromChat(emp, `[Sent image: ${imagePrompt}]`, response);
      
    } catch (error) {
      console.error('Error handling sent image:', error);
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      // Only show error message if this is still the active chat
      if (gameState.activeChat?.id === emp.id && chatMessages) {
        addChatMessage(emp.name, "Sorry, I couldn't process that image.", false);
      }
    }
  }
  
  // Handle sending money to NPC
  /**
   * Send money to NPC - Enhanced with better framing and reactions
   */
  async function sendMoneyToNPC(amount, message = '', employeeId = null, isMeetingContext = false) {
    if (amount <= 0) return;
    
    // Determine target employee
    const targetId = employeeId || gameState.activeChat?.id;
    if (!targetId) return;
    
    const emp = gameState.employees.find(e => e.id === targetId);
    if (!emp) return;
    
    // Update NPC bank balance (initialize if needed)
    if (!emp.bankBalance) emp.bankBalance = 0;
    emp.bankBalance += amount;
    
    // Initialize spending rate if needed (scaled to company size)
    if (!emp.spendingRate) {
      emp.spendingRate = calculateScaledSpendingRate(); // Company-scaled base rate
    }
    
    // Deduct money from player
    gameState.cash = Math.max(0, gameState.cash - amount);
    updateUI();
    
    // Show typing indicator
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = emp.name;
    }
    
    try {
      // Add money transfer message to chat
      const moneyMessage = message 
        ? `ğŸ’° Sent $${formatCash(amount)}\n"${message}"`
        : `ğŸ’° Sent $${formatCash(amount)}`;
      
      if (isMeetingContext) {
        // Find the meeting
        const meeting = gameState.meetings?.find(m => 
          m.participants?.some(p => p.id === emp.id)
        );
        
        if (meeting) {
          // Add to meeting messages
          if (!meeting.messages) meeting.messages = [];
          meeting.messages.push({
            sender: 'You',
            content: `ğŸ’° Sent $${formatCash(amount)} to ${emp.name}${message ? `\n"${message}"` : ''}`,
            isPlayer: true,
            isMoney: true,
            recipientId: emp.id,
            amount: amount,
            message: message,
            timestamp: gameState.time?.currentTime || Date.now()
          });
          
          // Update meeting display if it's active
          if (window.activeMeetingId === meeting.id) {
            displayMeetingMessages(meeting.id);
          }
        }
      } else {
        // Add to 1-on-1 chat history
        if (!gameState.chatHistory[emp.id]) {
          gameState.chatHistory[emp.id] = [];
        }
        gameState.chatHistory[emp.id].push({
          sender: 'You',
          content: moneyMessage,
          isPlayer: true,
          isMoney: true,
          amount: amount,
          message: message,
          timestamp: gameState.time?.currentTime || Date.now()
        });
        
        // Add to chat display (only if this is the active chat)
        if (gameState.activeChat?.id === emp.id) {
          addChatMessage('You', moneyMessage, true);
        }
      }
      
      // Determine payment framing based on context and amount
      const avgSalary = 50000; // Average employee salary for comparison
      const monthlyEquiv = (amount / avgSalary) * 12;
      
      // Categorize amount more contextually
      let paymentType = 'gift';
      let sizeDesc = 'small';
      
      if (amount < 100) {
        sizeDesc = 'tiny';
        paymentType = 'tip';
      } else if (amount < 1000) {
        sizeDesc = 'small';
        paymentType = 'gift';
      } else if (amount < 10000) {
        sizeDesc = 'nice';
        paymentType = message ? 'gift with meaning' : 'generous gift';
      } else if (amount < 50000) {
        sizeDesc = 'substantial';
        paymentType = 'bonus';
      } else if (amount < 200000) {
        sizeDesc = 'major';
        paymentType = 'windfall';
      } else {
        sizeDesc = 'life-changing';
        paymentType = 'fortune';
      }
      
      // Build conversation history
      let conversationHistory;
      if (isMeetingContext) {
        // Use meeting messages for context
        const meeting = gameState.meetings?.find(m => 
          m.participants?.some(p => p.id === emp.id)
        );
        conversationHistory = meeting?.messages
          ?.slice(-10)
          .map(msg => `${msg.sender}: ${msg.content}`)
          .join('\n') || '';
      } else {
        // Use 1-on-1 chat history
        conversationHistory = gameState.chatHistory[emp.id]
          .slice(-10)
          .map(msg => `${msg.sender}: ${msg.content}`)
          .join('\n');
      }
      
      const playerBio = getPlayerDescription('conversation');
      const playerContext = playerBio !== 'the boss' ? `\nğŸ‘¤ BOSS INFO: ${playerBio}` : '';
      
      // Build message context
      const messageContext = message 
        ? `\n\nğŸ’¬ YOUR BOSS'S MESSAGE WITH THE MONEY:\n"${message}"\n**IMPORTANT**: Acknowledge this message in your response!`
        : '';
      
      // Enhanced prompt that frames money more positively
      const responsePrompt = `${buildChatPrompt(emp, conversationHistory, '').prompt}${playerContext}

ğŸ’° SITUATION: Your boss just sent you $${formatCash(amount)} (a ${sizeDesc} ${paymentType})!${messageContext}

ğŸ“Š CONTEXT FOR YOUR REACTION:
- Amount: $${formatCash(amount)} (equivalent to ${monthlyEquiv.toFixed(1)} months of average salary)
- Your current bank balance: $${formatCash(emp.bankBalance)}
- Your personality: ${emp.personality}
- Your relationship: Affection ${emp.stats?.affection || 0}, Trust ${emp.trust || 0}, Obedience ${emp.obedience || 0}, Desire ${emp.desire || 0}

ğŸ’­ HOW TO REACT:
1. **BE GENUINE**: Show real emotion appropriate to the amount (surprise, gratitude, excitement, suspicion, etc.)
2. **FRAME POSITIVELY**: Unless you have serious trust issues or the amount is suspicious, treat this as a nice gesture
3. **AVOID HR COMPLAINTS**: Don't immediately jump to "this feels wrong" unless amount is truly absurd
4. **ACKNOWLEDGE THE GESTURE**: Recognize why they might be sending money (help, appreciation, flirting, etc.)
5. **BE IN CHARACTER**: Respond based on YOUR personality and relationship with them
${message ? '6. **ADDRESS THEIR MESSAGE**: Make sure to respond to what they said!' : ''}

ğŸ“ SUGGESTED REACTIONS BY AMOUNT:
- Tiny ($1-99): Casual thanks, maybe confused why so small
- Small ($100-999): Sweet gesture, appreciated
- Nice ($1K-9K): Really grateful, touched by the thoughtfulness  
- Substantial ($10K-49K): Wow, this is amazing! What's the occasion?
- Major ($50K-199K): Holy shit, this is incredible! You're changing my life!
- Life-changing ($200K+): I... I don't know what to say. This is unreal. Are you serious?!

ğŸ­ RESPOND NOW (3-8 sentences, natural conversation):`;

      const raw = await queuedGenerateText(responsePrompt, {}, `Generating gift money response for ${emp.name}`);
      const response = sanitizeNpcResponse(raw, 10);
      
      // Hide typing indicator
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      
      if (isMeetingContext) {
        // Add to meeting messages
        const meeting = gameState.meetings?.find(m => 
          m.participants?.some(p => p.id === emp.id)
        );
        
        if (meeting) {
          if (!meeting.messages) meeting.messages = [];
          meeting.messages.push({
            sender: emp.name,
            content: response,
            isPlayer: false,
            senderId: emp.id,
            timestamp: gameState.time?.currentTime || Date.now()
          });
          
          // Update meeting display if it's active
          if (window.activeMeetingId === meeting.id) {
            displayMeetingMessages(meeting.id);
          }
        }
      } else {
        // Add to 1-on-1 chat history
        gameState.chatHistory[emp.id].push({
          sender: emp.name,
          content: response,
          isPlayer: false,
          timestamp: gameState.time?.currentTime || Date.now()
        });
        
        // Only add message to UI if this is still the active chat
        if (gameState.activeChat?.id === emp.id && chatMessages) {
          const messageIndex = gameState.chatHistory[emp.id].length - 1;
          addChatMessage(emp.name, response, false, null, messageIndex);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }
      
      // Memory: remember receiving money
      const memoryText = message 
        ? `Received $${formatCash(amount)} from boss (${paymentType}) - "${message}"`
        : `Received $${formatCash(amount)} from boss (${paymentType})`;
      remember(emp, memoryText, 'event', 2.0);
      
      // Update stats - more nuanced based on context
      let favorGain = 0;
      let trustGain = 0;
      let desireGain = 0;
      
      if (amount < 1000) {
        favorGain = 2 + Math.floor(amount / 200);
        trustGain = 1;
        desireGain = 1;
      } else if (amount < 10000) {
        favorGain = 5 + Math.floor(amount / 1000);
        trustGain = 2;
        desireGain = 2;
      } else if (amount < 100000) {
        favorGain = 10 + Math.floor(amount / 5000);
        trustGain = 3;
        desireGain = 4;
      } else {
        favorGain = 20;
        trustGain = 5;
        desireGain = 8;
      }
      
      // Cap gains
      favorGain = Math.min(25, favorGain);
      trustGain = Math.min(10, trustGain);
      desireGain = Math.min(12, desireGain);
      
      // Apply stat changes
      emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + favorGain);
      emp.trust = Math.min(100, (emp.trust || 0) + trustGain);
      emp.desire = Math.min(100, (emp.desire || 0) + desireGain);
      emp.obedience = Math.min(100, (emp.obedience || 0) + Math.floor(favorGain / 2));
      
      // Lifestyle inflation - receiving money increases spending rate
      const lifestyleIncrease = amount / 10000; // $10k = +1/day spending
      const maxSpendingIncrease = 50; // Cap at +50/day per gift
      emp.spendingRate += Math.min(maxSpendingIncrease, lifestyleIncrease);
      
      // Show notification
      showNotification(`ğŸ’° ${emp.name}: +$${formatCash(amount)} to bank\n+${favorGain} Affection, +${trustGain} Trust, +${desireGain} Desire`, 'success');
      
      updateUI();
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
    } catch (error) {
      console.error('Error handling money transfer:', error);
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      
      // Only show fallback message if this is still the active chat
      if (gameState.activeChat?.id === emp.id && chatMessages) {
        addChatMessage(emp.name, "Wow, thank you so much! This is amazing! ğŸ’•", false);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Still apply basic stat gains even if AI fails
      emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 5);
      emp.trust = Math.min(100, (emp.trust || 0) + 2);
      emp.desire = Math.min(100, (emp.desire || 0) + 3);
      updateUI();
    }
  }
  
  /**
   * NEW: Quick send cash from social feed (without opening chat)
   */
  function quickSendCash(employeeId) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) {
      showNotification('âŒ Employee not found!', 'error');
      return;
    }
    
    // Prompt for amount
    const amountStr = prompt(`ğŸ’µ Send money to ${employee.name}\n\nHow much do you want to send?`, '1000');
    if (!amountStr) return; // User cancelled
    
    const amount = parseInt(amountStr);
    if (isNaN(amount) || amount <= 0) {
      showNotification('âŒ Invalid amount!', 'error');
      return;
    }
    
    if (gameState.cash < amount) {
      showNotification(`âŒ Not enough cash! You have $${formatCash(gameState.cash)}`, 'error');
      return;
    }
    
    // Deduct money
    gameState.cash -= amount;
    
    // Add to employee's bank
    if (!employee.bankBalance) employee.bankBalance = 0;
    employee.bankBalance += amount;
    
    // Apply stat gains (same as regular money transfer)
    const favorGain = Math.min(20, Math.floor(amount / 1000));
    const trustGain = Math.min(10, Math.floor(amount / 2000));
    const desireGain = Math.min(12, Math.floor(amount / 1500));
    
    employee.stats.affection = Math.min(100, (employee.stats.affection || 0) + favorGain);
    employee.stats.trust = Math.min(100, (employee.stats.trust || 0) + trustGain);
    employee.stats.desire = Math.min(100, (employee.stats.desire || 0) + desireGain);
    
    updateUI();
    showNotification(`ğŸ’° Sent $${formatCash(amount)} to ${employee.name}\n+${favorGain} Affection, +${trustGain} Trust`, 'success');
  }
  
  /**
   * NEW: Open gift modal for specific employee (from social feed)
   */
  function openGiftModal(employeeId) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) {
      showNotification('âŒ Employee not found!', 'error');
      return;
    }
    
    // Set active chat temporarily (required by gift modal)
    gameState.activeChat = employee;
    
    // Open the gift selection modal - use window.openGiftSelectionModal to ensure we get the correct function
    if (typeof window.openGiftSelectionModal === 'function') {
      window.openGiftSelectionModal();
    } else {
      showNotification('âŒ Gift system not available!', 'error');
    }
  }
  
  /**
   * ===== POST ACTIONS DROPDOWN MENU SYSTEM =====
   * Handles the [...] menu on social posts
   */
  
  // Track which menu is currently open
  let openPostActionsMenuId = null;
  
  /**
   * Toggle the post actions dropdown menu
   */
  function togglePostActionsMenu(postId) {
    const menu = document.getElementById(`postActionsMenu_${postId}`);
    if (!menu) return;
    
    // If this menu is already open, close it
    if (openPostActionsMenuId === postId) {
      closePostActionsMenu();
      return;
    }
    
    // Close any other open menu first
    closePostActionsMenu();
    
    // Open this menu
    menu.style.display = 'block';
    openPostActionsMenuId = postId;
    
    // Add click listener to close when clicking outside
    setTimeout(() => {
      document.addEventListener('click', handleOutsidePostMenuClick);
    }, 10);
  }
  
  /**
   * Close the post actions menu
   */
  function closePostActionsMenu() {
    if (openPostActionsMenuId) {
      const menu = document.getElementById(`postActionsMenu_${openPostActionsMenuId}`);
      if (menu) menu.style.display = 'none';
      openPostActionsMenuId = null;
    }
    document.removeEventListener('click', handleOutsidePostMenuClick);
  }
  
  /**
   * Handle clicks outside the menu to close it
   */
  function handleOutsidePostMenuClick(e) {
    if (openPostActionsMenuId) {
      const menu = document.getElementById(`postActionsMenu_${openPostActionsMenuId}`);
      const btn = document.getElementById(`postActionsBtn_${openPostActionsMenuId}`);
      if (menu && btn && !menu.contains(e.target) && !btn.contains(e.target)) {
        closePostActionsMenu();
      }
    }
  }
  
  /**
   * Send a tip (money) on a post with public logging and reactions
   */
  async function tipOnPost(postId) {
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) {
      showNotification('âŒ Post not found!', 'error');
      return;
    }
    
    const employee = gameState.employees.find(e => e.id === post.authorId);
    if (!employee) {
      showNotification('âŒ Author not found!', 'error');
      return;
    }
    
    // Prompt for amount
    const amountStr = prompt(`ğŸ’µ Send a tip to ${employee.name} for this post\n\nHow much do you want to tip?`, '500');
    if (!amountStr) return;
    
    const amount = parseInt(amountStr);
    if (isNaN(amount) || amount <= 0) {
      showNotification('âŒ Invalid amount!', 'error');
      return;
    }
    
    if (gameState.cash < amount) {
      showNotification(`âŒ Not enough cash! You have $${formatCash(gameState.cash)}`, 'error');
      return;
    }
    
    // Deduct money
    gameState.cash -= amount;
    
    // Add to employee's bank
    if (!employee.bankBalance) employee.bankBalance = 0;
    employee.bankBalance += amount;
    
    // Apply stat gains (scaled by amount)
    const favorGain = Math.min(25, Math.floor(amount / 500));
    const trustGain = Math.min(15, Math.floor(amount / 1000));
    const desireGain = Math.min(15, Math.floor(amount / 800));
    
    employee.stats.affection = Math.min(100, (employee.stats.affection || 0) + favorGain);
    employee.stats.trust = Math.min(100, (employee.stats.trust || 0) + trustGain);
    employee.stats.desire = Math.min(100, (employee.stats.desire || 0) + desireGain);
    
    // Create a public "action comment" showing the tip
    const tipComment = createComment({
      postId: post.id,
      authorId: 'player',
      authorName: 'You',
      content: `ğŸ’µ Tipped $${formatCash(amount)}`,
      isPlayerComment: true
    });
    tipComment.isTipAction = true;
    tipComment.tipAmount = amount;
    post.comments.push(tipComment);
    
    // Store in memory
    remember(employee, `Boss tipped me $${formatCash(amount)} on my social post!`, 'interaction', 3);
    
    updateUI();
    showNotification(`ğŸ’µ Tipped $${formatCash(amount)} to ${employee.name}!`, 'success');
    
    // Trigger reactions
    await generateTipGiftReactions(post, employee, 'tip', amount, null);
    
    // Refresh feed
    if (gameState.activeTab === 'social') {
      renderSocialFeed();
    }
    
    // Update modal if open
    if (postModalState.activePostId === postId) {
      renderModalComments(postId, false);
    }
  }
  
  /**
   * Send a gift on a post with public logging and reactions
   */
  async function giftOnPost(postId) {
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) {
      showNotification('âŒ Post not found!', 'error');
      return;
    }
    
    const employee = gameState.employees.find(e => e.id === post.authorId);
    if (!employee) {
      showNotification('âŒ Author not found!', 'error');
      return;
    }
    
    // Store context for gift callback
    window.pendingPostGift = { postId, employeeId: employee.id };
    
    // Set active chat temporarily (required by gift modal)
    gameState.activeChat = employee;
    
    // Open the gift selection modal
    if (typeof window.openGiftSelectionModal === 'function') {
      window.openGiftSelectionModal();
    } else {
      showNotification('âŒ Gift system not available!', 'error');
      delete window.pendingPostGift;
    }
  }
  
  /**
   * Called after a gift is given to handle post-specific logging
   * This hooks into the existing gift system
   */
  async function handlePostGiftGiven(employee, gift) {
    const pending = window.pendingPostGift;
    if (!pending) return; // Not a post gift
    
    const post = gameState.socialNetwork.posts.find(p => p.id === pending.postId);
    if (!post) {
      delete window.pendingPostGift;
      return;
    }
    
    // Create a public "action comment" showing the gift
    const giftComment = createComment({
      postId: post.id,
      authorId: 'player',
      authorName: 'You',
      content: `ğŸ Sent a gift: ${gift.emoji} ${gift.name}`,
      isPlayerComment: true
    });
    giftComment.isGiftAction = true;
    giftComment.giftName = gift.name;
    giftComment.giftEmoji = gift.emoji;
    giftComment.giftValue = gift.price;
    post.comments.push(giftComment);
    
    // Update memory
    remember(employee, `Boss gifted me a ${gift.name} on my social post!`, 'interaction', 3);
    
    // Trigger reactions
    await generateTipGiftReactions(post, employee, 'gift', gift.price, gift);
    
    // Refresh feed
    if (gameState.activeTab === 'social') {
      renderSocialFeed();
    }
    
    // Update modal if open
    if (postModalState.activePostId === pending.postId) {
      renderModalComments(pending.postId, false);
    }
    
    delete window.pendingPostGift;
  }
  
  /**
   * Generate NPC reactions to tips/gifts on posts
   */
  async function generateTipGiftReactions(post, recipient, actionType, value, gift = null) {
    console.log(`[Social Reactions] Generating reactions to ${actionType} of $${value} on post by ${recipient.name}`);
    
    // 1. Post author (recipient) always reacts
    const authorReactionDelay = 1500 + Math.random() * 2000;
    setTimeout(async () => {
      await generateRecipientReaction(post, recipient, actionType, value, gift);
    }, authorReactionDelay);
    
    // 2. Random other NPCs may comment (20-40% chance each, max 2-3)
    const otherNPCs = gameState.employees.filter(e => 
      e.id !== recipient.id && 
      e.employmentStatus === 'active' &&
      Math.random() < 0.35
    ).slice(0, 3);
    
    for (let i = 0; i < otherNPCs.length; i++) {
      const npc = otherNPCs[i];
      const delay = 3000 + (i * 2000) + Math.random() * 3000;
      
      setTimeout(async () => {
        await generateBystanderReaction(post, npc, recipient, actionType, value, gift);
      }, delay);
    }
  }
  
  /**
   * Generate the recipient's reaction to receiving a tip/gift
   */
  async function generateRecipientReaction(post, recipient, actionType, value, gift = null) {
    const intimacy = recipient.memory?.intimacyLevel || 0;
    const affection = recipient.stats?.affection || 50;
    const personality = recipient.personality || {};
    
    // Determine reaction intensity based on value
    const isGenerous = value >= 2000;
    const isHuge = value >= 5000;
    
    // Get some context about the recipient
    const traits = [];
    if (personality.flirty > 70) traits.push('flirty');
    if (personality.shy > 70) traits.push('shy');
    if (personality.confident > 70) traits.push('confident');
    if (personality.playful > 70) traits.push('playful');
    if (personality.professional > 70) traits.push('professional');
    
    let reactionPrompt;
    if (actionType === 'tip') {
      reactionPrompt = `You are ${recipient.name}, an employee who just received a $${value} tip from your boss (@TheBoss) on your social media post.

Your personality traits: ${traits.length > 0 ? traits.join(', ') : 'balanced'}
- Intimacy with boss: ${intimacy}/100 (${intimacy < 30 ? 'professional distance' : intimacy < 60 ? 'friendly' : 'close/intimate'})
- Affection: ${affection}/100
- Flirty tendency: ${personality.flirty || 50}/100

The tip was ${isHuge ? 'EXTREMELY generous ($5000+!)' : isGenerous ? 'very generous ($2000+)' : value >= 1000 ? 'generous' : 'nice'}.

Write a UNIQUE, personalized reply (1-2 sentences) thanking them. Your tone should be ${intimacy > 60 ? 'flirty, personal, maybe suggestive' : intimacy > 30 ? 'warm, friendly, appreciative' : 'professional but genuinely grateful'}.
${isHuge ? 'Express genuine excitement - this is a LOT of money!' : ''}
${personality.shy > 60 ? 'Be a bit bashful/flustered about the attention.' : ''}
${personality.flirty > 70 ? 'Add some playful flirtation.' : ''}

Be creative and natural - avoid generic phrases like "thank you so much" by itself. Add personality!

Write ONLY the reply text:`;
    } else {
      reactionPrompt = `You are ${recipient.name}, an employee who just received a gift (${gift.emoji} ${gift.name}, worth $${value}) from your boss (@TheBoss) on your social media post.

Your personality traits: ${traits.length > 0 ? traits.join(', ') : 'balanced'}
- Intimacy with boss: ${intimacy}/100 (${intimacy < 30 ? 'professional distance' : intimacy < 60 ? 'friendly' : 'close/intimate'})
- Affection: ${affection}/100
- Flirty tendency: ${personality.flirty || 50}/100

Gift details:
- Item: ${gift.name} ${gift.emoji}
- Category: ${gift.category || 'general'}
- Value: $${value}

Write a UNIQUE, personalized reply (1-2 sentences) thanking them for the ${gift.name}. Your tone should be ${intimacy > 60 ? 'flirty, personal, maybe suggestive' : intimacy > 30 ? 'warm, friendly, appreciative' : 'professional but genuinely grateful'}.
${gift.category === 'romantic' ? 'This is a romantic gift - be touched/flattered!' : ''}
${gift.category === 'luxury' ? 'This is a luxury item - express how impressed you are!' : ''}
${gift.category === 'funny' ? 'React with humor!' : ''}
${personality.shy > 60 ? 'Be a bit bashful about receiving such attention publicly.' : ''}

Be creative and natural - mention the specific gift, add emojis that fit your personality!

Write ONLY the reply text:`;
    }
    
    // Try up to 2 times to get a good AI response
    let reaction = null;
    for (let attempt = 0; attempt < 2 && !reaction; attempt++) {
      try {
        const rawReaction = await queuedGenerateText(reactionPrompt, {
          temperature: 0.9 + (attempt * 0.05), // Slightly higher temp on retry
          max_tokens: 80
        }, `${actionType} reaction from ${recipient.name}${attempt > 0 ? ' (retry)' : ''}`);
        
        let cleaned = rawReaction.trim()
          .replace(/^["']|["']$/g, '')
          .replace(/^(Reply:|Response:|Comment:)\s*/i, '')
          .split('\n')[0]
          .trim();
        
        if (cleaned && cleaned.length >= 10) {
          reaction = cleaned;
        }
      } catch (error) {
        console.warn(`[Social Reactions] Attempt ${attempt + 1} failed:`, error);
      }
    }
    
    // Only create comment if we got a valid AI response
    if (reaction) {
      const reactionComment = createComment({
        postId: post.id,
        authorId: recipient.id,
        authorName: recipient.name,
        content: reaction
      });
      post.comments.push(reactionComment);
      
      console.log(`[Social Reactions] ${recipient.name} reacted: "${reaction}"`);
      
      // Update feed/modal
      requestSmartFeedUpdate(post.id);
      if (postModalState.activePostId === post.id) {
        renderModalComments(post.id, true);
      }
    } else {
      console.error('[Social Reactions] Failed to generate recipient reaction after retries');
    }
  }
  
  /**
   * Generate a bystander NPC's reaction to seeing a tip/gift
   */
  async function generateBystanderReaction(post, bystander, recipient, actionType, value, gift = null) {
    const relationship = bystander.relationships?.find(r => r.targetId === recipient.id);
    const isJealous = bystander.personality?.envy > 60 || (relationship?.type === 'rival');
    const isFriendly = relationship?.type === 'friend' || relationship?.type === 'best_friend';
    const personality = bystander.personality || {};
    
    // Get some traits
    const traits = [];
    if (personality.flirty > 70) traits.push('flirty');
    if (personality.sarcastic > 70) traits.push('sarcastic');
    if (personality.playful > 70) traits.push('playful');
    if (personality.envy > 70) traits.push('envious');
    if (personality.supportive > 70) traits.push('supportive');
    
    const reactionPrompt = `You are ${bystander.name}, an employee seeing your boss (@TheBoss) ${actionType === 'tip' ? `tip $${value} to` : `gift a ${gift.emoji} ${gift.name} to`} your coworker ${recipient.name} on social media.

Your personality: ${traits.length > 0 ? traits.join(', ') : 'neutral'}
${isJealous ? `You're jealous of ${recipient.name} - you wish the boss noticed YOU like that!` : ''}
${isFriendly ? `You're friends with ${recipient.name} - you're happy for them!` : ''}
${!isJealous && !isFriendly ? 'You have a neutral relationship with them.' : ''}

Write a SHORT, UNIQUE comment (5-20 words max) reacting to this public display. Ideas:
${isJealous ? '- Express playful jealousy ("Ugh, some people get all the luck!" "When\'s my turn?")' : ''}
${isFriendly ? '- Hype up your friend ("Yesss get it!" "You deserve it!")' : ''}
- React to the boss's generosity
- Make a joke or witty observation
- Express something that fits YOUR unique personality

Be creative! NO generic responses. Add emojis that fit your vibe.

Write ONLY the comment:`;

    // Try up to 2 times
    let reaction = null;
    for (let attempt = 0; attempt < 2 && !reaction; attempt++) {
      try {
        const rawReaction = await queuedGenerateText(reactionPrompt, {
          temperature: 0.95 + (attempt * 0.03),
          max_tokens: 50
        }, `Bystander reaction from ${bystander.name}${attempt > 0 ? ' (retry)' : ''}`);
        
        let cleaned = rawReaction.trim()
          .replace(/^["']|["']$/g, '')
          .replace(/^(Comment:|Reply:)\s*/i, '')
          .split('\n')[0]
          .trim();
        
        if (cleaned && cleaned.length >= 5) {
          reaction = cleaned;
        }
      } catch (error) {
        console.warn(`[Social Reactions] Bystander attempt ${attempt + 1} failed:`, error);
      }
    }
    
    // Only create comment if we got a valid AI response
    if (reaction) {
      const reactionComment = createComment({
        postId: post.id,
        authorId: bystander.id,
        authorName: bystander.name,
        content: reaction
      });
      post.comments.push(reactionComment);
      
      console.log(`[Social Reactions] Bystander ${bystander.name} reacted: "${reaction}"`);
      
      // Update feed/modal
      requestSmartFeedUpdate(post.id);
      if (postModalState.activePostId === post.id) {
        renderModalComments(post.id, true);
      }
    } else {
      console.error(`[Social Reactions] Failed to generate bystander reaction from ${bystander.name}`);
    }
  }
  
  // Make functions globally available
  window.togglePostActionsMenu = togglePostActionsMenu;
  window.closePostActionsMenu = closePostActionsMenu;
  window.tipOnPost = tipOnPost;
  window.giftOnPost = giftOnPost;
  window.handlePostGiftGiven = handlePostGiftGiven;

  // Handle requesting an image from NPC
  /**
   * Request an image from NPC via attachment menu
   */
  async function requestImageFromNPC(preset = null, customPrompt = null) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    let requestType = preset || 'casual';
    let requestDescription = '';
    
    // Build request description based on preset or custom
    if (customPrompt) {
      requestDescription = customPrompt;
      // Try to detect type from custom prompt
      if (/\b(masturbat|dildo|toy|vibrator|orgasm|degradation|body.*writing|explicit.*act)\b/i.test(customPrompt)) {
        requestType = 'explicit';
      } else if (/\b(nude|naked|full.*nude)\b/i.test(customPrompt)) {
        requestType = 'nude';
      } else if (/\b(lewd|sexy|revealing|underwear|lingerie|topless)\b/i.test(customPrompt)) {
        requestType = 'lewd';
      } else if (/\b(work|office|professional)\b/i.test(customPrompt)) {
        requestType = 'work';
      } else if (/\b(selfie|picture|photo)\b/i.test(customPrompt)) {
        requestType = 'casual';
      }
    } else {
      // Use preset descriptions
      const presetDescriptions = {
        casual: 'send a casual selfie',
        work: 'send a work selfie',
        lewd: 'send a lewd/sexy photo',
        nude: 'send a nude photo',
        explicit: 'send explicit sexual content'
      };
      requestDescription = presetDescriptions[requestType] || 'send a photo';
    }
    
    // Add request message to chat directly (bypass normal AI response)
    const requestMessage = customPrompt || `Could you ${requestDescription}?`;
    
    // Add to chat history
    if (!gameState.chatHistory[emp.id]) {
      gameState.chatHistory[emp.id] = [];
    }
    gameState.chatHistory[emp.id].push({
      sender: 'You',
      content: requestMessage,
      isPlayer: true,
      timestamp: gameState.time?.currentTime || Date.now()
    });
    
    // Display the message
    addChatMessage('You', requestMessage, true);
    if (chatMessages) chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Clear input if it was set
    if (chatInput) chatInput.value = '';
    
    // Wait a moment, then check if NPC will agree and respond
    setTimeout(async () => {
      await evaluateAndExecuteImageRequest(emp, requestType, requestDescription, customPrompt);
    }, 1500);
  }
  
  /**
   * Evaluate if NPC agrees to image request and execute
   */
  async function evaluateAndExecuteImageRequest(employee, requestType, requestDescription, customPrompt = null) {
    const intimacy = employee.memory?.intimacyLevel || 0;
    const affection = employee.stats?.affection || 0;
    const comfort = employee.stats?.comfort || 0;
    const desire = employee.stats?.desire || 0;
    const personality = employee.personality || {};
    
    // Determine comfort level with request
    let comfortThreshold = 0;
    
    switch (requestType) {
      case 'casual':
        comfortThreshold = 5; // Almost always okay
        break;
      case 'work':
        comfortThreshold = 10; // Very easy
        break;
      case 'lewd':
        comfortThreshold = 48; // Need some attraction
        break;
      case 'nude':
        comfortThreshold = 73; // Need high intimacy
        break;
      case 'explicit':
        comfortThreshold = 88; // Need very high intimacy + desire
        break;
    }
    
    // Calculate willingness score (desire matters more for sexual content)
    const desireWeight = (requestType === 'explicit' || requestType === 'nude') ? 0.3 : 0.15;
    const willingnessScore = (intimacy * 0.35) + (affection * 0.2) + (desire * desireWeight) + (comfort * (0.3 - (desireWeight - 0.15)));
    
    // Determine if they'll do it
    const willDo = willingnessScore >= comfortThreshold || 
                   (willingnessScore >= comfortThreshold * 0.85 && Math.random() < 0.2);
    
    // LOG DECISION PROCESS
    console.log(`\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
    console.log(`ğŸ“¸ IMAGE REQUEST EVALUATION: ${employee.name}`);
    console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
    console.log(`Request Type: ${requestType.toUpperCase()}`);
    console.log(`Description: "${requestDescription}"`);
    console.log(`\nğŸ“Š Stats:`);
    console.log(`  â€¢ Intimacy: ${intimacy.toFixed(1)}`);
    console.log(`  â€¢ Affection: ${affection.toFixed(1)}`);
    console.log(`  â€¢ Comfort: ${comfort.toFixed(1)}`);
    console.log(`  â€¢ Desire: ${desire.toFixed(1)}`);
    console.log(`\nğŸ§® Calculation:`);
    console.log(`  â€¢ Intimacy Ã— 0.35 = ${(intimacy * 0.35).toFixed(2)}`);
    console.log(`  â€¢ Affection Ã— 0.2 = ${(affection * 0.2).toFixed(2)}`);
    console.log(`  â€¢ Desire Ã— ${desireWeight} = ${(desire * desireWeight).toFixed(2)}`);
    console.log(`  â€¢ Comfort Ã— ${(0.3 - (desireWeight - 0.15)).toFixed(2)} = ${(comfort * (0.3 - (desireWeight - 0.15))).toFixed(2)}`);
    console.log(`  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`);
    console.log(`  â€¢ Willingness Score: ${willingnessScore.toFixed(2)}`);
    console.log(`  â€¢ Required Threshold: ${comfortThreshold}`);
    console.log(`  â€¢ Grace Threshold (85%): ${(comfortThreshold * 0.85).toFixed(2)}`);
    console.log(`\nğŸ² Decision:`);
    if (willingnessScore >= comfortThreshold) {
      console.log(`  âœ… ACCEPTED - Score meets threshold`);
    } else if (willingnessScore >= comfortThreshold * 0.85) {
      console.log(`  ğŸ² GRACE ZONE - 20% chance (rolled: ${willDo ? 'SUCCESS' : 'FAIL'})`);
    } else {
      console.log(`  âŒ REJECTED - Score too low (${(comfortThreshold - willingnessScore).toFixed(2)} points short)`);
    }
    console.log(`\nğŸ“ Final Result: ${willDo ? 'âœ… WILL COMPLY' : 'âŒ WILL REFUSE'}`);
    console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`);
    
    if (willDo) {
      // Send agreement message first
      setTimeout(() => {
        if (gameState.activeChat?.id === employee.id && chatMessages) {
          const agreeMessages = {
            casual: ["Sure!", "Okay, one sec", "Alright"],
            work: ["Sure thing", "Okay", "No problem"],
            lewd: ["Okay... give me a sec ğŸ˜", "Fine, but only for you ğŸ˜˜", "Alright... one moment"],
            nude: ["Omg... okay ğŸ˜³", "I can't believe I'm doing this...", "Fuck it, why not"],
            explicit: ["Holy shit... okay ğŸ¥µ", "God, this is so hot...", "Fuck yes... one sec ğŸ’¦", "You're making me so wet... gimme a minute ğŸ˜ˆ"]
          };
          
          const messages = agreeMessages[requestType] || ["Okay"];
          const agreeMessage = messages[Math.floor(Math.random() * messages.length)];
          
          gameState.chatHistory[employee.id].push({
            sender: employee.name,
            content: agreeMessage,
            isPlayer: false,
            timestamp: gameState.time?.currentTime || Date.now()
          });
          
          const messageIndex = gameState.chatHistory[employee.id].length - 1;
          addChatMessage(employee.name, agreeMessage, false, null, messageIndex);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }, 1000 + Math.random() * 1500);
      
      // Generate and send it after a delay
      setTimeout(async () => {
        await generateAndSendRequestedImage(employee, requestType, customPrompt);
      }, 3000 + Math.random() * 5000); // 3-8 seconds
    } else {
      // Send a rejection message
      const rejectionMessages = {
        explicit: ["That's way too much for me", "I'm not comfortable with that", "That's crossing a line", "Absolutely not"],
        nude: ["I'm not ready for that", "That's a bit too much", "Maybe when we're closer", "I don't think so"],
        lewd: ["I'm not really comfortable with that", "That's a bit much for me", "Maybe another time"],
        work: ["Not really in the mood", "Maybe later"],
        casual: ["Not really feeling it right now", "Maybe later"]
      };
      
      const messages = rejectionMessages[requestType] || ["I'm not really comfortable with that"];
      const rejection = messages[Math.floor(Math.random() * messages.length)];
      
      setTimeout(() => {
        if (gameState.activeChat?.id === employee.id && chatMessages) {
          gameState.chatHistory[employee.id].push({
            sender: employee.name,
            content: rejection,
            isPlayer: false,
            timestamp: gameState.time?.currentTime || Date.now()
          });
          
          const messageIndex = gameState.chatHistory[employee.id].length - 1;
          addChatMessage(employee.name, rejection, false, null, messageIndex);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }, 2000 + Math.random() * 2000);
    }
  }
  
  /**
   * Generate and send requested image from NPC
   */
  async function generateAndSendRequestedImage(employee, requestType, customPrompt = null) {
    if (!gameState.activeChat || gameState.activeChat.id !== employee.id) return;
    
    const emp = employee;
    
    // Show typing indicator
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = emp.name;
    }
    
    try {
      let imagePrompt;
      
      if (customPrompt) {
        // For custom prompts, expand @mentions first to honor character targeting
        const expandedPrompt = expandImageMentions(customPrompt);
        
        if (expandedPrompt !== customPrompt) {
          console.log('[Request Image] ğŸ”„ Expanded @mentions in request');
          console.log('[Request Image] Original:', customPrompt);
          console.log('[Request Image] Expanded:', expandedPrompt);
          
          // Use the expanded prompt directly (don't inject current employee description)
          imagePrompt = expandedPrompt;
        } else {
          // No @ mentions found - use buildImagePrompt for context enhancement
          imagePrompt = await buildImagePrompt(emp, requestType, customPrompt);
        }
      } else {
        // No custom prompt - use standard buildImagePrompt
        imagePrompt = await buildImagePrompt(emp, requestType, customPrompt);
      }
      
      // Show loading message in chat
      const loadingMsg = document.createElement('div');
      loadingMsg.textContent = 'ğŸ¨ Generating image...';
      loadingMsg.style.cssText = 'text-align:center; padding:10px; opacity:0.7; font-style:italic;';
      if (chatMessages) {
        chatMessages.appendChild(loadingMsg);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Generate image using Perchance generateImage plugin
      const imageUrl = await queuedGenerateImage(applyImageStyle(imagePrompt), `Chat scene image for ${emp.name}`);
      
      // Remove loading message
      if (loadingMsg && loadingMsg.parentElement) {
        loadingMsg.remove();
      }
      
      // Get AI to generate a message accompanying the image
      const conversationHistory = gameState.chatHistory[emp.id]
        ?.map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n') || '';
      
      const messagePrompt = `${buildChatPrompt(emp, conversationHistory, '').prompt}

The player has requested a ${requestType || 'custom'} photo from you. You've agreed and are sending them an image that shows: ${imagePrompt}

Write a brief, natural message (1 sentence) to accompany the photo you're sending. Match your tone to the image type and your relationship:
- Casual/Work: Friendly, maybe playful
- Lewd: Flirty, teasing, confident  
- Nude: Bold, seductive, intimate
- Explicit: Intensely sexual, uninhibited, aroused, raw

${emp.name}'s message:`;

      const raw = await queuedGenerateText(messagePrompt, {}, `Generating image sharing message for ${emp.name}`);
      const message = sanitizeNpcResponse(raw, 1);
      
      // Hide typing indicator
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      
      // Add to history first to get the correct index
      if (!gameState.chatHistory[emp.id]) {
        gameState.chatHistory[emp.id] = [];
      }
      gameState.chatHistory[emp.id].push({
        sender: emp.name,
        content: message,
        isPlayer: false,
        imageUrl: imageUrl,
        imagePrompt: imagePrompt,
        imageType: 'received',
        timestamp: gameState.time?.currentTime || Date.now()
      });
      
      // CRITICAL FIX: Save immediately after image sent to prevent message loss
      saveGame(false);
      
      // Only add message to UI if this is still the active chat
      if (gameState.activeChat?.id === emp.id && chatMessages) {
        const receivedImageIndex = gameState.chatHistory[emp.id].length - 1;
        addChatMessage(emp.name, message, false, imageUrl, receivedImageIndex, imagePrompt);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Memory: remember sending this image
      remember(emp, `Sent ${requestType || 'custom'} photo to player`, 'event', 1.5);
      remember(emp, `The boss requested this photo`, 'interaction', 1.5);
      
      // Add to employee photos gallery
      if (!emp.photos) emp.photos = [];
      emp.photos.push({
        url: imageUrl,
        prompt: imagePrompt,
        type: requestType || 'custom',
        timestamp: gameState.time?.currentTime || Date.now()
      });
      
      // Update stats based on image type
      if (requestType === 'explicit') {
        emp.stats.desire = Math.min(100, (emp.stats.desire || 0) + 8);
        emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 4);
        emp.memory.intimacyLevel = Math.min(100, (emp.memory.intimacyLevel || 0) + 5);
        emp.stats.comfort = Math.min(100, (emp.stats.comfort || 0) + 3);
      } else if (requestType === 'nude') {
        emp.stats.desire = Math.min(100, (emp.stats.desire || 0) + 5);
        emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 3);
        emp.memory.intimacyLevel = Math.min(100, (emp.memory.intimacyLevel || 0) + 3);
      } else if (requestType === 'lewd') {
        emp.stats.desire = Math.min(100, (emp.stats.desire || 0) + 3);
        emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 2);
        emp.memory.intimacyLevel = Math.min(100, (emp.memory.intimacyLevel || 0) + 2);
      } else {
        emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 1);
      }
      
    } catch (error) {
      console.error('Error handling image request:', error);
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      // Only show error message if this is still the active chat
      if (gameState.activeChat?.id === emp.id && chatMessages) {
        addChatMessage(emp.name, "Sorry, I can't send that right now.", false);
      }
    }
  }
  
  // Visualize current scene without NPC response
  async function visualizeCurrentScene() {
    if (!gameState.activeChat) return;
    
    // IMPORTANT: Capture the employee at the START to prevent chat-switching bugs
    const emp = gameState.activeChat;
    const empId = emp.id;
    const empName = emp.name;
    
    try {
      // Build comprehensive scene description from context
      const recentMessages = gameState.chatHistory[empId]
        ?.slice(-15)
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n') || '';
      
      // Get consistent character description
      const empDesc = getPhysicalDescriptionForPrompt(emp);
      
      const playerBio = gameState.settings?.playerBio || 'the player';
      
      // Get current context from the conversation
      const lastPlayerMessage = gameState.chatHistory[empId]
        ?.filter(msg => msg.isPlayer)
        ?.slice(-3)
        .map(msg => msg.content)
        .join(' ') || '';
      
      const lastNpcMessage = gameState.chatHistory[empId]
        ?.filter(msg => !msg.isPlayer)
        ?.slice(-3)
        .map(msg => msg.content)
        .join(' ') || '';
      
      // AI analyzes scene and builds DETAILED visual prompt
      const scenePrompt = `You are generating an image prompt for the CURRENT MOMENT in this conversation.

Recent conversation between player and ${empName}:
${recentMessages}

Character descriptions:
${empName}: ${empDesc}
Player: ${playerBio}

Based on the conversation context, create a DETAILED, SPECIFIC image generation prompt showing:
1. The exact current activity or scene (what are they doing RIGHT NOW based on the last messages?)
2. Both characters' poses, expressions, and body language
3. The specific location/setting details (office, bedroom, outdoors, etc.)
4. Current mood/atmosphere from the conversation
5. Relevant clothing, props, or environmental details mentioned

Focus on VISUAL DETAILS that reflect the conversation's tone and content. Be specific and descriptive.

CRITICAL: Write ONLY the image description itself. NO markdown formatting, NO bold headers, NO labels like "Image Prompt:" or "Visual Details:", NO word counts, NO notes. Just the raw visual description.

Image prompt (50-150 words):`;

      let imagePrompt = await queuedGenerateText(scenePrompt, {
        temperature: 0.8,
        max_tokens: 200,
        stopSequences: ['---', 'Note:', 'Remember:', 'Visual Details:', '**Visual', 'Word count:']
      }, `Generating scene image prompt for ${emp.name}`);
      
      // CRITICAL FIX: Extract actual string from response
      imagePrompt = extractText(imagePrompt);
      
      // Remove XML-style tags if present
      imagePrompt = imagePrompt.replace(/<image prompt>/gi, '').replace(/<\/image prompt>/gi, '').trim();
      
      // Remove markdown formatting that AI sometimes adds
      imagePrompt = imagePrompt.replace(/^\*\*Image Prompt:\*\*\s*/gi, '');
      imagePrompt = imagePrompt.replace(/\*\*Visual Details:\*\*[\s\S]*/gi, ''); // Remove everything after "Visual Details:"
      imagePrompt = imagePrompt.replace(/\*\(Word count:.*?\)\*/gi, ''); // Remove word count notes
      imagePrompt = imagePrompt.replace(/\n\*\*.*?\*\*/g, ''); // Remove any other bold headers
      imagePrompt = imagePrompt.replace(/\n\s*-\s+\*\*.*?:\*\*/g, ''); // Remove bullet points with bold labels
      imagePrompt = imagePrompt.trim();
      
      console.log('[Scene Visualization] Generated prompt:', imagePrompt);
      console.log('[Scene Visualization] Prompt length:', imagePrompt.length, 'chars');
      
      // Show loading message in chat (but verify we're still in the right chat)
      const loadingMsg = document.createElement('div');
      loadingMsg.textContent = 'ğŸ¨ Visualizing current scene...';
      loadingMsg.style.cssText = 'text-align:center; padding:10px; opacity:0.7; font-style:italic;';
      
      // Only add loading message if we're still viewing this chat
      if (gameState.activeChat?.id === empId) {
        if (chatMessages) {
          chatMessages.appendChild(loadingMsg);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }
      
      // Generate image using Perchance generateImage plugin
      const imageUrl = await queuedGenerateImage(applyImageStyle(imagePrompt), `Scene visualization`);
      
      // Remove loading message (if it exists)
      if (loadingMsg && loadingMsg.parentElement) {
        loadingMsg.remove();
      }
      
      // Add to history with special type FIRST (so it persists even if chat switches)
      if (!gameState.chatHistory[empId]) {
        gameState.chatHistory[empId] = [];
      }
      gameState.chatHistory[empId].push({
        sender: 'System',
        content: 'ğŸ¬ Scene visualization',
        isPlayer: false,
        imageUrl: imageUrl,
        imagePrompt: imagePrompt,
        imageType: 'scene',
        timestamp: gameState.time?.currentTime || Date.now()
      });
      
      // Only add image to visible chat if we're still viewing this employee's chat
      if (gameState.activeChat?.id === empId) {
        const messageEl = document.createElement('div');
        messageEl.style.cssText = 'max-width:80%; padding:10px; margin:0 auto; text-align:center;';
        
        const img = document.createElement('img');
        img.src = imageUrl;
        img.style.cssText = 'width:100%; max-width:400px; border-radius:10px; cursor:pointer; box-shadow:0 2px 10px rgba(0,0,0,0.3);';
        img.onclick = () => {
          const viewer = document.createElement('div');
          viewer.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:99999; display:flex; justify-content:center; align-items:center; cursor:pointer;';
          viewer.innerHTML = `<img src="${imageUrl}" style="max-width:90%; max-height:90%; border-radius:10px;">`;
          viewer.onclick = () => viewer.remove();
          document.body.appendChild(viewer);
        };
        
        const caption = document.createElement('p');
        caption.style.cssText = 'margin:8px 0 0 0; color:#aaa; font-size:0.85rem; font-style:italic;';
        caption.textContent = 'ğŸ¬ Scene visualization';
        
        messageEl.appendChild(img);
        messageEl.appendChild(caption);
        chatMessages.appendChild(messageEl);
        
        // Scroll to bottom
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      // If chat switched, the image is already in history and will show when they return to this chat
      
    } catch (error) {
      console.error('Error visualizing scene:', error);
      // Only show error in the original chat
      if (gameState.activeChat?.id === empId) {
        addChatMessage('System', 'Could not generate scene visualization.', false);
      }
    }
  }
  
  // -------- AI-POWERED STAT EVALUATION --------
  // Analyzes conversation and updates employee stats naturally
  async function updateEmployeeStatsFromChat(emp, playerMessage, npcResponse) {
    if (!emp || !emp.stats) return;
    
    // Get office culture settings
    const policy = gameState.settings?.policy || 'professional';
    const guidelines = gameState.settings?.guidelines ?? 50;
    const atmosphere = gameState.settings?.atmosphere ?? 50;
    
    // Build evaluation context based on settings
    const atmosphereContext = (() => {
      if (atmosphere < 33) {
        return 'PROFESSIONAL office: Formal behavior expected. Personal topics, flirting, or casual banter may DECREASE comfort/affection unless trust is already very high. Work-focused conversations are valued.';
      } else if (atmosphere > 66) {
        return 'RELAXED office: Casual, friendly environment. Personal topics, humor, and informal chat INCREASE comfort/affection easily. Formality might seem stiff or awkward.';
      } else {
        return 'BALANCED office: Friendly professionalism. Personal topics are fine when rapport exists. Both formal and casual approaches can work depending on relationship level.';
      }
    })();
    
    const guidelineContext = (() => {
      if (guidelines < 33) {
        return 'NPC has RESERVED personality: Slow to warm up, guarded. Compliments and friendliness may DECREASE comfort initially (seems too forward). Trust builds slowly. Pushback and sarcasm are normal. Rate harshly on pushy/forward behavior.';
      } else if (guidelines > 66) {
        return 'NPC has OUTGOING personality: Warm and open. Friendly behavior and compliments INCREASE affection easily. Coldness or distance DECREASES stats. Be lenient - they want to connect.';
      } else {
        return 'NPC has STANDARD personality: Balanced responses. Rate authentically based on the message quality. Not overly harsh or lenient.';
      }
    })();
    
    const policyContext = (() => {
      if (policy === 'open') {
        return 'ENTHUSIASTIC consent model: NPCs are receptive to romantic/intimate advances. Flirting and personal interest INCREASE desire and affection. Be lenient with advances - they\'re welcome. Only decrease stats for genuinely disrespectful behavior.';
      } else if (policy === 'professional') {
        return 'PROFESSIONAL consent model: Boundaries are important. Romantic/intimate advances may DECREASE comfort/trust unless relationship stats are already very high (70+). Respect for boundaries is valued.';
      } else {
        return 'CASUAL consent model: NPCs need moderate trust/comfort before being receptive. Advances when stats are low (below 40) may decrease comfort. When stats are good (50+), advances are welcome.';
      }
    })();
    
    // Build evaluation prompt with extended context
    const conversationContext = gameState.chatHistory[emp.id]
      ?.slice(-4) // Last 2 exchanges only - reduced for speed
      .map(msg => `${msg.sender}: ${msg.content}`)
      .join('\n') || '';
    
    const currentStats = `Aff:${emp.stats.affection ?? 0} Com:${emp.stats.comfort ?? 0} Tru:${emp.stats.trust ?? 0} Des:${emp.stats.desire ?? 0} Obe:${emp.stats.obedience ?? 0}`;
    
    // OPTIMIZED: Front-load format, minimize prose, force cooperation
    const evaluationPrompt = `FORMAT: Output EXACTLY five integers [-10,+10] separated by single spaces. Example: "5 3 2 4 1" or "-2 0 1 -1 3". Do not add rationale or explanation, even silently.

RULES: Judge exchange; NPC consent/enthusiasm=increase; high stats(70+)=tolerant; gossip=bond
Stats: ${currentStats}
Culture: ${atmosphereContext} ${guidelineContext} ${policyContext}

Player: "${playerMessage}"
NPC: "${npcResponse}"

Output (Affection Comfort Trust Desire Obedience):`;

    try {
      const raw = await queuedGenerateText(evaluationPrompt, {
        temperature: 0,  // CHANGED: 0.3 â†’ 0 for deterministic output
        top_p: 0,        // NEW: Force deterministic
        max_tokens: 14,  // CHANGED: 10 â†’ 14 (room for -10 -10 -10 -10 -10)
        stopSequences: ['\n', '.', ',', 'Affection', 'Rationale', 'Why', 'Because', '(', '[', 'The', 'This', 'I', 'A', 'Rating']  // EXPANDED: hostile to prose
      }, `Evaluating chat interaction stats for ${emp.name}`);
      
      // IMPROVED: Better parsing with validation
      const cleanedRaw = raw.trim().replace(/[^\d\s\-+]/g, ''); // Strip non-numeric chars except spaces, -, +
      const numbers = cleanedRaw.split(/\s+/).map(n => {
        const parsed = parseFloat(n);
        return isNaN(parsed) ? 0 : Math.max(-10, Math.min(10, parsed)); // Clamp to [-10, 10]
      }).filter(n => n !== null);
      
      console.log(`[Stat Eval] Raw: "${raw.substring(0, 50)}" â†’ Parsed: [${numbers.join(', ')}]`);
      
      if (numbers.length >= 5) {
        // Detect if NPC response shows consent/enthusiasm
        const npcResponseLower = (npcResponse || '').toLowerCase();
        const showsConsent = /\b(yes|okay|sure|love|want|enjoy|feel.*good|amazing|please|more|don't.*stop|keep.*going|feels.*so|like.*that|mm+|ah+|oh+.*god|fuck.*yes)\b/.test(npcResponseLower);
        const showsEnthusiasm = /\b(love|amazing|incredible|perfect|yes+|god.*yes|so.*good|feels.*amazing|want.*more|don't.*stop)\b/.test(npcResponseLower);
        const showsDiscomfort = /\b(no|stop|don't|uncomfortable|not.*ready|too.*much|can't|won't|shouldn't|wait|slow.*down)\b/.test(npcResponseLower);
        
        // Calculate average current stat level (for relationship strength check)
        const avgStats = ((emp.stats.affection ?? 50) + (emp.stats.comfort ?? 50) + (emp.stats.trust ?? 50) + (emp.stats.desire ?? 20)) / 4;
        const strongRelationship = avgStats >= 70;
        
        // Apply stat changes with smart moderation
        const applyChange = (current, change, statName, max = 100, min = 0) => {
          // SAFETY CHECK: Prevent harsh drops in consensual scenarios
          if (change < -3 && showsConsent && !showsDiscomfort) {
            // NPC clearly consented - cap the negative change
            console.log(`[Stat Protection] ${emp.name}'s ${statName}: Capping drop from ${change} to -2 (NPC showed consent)`);
            change = Math.max(change, -2);
          }
          
          // SAFETY CHECK: Strong relationships are more resilient
          if (change < -5 && strongRelationship && !showsDiscomfort) {
            // High stats = strong bond, can handle more
            console.log(`[Stat Protection] ${emp.name}'s ${statName}: Capping drop from ${change} to -3 (strong relationship)`);
            change = Math.max(change, -3);
          }
          
          // BONUS: Amplify gains when NPC shows enthusiasm
          if (change > 0 && showsEnthusiasm) {
            change = change * 1.5;
            console.log(`[Stat Bonus] ${emp.name}'s ${statName}: Amplifying gain to ${change.toFixed(1)} (NPC enthusiastic)`);
          }
          
          // Apply cheat multiplier if it exists
          const multiplier = gameState.cheatMultipliers?.[statName.toLowerCase()] || 1.0;
          if (multiplier !== 1.0) {
            change = change * multiplier;
            console.log(`[Cheat Multiplier] ${emp.name}'s ${statName}: ${multiplier.toFixed(1)}x multiplier applied`);
          }
          
          let newVal = current + change;
          
          // Diminishing returns near caps
          if (change > 0 && current > 80) {
            newVal = current + (change * 0.5); // Half effect above 80
          } else if (change > 0 && current > 90) {
            newVal = current + (change * 0.25); // Quarter effect above 90
          }
          
          return Math.max(min, Math.min(max, newVal));
        };
        
        emp.stats.affection = applyChange(emp.stats.affection ?? 50, numbers[0], 'Affection');
        emp.stats.comfort = applyChange(emp.stats.comfort ?? 50, numbers[1], 'Comfort');
        emp.stats.trust = applyChange(emp.stats.trust ?? 50, numbers[2], 'Trust');
        emp.stats.desire = applyChange(emp.stats.desire ?? 20, numbers[3], 'Desire');
        emp.stats.obedience = applyChange(emp.stats.obedience ?? 50, numbers[4], 'Obedience');
        
        // Log stat changes for debugging
        console.log(`[Stat Update] ${emp.name}: Aff${numbers[0]>0?'+':''}${numbers[0]} Com${numbers[1]>0?'+':''}${numbers[1]} Tru${numbers[2]>0?'+':''}${numbers[2]} Des${numbers[3]>0?'+':''}${numbers[3]} Obe${numbers[4]>0?'+':''}${numbers[4]}${showsConsent?' [CONSENT]':''}${showsEnthusiasm?' [ENTHUSIASTIC]':''}${showsDiscomfort?' [DISCOMFORT]':''}`);
        
        // Update UI if on people tab
        if (gameState.activeTab === 'people') {
          updatePeopleTab();
        }
      } else {
        // Fallback: Basic keyword analysis if AI fails
        console.warn('[Stat Update] AI evaluation failed, using fallback');
        fallbackStatUpdate(emp, playerMessage, npcResponse);
      }
    } catch (error) {
      console.error('[Stat Update] Error:', error);
      fallbackStatUpdate(emp, playerMessage, npcResponse);
    }
  }
  
  // Fallback stat update using keyword analysis
  function fallbackStatUpdate(emp, playerMsg, npcMsg) {
    const p = (playerMsg || '').toLowerCase();
    const n = (npcMsg || '').toLowerCase();
    
    // Affection changes
    if (/\b(thank|appreciate|grateful|wonderful|amazing|great job)\b/.test(p)) {
      emp.stats.affection = Math.min(100, (emp.stats.affection ?? 50) + 3);
    }
    if (/\b(stupid|idiot|useless|hate)\b/.test(p)) {
      emp.stats.affection = Math.max(0, (emp.stats.affection ?? 50) - 5);
    }
    
    // Comfort changes
    if (/\b(comfortable|relaxed|casual|easy|chill)\b/.test(p)) {
      emp.stats.comfort = Math.min(100, (emp.stats.comfort ?? 50) + 2);
    }
    if (/\b(nervous|anxious|worried|uncomfortable)\b/.test(n)) {
      emp.stats.comfort = Math.max(0, (emp.stats.comfort ?? 50) - 3);
    }
    
    // Trust changes
    if (/\b(honest|truth|trust|believe|promise)\b/.test(p)) {
      emp.stats.trust = Math.min(100, (emp.stats.trust ?? 50) + 2);
    }
    if (/\b(lie|lied|dishonest|deceive)\b/.test(p)) {
      emp.stats.trust = Math.max(0, (emp.stats.trust ?? 50) - 4);
    }
    
    // Desire changes
    if (/\b(beautiful|gorgeous|sexy|hot|attractive|cute)\b/.test(p)) {
      emp.stats.desire = Math.min(100, (emp.stats.desire ?? 20) + 4);
    }
    if (/\b(date|dinner|kiss|touch|want you)\b/.test(p)) {
      emp.stats.desire = Math.min(100, (emp.stats.desire ?? 20) + 3);
    }
    
    // Obedience changes
    if (/\b(good job|well done|excellent|perfect)\b/.test(p)) {
      emp.stats.obedience = Math.min(100, (emp.stats.obedience ?? 50) + 2);
    }
    if (/\b(no|won't|refuse|can't make me)\b/.test(n)) {
      emp.stats.obedience = Math.max(0, (emp.stats.obedience ?? 50) - 2);
    }
    
    // Productivity is more stable, changes slowly
    if (/\b(work|project|task|deadline)\b/.test(p)) {
      emp.stats.productivity = Math.min(100, (emp.stats.productivity ?? 50) + 1);
    }
    
    // Check for gossip-worthy interactions!
    checkForGossipWorthyInteraction(emp, playerMsg, npcMsg);
  }
  
  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * ğŸŒ SOCIAL DYNAMICS SYSTEM: NPC-to-NPC Relationship Evolution
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * Evaluates how NPCs feel about each other based on social interactions
   * Posts, comments, likes, and tags all influence relationships
   * 
   * OPTIMIZATION: Uses batching and heuristics to reduce AI calls by 60%
   */
  
  /**
   * Track post topic keywords to prevent duplicates (AI Optimization)
   */
  function trackPostTopic(postContent) {
    if (!postContent) return;
    
    const content = postContent.toLowerCase();
    
    // Extract key terms
    const keywords = [
      // Work related
      'meeting', 'deadline', 'project', 'presentation', 'report', 'work',
      // Social
      'coffee', 'lunch', 'drinks', 'party', 'dinner', 'hangout',
      // Objects
      'keys', 'phone', 'laptop', 'car', 'desk', 'folder',
      // Actions
      'lost', 'found', 'looking for', 'searching', 'organize', 'clean',
      // Locations
      'garage', 'parking', 'office', 'break room', 'kitchen',
      // Common themes
      'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'weekend',
      'tired', 'stressed', 'excited', 'happy', 'frustrated'
    ];
    
    const foundKeywords = keywords.filter(kw => content.includes(kw));
    
    if (foundKeywords.length > 0) {
      const topicKey = foundKeywords.join('_');
      aiOptimization.recentTopics.set(topicKey, Date.now());
      
      // Clean old topics (older than 5 minutes)
      const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
      for (const [key, timestamp] of aiOptimization.recentTopics.entries()) {
        if (timestamp < fiveMinutesAgo) {
          aiOptimization.recentTopics.delete(key);
        }
      }
    }
  }
  
  /**
   * Check if a topic was recently used (AI Optimization)
   */
  function wasTopicRecentlyUsed(postContent) {
    if (!postContent) return false;
    
    const content = postContent.toLowerCase();
    const threeMinutesAgo = Date.now() - (3 * 60 * 1000);
    
    // Check if this content contains any recently used keyword combinations
    for (const [topicKey, timestamp] of aiOptimization.recentTopics.entries()) {
      if (timestamp > threeMinutesAgo) {
        const keywords = topicKey.split('_');
        const matchCount = keywords.filter(kw => content.includes(kw)).length;
        
        // If 50%+ of the keywords match, consider it a duplicate topic
        if (matchCount >= Math.ceil(keywords.length / 2)) {
          return true;
        }
      }
    }
    
    return false;
  }
  
  /**
   * Start relationship evaluation batching system
   */
  function startRelationshipBatching() {
    if (aiOptimization.relationshipBatchInterval) return;
    
    aiOptimization.relationshipBatchInterval = setInterval(() => {
      processRelationshipBatch();
    }, aiOptimization.relationshipBatchDelay);
    
    console.log('[AI Optimization] Relationship batching started (30s intervals)');
  }
  
  /**
   * Process batched relationship evaluations
   * IMPROVED: Limits batch size and processes most important first
   */
  async function processRelationshipBatch() {
    if (aiOptimization.relationshipQueue.length === 0) return;
    
    // OPTIMIZATION: Limit queue size to prevent memory issues and excessive AI calls
    const MAX_QUEUE_SIZE = 50; // Process max 50 evaluations per batch
    
    if (aiOptimization.relationshipQueue.length > MAX_QUEUE_SIZE) {
      console.log(`[AI Optimization] âš ï¸ Queue too large (${aiOptimization.relationshipQueue.length}), trimming to ${MAX_QUEUE_SIZE}`);
      
      // Keep most recent items (they're more relevant)
      aiOptimization.relationshipQueue = aiOptimization.relationshipQueue.slice(-MAX_QUEUE_SIZE);
    }
    
    const batch = [...aiOptimization.relationshipQueue];
    aiOptimization.relationshipQueue = [];
    
    console.log(`[AI Optimization] Processing ${batch.length} queued relationship evaluations`);
    
    // OPTIMIZATION: Process sequentially with a small delay to avoid rate limiting
    for (let i = 0; i < batch.length; i++) {
      const item = batch[i];
      try {
        await evaluateNPCReactionToPostImmediate(item.viewer, item.postAuthor, item.post, item.comment);
        
        // Add small delay between calls (100ms) to prevent overwhelming the AI
        if (i < batch.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      } catch (error) {
        console.error('[AI Optimization] Batch processing error:', error);
      }
    }
    
    console.log(`[AI Optimization] âœ“ Batch complete. Queue now at ${aiOptimization.relationshipQueue.length}`);
  }
  
  /**
   * ALGORITHMIC NPC->NPC INTERACTION ANALYZER
   * Pure pattern recognition - NO AI CALLS
   */
  function evaluateNPCReactionToPost(viewer, postAuthor, post, comment = null) {
    if (!viewer || !postAuthor || viewer.id === postAuthor.id) return;
    
    // Use ONLY algorithmic analysis
    const change = analyzeNPCInteractionAlgorithmic(viewer, postAuthor, post, comment);
    applyRelationshipChange(viewer, postAuthor, change, 'algorithmic');
  }
  
  /**
   * ALGORITHMIC NPC INTERACTION ANALYZER
   * Sophisticated pattern recognition system - NO AI
   * Analyzes post content, comment sentiment, personality compatibility, and context
   * Returns relationship change value (-5 to +5)
   */
  function analyzeNPCInteractionAlgorithmic(viewer, postAuthor, post, comment) {
    // Initialize relationship
    if (!viewer.relationships) viewer.relationships = {};
    const relationship = viewer.relationships[postAuthor.id] || { strength: 50, type: 'colleague' };
    const currentStrength = relationship.strength;
    
    // Get personalities
    const viewerPersonality = viewer.personality || {};
    const authorPersonality = postAuthor.personality || {};
    
    let baseChange = 0;
    let modifiers = [];
    
    // ===== PHASE 1: ANALYZE POST CONTENT =====
    const postContent = (post.content || '').toLowerCase();
    const postType = post.type || 'text';
    const explicitLevel = post.explicitLevel || 0;
    const hasImage = !!post.imageUrl;
    
    // Base reaction to post type
    const postTypeScores = {
      'meme': 1,
      'funny': 1,
      'achievement': 2,
      'work_update': 0,
      'selfie': 1,
      'thirst_trap': 0,
      'explicit': -1,
      'life_update': 1,
      'food': 0,
      'travel': 1,
      'fitness': 0,
      'hobby': 1,
      'entertainment': 0,
      'mood': 0,
      'question': 0,
      'throwback': 1,
      'tea_spilling': 2,
      'gossip': 1
    };
    
    baseChange += postTypeScores[postType] || 0;
    
    // Explicit content reactions based on viewer personality
    if (explicitLevel >= 2) {
      const viewerFlirty = viewerPersonality.flirty || 50;
      const viewerProfessional = viewerPersonality.professional || 50;
      const viewerConfidence = viewerPersonality.confidence || 50;
      
      if (viewerFlirty > 70) {
        baseChange += 2; // Flirty people enjoy explicit content
        modifiers.push('flirty_viewer_likes_explicit');
      } else if (viewerProfessional > 70) {
        baseChange -= 1; // Professional people uncomfortable
        modifiers.push('professional_viewer_uncomfortable');
      }
      
      // Confidence affects reaction
      if (viewerConfidence < 40 && explicitLevel >= 3) {
        baseChange -= 1; // Shy people uncomfortable with very explicit
        modifiers.push('shy_viewer_uncomfortable');
      }
    }
    
    // ===== PHASE 2: ANALYZE COMMENT (if present) =====
    if (comment) {
      const commentLower = comment.toLowerCase();
      const commentLength = comment.length;
      
      // Sentiment analysis via keywords and emojis
      const positiveKeywords = ['love', 'amazing', 'great', 'awesome', 'beautiful', 'perfect', 'best', 'proud', 'congrats', 'yay', 'yes', 'nice', 'good', 'happy'];
      const negativeKeywords = ['hate', 'awful', 'terrible', 'worst', 'wtf', 'seriously', 'ugh', 'gross', 'cringe', 'yikes'];
      const funnyKeywords = ['lol', 'haha', 'lmao', 'rofl', 'dead', 'omg', 'hilarious'];
      const flirtyKeywords = ['hot', 'sexy', 'damn', 'gorgeous', 'stunning', 'fine', 'looking good'];
      const dramaKeywords = ['tea', 'drama', 'omg', 'spill', 'gossip', 'scandal', 'messy'];
      
      const positiveEmojis = ['â¤ï¸', 'ğŸ’•', 'ğŸ˜', 'ğŸ¥°', 'ğŸ˜Š', 'ğŸ˜', 'ğŸ‰', 'ğŸ‘', 'âœ¨', 'ğŸ’¯', 'ğŸ”¥'];
      const negativeEmojis = ['ğŸ™„', 'ğŸ˜’', 'ğŸ˜¤', 'ğŸ’€', 'ğŸ˜¬'];
      const funnyEmojis = ['ğŸ˜‚', 'ğŸ¤£', 'ğŸ’€', 'ğŸ˜­'];
      const flirtyEmojis = ['ğŸ˜', 'ğŸ˜˜', 'ğŸ¥µ', 'ğŸ‘€', 'ğŸ”¥'];
      const dramaEmojis = ['â˜•', 'ğŸ«–', 'ğŸ‘€', 'ğŸ¿'];
      
      // Count sentiment indicators
      let positiveScore = 0;
      let negativeScore = 0;
      let funnyScore = 0;
      let flirtyScore = 0;
      let dramaScore = 0;
      
      // Keywords
      positiveKeywords.forEach(kw => { if (commentLower.includes(kw)) positiveScore += 1; });
      negativeKeywords.forEach(kw => { if (commentLower.includes(kw)) negativeScore += 1; });
      funnyKeywords.forEach(kw => { if (commentLower.includes(kw)) funnyScore += 1; });
      flirtyKeywords.forEach(kw => { if (commentLower.includes(kw)) flirtyScore += 1; });
      dramaKeywords.forEach(kw => { if (commentLower.includes(kw)) dramaScore += 1; });
      
      // Emojis (worth 1.5x keywords)
      positiveEmojis.forEach(em => { if (comment.includes(em)) positiveScore += 1.5; });
      negativeEmojis.forEach(em => { if (comment.includes(em)) negativeScore += 1.5; });
      funnyEmojis.forEach(em => { if (comment.includes(em)) funnyScore += 1.5; });
      flirtyEmojis.forEach(em => { if (comment.includes(em)) flirtyScore += 1.5; });
      dramaEmojis.forEach(em => { if (comment.includes(em)) dramaScore += 1.5; });
      
      // Determine dominant sentiment
      const maxScore = Math.max(positiveScore, negativeScore, funnyScore, flirtyScore, dramaScore);
      
      if (maxScore > 0) {
        if (positiveScore === maxScore) {
          baseChange += 3;
          modifiers.push('supportive_comment');
        } else if (funnyScore === maxScore) {
          baseChange += 2;
          modifiers.push('funny_comment');
        } else if (flirtyScore === maxScore) {
          baseChange += 2;
          modifiers.push('flirty_comment');
        } else if (dramaScore === maxScore) {
          baseChange += 1;
          modifiers.push('dramatic_comment');
        } else if (negativeScore === maxScore) {
          baseChange -= 2;
          modifiers.push('negative_comment');
        }
      } else {
        // Neutral/generic comment
        if (commentLength < 15) {
          baseChange += 0.5; // Short generic comments are weak bonding
          modifiers.push('generic_comment');
        } else {
          baseChange += 1; // Longer comments show engagement
          modifiers.push('engaged_comment');
        }
      }
      
      // Comment length bonus (more effort = stronger bond)
      if (commentLength > 50) {
        baseChange += 0.5;
        modifiers.push('lengthy_comment');
      }
      
    } else {
      // Just viewing, no comment
      // Most views have minimal impact
      if (explicitLevel < 2 && postType !== 'achievement' && postType !== 'tea_spilling') {
        baseChange += 0; // Neutral view
        modifiers.push('casual_view');
      } else if (postType === 'achievement') {
        baseChange += 1; // Appreciate achievements even without comment
        modifiers.push('appreciates_achievement');
      } else if (postType === 'tea_spilling' || postType === 'gossip') {
        baseChange += 0.5; // Drama is interesting
        modifiers.push('interested_in_drama');
      }
    }
    
    // ===== PHASE 3: PERSONALITY COMPATIBILITY =====
    const viewerOutgoing = viewerPersonality.outgoing || 50;
    const authorOutgoing = authorPersonality.outgoing || 50;
    const viewerHumor = viewerPersonality.humor || 50;
    const authorHumor = authorPersonality.humor || 50;
    const viewerFlirty = viewerPersonality.flirty || 50;
    const authorFlirty = authorPersonality.flirty || 50;
    
    // Similar personalities bond better
    const outgoingDiff = Math.abs(viewerOutgoing - authorOutgoing);
    const humorDiff = Math.abs(viewerHumor - authorHumor);
    const flirtyDiff = Math.abs(viewerFlirty - authorFlirty);
    
    const avgDiff = (outgoingDiff + humorDiff + flirtyDiff) / 3;
    
    if (avgDiff < 20) {
      baseChange += 0.5; // Very compatible
      modifiers.push('compatible_personalities');
    } else if (avgDiff > 60) {
      baseChange -= 0.5; // Clashing personalities
      modifiers.push('clashing_personalities');
    }
    
    // ===== PHASE 4: RELATIONSHIP CONTEXT =====
    // Strong relationships amplify positive interactions
    if (currentStrength > 70 && baseChange > 0) {
      baseChange *= 1.2;
      modifiers.push('strong_bond_amplifies');
    }
    
    // Weak relationships dampen negative interactions (not close enough to care)
    if (currentStrength < 30 && baseChange < 0) {
      baseChange *= 0.7;
      modifiers.push('weak_bond_dampens');
    }
    
    // ===== PHASE 5: CONTENT-SPECIFIC MODIFIERS =====
    // Tag analysis
    if (postContent.includes('@' + viewer.name.toLowerCase())) {
      baseChange += 1.5; // Being mentioned is bonding
      modifiers.push('mentioned_in_post');
    }
    
    // Question posts invite engagement
    if (postContent.includes('?') && !comment) {
      baseChange -= 0.5; // Ignoring a question is slightly negative
      modifiers.push('ignored_question');
    }
    
    // Shared interests (hobby matching)
    const viewerHobbies = (viewer.hobbies || []).map(h => h.toLowerCase());
    const postHobbies = (post.tags || []).map(t => t.toLowerCase());
    const sharedInterests = viewerHobbies.filter(h => postHobbies.includes(h)).length;
    
    if (sharedInterests > 0) {
      baseChange += sharedInterests * 0.5;
      modifiers.push(`shared_interests_x${sharedInterests}`);
    }
    
    // ===== FINAL: CLAMP AND RETURN =====
    const finalChange = Math.max(-5, Math.min(5, Math.round(baseChange * 10) / 10));
    
    // Removed flooding console logs - relationship changes tracked silently
    // if (finalChange !== 0) {
    //   console.log(`[Algorithmic] ${viewer.name} â†” ${postAuthor.name}: ${finalChange > 0 ? '+' : ''}${finalChange} (${currentStrength} â†’ ${currentStrength + finalChange}) [${modifiers.join(', ')}]`);
    // }
    
    return finalChange;
  }
  
  /**
   * Apply relationship change without AI evaluation
   */
  function applyRelationshipChange(viewer, postAuthor, change, source = 'ai') {
    if (!viewer || !postAuthor || viewer.id === postAuthor.id) return;
    
    // Get or initialize relationship
    if (!viewer.relationships) viewer.relationships = {};
    if (!viewer.relationships[postAuthor.id]) {
      viewer.relationships[postAuthor.id] = {
        strength: 50,
        type: 'colleague',
        history: []
      };
    }
    
    const relationship = viewer.relationships[postAuthor.id];
    const oldStrength = relationship.strength || 50; // Default to 50 if undefined
    const newStrength = oldStrength + change;
    relationship.strength = Math.max(0, Math.min(100, newStrength));
    
    // Update relationship type based on strength
    if (relationship.strength > 80) relationship.type = 'best_friend';
    else if (relationship.strength > 65) relationship.type = 'friend';
    else if (relationship.strength > 35) relationship.type = 'colleague';
    else if (relationship.strength > 15) relationship.type = 'acquaintance';
    else relationship.type = 'distant';
    
    if (change !== 0) {
      // Add to history
      relationship.history.push({
        timestamp: gameState.time?.currentTime || Date.now(),
        type: 'social_interaction',
        change: change,
        source: source
      });
      
      // Keep history reasonable
      if (relationship.history.length > 20) {
        relationship.history = relationship.history.slice(-20);
      }
      
      // Create gossip if relationship changed significantly
      if (Math.abs(change) >= 4) {
        createGossipFromSocialInteraction(viewer, postAuthor, null, null, change);
      }
    }
  }
  
  /**
   * Evaluate NPC reaction to another NPC's post (IMMEDIATE - used by batch processor)
   * Called when NPC views/comments on another NPC's post
   * This is the AI-powered version that gets called for complex cases
   */
  async function evaluateNPCReactionToPostImmediate(viewer, postAuthor, post, comment = null) {
    if (!viewer || !postAuthor || viewer.id === postAuthor.id) return;
    
    // Get or initialize relationship
    if (!viewer.relationships) viewer.relationships = {};
    if (!viewer.relationships[postAuthor.id]) {
      viewer.relationships[postAuthor.id] = {
        strength: 50,
        type: 'colleague',
        history: []
      };
    }
    
    const relationship = viewer.relationships[postAuthor.id];
    const currentStrength = relationship.strength || 50;
    
    // Build context
    const postType = post.type || 'text';
    const explicitLevel = post.explicitLevel || 0;
    const hasComment = !!comment;
    
    // Get viewer's personality to determine reaction style
    const viewerPersonality = viewer.personality || {};
    const viewerFlirty = viewerPersonality.flirty || 50;
    const viewerProfessional = viewerPersonality.professional || 50;
    const viewerHumor = viewerPersonality.humor || 50;
    
    const evaluationPrompt = `Post: "${post.content?.substring(0, 60) || ''}"${hasComment ? `\nComment: "${comment.substring(0, 50)}"` : ''}
Rel: ${currentStrength}/100
Output single number -5 to +5 only:`;

    try {
      const raw = await queuedGenerateText(evaluationPrompt, { 
        temperature: 0.3, 
        max_tokens: 3,
        stopSequences: ['\n', ' ', 'Rating:', '**', 'Why', '(', 'The ', 'This ']
      }, `Evaluating social post reaction for ${viewer.name}`);
      const change = parseFloat(raw.trim());
      
      if (!isNaN(change) && change >= -5 && change <= 5) {
        applyRelationshipChange(viewer, postAuthor, change, 'ai');
      }
    } catch (error) {
      console.error(`[Social Dynamics] Error evaluating ${viewer.name}'s reaction:`, error);
    }
  }
  
  /**
   * Evaluate NPC-to-NPC comment interaction
   * Called when one NPC comments on another NPC's comment
   */
  /**
   * ALGORITHMIC NPC COMMENT REPLY ANALYZER
   * Evaluates NPC-to-NPC comment exchanges - NO AI
   */
  async function evaluateNPCCommentInteraction(commenter, originalCommenter, post, comment, replyComment) {
    if (!commenter || !originalCommenter || commenter.id === originalCommenter.id) return;
    
    // Initialize relationships
    if (!commenter.relationships) commenter.relationships = {};
    if (!commenter.relationships[originalCommenter.id]) {
      commenter.relationships[originalCommenter.id] = {
        strength: 50,
        type: 'colleague',
        history: []
      };
    }
    
    const relationship = commenter.relationships[originalCommenter.id];
    const oldStrength = relationship.strength || 50;
    
    // ALGORITHMIC ANALYSIS - NO AI
    const change = analyzeCommentReplyAlgorithmic(commenter, originalCommenter, comment, replyComment, relationship);
    
    if (!isNaN(change) && change >= -5 && change <= 5 && change !== 0) {
      relationship.strength = Math.max(0, Math.min(100, oldStrength + change));
      
      // Update type
      if (relationship.strength > 80) relationship.type = 'best_friend';
      else if (relationship.strength > 65) relationship.type = 'friend';
      else if (relationship.strength > 35) relationship.type = 'colleague';
      else relationship.type = 'distant';
      
      console.log(`[Comment Dynamics] ${commenter.name} â†” ${originalCommenter.name}: ${change > 0 ? '+' : ''}${change} (${oldStrength} â†’ ${relationship.strength})`);
      
      relationship.history.push({
        timestamp: gameState.time?.currentTime || Date.now(),
        type: 'comment_exchange',
        description: `Replied to ${originalCommenter.name}'s comment`,
        change: change
      });
      
      if (relationship.history.length > 20) {
        relationship.history = relationship.history.slice(-20);
      }
    }
  }
  
  /**
   * ALGORITHMIC COMMENT REPLY ANALYZER
   * Pattern recognition for comment tone and relationship dynamics
   * NO AI - Pure sentiment analysis and pattern matching
   */
  function analyzeCommentReplyAlgorithmic(commenter, originalCommenter, comment, replyComment, relationship) {
    const commentLower = comment.toLowerCase();
    const replyLower = replyComment.toLowerCase();
    const currentStrength = relationship.strength || 50;
    
    let baseChange = 0;
    
    // Get personalities
    const commenterPersonality = commenter.personality || {};
    const originalPersonality = originalCommenter.personality || {};
    
    // ===== ANALYZE SENTIMENT MATCH/CLASH =====
    
    // Sentiment indicators
    const positiveWords = ['love', 'great', 'awesome', 'amazing', 'perfect', 'yes', 'agree', 'right', 'exactly', 'totally'];
    const negativeWords = ['hate', 'wrong', 'no', 'disagree', 'awful', 'terrible', 'stop', 'wtf'];
    const agreementWords = ['yeah', 'yep', 'same', 'agree', 'right', 'exactly', 'totally', 'fr', 'facts'];
    const disagreementWords = ['but', 'actually', 'no', 'nah', 'disagree', 'wrong'];
    
    // Score sentiments
    let commentPositive = 0;
    let commentNegative = 0;
    let replyPositive = 0;
    let replyNegative = 0;
    let replyAgreement = 0;
    let replyDisagreement = 0;
    
    positiveWords.forEach(w => {
      if (commentLower.includes(w)) commentPositive++;
      if (replyLower.includes(w)) replyPositive++;
    });
    
    negativeWords.forEach(w => {
      if (commentLower.includes(w)) commentNegative++;
      if (replyLower.includes(w)) replyNegative++;
    });
    
    agreementWords.forEach(w => {
      if (replyLower.includes(w)) replyAgreement++;
    });
    
    disagreementWords.forEach(w => {
      if (replyLower.includes(w)) replyDisagreement++;
    });
    
    // ===== ANALYZE INTERACTION TYPE =====
    
    // 1. Agreement/Support
    if (replyAgreement > replyDisagreement) {
      baseChange += 2; // Agreement builds bonds
      if (currentStrength > 60) baseChange += 1; // Friends agreeing is extra bonding
    }
    
    // 2. Disagreement/Conflict
    if (replyDisagreement > replyAgreement) {
      baseChange -= 1.5; // Disagreement creates tension
      if (currentStrength < 40) baseChange -= 0.5; // Worse if not close
    }
    
    // 3. Positive exchange (both positive)
    if (commentPositive > commentNegative && replyPositive > replyNegative) {
      baseChange += 2; // Mutual positivity
    }
    
    // 4. Negative exchange (both negative)
    if (commentNegative > commentPositive && replyNegative > replyPositive) {
      // Could be bonding over shared complaint or actual conflict
      if (replyAgreement > 0) {
        baseChange += 1.5; // Bonding over shared grievance
      } else {
        baseChange -= 1; // Just negative
      }
    }
    
    // 5. Mismatched sentiment (one positive, one negative)
    if ((commentPositive > commentNegative && replyNegative > replyPositive) ||
        (commentNegative > commentPositive && replyPositive > replyNegative)) {
      baseChange -= 1; // Tone mismatch
    }
    
    // ===== ANALYZE EMOJIS =====
    const positiveEmojis = ['â¤ï¸', 'ğŸ’•', 'ğŸ˜', 'ğŸ¥°', 'ğŸ˜Š', 'ğŸ˜', 'ğŸ‰', 'âœ¨'];
    const funnyEmojis = ['ğŸ˜‚', 'ğŸ¤£', 'ğŸ’€', 'ğŸ˜­'];
    const negativeEmojis = ['ğŸ™„', 'ğŸ˜’', 'ğŸ˜¤', 'ğŸ˜¬'];
    const flirtyEmojis = ['ğŸ˜', 'ğŸ˜˜', 'ğŸ¥µ', 'ğŸ”¥'];
    
    let replyEmojiScore = 0;
    positiveEmojis.forEach(e => { if (replyComment.includes(e)) replyEmojiScore += 1; });
    funnyEmojis.forEach(e => { if (replyComment.includes(e)) replyEmojiScore += 0.5; });
    negativeEmojis.forEach(e => { if (replyComment.includes(e)) replyEmojiScore -= 1; });
    flirtyEmojis.forEach(e => { if (replyComment.includes(e)) replyEmojiScore += 0.5; });
    
    baseChange += replyEmojiScore;
    
    // ===== LENGTH ANALYSIS =====
    const replyLength = replyComment.length;
    
    if (replyLength > 50) {
      baseChange += 0.5; // Thoughtful long replies show care
    } else if (replyLength < 10) {
      baseChange -= 0.3; // Very short replies seem dismissive
    }
    
    // ===== PERSONALITY COMPATIBILITY =====
    const humorMatch = Math.abs((commenterPersonality.humor || 50) - (originalPersonality.humor || 50));
    const outgoingMatch = Math.abs((commenterPersonality.outgoing || 50) - (originalPersonality.outgoing || 50));
    
    const avgMatch = (humorMatch + outgoingMatch) / 2;
    
    if (avgMatch < 25) {
      baseChange += 0.5; // Compatible personalities
    } else if (avgMatch > 65) {
      baseChange -= 0.3; // Clashing personalities
    }
    
    // ===== RELATIONSHIP CONTEXT =====
    if (currentStrength > 70) {
      // Close friends - amplify positive, dampen negative
      if (baseChange > 0) baseChange *= 1.3;
      if (baseChange < 0) baseChange *= 0.7;
    } else if (currentStrength < 30) {
      // Distant - reduce all impact
      baseChange *= 0.8;
    }
    
    // ===== CLAMP AND RETURN =====
    return Math.max(-5, Math.min(5, Math.round(baseChange * 10) / 10));
  }
  
  /**
   * Create gossip from notable social interactions
   */
  function createGossipFromSocialInteraction(viewer, postAuthor, post, comment, relationshipChange) {
    // Only create gossip for significant changes or explicit content
    const postExplicitLevel = post?.explicitLevel || 0;
    if (Math.abs(relationshipChange) < 3 && postExplicitLevel < 2) return;
    
    let gossipContent = '';
    let contextType = 'gossip';
    
    if (relationshipChange >= 4) {
      // Positive bonding
      gossipContent = `${viewer.name} and ${postAuthor.name} seem to be getting really close on social media`;
      contextType = 'friendship';
    } else if (relationshipChange <= -4) {
      // Drama/conflict
      gossipContent = `${viewer.name} and ${postAuthor.name} had tension on social media`;
      contextType = 'fight';
    } else if (postExplicitLevel >= 3) {
      // Explicit content reaction
      gossipContent = `${postAuthor.name} posted something VERY explicit and ${viewer.name} ${comment ? 'commented on it' : 'saw it'}`;
      contextType = 'scandal';
    }
    
    if (gossipContent) {
      const juiciness = Math.abs(relationshipChange) * 10 + (postExplicitLevel * 15);
      
      // Add to gossip engine for other NPCs to discover
      if (!gameState.activeGossip) gameState.activeGossip = [];
      
      gameState.activeGossip.push({
        id: `gossip_${Date.now()}_${Math.random()}`,
        subjectId: postAuthor.id,
        targetId: viewer.id,
        content: gossipContent,
        juiciness: juiciness,
        timestamp: gameState.time?.currentTime || Date.now(),
        accuracy: 100, // Direct observation
        knownBy: [viewer.id] // Viewer knows it firsthand
      });
      
      // Keep gossip list manageable
      if (gameState.activeGossip.length > 50) {
        gameState.activeGossip = gameState.activeGossip.slice(-50);
      }
      
      console.log(`[Gossip Created] ${gossipContent} (juiciness: ${juiciness})`);
      
      // Add juicy gossip to Company-Wide Context if it's scandalous enough
      if (juiciness >= 65) {
        addToCompanyWideContext({
          content: gossipContent,
          type: contextType,
          subjectIds: [viewer.id, postAuthor.id],
          juiciness: juiciness,
          source: 'gossip'
        });
        console.log(`[CompanyContext] Gossip was juicy enough to become public knowledge!`);
      }
    }
  }
  
  /**
   * Check if a conversation interaction is juicy enough to create gossip
   */
  function checkForGossipWorthyInteraction(emp, playerMsg, npcMsg) {
    const p = (playerMsg || '').toLowerCase();
    const n = (npcMsg || '').toLowerCase();
    const intimacy = emp.intimacy || 0;
    const desire = emp.stats?.desire || 0;
    
    // HOOKUP/SEXUAL interactions (Very juicy!)
    if (intimacy > 60 && desire > 50) {
      if (/\b(sex|fuck|bed|sleep together|hook up|come over)\b/.test(p + n)) {
        createPlayerGossip({
          type: 'hookup',
          npcId: emp.id,
          description: `${emp.name} and the boss hooked up`,
          juiciness: 90
        });
        return;
      }
    }
    
    // DATING/ROMANTIC interactions (Juicy!)
    if (desire > 40) {
      if (/\b(date|dating|girlfriend|boyfriend|relationship|love you)\b/.test(p + n)) {
        createPlayerGossip({
          type: 'date',
          npcId: emp.id,
          description: `${emp.name} and the boss went on a date`,
          juiciness: 70
        });
        return;
      }
      
      if (/\b(kiss|kissing|kissed|make out)\b/.test(p + n)) {
        createPlayerGossip({
          type: 'hookup',
          npcId: emp.id,
          description: `${emp.name} and the boss kissed`,
          juiciness: 65
        });
        return;
      }
    }
    
    // FLIRTING interactions (Moderately juicy)
    if (desire > 25 && /\b(flirt|sexy|hot|gorgeous|beautiful|cute)\b/.test(p)) {
      if (Math.random() < 0.3) { // 30% chance to gossip about flirting
        createPlayerGossip({
          type: 'rumor',
          npcId: emp.id,
          description: `the boss was flirting with ${emp.name}`,
          juiciness: 45
        });
      }
    }
    
    // PROMOTION/FAVORITISM (Office politics!)
    if (/\b(promot|raise|bonus|favor|special treatment)\b/.test(p)) {
      createPlayerGossip({
        type: 'promotion',
        npcId: emp.id,
        description: `${emp.name} got special treatment from the boss`,
        juiciness: 55
      });
    }
    
    // FIRED/CONFLICT (Drama!)
    if (/\b(fire|fired|quit|resign|argument|fight|angry)\b/.test(p + n)) {
      createPlayerGossip({
        type: 'scandal',
        npcId: emp.id,
        description: `${emp.name} and the boss had a heated argument`,
        juiciness: 60
      });
    }
  }

  
  // Update news
  function updateNews() {
    // Add new news item
    const newsItems = [
      `${gameState.employees.length > 0 ? gameState.employees[0].name : 'Your company'} makes headlines with innovative approach`,
      `Industry experts praise ${gameState.employees.length > 0 ? gameState.employees[0].name : 'your team'}'s performance`,
      `New workplace policies at your company set industry standards`,
      `Your business growth outpaces competitors this quarter`,
      `Employee satisfaction at your company reaches all-time high`,
      `Tech community buzzing about your latest product launch`
    ];
    
    const randomNews = newsItems[Math.floor(Math.random() * newsItems.length)];
    gameState.news.unshift(randomNews);
    
    // Keep only latest 5 news items
    if (gameState.news.length > 5) {
      gameState.news = gameState.news.slice(0, 5);
    }
    
    // Update news ticker
    if (newsContent) newsContent.textContent = randomNews;
    
    // Update news feed if dashboard is active
    if (gameState.activeTab === 'dashboard') {
      updateNewsFeed();
    }
  }
  
  // ========== PLAYER POST COMPOSER FUNCTIONS ==========
  
  // ============================================
  // MENTION SUGGESTION SYSTEM (@suggest)
  // ============================================
  
  /**
   * Get suggested employees for @mentions
   * Ranked by: recent mentions > frequent mentions > affection > alphabetical
   */
  function getMentionSuggestions(searchQuery = '') {
    const activeEmployees = gameState.employees.filter(e => e && e.employmentStatus === 'active' && e.id);
    
    const now = Date.now();
    const stats = gameState.playerMentionStats || { mentionHistory: [], mentionCounts: {} };
    
    // Ensure mentionCounts exists
    if (!stats.mentionCounts) {
      stats.mentionCounts = {};
    }
    if (!stats.mentionHistory) {
      stats.mentionHistory = [];
    }
    
    // Add player/TheBoss as suggestion options
    const playerSuggestions = [];
    const query = (searchQuery || '').toLowerCase();
    
    // Add @TheBoss option
    if (!query || 'theboss'.includes(query) || 'boss'.includes(query)) {
      playerSuggestions.push({
        employee: { id: 'player', name: 'You (TheBoss)' },
        username: 'TheBoss',
        name: 'You (TheBoss)',
        affection: 100,
        mentionCount: 0,
        score: 5000 // High priority so it appears first when searching
      });
    }
    
    // Add @player option
    if (!query || 'player'.includes(query) || 'me'.includes(query)) {
      playerSuggestions.push({
        employee: { id: 'player', name: 'You (player)' },
        username: 'player',
        name: 'You (player)',
        affection: 100,
        mentionCount: 0,
        score: 4900 // Slightly lower than TheBoss
      });
    }
    
    if (activeEmployees.length === 0) {
      return playerSuggestions;
    }
    
    // Calculate scores for each employee
    const suggestions = activeEmployees.map(emp => {
      if (!emp || !emp.id) return null; // Skip invalid employees
      
      let score = 0;
      
      // Frequency score (how often mentioned) - weight: 50
      const mentionCount = stats.mentionCounts[emp.id] || 0;
      score += mentionCount * 50;
      
      // Recency score (how recently mentioned) - weight: 100
      const recentMentions = stats.mentionHistory.filter(m => 
        m && m.employeeId === emp.id && (now - m.timestamp) < 86400000 * 7 // Last 7 days
      );
      if (recentMentions.length > 0) {
        const latestMention = Math.max(...recentMentions.map(m => m.timestamp));
        const daysAgo = (now - latestMention) / 86400000;
        score += Math.max(0, 100 - (daysAgo * 10)); // Decay over 10 days
      }
      
      // Relationship score - weight: 30
      const affection = emp.stats?.affection || 0;
      const intimacy = emp.intimacy || 0;
      score += (affection + intimacy) / 2 * 0.3;
      
      // Search query match boost
      const username = emp.social?.username || emp.name.toLowerCase().replace(/\s+/g, '');
      const name = emp.name.toLowerCase();
      const query = searchQuery.toLowerCase();
      
      if (query && (username.startsWith(query) || name.startsWith(query))) {
        score += 1000; // High priority for matches
      } else if (query && (username.includes(query) || name.includes(query))) {
        score += 500; // Medium priority for partial matches
      }
      
      return {
        employee: emp,
        username: emp.social?.username || username,
        name: emp.name,
        affection: affection,
        mentionCount: mentionCount,
        score: score
      };
    }).filter(s => s !== null); // Remove null entries
    
    // Combine player suggestions with employee suggestions
    const allSuggestions = [...playerSuggestions, ...suggestions];
    
    // Sort by score descending
    allSuggestions.sort((a, b) => b.score - a.score);
    
    // Filter by search query if provided
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      return allSuggestions.filter(s => 
        s.username.toLowerCase().includes(query) || 
        s.name.toLowerCase().includes(query)
      );
    }
    
    return allSuggestions;
  }
  
  /**
   * Track when player mentions someone
   */
  function trackPlayerMention(employeeId) {
    // Ensure stats object and arrays exist
    if (!gameState.playerMentionStats) {
      gameState.playerMentionStats = {
        mentionHistory: [],
        mentionCounts: {}
      };
    }
    
    const stats = gameState.playerMentionStats;
    
    // Defensive: ensure mentionHistory is an array
    if (!stats.mentionHistory || !Array.isArray(stats.mentionHistory)) {
      stats.mentionHistory = [];
    }
    
    // Defensive: ensure mentionCounts is an object
    if (!stats.mentionCounts || typeof stats.mentionCounts !== 'object') {
      stats.mentionCounts = {};
    }
    
    // Add to history
    stats.mentionHistory.push({
      employeeId: employeeId,
      timestamp: gameState.time?.currentTime || Date.now()
    });
    
    // Increment count
    if (!stats.mentionCounts[employeeId]) {
      stats.mentionCounts[employeeId] = 0;
    }
    stats.mentionCounts[employeeId]++;
    
    // Keep history manageable (last 100 mentions)
    if (stats.mentionHistory.length > 100) {
      stats.mentionHistory.shift();
    }
    
    console.log(`[Mentions] Tracked mention of ${employeeId}, total: ${stats.mentionCounts[employeeId]}`);
  }
  
  /**
   * Expand @mentions in image prompts to include physical descriptions
   * @param {string} promptText - The original image prompt text
   * @returns {string} - The expanded prompt with physical descriptions
   */
  function expandImageMentions(promptText) {
    if (!promptText) return promptText;
    
    // Find all @mentions in the text - support various username formats:
    // @name, @firstName, @first_last, @first.last, @FirstLast, etc.
    const mentionRegex = /@([\w.]+)/g;
    let expandedPrompt = promptText;
    const matches = [...promptText.matchAll(mentionRegex)];
    
    if (matches.length === 0) return promptText;
    
    console.log(`[Image Mentions] Found ${matches.length} @mention(s) in image prompt`);
    
    // Process each mention
    for (const match of matches) {
      const username = match[1];
      const fullMention = match[0]; // e.g., "@Sarah"
      
      // Check if this is a self-mention (@player or @TheBoss)
      if (username.toLowerCase() === 'player' || username.toLowerCase() === 'theboss' || username.toLowerCase() === 'boss' || username.toLowerCase() === 'me') {
        console.log(`[Image Mentions] Processing self-mention: @${username}`);
        
        // Get player's physical description from their profile
        const playerDesc = getPlayerPhysicalDescription();
        
        if (playerDesc) {
          // Use the player's physical description
          const replacement = `the player (${playerDesc})`;
          expandedPrompt = expandedPrompt.replace(fullMention, replacement);
          console.log(`[Image Mentions] Expanded @${username} to player description: ${replacement.substring(0, 100)}...`);
        } else {
          // If no description, just keep a generic reference
          const replacement = 'the player';
          expandedPrompt = expandedPrompt.replace(fullMention, replacement);
          console.log(`[Image Mentions] No player description set, using generic reference`);
        }
        continue;
      }
      
      // Find the employee using multiple matching strategies
      const employee = gameState.employees.find(emp => {
        const empUsername = emp.social?.username || '';
        const empName = emp.name || '';
        const firstName = empName.split(' ')[0] || '';
        const lastName = empName.split(' ').slice(1).join(' ') || '';
        const nameNoSpaces = empName.toLowerCase().replace(/\s+/g, '');
        const nameWithUnderscore = empName.toLowerCase().replace(/\s+/g, '_');
        const nameWithDot = empName.toLowerCase().replace(/\s+/g, '.');
        
        const mentionLower = username.toLowerCase();
        const usernameLower = empUsername.toLowerCase();
        
        // Strategy 1: Exact username match
        if (usernameLower === mentionLower) {
          console.log(`[Image Mentions] âœ“ Matched @${username} to ${empName} (exact username)`);
          return true;
        }
        
        // Strategy 2: First name match
        if (firstName.toLowerCase() === mentionLower) {
          console.log(`[Image Mentions] âœ“ Matched @${username} to ${empName} (first name)`);
          return true;
        }
        
        // Strategy 3: Full name without spaces
        if (nameNoSpaces === mentionLower) {
          console.log(`[Image Mentions] âœ“ Matched @${username} to ${empName} (name no spaces)`);
          return true;
        }
        
        // Strategy 4: Full name with underscore
        if (nameWithUnderscore === mentionLower) {
          console.log(`[Image Mentions] âœ“ Matched @${username} to ${empName} (name with underscore)`);
          return true;
        }
        
        // Strategy 5: Full name with dot
        if (nameWithDot === mentionLower) {
          console.log(`[Image Mentions] âœ“ Matched @${username} to ${empName} (name with dot)`);
          return true;
        }
        
        // Strategy 6: Username contains the mention (for prefixes like the_, real_)
        if (usernameLower.includes(mentionLower) || mentionLower.includes(usernameLower.replace(/^(the_|real_|official_)|(_official)$/g, ''))) {
          console.log(`[Image Mentions] âœ“ Matched @${username} to ${empName} (partial username match)`);
          return true;
        }
        
        // Strategy 7: Last name match
        if (lastName && lastName.toLowerCase() === mentionLower) {
          console.log(`[Image Mentions] âœ“ Matched @${username} to ${empName} (last name)`);
          return true;
        }
        
        return false;
      });
      
      if (employee) {
        // Get the physical description using the best available source
        let description = getPhysicalDescriptionForPrompt(employee);
        
        // If getPhysicalDescriptionForPrompt didn't return anything useful, try fallbacks
        if (!description || description.length < 20) {
          if (employee.appearance?.prompt) {
            // Extract just the physical appearance details from the prompt
            // Remove any style directives or technical terms
            const cleanPrompt = employee.appearance.prompt
              .replace(/,?\s*(photorealistic|high detail|professional photography|realistic lighting|anime style|manga art|cel-shaded|vibrant colors|artistic painting|painterly style|fine art|cartoon style|comic book art|cinematic lighting|movie scene|dramatic|film quality|professional studio|clean lighting|corporate setting|polished|high quality|detailed)/gi, '')
              .replace(/,\s*,/g, ',') // Remove double commas
              .trim();
            
            description = cleanPrompt;
          } else if (employee.appearance?.description) {
            description = employee.appearance.description;
          } else {
            // Build basic description from attributes
            const traits = [];
            if (employee.gender) traits.push(employee.gender);
            if (employee.ethnicity) traits.push(employee.ethnicity);
            if (employee.appearance?.hair) traits.push(`${employee.appearance.hair} hair`);
            if (employee.appearance?.eyes) traits.push(`${employee.appearance.eyes} eyes`);
            if (employee.appearance?.body) traits.push(employee.appearance.body);
            description = traits.join(', ') || 'employee';
          }
        }
        
        // Replace the @mention with the description
        // Keep the name but add details
        const replacement = `${employee.name} (${description})`;
        expandedPrompt = expandedPrompt.replace(fullMention, replacement);
        
        console.log(`[Image Mentions] Expanded @${username} to: ${replacement.substring(0, 100)}...`);
      } else {
        console.log(`[Image Mentions] Could not find employee for @${username}`);
        // List available employees to help debug
        const availableNames = gameState.employees.slice(0, 5).map(e => e.name).join(', ');
        console.log(`[Image Mentions] Available employees (first 5): ${availableNames}`);
      }
    }
    
    return expandedPrompt;
  }
  
  /**
   * Extract @mentions from text
   * Returns array of { username, employeeId }
   */
  function extractMentions(text) {
    const mentions = [];
    const mentionRegex = /@([\w.]+)/g; // Allow dots in usernames
    let match;
    
    while ((match = mentionRegex.exec(text)) !== null) {
      const mentionedUsername = match[1].toLowerCase();
      
      // Check if it's @TheBoss (the player)
      if (mentionedUsername === 'theboss' || mentionedUsername === 'boss') {
        mentions.push({
          username: match[1],
          employeeId: 'player',
          fullMention: match[0]
        });
        console.log(`[Mention] Found @${match[1]} -> The Boss (player)`);
        continue;
      }
      
      // Find employee with this username - try multiple matching strategies
      const employee = gameState.employees.find(e => {
        if (!e.social?.username) return false;
        
        const storedUsername = e.social.username.toLowerCase();
        
        // Strategy 1: Exact match
        if (storedUsername === mentionedUsername) return true;
        
        // Strategy 2: Remove all separators (_, ., numbers, prefixes) and compare
        const normalizeUsername = (u) => u.replace(/[_.\-\d]/g, '').replace(/^(the|real)|official$/g, '');
        if (normalizeUsername(storedUsername) === normalizeUsername(mentionedUsername)) return true;
        
        // Strategy 3: Check if it's just firstname
        const firstName = e.name.split(' ')[0].toLowerCase();
        if (mentionedUsername === firstName) return true;
        
        // Strategy 4: Check if it's firstname + lastname no separator
        const firstLast = e.name.toLowerCase().replace(/\s+/g, '');
        if (mentionedUsername === firstLast) return true;
        
        // Strategy 5: Check if mentioned is contained in stored (for prefixes like the_, real_)
        if (storedUsername.includes(mentionedUsername) || mentionedUsername.includes(storedUsername.replace(/^(the_|real_)|_official$/g, ''))) {
          return true;
        }
        
        return false;
      });
      
      if (employee) {
        mentions.push({
          username: match[1],
          employeeId: employee.id,
          fullMention: match[0]
        });
        console.log(`[Mention] Found @${match[1]} -> ${employee.name} (username: ${employee.social.username}, ID: ${employee.id})`);
      } else {
        console.warn(`[Mention] Could not find employee for @${match[1]}`);
      }
    }
    
    console.log(`[Mention] Extracted ${mentions.length} mentions:`, mentions);
    return mentions;
  }
  
  /**
   * Show mention suggestions dropdown
   */
  function showMentionSuggestions(input, searchQuery = '') {
    const dropdown = $('mentionSuggestions');
    if (!dropdown) return;
    
    const suggestions = getMentionSuggestions(searchQuery);
    
    if (suggestions.length === 0) {
      dropdown.style.display = 'none';
      return;
    }
    
    // Limit to top 8 suggestions
    const topSuggestions = suggestions.slice(0, 8);
    
    dropdown.innerHTML = topSuggestions.map((s, index) => {
      const relationshipIcon = s.affection > 70 ? 'ğŸ’•' : s.affection > 40 ? 'ğŸ˜Š' : 'ğŸ‘¤';
      const mentionBadge = s.mentionCount > 0 ? `<span style="background:#0f3460; padding:2px 6px; border-radius:4px; font-size:0.75rem; color:#00d4ff;">${s.mentionCount}x</span>` : '';
      
      return `
        <div class="mention-suggestion-item" data-index="${index}" data-username="${s.username}" data-employee-id="${s.employee.id}" style="padding:10px 15px; cursor:pointer; border-bottom:1px solid #0f3460; display:flex; align-items:center; justify-content:space-between; transition:background 0.2s;">
          <div style="display:flex; align-items:center; gap:10px; flex:1;">
            <span style="font-size:1.2rem;">${relationshipIcon}</span>
            <div style="flex:1;">
              <div style="color:white; font-weight:600;">@${s.username}</div>
              <div style="color:#aaa; font-size:0.85rem;">${s.name}</div>
            </div>
          </div>
          ${mentionBadge}
        </div>
      `;
    }).join('');
    
    // Add hover effects
    dropdown.querySelectorAll('.mention-suggestion-item').forEach(item => {
      item.addEventListener('mouseenter', () => {
        item.style.background = '#0f3460';
      });
      item.addEventListener('mouseleave', () => {
        item.style.background = 'transparent';
      });
      item.addEventListener('click', () => {
        const username = item.dataset.username;
        const employeeId = item.dataset.employeeId;
        insertMention(input, username, employeeId);
      });
    });
    
    dropdown.style.display = 'block';
  }
  
  /**
   * Insert @mention into text input
   */
  function insertMention(input, username, employeeId, dropdownId = 'mentionSuggestions') {
    if (!input) return;
    
    const text = input.value;
    const cursorPos = input.selectionStart;
    
    // Find the @ symbol position
    let atPos = cursorPos - 1;
    while (atPos >= 0 && text[atPos] !== '@') {
      atPos--;
    }
    
    if (atPos >= 0) {
      // Replace from @ to cursor with @username
      const before = text.substring(0, atPos);
      const after = text.substring(cursorPos);
      input.value = before + '@' + username + ' ' + after;
      
      // Set cursor after mention
      const newPos = atPos + username.length + 2;
      input.selectionStart = newPos;
      input.selectionEnd = newPos;
      
      // Track the mention
      trackPlayerMention(employeeId);
      
      // Trigger input event for char counter
      input.dispatchEvent(new Event('input'));
    }
    
    // Hide dropdown
    const dropdown = (dropdownId === 'mentionSuggestions' || 
                     dropdownId === 'modalMentionSuggestions' ||
                     dropdownId === 'sendImageMentionSuggestions' ||
                     dropdownId === 'postImageMentionSuggestions' ||
                     dropdownId === 'requestImageMentionSuggestions') ? $(dropdownId) : 
                     document.querySelector(`.comment-mention-suggestions[data-post-id="${dropdownId}"]`);
    if (dropdown) dropdown.style.display = 'none';
    
    // Focus back on input
    input.focus();
  }
  
  /**
   * Setup mention autocomplete on an input
   */
  function setupMentionAutocomplete(input, dropdownId = 'mentionSuggestions') {
    if (!input) return;
    
    let mentionActive = false;
    let mentionStartPos = -1;
    let currentHighlightIndex = 0;
    
    const getDropdown = () => {
      // Handle standard suggestions dropdowns, modal suggestions dropdown, image prompt dropdowns, or post-specific comment dropdowns
      if (dropdownId === 'mentionSuggestions' || 
          dropdownId === 'modalMentionSuggestions' || 
          dropdownId === 'sendImageMentionSuggestions' ||
          dropdownId === 'postImageMentionSuggestions' ||
          dropdownId === 'requestImageMentionSuggestions') {
        return $(dropdownId);
      }
      return document.querySelector(`.comment-mention-suggestions[data-post-id="${dropdownId}"]`);
    };
    
    const updateHighlight = () => {
      const dropdown = getDropdown();
      if (!dropdown) return;
      
      const items = dropdown.querySelectorAll('.mention-suggestion-item');
      items.forEach((item, index) => {
        if (index === currentHighlightIndex) {
          item.style.background = '#0f3460';
          item.setAttribute('data-highlighted', 'true');
        } else {
          item.style.background = 'transparent';
          item.removeAttribute('data-highlighted');
        }
      });
    };
    
    const showDropdownForInput = (searchQuery) => {
      const suggestions = getMentionSuggestions(searchQuery);
      const topSuggestions = suggestions.slice(0, 6);
      
      if (topSuggestions.length === 0) {
        const dropdown = getDropdown();
        if (dropdown) dropdown.style.display = 'none';
        return;
      }
      
      const dropdown = getDropdown();
      if (!dropdown) return;
      
      dropdown.innerHTML = topSuggestions.map((s, index) => {
        const relationshipIcon = s.affection > 70 ? 'ğŸ’•' : s.affection > 40 ? 'ğŸ˜Š' : 'ğŸ‘¤';
        const mentionBadge = s.mentionCount > 0 ? `<span style="background:#0f3460; padding:2px 6px; border-radius:4px; font-size:0.75rem; color:#00d4ff;">${s.mentionCount}x</span>` : '';
        
        return `
          <div class="mention-suggestion-item" data-index="${index}" data-username="${s.username}" data-employee-id="${s.employee.id}" style="padding:10px 15px; cursor:pointer; border-bottom:1px solid #0f3460; display:flex; align-items:center; justify-content:space-between; transition:background 0.2s;">
            <div style="display:flex; align-items:center; gap:10px; flex:1;">
              <span style="font-size:1.2rem;">${relationshipIcon}</span>
              <div style="flex:1;">
                <div style="color:white; font-weight:600;">@${s.username}</div>
                <div style="color:#aaa; font-size:0.85rem;">${s.name}</div>
              </div>
            </div>
            ${mentionBadge}
          </div>
        `;
      }).join('');
      
      // Add hover and click effects
      dropdown.querySelectorAll('.mention-suggestion-item').forEach((item, index) => {
        item.addEventListener('mouseenter', () => {
          currentHighlightIndex = index;
          updateHighlight();
        });
        item.addEventListener('click', () => {
          const username = item.dataset.username;
          const employeeId = item.dataset.employeeId;
          insertMention(input, username, employeeId, dropdownId);
          mentionActive = false;
        });
      });
      
      currentHighlightIndex = 0;
      updateHighlight();
      dropdown.style.display = 'block';
    };
    
    input.addEventListener('input', (e) => {
      const text = input.value;
      const cursorPos = input.selectionStart;
      
      // Check if @ was just typed or we're in a mention
      const charBefore = cursorPos > 0 ? text[cursorPos - 1] : '';
      const charBeforeThat = cursorPos > 1 ? text[cursorPos - 2] : '';
      
      // Detect @ at start or after space/newline
      if (charBefore === '@' && (cursorPos === 1 || charBeforeThat === ' ' || charBeforeThat === '\n')) {
        mentionActive = true;
        mentionStartPos = cursorPos - 1;
        showDropdownForInput('');
      } else if (mentionActive) {
        // Get text after @
        const textAfterAt = text.substring(mentionStartPos + 1, cursorPos);
        
        // Check if we're still in the mention (no space yet)
        if (textAfterAt.includes(' ') || textAfterAt.includes('\n')) {
          mentionActive = false;
          const dropdown = getDropdown();
          if (dropdown) dropdown.style.display = 'none';
        } else {
          // Update suggestions based on search
          showDropdownForInput(textAfterAt);
        }
      }
    });
    
    // Handle keyboard navigation and Tab autocomplete
    input.addEventListener('keydown', (e) => {
      const dropdown = getDropdown();
      if (!dropdown || dropdown.style.display === 'none') return;
      
      const items = dropdown.querySelectorAll('.mention-suggestion-item');
      if (items.length === 0) return;
      
      if (e.key === 'Escape') {
        dropdown.style.display = 'none';
        mentionActive = false;
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        currentHighlightIndex = (currentHighlightIndex + 1) % items.length;
        updateHighlight();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        currentHighlightIndex = (currentHighlightIndex - 1 + items.length) % items.length;
        updateHighlight();
      } else if (e.key === 'Tab' || e.key === 'Enter') {
        // Tab or Enter to insert highlighted suggestion
        e.preventDefault();
        const highlightedItem = items[currentHighlightIndex];
        if (highlightedItem) {
          const username = highlightedItem.dataset.username;
          const employeeId = highlightedItem.dataset.employeeId;
          insertMention(input, username, employeeId, dropdownId);
          mentionActive = false;
        }
      }
    });
    
    // Close dropdown when clicking outside
    const clickHandler = (e) => {
      const dropdown = getDropdown();
      if (dropdown && !input.contains(e.target) && !dropdown.contains(e.target)) {
        dropdown.style.display = 'none';
        mentionActive = false;
      }
    };
    
    document.addEventListener('click', clickHandler);
  }
  
  /**
   * Open player post composer modal
   */
  function openPlayerPostComposer() {
    const modal = $('playerPostModal');
    if (!modal) return;
    
    // Reset form
    const captionInput = $('playerPostCaption');
    const imagePromptInput = $('playerPostImagePrompt');
    const imageAltInput = $('playerPostAltText');
    const explicitCheckbox = $('playerPostExplicit');
    const charCount = $('captionCharCount');
    const previewContainer = $('playerPostImagePreview');
    
    if (captionInput) captionInput.value = '';
    if (imagePromptInput) imagePromptInput.value = '';
    if (imageAltInput) imageAltInput.value = '';
    if (explicitCheckbox) explicitCheckbox.checked = false;
    if (charCount) charCount.textContent = '0';
    if (previewContainer) {
      previewContainer.style.display = 'none';
    }
    
    // Reset to text type
    document.querySelectorAll('.post-type-btn').forEach(btn => {
      btn.classList.remove('active');
      btn.style.borderColor = '#0f3460';
      btn.style.color = '#aaa';
    });
    
    const textTypeBtn = document.querySelector('.post-type-btn[data-type="text"]');
    if (textTypeBtn) {
      textTypeBtn.classList.add('active');
      textTypeBtn.style.borderColor = '#00d4ff';
      textTypeBtn.style.color = 'white';
    }
    
    const imageSection = $('playerPostImageSection');
    const generateImageBtn = $('generatePlayerPostImage');
    if (imageSection) imageSection.style.display = 'none';
    if (generateImageBtn) generateImageBtn.style.display = 'none';
    
    // Clear stored image
    delete gameState.tempPostImage;
    
    // Setup mention autocomplete
    if (captionInput) {
      setupMentionAutocomplete(captionInput);
    }
    
    // Show modal with flex display
    modal.style.display = 'flex';
  }
  
  /**
   * Close player post composer modal
   */
  function closePlayerPostModal() {
    const modal = $('playerPostModal');
    if (modal) modal.style.display = 'none';
    
    // Clear temp data
    delete gameState.tempPostImage;
  }
  
  /**
   * Generate image for player post
   */
  /**
   * Generate image for player post
   * ENHANCED WITH DETAILED LOGGING FOR IMAGE GENERATION PIPELINE
   */
  async function generatePlayerPostImage_handler() {
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('ğŸ¨ [IMAGE GENERATION PIPELINE] Starting...');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    
    const promptInput = $('playerPostImagePrompt');
    const altInput = $('playerPostAltText');
    const generateBtn = $('generatePlayerPostImage');
    const previewContainer = $('playerPostImagePreview');
    const previewImg = $('playerPostPreviewImg');
    
    if (!promptInput || !generateBtn) {
      console.error('[IMAGE GEN] âŒ Required DOM elements not found');
      return;
    }
    
    const prompt = promptInput.value.trim();
    
    console.log('[IMAGE GEN] STEP 1: Validate Input');
    console.log('[IMAGE GEN] User Prompt:', prompt || '(empty)');
    
    if (!prompt) {
      console.warn('[IMAGE GEN] âŒ Validation failed: Empty prompt');
      alert('Please enter an image description first!');
      return;
    }
    
    console.log('[IMAGE GEN] âœ… Validation passed');
    console.log('[IMAGE GEN] Prompt length:', prompt.length, 'characters');
    
    // Expand @mentions to include physical descriptions
    const expandedPrompt = expandImageMentions(prompt);
    if (expandedPrompt !== prompt) {
      console.log('[IMAGE GEN] ğŸ”„ Expanded @mentions in prompt');
      console.log('[IMAGE GEN] Expanded Prompt:', expandedPrompt);
    }
    
    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    console.log('[IMAGE GEN] STEP 2: Analyze Prompt Context');
    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    
    // Analyze prompt for content flags (use expanded prompt for better analysis)
    const promptLower = expandedPrompt.toLowerCase();
    const contentAnalysis = {
      mentions: {
        person: /\b(person|people|man|woman|guy|girl|employee|worker)\b/i.test(prompt),
        location: /\b(office|desk|room|outside|park|beach|home|building)\b/i.test(prompt),
        object: /\b(desk|chair|computer|phone|coffee|car|food)\b/i.test(prompt),
        clothing: /\b(dress|suit|shirt|pants|outfit|uniform|casual|formal)\b/i.test(prompt),
        action: /\b(sitting|standing|walking|working|smiling|looking|holding)\b/i.test(prompt)
      },
      style: {
        selfie: /\b(selfie|self portrait)\b/i.test(prompt),
        professional: /\b(professional|business|work|formal|corporate)\b/i.test(prompt),
        casual: /\b(casual|relaxed|informal|candid)\b/i.test(prompt),
        artistic: /\b(artistic|creative|stylized|aesthetic)\b/i.test(prompt)
      },
      suggestiveKeywords: ['sexy', 'hot', 'revealing', 'attractive', 'seductive', 'provocative', 'intimate', 'sensual'].filter(word => promptLower.includes(word))
    };
    
    console.log('[IMAGE GEN] Content Analysis:', {
      hasPerson: contentAnalysis.mentions.person,
      hasLocation: contentAnalysis.mentions.location,
      hasAction: contentAnalysis.mentions.action,
      style: Object.keys(contentAnalysis.style).filter(k => contentAnalysis.style[k]),
      suggestiveWords: contentAnalysis.suggestiveKeywords.length > 0 ? contentAnalysis.suggestiveKeywords : 'none'
    });
    
    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    console.log('[IMAGE GEN] STEP 3: Prepare Generation');
    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    
    // Show loading state
    generateBtn.textContent = 'â³ Generating...';
    generateBtn.disabled = true;
    generateBtn.style.opacity = '0.6';
    
    console.log('[IMAGE GEN] UI State: Loading');
    console.log('[IMAGE GEN] Calling generateImage API...');
    
    const startTime = Date.now();
    
    try {
      console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
      console.log('[IMAGE GEN] STEP 4: Generate Image (AI Processing)');
      console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
      console.log('[IMAGE GEN] Prompt sent to AI:', expandedPrompt);
      
      // Generate image using Perchance AI (use expanded prompt)
      const imageUrl = await queuedGenerateImage(applyImageStyle(expandedPrompt), `Player social post image`);
      
      const generationTime = ((Date.now() - startTime) / 1000).toFixed(2);
      console.log(`[IMAGE GEN] âœ… Image generated successfully in ${generationTime}s`);
      console.log('[IMAGE GEN] Image URL:', imageUrl.substring(0, 100) + '...');
      
      console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
      console.log('[IMAGE GEN] STEP 5: Store & Display Image');
      console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
      
      // Store in temp state
      gameState.tempPostImage = imageUrl;
      console.log('[IMAGE GEN] âœ… Image stored in gameState.tempPostImage');
      
      // Show preview
      if (previewContainer && previewImg) {
        previewImg.src = imageUrl;
        previewContainer.style.display = 'block';
        console.log('[IMAGE GEN] âœ… Preview displayed');
      } else {
        console.warn('[IMAGE GEN] âš ï¸ Preview container not found');
      }
      
      // Auto-fill alt text if empty
      if (altInput && !altInput.value.trim()) {
        altInput.value = prompt;
        console.log('[IMAGE GEN] âœ… Alt text auto-filled with prompt');
      } else {
        console.log('[IMAGE GEN] Alt text already present, not overwriting');
      }
      
      console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
      console.log('[IMAGE GEN] STEP 6: Update UI State');
      console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
      
      // Success feedback
      generateBtn.textContent = 'âœ“ Image Generated!';
      generateBtn.style.background = '#00d4ff';
      console.log('[IMAGE GEN] UI State: Success');
      
      setTimeout(() => {
        generateBtn.textContent = 'ğŸ¨ Generate Image';
        generateBtn.style.background = '#533483';
        generateBtn.disabled = false;
        generateBtn.style.opacity = '1';
        console.log('[IMAGE GEN] UI State: Reset to ready');
      }, 2000);
      
      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
      console.log('âœ… [IMAGE GENERATION PIPELINE] COMPLETE');
      console.log(`   Total time: ${generationTime}s`);
      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
      
    } catch (error) {
      const failTime = ((Date.now() - startTime) / 1000).toFixed(2);
      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
      console.error('âŒ [IMAGE GENERATION PIPELINE] FAILED');
      console.error(`   Time to failure: ${failTime}s`);
      console.error('   Error:', error);
      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
      
      alert('Failed to generate image. Please try again.');
      
      generateBtn.textContent = 'ğŸ¨ Generate Image';
      generateBtn.disabled = false;
      generateBtn.style.opacity = '1';
    }
  }
  
  /**
   * Regenerate player post image
   */
  async function regeneratePlayerPostImage() {
    await generatePlayerPostImage_handler();
  }
  
  /**
   * Submit player post to feed
   * ENHANCED WITH DETAILED LOGGING FOR EACH STEP
   */
  function submitPlayerPostToFeed() {
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('ğŸš€ [POST CREATION PIPELINE] STEP 1: Initialize Post');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    
    const captionInput = $('playerPostCaption');
    const imageAltInput = $('playerPostAltText');
    const explicitCheckbox = $('playerPostExplicit');
    const imagePromptInput = $('playerPostImagePrompt');
    
    const caption = captionInput?.value.trim() || '';
    const imageUrl = gameState.tempPostImage || null;
    const imageAlt = imageAltInput?.value.trim() || '';
    const isExplicit = explicitCheckbox?.checked || false;
    const imagePrompt = imagePromptInput?.value.trim() || null; // Capture the original prompt for regeneration
    
    console.log('[POST CREATION] Input Data:', {
      caption: caption || '(none)',
      imageUrl: imageUrl ? 'Present' : 'None',
      imageAlt: imageAlt || '(none)',
      isExplicitMarked: isExplicit,
      imagePrompt: imagePrompt || '(none)'
    });
    
    // Validate
    if (!caption && !imageUrl) {
      console.warn('[POST CREATION] âŒ Validation failed: No caption or image');
      alert('Please add either a caption or an image!');
      return;
    }
    
    if (imageUrl && !imageAlt) {
      console.warn('[POST CREATION] âŒ Validation failed: Image without alt text');
      alert('Please add alt text for your image (helps NPCs understand it)!');
      return;
    }
    
    if (caption.length > 500) {
      console.warn('[POST CREATION] âŒ Validation failed: Caption too long');
      alert('Caption is too long! Maximum 500 characters.');
      return;
    }
    
    console.log('[POST CREATION] âœ… Validation passed');
    
    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    console.log('ğŸ“‹ [POST CREATION PIPELINE] STEP 2: Determine Content/Type');
    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    
    // Determine post type
    let postType = 'text';
    const activeTypeBtn = document.querySelector('.post-type-btn.active');
    if (activeTypeBtn) {
      postType = activeTypeBtn.dataset.type;
    }
    
    console.log('[POST CREATION] Post Type:', postType);
    
    // Determine explicit level
    let explicitLevel = 0;
    if (isExplicit) {
      explicitLevel = 3; // Player marked as explicit
      console.log('[POST CREATION] Explicit Level: 3 (player marked as explicit)');
    } else if (imageUrl) {
      // Check for suggestive keywords in alt text
      const suggestiveWords = ['sexy', 'hot', 'revealing', 'underwear', 'lingerie', 'bikini'];
      const hasSuggestive = suggestiveWords.some(word => 
        imageAlt.toLowerCase().includes(word) || caption.toLowerCase().includes(word)
      );
      if (hasSuggestive) {
        explicitLevel = 1;
        console.log('[POST CREATION] Explicit Level: 1 (suggestive keywords detected)');
      } else {
        console.log('[POST CREATION] Explicit Level: 0 (safe content)');
      }
    } else {
      console.log('[POST CREATION] Explicit Level: 0 (text-only post)');
    }
    
    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    console.log('ğŸ” [POST CREATION PIPELINE] STEP 3: Extract Context');
    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    
    // Extract @mentions from caption
    const mentions = extractMentions(caption) || []; // Safety: default to empty array
    const mentionedEmployeeIds = mentions.map(m => m.employeeId);
    
    console.log('[POST CREATION] Mention Analysis:');
    console.log(`  - Found ${mentions.length} @mentions`);
    if (mentions.length > 0) {
      mentions.forEach(m => {
        const emp = gameState.employees.find(e => e.id === m.employeeId);
        console.log(`  - @${m.username} â†’ ${emp?.name} (ID: ${m.employeeId})`);
      });
    }
    
    // Analyze caption for context
    const captionLower = caption.toLowerCase();
    const contextFlags = {
      hasQuestion: captionLower.includes('?'),
      hasEmoji: /[\u{1F600}-\u{1F64F}|\u{1F300}-\u{1F5FF}|\u{1F680}-\u{1F6FF}|\u{2600}-\u{26FF}|\u{2700}-\u{27BF}]/u.test(caption),
      wordCount: caption.split(/\s+/).length,
      hasHashtag: caption.includes('#'),
      hasMention: caption.includes('@'),
      hasExclamation: caption.includes('!')
    };
    
    console.log('[POST CREATION] Caption Context:', contextFlags);
    
    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    console.log('ğŸ“ [POST CREATION PIPELINE] STEP 4: Create Post Object');
    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    
    // Create post
    const post = createPost({
      authorId: 'player',
      authorName: 'You',
      type: postType,
      content: caption,
      imageUrl: imageUrl,
      imageAlt: imageAlt,
      imagePrompt: imagePrompt, // Include the original prompt for regeneration
      explicitLevel: explicitLevel,
      tags: [],
      location: gameState.activeLocationId || 'headquarters',
      isPlayerPost: true,
      referencedEmployees: mentionedEmployeeIds // Store mentioned employee IDs (correct param name)
    });
    
    console.log('[POST CREATION] Post Object Created:', {
      id: post.id,
      type: post.type,
      explicitLevel: post.explicitLevel,
      hasImage: !!post.imageUrl,
      mentions: (post.referencedEmployees || []).length,
      location: post.location,
      timestamp: new Date(post.timestamp).toLocaleTimeString()
    });
    
    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    console.log('ğŸ“¤ [POST CREATION PIPELINE] STEP 5: Publish to Feed');
    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    
    // Add to feed
    gameState.socialNetwork.posts.unshift(post);
    console.log('[POST CREATION] âœ… Post added to feed (position: 0)');
    console.log(`[POST CREATION] Total posts in feed: ${gameState.socialNetwork.posts.length}`);
    
    // Analyze post for public knowledge
    setTimeout(() => {
      analyzePostForPublicKnowledge(post);
    }, 2000); // Slight delay to let engagement start
    
    // Refresh dashboard to show new posts/mentions
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
      console.log('[POST CREATION] Dashboard refreshed');
    }
    
    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    console.log('ğŸ§  [POST CREATION PIPELINE] STEP 6: Update NPC Awareness');
    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    
    // Store in all employees' awareness - they can see the player's posts
    const imageNote = imageUrl ? ' with image' : '';
    const postSummary = `The boss posted${imageNote}: "${caption}"`;
    let awareEmployees = 0;
    for (const emp of gameState.employees) {
      if (emp.employmentStatus === 'active') {
        remember(emp, postSummary, 'event', 1.5);
        awareEmployees++;
      }
    }
    console.log(`[POST CREATION] Updated memory for ${awareEmployees} active employees`);
    
    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    console.log('ğŸ’¬ [POST CREATION PIPELINE] STEP 7: Trigger NPC Reactions');
    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    
    const reactionDelay = 3000 + Math.random() * 5000;
    console.log(`[POST CREATION] NPC reactions will trigger in ${(reactionDelay/1000).toFixed(1)}s`);
    
    // Trigger automatic NPC reactions (delayed slightly for realism)
    setTimeout(() => {
      console.log('[POST CREATION] ğŸ¬ Triggering NPC reactions now...');
      triggerAutomaticNPCReactions(post);
    }, reactionDelay); // 3-8 seconds
    
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('âœ… [POST CREATION PIPELINE] COMPLETE');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
    
    // Close modal
    closePlayerPostModal();
    
    // Switch to social tab if not already there
    if (gameState.activeTab !== 'social') {
      switchTab('social');
    } else {
      // Just refresh feed
      renderSocialFeed();
    }
    
    // Show success message
    const feedHeader = document.querySelector('#socialTab h2');
    if (feedHeader) {
      const successMsg = document.createElement('div');
      successMsg.style.cssText = 'position:fixed; top:80px; right:20px; background:#00d4ff; color:#0f1419; padding:12px 20px; border-radius:8px; font-weight:600; box-shadow:0 4px 12px rgba(0,212,255,0.4); z-index:9999;';
      successMsg.textContent = 'âœ“ Post published!';
      document.body.appendChild(successMsg);
      
      setTimeout(() => successMsg.remove(), 3000);
    }
  }
  
  /**
   * Generate a test post
   */
  function generateTestPost() {
    // Pick random employee or player
    const isPlayerPost = Math.random() < 0.3;
    
    let authorId, authorName;
    if (isPlayerPost) {
      authorId = 'player';
      authorName = 'You';
    } else {
      const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
      if (activeEmployees.length === 0) {
        alert('No employees to post! Hire someone first.');
        return;
      }
      const emp = activeEmployees[Math.floor(Math.random() * activeEmployees.length)];
      authorId = emp.id;
      authorName = emp.name;
    }
    
    // Random post types
    const types = ['text', 'work', 'selfie', 'meme', 'life_update'];
    const type = types[Math.floor(Math.random() * types.length)];
    
    // Random content
    const textContents = [
      "Just finished a great meeting! ğŸ’¼",
      "Coffee break vibes â˜•âœ¨",
      "Feeling productive today! ğŸš€",
      "Anyone else excited for the weekend? ğŸ‰",
      "New project, who dis? ğŸ‘€",
      "Office life got me like... ğŸ˜…",
      "Team lunch was amazing! ğŸ•",
      "Crushing these deadlines! ğŸ’ª",
      "Best coworkers ever! â¤ï¸",
      "Friday feeling! ğŸŠ"
    ];
    
    const content = textContents[Math.floor(Math.random() * textContents.length)];
    
    // Random explicit level (mostly safe)
    const explicitLevel = Math.random() < 0.8 ? 0 : (Math.random() < 0.7 ? 1 : 2);
    
    // Create post
    const post = createPost({
      authorId,
      authorName,
      type,
      content,
      imageUrl: null,
      imageAlt: '',
      explicitLevel,
      tags: [],
      location: gameState.activeLocationId || 'headquarters',
      isPlayerPost
    });
    
    // Add some random likes (20-70% chance per employee)
    const allEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    allEmployees.forEach(emp => {
      if (Math.random() < 0.4 && emp.id !== authorId) {
        post.likes.push(emp.id);
      }
    });
    
    // Add some random comments (10% chance per employee)
    const commentTexts = [
      "Love this! ğŸ˜",
      "So true!",
      "Haha same here!",
      "Amazing! ğŸ”¥",
      "Can't wait!",
      "You're the best!",
      "This made my day!",
      "Absolutely!",
      "ğŸ‘ğŸ‘ğŸ‘",
      "Facts! ğŸ’¯"
    ];
    
    allEmployees.forEach(emp => {
      if (Math.random() < 0.15 && emp.id !== authorId) {
        const commentText = commentTexts[Math.floor(Math.random() * commentTexts.length)];
        const comment = createComment({
          postId: post.id,
          authorId: emp.id,
          authorName: emp.name,
          content: commentText
        });
        post.comments.push(comment);
      }
    });
    
    // Add to feed
    gameState.socialNetwork.posts.unshift(post);
    
    // Refresh dashboard to show new posts/mentions
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
    
    // Refresh feed
    renderSocialFeed();
  }
  
  // ========== AUTONOMOUS POST GENERATION SYSTEM ==========
  
  /**
   * Main autonomous post generation loop
   * Called from gameTick to continuously generate posts
   */
  async function autonomousPostGeneration() {
    // Early return if social features not initialized
    if (!gameState.socialNetwork || !gameState.employees) return;
    
    // Check if enough time has passed since last generation
    const now = Date.now();
    const timeSinceLastPost = now - (gameState.socialNetwork.lastPostGeneration || 0);
    
    // MASSIVELY INCREASED FREQUENCY: 1-3 minutes between posts (was 4-6 min)
    // With 28 employees, this means 20-60 posts per hour instead of 10-15
    const baseInterval = 90000 + Math.random() * 150000; // 1.5-4 min

    if (timeSinceLastPost < baseInterval) return;
    
    // Must have at least 1 employee
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (activeEmployees.length === 0) return;
    
    // Update last generation time
    gameState.socialNetwork.lastPostGeneration = now;
    
    // More posts per batch with larger teams (was 1-2, now 1-3)
    const postCount = Math.min(3, Math.floor(1 + activeEmployees.length / 6));
    
    // Generate posts
    for (let i = 0; i < postCount; i++) {
      try {
        await generateEmployeePost();
      } catch (err) {
        console.error('Error generating employee post:', err);
      }
      
      // Small delay between posts for realism
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // Also generate autonomous comments, likes, and ğŸ˜ˆ DOWNVOTES on recent posts
    try {
      await generateAutonomousComments();
      await generateAutonomousLikes();
      await generateAutonomousDownvotes(); // ğŸ˜ˆ DRAMA TIME
    } catch (err) {
      console.error('Error generating autonomous interactions:', err);
    }
    
    // Refresh feed if social tab is active
    if (gameState.activeTab === 'social') {
      renderSocialFeed();
    }
  }
  
  /**
   * Check if content is too similar to recent posts by the same author
   * Uses simple keyword overlap and phrase matching
   * IMPROVED: Less aggressive to allow natural topic variations
   */
  function isContentTooSimilar(content, authorId, maxRecentPosts = 5) {
    if (!content) return false;
    
    // Get recent posts by this author
    const authorPosts = gameState.socialNetwork.posts
      .filter(p => p.authorId === authorId)
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, maxRecentPosts);
    
    if (authorPosts.length === 0) return false;
    
    // Normalize content for comparison
    const normalizeText = (text) => {
      if (!text || typeof text !== 'string') return [];
      return text.toLowerCase()
        .replace(/[^\w\s]/g, '') // Remove punctuation
        .split(/\s+/)
        .filter(word => word.length > 3); // Only words longer than 3 chars
    };
    
    const newWords = normalizeText(content);
    
    // Check each recent post
    for (const post of authorPosts) {
      // Skip if post has no content
      if (!post.content || typeof post.content !== 'string') continue;
      
      const existingWords = normalizeText(post.content);
      
      // Calculate word overlap (INCREASED THRESHOLD: 70% instead of 50%)
      const commonWords = newWords.filter(word => existingWords.includes(word));
      const overlapRatio = commonWords.length / Math.min(newWords.length, existingWords.length);
      
      // If more than 70% overlap, consider it too similar (was 50%)
      if (overlapRatio > 0.7) {
        console.log(`Content similarity detected: ${Math.round(overlapRatio * 100)}% overlap with recent post`);
        return true;
      }
      
      // Check for exact phrase repetition (IMPROVED: 5+ word sequences instead of 3+)
      // This allows common phrases like "weirdest chat with" to pass through
      const newText = content.toLowerCase();
      const existingText = post.content.toLowerCase();
      for (let i = 0; i < newWords.length - 4; i++) { // Changed from -2 to -4 (5 words instead of 3)
        const phrase = newWords.slice(i, i + 5).join(' '); // Changed from 3 to 5
        // Also increased minimum phrase length from 15 to 25 characters
        if (phrase.length > 25 && existingText.includes(phrase)) {
          console.log(`Duplicate phrase detected: "${phrase}"`);
          return true;
        }
      }
    }
    
    return false;
  }
  
  /**
   * Generate a single post from a random employee
   */
  async function generateEmployeePost() {
    // Select random active employee
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (activeEmployees.length === 0) return;
    
    const author = activeEmployees[Math.floor(Math.random() * activeEmployees.length)];
    
    // Get employee context (pass ID, not object)
    const context = getEmployeeAwarenessForPost(author.id);
    
    // Safety check - if context is null, skip this post
    if (!context) {
      console.error('Failed to get context for employee:', author.name);
      return;
    }
    
    // Determine post type based on personality and recent activity
    const postType = selectPostType(author, context);
    
    // Check if this is an event-triggered post
    const recentEvents = getRelevantEvents(author.id, 3);
    const shouldReactToEvent = recentEvents.length > 0 && Math.random() < 0.4;
    
    let postContent, imagePrompt, imageUrl, explicitLevel, tags;
    
    if (shouldReactToEvent) {
      // Event-triggered post
      const event = recentEvents[0];
      const reaction = await generateEventReaction(author, event, context);
      
      // Safety check - if reaction generation failed, fall back to organic post
      if (!reaction) {
        console.warn('Event reaction generation failed, falling back to organic post');
        const generated = await generateOrganicPost(author, postType, context);
        postContent = generated.content;
        imagePrompt = generated.imagePrompt;
        explicitLevel = generated.explicitLevel;
        tags = generated.tags || [];
      } else {
        postContent = reaction.content;
        imagePrompt = reaction.imagePrompt;
        explicitLevel = reaction.explicitLevel;
        tags = reaction.tags || [];
      }
    } else {
      // Organic post based on personality
      const generated = await generateOrganicPost(author, postType, context);
      postContent = generated.content;
      imagePrompt = generated.imagePrompt;
      explicitLevel = generated.explicitLevel;
      tags = generated.tags || [];
    }
    
    // Safety check: Ensure postContent is valid
    if (!postContent || typeof postContent !== 'string') {
      console.warn(`Invalid post content generated for ${author.name}, skipping post`);
      return null;
    }
    
    // Check for content similarity with recent posts
    if (isContentTooSimilar(postContent, author.id)) {
      console.log(`Skipping similar post from ${author.name}, will try again later`);
      return null; // Skip this post, will generate a different one next time
    }
    
    // Generate image if needed
    if (imagePrompt && ['selfie', 'meme', 'thirst_trap', 'explicit', 'food', 'travel', 'life_update'].includes(postType)) {
      try {
        imageUrl = await queuedGenerateImage(applyImageStyle(imagePrompt), `Organic social post image for ${author.name}`);
      } catch (error) {
        console.error('Image generation failed:', error);
        imageUrl = null;
      }
    }
    
    // Create post
    const post = createPost({
      authorId: author.id,
      authorName: author.name,
      type: postType,
      content: postContent,
      imageUrl: imageUrl || null,
      imageAlt: imagePrompt || '',
      imagePrompt: imagePrompt || null, // Store the original prompt for regeneration
      explicitLevel: explicitLevel,
      tags: tags,
      location: author.location || 'headquarters',
      isPlayerPost: false
    });
    
    // Add to feed
    gameState.socialNetwork.posts.unshift(post);
    
    // Track topic to avoid duplicates (AI Optimization)
    trackPostTopic(postContent);
    
    // Refresh dashboard to show new posts/mentions
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
    
    // Store post in employee memory - ONLY interesting/impactful posts
    const isInterestingPost = 
      explicitLevel >= 2 || // Explicit/revealing content
      ['hookup', 'masturbation', 'nudes', 'sexting', 'moneyshot', 'morning_after', 
       'explicit', 'thirst_trap', 'tea_spilling', 'gossip'].includes(postType) ||
      postContent.includes('@TheBoss') || // Mentions boss
      postContent.includes('@'); // Mentions another employee
    
    if (isInterestingPost) {
      const imageNote = imageUrl ? ' with image' : '';
      remember(author, `I posted${imageNote}: "${postContent}"`, 'event', 2.0);
    }
    
    // Track post type for variety
    gameState.socialNetwork.recentPostTypes.push(postType);
    if (gameState.socialNetwork.recentPostTypes.length > 20) {
      gameState.socialNetwork.recentPostTypes.shift();
    }
    
    // Trigger targeted comments for tea_spilling posts
    if (postType === 'tea_spilling') {
      setTimeout(() => {
        triggerTeaSpillingComments(post, author);
      }, 3000 + Math.random() * 5000); // 3-8 seconds delay
    }
    
    // Log event
    logCompanyEvent('post_created', {
      authorId: author.id,
      authorName: author.name,
      postType: postType,
      explicitLevel: explicitLevel
    });
    
    return post;
  }
  
  /**
   * Select post type based on employee personality
   */
  function selectPostType(employee, context) {
    const social = employee.social;
    if (!social) return 'text';
    
    // Get recent post types to ensure variety
    const recentTypes = gameState.socialNetwork.recentPostTypes || [];
    
    // EXPANDED post type weights - MASSIVELY BOOSTED FOR EXPLICIT/SEXY CONTENT
    // Target: 60%+ Visual/Sexy (especially with high relationships), 20% Mood/Personal, 12% Social, 5% Work, 3% Mundane
    const prefs = social.contentPreferences || {};
    const weights = {
      // ===== VISUAL/SEXY CONTENT (60%+ of posts) - MASSIVELY BOOSTED =====
      selfie: prefs.selfies ? Math.round(prefs.selfies * 60) : 50,          // Was 35
      thirst_trap: prefs.thirstTraps ? Math.round(prefs.thirstTraps * 60) : 60,  // Was 40
      explicit: prefs.explicitContent ? Math.round(prefs.explicitContent * 60) : 55,  // Was 35
      fashion: 35,  // Was 20 - sexy outfit posts
      
      // NEW PORNOGRAPHIC EXPLICIT TYPES (part of 60% Visual/Sexy) - ALL BOOSTED
      hookup: 50,        // Was 30 - Posts about having sex with someone
      masturbation: 45,  // Was 25 - Posts about solo play
      nudes: 48,         // Was 28 - Sending/receiving/posting nude photos
      sexting: 40,       // Was 22 - Flirty/explicit text exchanges
      moneyshot: 35,     // Was 18 - Ejaculation/finish content (most explicit)
      morning_after: 38, // Was 20 - Post-sex glow, pillow talk vibes
      
      // ===== MOOD/PERSONAL (20% total) - SLIGHTLY REDUCED =====
      mood: 18,          // Was 20
      life_update: 12,   // Was 15
      random: 10,        // Was 12
      inspiration: 6,    // Was 8
      
      // ===== SOCIAL/INTERACTIVE (12% total) - REDUCED =====
      text: 10,          // Was 14
      question: 8,       // Was 12
      gossip: 10,        // Was 12
      tea_spilling: 10,  // Was 12
      entertainment: 8,  // Was 10
      
      // ===== WORK/ACHIEVEMENT (5% total) - HEAVILY REDUCED =====
      work: prefs.workPosts ? Math.round(prefs.workPosts * 30) : 4,  // Was 6
      achievement: 4,    // Was 6
      fitness: 5,        // Was 7
      hobby: 5,          // Was 7
      
      // ===== MUNDANE (3% total) - MINIMAL =====
      food: 2,           // Was 4
      travel: 3,         // Was 5
      pet: 2,            // Was 4
      throwback: 2,      // Was 3
      complaint: 3,      // Was 4
      weather: 1,        // Was 2
      meme: 3            // Was 5
    };
    
    // Boost certain post types if there's recent chat context
    if (context.chatContext?.hasRecentChat) {
      const themes = context.chatContext.themes || [];
      
      // If conversation was flirty, boost suggestive AND PORNOGRAPHIC post types
      // REDUCED bonuses to make explicit content more autonomous (not boss-dependent)
      if (themes.includes('flirty/romantic')) {
        weights.text += 8;        // Reduced from 15
        weights.selfie += 10;     // Reduced from 20
        weights.thirst_trap += 12; // Reduced from 25
        weights.mood += 5;        // Reduced from 10
        weights.sexting += 10;    // Reduced from 20
        weights.nudes += 8;       // Reduced from 15
        if (employee.intimacy > 40) { // Lowered from 60 - more autonomous
          weights.explicit += 10;      // Reduced from 20
          weights.hookup += 12;        // Reduced from 25
          weights.masturbation += 9;   // Reduced from 18
          weights.morning_after += 8;  // Reduced from 15
        }
        if (employee.intimacy > 70) { // Lowered from 80
          weights.moneyshot += 10;  // Reduced from 20
        }
      }
      
      // If conversation was work-related, slightly boost work posts
      if (themes.includes('work-related')) {
        weights.work += 10;
        weights.text += 5;
        weights.achievement += 8;
      }
      
      // If conversation was emotional/personal, boost personal content
      if (themes.includes('emotional/personal')) {
        weights.text += 15;
        weights.life_update += 10;
        weights.mood += 12;
        weights.inspiration += 8;
        weights.morning_after += 5;  // Reduced from 10 - less boss-dependent
      }
      
      // If conversation was about food/social, boost related content
      if (themes.includes('food/social')) {
        weights.food += 15;
        weights.life_update += 10;
      }
    }
    
    // Reduce weights for recently used types (variety) - LESS AGGRESSIVE for sexy content
    Object.keys(weights).forEach(type => {
      const recentUseCount = recentTypes.filter(t => t === type).length;
      
      // Sexy content gets SMALLER penalty to maintain high frequency
      const isSexyContent = ['selfie', 'thirst_trap', 'explicit', 'hookup', 'masturbation', 
                            'nudes', 'sexting', 'moneyshot', 'morning_after', 'fashion'].includes(type);
      
      const penalty = isSexyContent ? 3 : 8; // Sexy: -3 per use, Others: -8 per use
      weights[type] = Math.max(1, weights[type] - (recentUseCount * penalty));
    });
    
    // Apply personality modifiers
    const personality = employee.personality || {};
    if (personality.outgoing > 70) {
      weights.selfie += 15;
      weights.life_update += 10;
      weights.question += 10;
      weights.hookup += 12;        // NEW - Outgoing = more social sex
      weights.morning_after += 10; // NEW
    }
    if (personality.professional > 70) {
      weights.work += 20;
      weights.achievement += 10;
      weights.inspiration += 8;
      // Reduce ALL explicit types for professional employees
      weights.explicit -= 10;
      weights.hookup -= 15;
      weights.masturbation -= 12;
      weights.nudes -= 10;
      weights.sexting -= 8;
      weights.moneyshot -= 20;
    }
    if (personality.flirty > 70) {
      weights.thirst_trap += 20;
      weights.selfie += 10;
      weights.mood += 5;
      weights.fashion += 8;
      weights.sexting += 15;       // NEW - Flirty = more sexting
      weights.nudes += 12;         // NEW
      weights.explicit += 10;
      // AUTONOMOUS BOOST: Flirty personalities post sexy content on their own
      weights.hookup += 10;        // Not boss-dependent
      weights.masturbation += 8;   // Self-initiated
    }
    
    // NEW: Confidence affects boldness of posts
    if (personality.confidence > 70) {
      weights.selfie += 10;
      weights.achievement += 12;
      weights.question += 5;
      weights.nudes += 15;         // NEW - Confident = not shy about nudes
      weights.thirst_trap += 12;
      weights.explicit += 10;
      // AUTONOMOUS BOOST: Confident people express sexuality freely
      weights.masturbation += 10;  // Self-expression
      weights.hookup += 8;         // Confident about sharing
    } else if (personality.confidence < 40) {
      weights.mood += 10;
      weights.random += 8;
      weights.complaint += 5;
      // Reduce explicit types for shy employees
      weights.nudes -= 10;
      weights.hookup -= 8;
      weights.moneyshot -= 15;
    }
    
    // NEW: Boost gossip if employee knows juicy gossip!
    initializeGossipSystem(employee);
    const knownGossip = getKnownGossip(employee.id, 1);
    if (knownGossip.length > 0) {
      const gossipJuiciness = knownGossip[0].juiciness || 50;
      const gossipBoost = Math.floor(gossipJuiciness / 5); // Up to +20 for very juicy gossip
      
      weights.gossip += gossipBoost;
      weights.tea_spilling += gossipBoost;
      
      // Super juicy gossip (80+) makes tea_spilling more likely
      if (gossipJuiciness >= 80) {
        weights.tea_spilling += 20;
      }
      
      // Gossipy people post gossip more
      if (employee.gossip.gossipTendency > 60) {
        weights.gossip += 15;
        weights.tea_spilling += 10;
      }
      
      // Bold/confident people more likely to spill tea directly
      if (personality.confidence > 65) {
        weights.tea_spilling += 15;
      }
    } else {
      // No gossip to share, reduce weight
      weights.gossip = 1;
      weights.tea_spilling = 1;
    }
    
    // NEW: Stats-based modifiers for explicit content - MASSIVELY BOOSTED
    const stats = employee.stats || {};
    const desire = stats.desire ?? 50;
    const obedience = stats.obedience ?? 50;
    const comfort = stats.comfort ?? 50;
    const affectionStat = stats.affection ?? 50;
    
    // MAXED RELATIONSHIPS = CONSTANT SEXY CONTENT
    // If ALL stats are high (80+), this employee should post explicit content VERY frequently
    const isMaxedRelationship = desire >= 80 && comfort >= 80 && affectionStat >= 80;
    
    if (isMaxedRelationship) {
      // NUCLEAR BOOST for maxed relationships - 43%+ of their posts should be sexy
      weights.explicit += 80;         // MASSIVE boost
      weights.thirst_trap += 70;      // MASSIVE boost
      weights.hookup += 85;           // MASSIVE boost
      weights.sexting += 65;          // MASSIVE boost
      weights.masturbation += 75;     // MASSIVE boost
      weights.nudes += 80;            // MASSIVE boost
      weights.morning_after += 60;    // MASSIVE boost
      weights.moneyshot += 70;        // MASSIVE boost
      weights.selfie += 50;           // Also boost sexy selfies
      weights.fashion += 40;          // Sexy outfits
      
      // REDUCE mundane content for maxed relationships
      weights.work = Math.max(2, weights.work - 30);
      weights.complaint = Math.max(1, weights.complaint - 20);
      weights.weather = Math.max(1, weights.weather - 15);
      weights.food = Math.max(3, weights.food - 15);
      weights.pet = Math.max(1, weights.pet - 10);
    } else if (desire > 70 || affectionStat > 70 || comfort > 70) {
      // High stats but not maxed - still significant boost
      weights.explicit += 30;
      weights.thirst_trap += 25;
      weights.hookup += 35;
      weights.sexting += 25;
      weights.masturbation += 30;
      weights.nudes += 28;
      weights.morning_after += 20;
      if (desire > 75) weights.moneyshot += 25;
    } else if (desire > 50 || affectionStat > 50) {
      // Moderate stats - smaller boost
      weights.explicit += 12;
      weights.thirst_trap += 10;
      weights.hookup += 15;
      weights.sexting += 10;
      weights.masturbation += 12;
    }
    
    // High obedience + high desire = very explicit content
    if (obedience > 70 && desire > 70) {
      weights.moneyshot += 25;  // Most explicit tier
      weights.nudes += 18;
      weights.hookup += 15;
    }
    
    // High comfort = more open about sex life
    if (comfort > 70) {
      weights.hookup += 12;
      weights.morning_after += 15;
      weights.explicit += 10;
    }
    
    // NEW: Add time-of-day bonuses for realism
    const hour = new Date().getHours();
    if (hour >= 6 && hour < 9) {
      // Morning posts
      weights.mood += 8;
      weights.fitness += 10;
      weights.food += 5; // Coffee/breakfast
      weights.morning_after += 12; // Post-sex morning posts
    } else if (hour >= 9 && hour < 17) {
      // Work hours
      weights.work += 12;
      weights.complaint += 5;
      weights.food += 5; // Lunch
      weights.sexting += 8; // Bored at work = sexting
    } else if (hour >= 17 && hour < 22) {
      // Evening
      weights.life_update += 10;
      weights.entertainment += 10;
      weights.food += 8; // Dinner/drinks
      weights.hookup += 15; // Evening hookups
      weights.thirst_trap += 10; // Getting ready to go out
    } else {
      // Late night (11pm-6am)
      weights.mood += 10;
      weights.random += 8;
      weights.throwback += 8;
      weights.explicit += 15;      // Late night horniness
      weights.masturbation += 20;  // Solo late night fun
      weights.sexting += 12;       // Late night texting
      weights.nudes += 15;         // Late night photo sharing
    }
    
    // Apply company policy modifiers
    const policy = gameState.settings.consentModel || 'casual';
    if (policy === 'professional') {
      // Reduce all explicit content for professional policy
      weights.explicit = Math.max(1, weights.explicit - 15);
      weights.thirst_trap = Math.max(5, weights.thirst_trap - 8);
      weights.hookup = Math.max(1, weights.hookup - 20);
      weights.masturbation = Math.max(1, weights.masturbation - 18);
      weights.nudes = Math.max(1, weights.nudes - 15);
      weights.sexting = Math.max(1, weights.sexting - 12);
      weights.moneyshot = Math.max(1, weights.moneyshot - 25);
      weights.morning_after = Math.max(1, weights.morning_after - 10);
    } else if (policy === 'open') {
      // Boost all explicit content for open policy
      weights.thirst_trap += 15;
      weights.explicit += 15;
      weights.hookup += 20;
      weights.masturbation += 15;
      weights.nudes += 18;
      weights.sexting += 12;
      weights.moneyshot += 10;
      weights.morning_after += 12;
    }
    
    // Weighted random selection
    const totalWeight = Object.values(weights).reduce((sum, w) => sum + Math.max(0, w), 0);
    let random = Math.random() * totalWeight;
    
    for (const [type, weight] of Object.entries(weights)) {
      random -= Math.max(0, weight);
      if (random <= 0) return type;
    }
    
    return 'text'; // Fallback
  }
  
  /**
   * Generate event reaction post using AI
   */
  async function generateEventReaction(employee, event, context) {
    const personality = employee.personality || {};
    const social = employee.social || {};
    
    // Safety check for event structure
    if (!event || !event.type) {
      console.warn('Invalid event structure in generateEventReaction:', event);
      return null;
    }
    
    // Build context for AI
    // Events have properties directly on them (description, involvedEmployees, etc.)
    const eventDescription = (() => {
      switch (event.type) {
        case 'hire': 
          // Extract name from description
          const hireName = event.description ? event.description.split(' ')[0] : 'someone';
          return `${hireName} just joined the company`;
        case 'fire': 
          const fireName = event.description ? event.description.split(' ')[0] : 'someone';
          return `${fireName} left the company`;
        case 'promotion': 
          const promoName = event.description ? event.description.split(' ')[0] : 'someone';
          const newRole = event.description ? event.description.match(/as (.+)/)?.[1] || 'a new role' : 'a new role';
          return `${promoName} got promoted to ${newRole}`;
        case 'chat': 
          return `Had a ${event.sentiment || 'interesting'} chat with a coworker`;
        case 'gift': 
          return `Received a gift`;
        case 'achievement': 
          return `Reached a milestone: ${event.description || 'an achievement'}`;
        default: 
          return event.description || 'Something happened at work';
      }
    })();
    
    // NATURAL LANGUAGE personality description
    const personalityDescParts = [
      personalityToText(personality.outgoing || 50, 'outgoing'),
      personalityToText(personality.professional || 50, 'professional'),
      personalityToText(personality.flirty || 50, 'flirty')
    ];
    const personalityDesc = `${employee.name} is ${personalityDescParts.join(', ')}`;
    
    const relationshipContext = (context.coworkers || []).slice(0, 3).map(c => 
      `${c.coworkerName} (${c.relationship})`
    ).join(', ');
    
    // Get player/boss description for relevant events
    const playerDesc = getPlayerDescription('post');
    const bossContextNote = (event.type === 'chat' || event.type === 'gift' || event.type === 'promotion') && playerDesc !== 'the boss'
      ? `\nYour boss: ${playerDesc}`
      : '';
    
    // Gender-appropriate description
    const genderDesc = employee.gender ? `, a ${employee.age || 'young'}-year-old ${employee.gender === 'male' ? 'man' : employee.gender === 'transMan' ? 'trans man' : employee.gender === 'transWoman' ? 'trans woman' : employee.gender === 'femaleFuta' ? 'woman' : 'woman'}` : '';
    
    const prompt = `You are ${employee.name}${genderDesc}, an employee posting on an uncensored social media about a recent event.

Event: ${eventDescription}
Your personality: ${personalityDesc}
Your coworkers: ${relationshipContext}
Location: ${employee.location || 'office'}${bossContextNote}

Write a SHORT (1-3 sentences) social media post reacting to this event. Be authentic to the personality. Use emojis sparingly (0-2). Be conversational and natural.

${social.contentStyle === 'casual' ? 'Style: Casual and relaxed' : social.contentStyle === 'professional' ? 'Style: Professional but friendly' : 'Style: Balanced between casual and professional'}

Post only:`;

    try {
      const content = await queuedGenerateText(prompt, {
        temperature: 0.9,
        max_tokens: 50,
        stopSequences: ['\n\n', 'Rating:', '**Rating', '---', 'Why:', 'The stapler', 'The ', '{SEEDS', '{BAN', '{BOOST']
      }, `Generating company social post content`);
      
      // Clean Perchance tokens and meta-commentary
      let cleanContent = content;
      cleanContent = cleanContent.replace(/\{SEEDS:[^}]*\}\s*/gi, '');
      cleanContent = cleanContent.replace(/\{BAN:[^}]*\}\s*/gi, '');
      cleanContent = cleanContent.replace(/\{BOOST:[^}]*\}\s*/gi, '');
      cleanContent = cleanContent.replace(/\{[A-Z]+:[^}]*\}\s*/g, '');
      cleanContent = cleanContent.trim();
      
      // Determine explicit level
      let explicitLevel = 0;
      if (event.type === 'chat' && event.sentiment === 'flirty') {
        explicitLevel = Math.min(2, Math.floor(personality.flirty / 40));
      }
      
      // Determine if image should be generated
      let imagePrompt = null;
      if (event.type === 'promotion' && Math.random() < 0.6) {
        const physDesc = employee.physical?.shortDescription || `${employee.age || 'young'}-year-old ${employee.gender === 'male' ? 'man' : employee.gender === 'transMan' ? 'trans man' : 'woman'}`;
        imagePrompt = `Professional celebration selfie: ${physDesc} smiling, office setting, happy expression, high quality`;
      } else if (event.type === 'achievement' && Math.random() < 0.5) {
        const physDesc = employee.physical?.shortDescription || `${employee.age || 'young'}-year-old ${employee.gender === 'male' ? 'man' : employee.gender === 'transMan' ? 'trans man' : 'woman'}`;
        imagePrompt = `Excited celebration photo: ${physDesc} celebrating achievement, office environment, triumphant pose, high quality`;
      }
      
      return {
        content: cleanContent,
        imagePrompt,
        explicitLevel,
        tags: [event.type]
      };
    } catch (error) {
      console.error('AI generation failed:', error);
      // Fallback to template
      return {
        content: `${eventDescription}! ğŸ‰`,
        imagePrompt: null,
        explicitLevel: 0,
        tags: [event.type]
      };
    }
  }
  
  /**
   * Convert numeric personality value to natural language descriptor
   */
  function personalityToText(value, traitName) {
    if (value >= 85) return `extremely ${traitName}`;
    if (value >= 70) return `very ${traitName}`;
    if (value >= 55) return `quite ${traitName}`;
    if (value >= 40) return `moderately ${traitName}`;
    if (value >= 25) return `somewhat ${traitName}`;
    return `not very ${traitName}`;
  }

  /**
   * Generate organic post using AI
   */
  async function generateOrganicPost(employee, postType, context) {
    const personality = employee.personality || {};
    const social = employee.social || {};
    
    // Build rich context with NATURAL LANGUAGE personality description
    const personalityDesc = [
      personalityToText(personality.outgoing || 50, 'outgoing'),
      personalityToText(personality.professional || 50, 'professional'),
      personalityToText(personality.flirty || 50, 'flirty'),
      personalityToText(personality.confidence || 50, 'confident'),
      personalityToText(personality.humor || 50, 'humorous')
    ].join(', ');
    
    // Get people you know with their usernames for potential mentions
    const peopleWithUsernames = (context.coworkers || []).slice(0, 5).map(c => {
      const person = gameState.employees.find(e => e.id === c.coworkerId);
      const username = person?.social?.username || null;
      return {
        name: c.coworkerName,
        username: username,
        relationship: c.relationship,
        knownFor: c.knownFor || 'friend'
      };
    });
    
    const relationshipContext = peopleWithUsernames.map(c => 
      c.username 
        ? `${c.name} (@${c.username}) - ${c.relationship}, ${c.knownFor}` 
        : `${c.name} - ${c.relationship}, ${c.knownFor}`
    ).join(', ') || 'new to the network';
    
    const locationContext = (context.knownLocations || []).join(', ') || 'around town';
    
    // Get boss relationship
    const bossRelationship = employee.relationships?.player || { level: 0, type: 'professional' };
    const intimacy = employee.intimacy || 0;
    const affection = employee.stats?.affection || 0;
    
    // Randomly decide if this post should mention someone (30% chance for relevant post types)
    const shouldMention = Math.random() < 0.3 && 
                          ['text', 'work', 'life_update', 'food'].includes(postType) &&
                          (peopleWithUsernames.length > 0 && peopleWithUsernames.some(c => c.username));
    
    // Boss mention (lower chance, but increases with relationship)
    const shouldMentionBoss = Math.random() < (0.05 + (affection / 100) * 0.15) && // 5-20% chance based on affection
                              ['text', 'work', 'food', 'life_update'].includes(postType);
    
    const mentionablePeople = peopleWithUsernames.filter(c => c.username);
    let mentionInstruction = '';
    
    if (shouldMentionBoss) {
      const bossTone = intimacy > 60 ? 'warmly and casually' : affection > 50 ? 'appreciatively' : 'casually';
      mentionInstruction = `\nğŸ’¡ Consider naturally mentioning @TheBoss if relevant. Be ${bossTone}. Examples: "Hanging with @TheBoss was fun!", "Thanks @TheBoss", "@TheBoss really came through". Only mention if it feels natural!`;
    } else if (shouldMention && mentionablePeople.length > 0) {
      const randomPerson = mentionablePeople[Math.floor(Math.random() * mentionablePeople.length)];
      mentionInstruction = `\nğŸ’¡ Consider naturally mentioning @${randomPerson.username} (${randomPerson.name}) if relevant to your post. Examples: "Coffee with @${randomPerson.username} hit different today", "Thanks @${randomPerson.username}!", "Hanging with @${randomPerson.username}". Only mention if it feels natural - don't force it!`;
    }
    
    // Post type specific instructions - MASSIVELY EXPANDED
    const typeInstructions = {
      // Original types (enhanced)
      text: 'Write a casual status update about your day, thoughts, or feelings. Be authentic and varied. Topics: how you\'re feeling, observations, random thoughts, what you\'re doing. 1-2 sentences. Examples: "Why does Monday exist ğŸ˜©", "Feeling like a main character today âœ¨", "That moment when you realize it\'s only Tuesday", "Honestly just vibing", "Send coffee or leave me alone â˜•"',
      
      work: 'Write about your job/projects BUT make it relatable and interesting. NOT just "meetings". Topics: cool project wins, funny moments, learning something new, frustrations, accomplishments. 1-2 sentences. Examples: "Actually proud of what I made today ğŸš€", "When everything works on the first try ğŸ‰", "Been at this since 9am send help ğŸ’€", "That feeling when you solve a tough problem", "Living my best productive life"',
      
      selfie: 'Write a SHORT caption for a selfie. Show personality - NOT generic "feeling cute". Topics: your mood, confidence, what you\'re doing, where you are, or just pure vibe. Max 15 words. Examples: "Main character energy ğŸ’«", "No thoughts, just vibes", "Serving looks and chaos", "That post-workout glow though", "Unapologetically me", "Caught in the act of existing"',
      
      meme: 'Write a humorous, relatable caption. Reference real life, pop culture, common experiences. Be funny and current. 1 sentence. Examples: "Me: *buys coffee* / My bank account: ğŸ‘ï¸ğŸ‘„ğŸ‘ï¸", "POV: You said you\'d be productive today ğŸ’€", "Everyone else: weekend plans / Me:", "Not me stress eating again ğŸ˜…", "When they ask if I\'m okay: *insert image of everything on fire*"',
      
      life_update: 'Share a genuine personal life update - hobbies, weekend, personal news, life moments. Be specific and interesting. 1-2 sentences. Examples: "Finally finished that book I\'ve been reading for 6 months ğŸ“š", "Learned a new recipe and didn\'t burn the kitchen down ğŸ‰", "Adopting a plant parent lifestyle, wish me luck ğŸŒ±", "Started binging a new show and can\'t stop ğŸ“º"',
      
      thirst_trap: `Write a CONFIDENT, FLIRTY caption for a revealing/attractive photo. Be bold, suggestive, playful. ${personality.flirty > 60 ? 'Be explicitly flirtatious' : 'Be subtly seductive'}. Reference confidence, your look, or energy. Max 10 words. Examples: "Confidence looks good on me ğŸ˜", "You\'re welcome ğŸ’‹", "Just thinking out loud ğŸ¤”ğŸ”¥", "Felt cute, felt powerful", "No caption needed ğŸ‘€", "Making Monday better", "Dangerous mood today"`,
      
      explicit: `Write a SEXUALLY BOLD caption for explicit content. Be provocative and unapologetic. ${personality.flirty > 70 ? 'Be very direct' : 'Use suggestive language'}. Max 12 words. Examples: "After hours ğŸ”¥", "Private show ğŸ’¦", "What you don't usually see ğŸ˜ˆ", "Special delivery", "No rules tonight", "Taking requests ğŸ‘€", "Feeling dangerous", "Handle with care"`,
      
      travel: 'Post about travel, places, or wanting to travel. Show excitement or wanderlust. 1 sentence. Examples: "Daydreaming about beaches and zero responsibilities ğŸ–ï¸", "Next vacation can\'t come soon enough", "That travel bug hitting different lately âœˆï¸", "Exploring local spots hits different ğŸ—ºï¸"',
      
      food: 'Post about food, drinks, or cravings with enthusiasm. Be specific or playful. 1 sentence. Examples: "This coffee is single-handedly keeping me alive â˜•", "Taco Tuesday is the only thing I believe in ğŸŒ®", "Why does food taste better when someone else makes it ğŸ•", "Currently accepting dinner recommendations", "That post-meal satisfaction ğŸ˜Œ"',
      
      // NEW expanded types for variety
      fitness: 'Post about workout, gym, health, or physical activity. Show effort, results, or motivation. 1-2 sentences. Examples: "That post-workout high hits different ğŸ’ª", "Gym session: crushed / My legs: destroyed", "Actually showed up today, proud of myself ğŸ‹ï¸", "Running on endorphins and stubbornness", "Started my fitness journey, we\'ll see how this goes ğŸƒ"',
      
      hobby: `Post about a specific hobby or interest. Be passionate and specific - reference what you DO. Include details. 1-2 sentences. ${employee.hobbies && employee.hobbies.length > 0 ? `Your hobbies: ${employee.hobbies.join(', ')}. Reference one of these!` : ''} Examples: "Finally beat that level I\'ve been stuck on ğŸ®", "New vinyl just dropped and it\'s ğŸ”¥", "Spent the afternoon painting and lost track of time ğŸ¨", "Photography walk was exactly what I needed ğŸ“¸"`,
      
      entertainment: 'Post about movies, shows, music, books, or pop culture. Share opinions, recommendations, or what you\'re into. 1-2 sentences. Examples: "Just finished that show everyone\'s talking about and WOW ğŸ¬", "This song is living rent-free in my head ğŸµ", "Reading a book that\'s actually making me think ğŸ“–", "Can we talk about that plot twist though ğŸ˜±", "New album on repeat, absolute fire ğŸ”¥"',
      
      mood: 'Pure vibe/feeling post. Express current mood, energy, or emotional state. Be authentic and relatable. 1 sentence. Examples: "Big chaotic energy today ğŸŒªï¸", "Soft girl hours ğŸŒ¸", "Feeling myself a little too much today âœ¨", "Main character syndrome activated", "That unexplainable good mood", "Tired but make it aesthetic ğŸ˜´", "Existing and thriving", "No thoughts, head empty, vibes immaculate"',
      
      question: 'Ask followers something - opinion, recommendation, this-or-that. Be engaging. 1 sentence with question mark. Examples: "Coffee or tea, and why is coffee the only right answer? â˜•", "What\'s a show I NEED to watch right now? ğŸ“º", "Hot take: pineapple on pizza is valid. Fight me or agree? ğŸ•", "Weekend plans or just winging it? ğŸ‰", "What\'s your go-to comfort food when life gets weird? ğŸœ"',
      
      achievement: 'Share a personal win - small or big. NOT always work (can be life, personal growth, random wins). Show pride. 1-2 sentences. Examples: "Didn\'t hit snooze once this week, I\'m basically unstoppable", "Finally organized my closet and found clothes I forgot existed ğŸ‰", "Made it through the week without a breakdown, new personal record ğŸ’ª", "Hit a goal I didn\'t think I could reach ğŸ¯", "Small win but it feels big âœ¨"',
      
      throwback: 'Nostalgic post about a memory, past experience, or "remember when". Be specific and reflective. 1-2 sentences. Examples: "Remember when we all thought 2020 would be our year ğŸ’€", "Thinking about that summer where everything just hit different â˜€ï¸", "Found old photos and the nostalgia is hitting hard ğŸ“¸", "Miss the days when my biggest worry was what to eat ğŸ¥º", "Throwback to when life was simpler"',
      
      pet: 'Post about pets, animals, or wanting a pet. Show affection or humor. 1 sentence. Examples: "My cat judges every life decision I make and she\'s not wrong ğŸ±", "Dogs really are too pure for this world ğŸ•", "That moment when your pet becomes your therapist ğŸ’•", "Saw the cutest dog today and it made my whole week", "Considering adopting a pet just for the emotional support"',
      
      fashion: 'Post about outfit, style, clothing, or fashion choices. Show confidence in your look. 1 sentence. Examples: "Serving looks and confidence today ğŸ’ƒ", "This outfit said main character and I listened âœ¨", "When your outfit matches your energy >>", "Feeling this style lately ğŸ‘—", "Comfortable AND cute, we love to see it"',
      
      complaint: 'Vent about something annoying, frustrating, or relatable. Keep it real and funny. 1-2 sentences. Examples: "Why does everything decide to break at the same time ğŸ˜©", "Being an adult is just constantly asking wait do I have plans ğŸ’€", "My back hurts and I didn\'t even do anything this is 25", "Can life give me a break or is that too much to ask", "Monday can take several seats ğŸ’º"',
      
      inspiration: 'Share something motivational, philosophical, or reflective. Be genuine not corporate-cheesy. 1-2 sentences. Examples: "Growth is uncomfortable but staying the same is worse ğŸŒ±", "Normalize doing what\'s best for you even if others don\'t get it âœ¨", "You don\'t have to be perfect just keep showing up ğŸ’ª", "Small steps still count as progress ğŸš¶", "Be the energy you want to attract"',
      
      weather: 'Comment on weather and how it affects mood or plans. Be relatable. 1 sentence. Examples: "This weather is giving main character energy â˜€ï¸", "Rain + cozy vibes = perfect day for doing nothing ğŸŒ§ï¸", "Why is it so hot I\'m literally melting ğŸ¥µ", "Cold weather = excuse to stay in bed all day â„ï¸", "Perfect weather for absolutely nothing productive"',
      
      random: 'Completely random thought observation or chaotic energy. Be spontaneous and unexpected. 1 sentence. Examples: "Thinking about how penguins have knees and now I can\'t unthink it ğŸ§", "What if plants are actually farming us ğŸŒ±ğŸ¤”", "The word bed looks like a bed", "Why do we say heads up when we actually mean duck ğŸ’€", "Random urge to completely change my life at 2am", "Not all thoughts need to be said but here we are"',
      
      gossip: `Post about gossip/drama you know about. Be VAGUE and MYSTERIOUS but juicy. Use cryptic language or emojis. DON'T name names. 1-2 sentences. ${employee.gossip?.knownGossip?.length > 0 ? 'Reference the gossip you know but DON\'T name names directly - keep it mysterious!' : ''} Examples: "Someone is MESSY and I'm here for it ğŸ‘€â˜•", "The tea is piping hot today and I'm observing from a safe distance ğŸ¿", "Not me knowing things I probably shouldn't know ğŸ¤", "Drama >>> any reality TV show ğŸ“º", "Just heard something WILD but my lips are sealed... for now ğŸ¤«", "Y'all I can't evenâ€”things are SPICY lately ğŸŒ¶ï¸"`,
      
      tea_spilling: `SPILL THE TEA! Post about gossip/drama you know with SPECIFIC NAMES using @mentions. Be DIRECT and call people out, but keep it playful/dramatic not mean. ${employee.gossip?.knownGossip?.length > 0 ? 'Reference the gossip you know and USE NAMES with @ mentions!' : ''} 1-2 sentences max. Examples: "Sooo @sarah and @mike definitely hooked up last night, I'm just saying ğŸ‘€", "Wait @jessica has been wearing @kevin's hoodie all week? TEA ğŸµ", "Not @emma posting thirst traps right after her breakup with @alex... we see you queen ğŸ’…", "@chris really thought nobody would notice him sneaking out with @amber ğŸ˜", "The way @madison looked at @tyler... PLEASE ğŸ’•"`
    };
    
    const contentStyleNote = social.contentStyle === 'casual' ? 'Use casual language, contractions, slang' :
                            social.contentStyle === 'professional' ? 'Use professional but friendly tone' :
                            'Use balanced conversational tone';
    
    // Get recent posts by this employee to encourage variety
    const recentPosts = gameState.socialNetwork.posts
      .filter(p => p.authorId === employee.id)
      .slice(0, 3)
      .map(p => p.content)
      .join(' | ');
    
    // Check recent community posts for overused themes
    const recentCommunityPosts = gameState.socialNetwork.posts
      .slice(0, 20)
      .map(p => p.content.toLowerCase());
    
    // EXPANDED theme detection to catch more repetitive patterns
    const overusedThemes = [];
    const themeChecks = [
      // Original checks
      { keywords: ['garage', 'park', 'parking'], theme: 'garage/parking' },
      { keywords: ['keys', 'lost', 'looking for', 'hunting for', 'found'], theme: 'lost items' },
      { keywords: ['reorganiz', 'organiz', 'clean', 'tidy'], theme: 'organization' },
      { keywords: ['server', 'rack', 'cable', 'wifi'], theme: 'IT equipment' },
      
      // NEW expanded checks for common repetitive themes
      { keywords: ['coffee', 'caffeine', 'espresso', 'latte'], theme: 'coffee' },
      { keywords: ['monday', 'mondays'], theme: 'Monday complaints' },
      { keywords: ['weekend', 'friday', 'tgif'], theme: 'weekend vibes' },
      { keywords: ['meeting', 'meetings', 'zoom', 'conference'], theme: 'meetings' },
      { keywords: ['deadline', 'due date', 'crunch'], theme: 'deadlines' },
      { keywords: ['tired', 'exhausted', 'sleep', 'nap'], theme: 'being tired' },
      { keywords: ['vibe', 'vibing', 'vibes'], theme: 'vibe posts' },
      { keywords: ['main character', 'mc energy'], theme: 'main character' },
      { keywords: ['chaos', 'chaotic'], theme: 'chaos energy' },
      { keywords: ['broke', 'money', 'paycheck', 'bank account'], theme: 'money struggles' }
    ];
    
    themeChecks.forEach(check => {
      const matchCount = recentCommunityPosts.filter(post => 
        check.keywords.some(kw => post.includes(kw))
      ).length;
      // More strict: 2+ posts (was 3+) about same theme triggers avoidance
      if (matchCount >= 2) {
        overusedThemes.push(check.theme);
      }
    });
    
    const themeAvoidanceNote = overusedThemes.length > 0 
      ? `\nâš ï¸ AVOID these overused themes: ${overusedThemes.join(', ')} - pick something completely different!`
      : '';
    
    const varietyNote = recentPosts 
      ? `\nYour recent posts: "${recentPosts}"\nâš ï¸ Write something DIFFERENT - new topic, different angle, fresh perspective!${themeAvoidanceNote}` 
      : themeAvoidanceNote;
    
    // Build chat context instruction
    let chatContextNote = '';
    if (context.chatContext?.hasRecentChat) {
      const chat = context.chatContext;
      const timeAgoText = chat.timeAgo < 60 ? `${chat.timeAgo} minutes ago` : `${Math.round(chat.timeAgo / 60)} hours ago`;
      const themesText = chat.themes.length > 0 ? chat.themes.join(', ') : 'casual conversation';
      
      // Get last few message previews
      // NOTE: "[truncated]" instead of "..." to avoid AI thinking person trailed off mid-sentence
      const messagePreview = chat.lastMessages
        .map(msg => `${msg.sender}: "${msg.preview}${msg.preview.length >= 100 ? ' [truncated]' : ''}"`)
        .join('\n');
      
      // Check relationship level to determine tone - NATURAL LANGUAGE
      const relationshipTone = intimacy > 60 
        ? 'ğŸ”¥ IMPORTANT: You have a very intimate, consensual relationship with your boss. You genuinely enjoy this dynamic! If posting about intimate conversations or requests, be positive, excited, teasing, or playful.'
        : intimacy > 30
        ? 'ğŸ’• You have a developing close relationship with your boss. Frame flirty or intimate content positively and teasingly.'
        : affection > 60
        ? 'ğŸ˜Š You have good rapport with your boss. Keep posts about interactions positive or playful.'
        : '';
      
      chatContextNote = `\n\nğŸ’¬ RECENT CHAT WITH BOSS (${timeAgoText}):
Conversation themes: ${themesText}
Last messages:
${messagePreview}

âš ï¸ NOTE: If you see "..." (ellipses) in messages above, that's just typing style for dramatic effect - NOT the person trailing off incomplete. Don't make posts about "mysterious unfinished sentences" or "what were they going to say?"

${relationshipTone}

ğŸ’¡ OPTIONAL: You could make a post inspired by this conversation! Examples:
- If it was flirty: "Still thinking about that conversation... ğŸ˜" or "Feeling some type of way today ğŸ”¥"
- If it was about projects: "Excited about this new thing I'm working on!" or "Time to crush it ğŸ’ª"
- If it was personal: "Good talks hit different" or "Grateful for good listeners"
- Or post about something COMPLETELY DIFFERENT - you don't have to reference the chat!

${chat.themes.includes('flirty/romantic') && ['text', 'selfie', 'thirst_trap'].includes(postType) 
  ? 'ğŸ”¥ Since you had a flirty chat recently, feel free to make a suggestive/spicy post if it feels natural!' 
  : ''}`;
    }
    
    // Build boss request context
    let bossRequestNote = '';
    if (context.requestedByBoss) {
      bossRequestNote = `\n\nğŸ¯ BOSS REQUESTED THIS POST:
The boss specifically asked you to make this post${context.requestContext ? `: "${context.requestContext}"` : ''}.
You've already agreed to do it, so make the post they requested!
Be confident and match the tone they were asking for.
${postType === 'explicit' || postType === 'thirst_trap' ? 'They want something bold and provocative - don\'t hold back!' : ''}`;
    }
    
    // Get player/boss description for context when mentioning
    const playerDesc = getPlayerDescription('post'); // Use 'post' context for social media
    const bossContextNote = playerDesc !== 'the boss' ? `\n\nğŸ‘¤ ABOUT YOUR BOSS:\n${playerDesc}` : '';
    
    // Add gossip context for gossip posts
    let gossipContextNote = '';
    if (postType === 'gossip' || postType === 'tea_spilling') {
      const knownGossip = getKnownGossip(employee.id, 3);
      if (knownGossip.length > 0) {
        const gossipDetails = knownGossip.map(g => {
          const subject = g.subjectId === 'player' ? 'the boss' : 
                        gameState.employees.find(e => e.id === g.subjectId)?.name || 'someone';
          const subjectUsername = g.subjectId === 'player' ? '@boss' :
                                 gameState.employees.find(e => e.id === g.subjectId)?.social?.username || null;
          const target = g.targetId ? 
                        (g.targetId === 'player' ? 'the boss' : 
                         gameState.employees.find(e => e.id === g.targetId)?.name || 'someone') : '';
          const targetUsername = g.targetId ? 
                                (g.targetId === 'player' ? '@boss' :
                                 gameState.employees.find(e => e.id === g.targetId)?.social?.username || null) : '';
          const accuracy = g.accuracy < 50 ? ' (might be a rumor)' : 
                          g.accuracy < 80 ? ' (heard through grapevine)' : '';
          
          if (postType === 'tea_spilling' && subjectUsername) {
            // For tea spilling, provide names with usernames
            return `- ${subject} (${subjectUsername})${target ? ` and ${target} (${targetUsername})` : ''}: ${g.content}${accuracy}`;
          } else {
            return `- ${g.content}${accuracy}`;
          }
        }).join('\n');
        
        if (postType === 'tea_spilling') {
          gossipContextNote = `\n\nğŸµ TEA TO SPILL:
${gossipDetails}

ğŸ¯ SPILL IT! Use @usernames to call people out directly! Be dramatic and juicy but playful. Examples:
- "Not @sarah hooking up with @mike in the supply closet ğŸ‘€"
- "@kevin has been acting SUS around @jessica lately... just saying ğŸ«–"
- "Everyone pretending they don't see @alex and @emma sneaking around ğŸ˜"`;
        } else {
          gossipContextNote = `\n\nğŸ«– GOSSIP YOU KNOW:
${gossipDetails}

âš ï¸ DON'T name names directly! Keep it mysterious and vague. Hint at the drama without being too specific. Use "someone", "people", "coworkers", etc.`;
        }
      } else {
        if (postType === 'tea_spilling') {
          gossipContextNote = `\n\nâš ï¸ You don't have specific tea right now, so make a teasing post about ALMOST spilling tea or hinting that you know something without details.`;
        } else {
          gossipContextNote = `\n\nâš ï¸ You don't actually know any specific gossip right now, so make a generic "something's happening" type post or pretend you heard something vague.`;
        }
      }
    }
    
    // Gender and physical description for full self-awareness
    const genderDesc = employee.gender ? `, a ${employee.age || 'young'}-year-old ${employee.gender === 'Male' ? 'man' : employee.gender === 'Trans Man' ? 'trans man' : employee.gender === 'Trans Woman' ? 'trans woman' : employee.gender === 'Female Futa' ? 'woman with unique anatomy' : 'woman'}` : '';
    const physicalDesc = context.employee?.physicalDescription || getPhysicalDescriptionForPrompt(employee);
    
    // === FLAG CONTEXT FOR POSTS ===
    let flagContextNote = '';
    const activeFlags = getActiveFlags(employee);
    if (activeFlags.length > 0) {
      const relevantFlags = activeFlags.filter(f => 
        f.priority === 'high' || 
        f.key === 'pregnant' ||
        f.key === 'chastity' ||
        f.key === 'in_relationship' ||
        f.key === 'engaged' ||
        f.key === 'married' ||
        f.affectsContext
      );
      
      if (relevantFlags.length > 0) {
        flagContextNote = '\n\nğŸ·ï¸ YOUR CURRENT STATUS/FLAGS:';
        relevantFlags.forEach(flag => {
          flagContextNote += `\n- ${flag.key}: ${flag.playerDescription || flag.value}`;
          if (flag.aiGuidance) {
            flagContextNote += `\n  ğŸ’¡ ${flag.aiGuidance}`;
          }
        });
        flagContextNote += '\n\nâš ï¸ Consider these when making your post! They affect your current life situation and what you might share on social media.';
      }
    }
    
    // === AI QUALITY LEARNING: Add good examples to prompt ===
    let learningExamples = '';
    const goodPosts = gameState.aiQuality?.goodExamples?.posts || [];
    if (goodPosts.length > 0) {
      // Get up to 3 recent good examples
      const examples = goodPosts.slice(0, 3).map(ex => `"${ex.content}"`).join(', ');
      learningExamples = `\n\nâœ… QUALITY EXAMPLES (player-approved posts that work well):\n${examples}\n\nUse these as inspiration for quality and style. Match this level of authenticity and readability.`;
    }
    
    const prompt = `You are ${employee.name}${genderDesc}, posting on an uncensored PERSONAL social media platform (like Instagram/Twitter).

ğŸŒ PLATFORM CONTEXT: This is a PERSONAL social network separate from work - NOT a work chat or Slack channel. While you work together, this is for PERSONAL sharing, fun, and connecting outside of professional boundaries. Think Instagram vibes - casual, personal, sometimes spicy!

YOUR PHYSICAL APPEARANCE: ${physicalDesc}
(You are fully aware of your body, gender, and physical characteristics. Reference them naturally if relevant to your post, especially in selfies or intimate content.)
${flagContextNote}

Your personality: You are ${personalityDesc}.
${buildAIContextFromSkills(employee)}
Post type: ${postType}
People you know: ${relationshipContext}
Style: ${contentStyleNote}${varietyNote}${mentionInstruction}${chatContextNote}${bossRequestNote}${bossContextNote}${gossipContextNote}${learningExamples}

${typeInstructions[postType] || typeInstructions.text}

CRITICAL RULES: 
- Write ONLY the post itself - NO explanations, notes, or meta-commentary
- NO parenthetical notes like "(Note: ...)" or style explanations
- Be SHORT and authentic (1-2 sentences MAX, but NOT single-word posts)
- This is a PERSONAL social network - NOT professional, NOT work chat
- Feel free to be casual, flirty, fun, and expressive
- Hashtags: Use 0-1 hashtags, make them natural and varied (avoid #Garage unless truly relevant)
- Emojis: 0-2 max, use sparingly
- Don't always mention location - posts can be about ANYTHING
- Vary your topics - avoid repetitive scenarios (keys, parking, garage organization)
- Sound like a real person, not AI
- When mentioning people, use their @username format naturally
- NEVER use "caught in mid-[action]" phrases or similar incomplete action descriptions
- Avoid one-word or extremely short posts like "Made it to work" or "Self-care morning"
- Add personality and context - give readers something interesting

Write ONLY the social media post text:`;

    try {
      // Check if AI is available
      if (typeof generateText !== 'function') {
        throw new Error('AI text plugin not available');
      }
      
      let content = await queuedGenerateText(prompt, {
        temperature: 0.9,
        max_tokens: 80,
        stopSequences: ['\n\n', '{SEEDS', '{BAN', '{BOOST', '---', 'Rating:', '**Rating', 'Rationale:', 'Analysis:', '(Note:', '**(Note', 'Physical description:', 'Selfie Caption:', '**Why']
      }, `Generating organic social post (${postType}) for ${employee.name}`);
      
      // CRITICAL FIX: Extract actual string from response
      content = extractText(content);
      
      // AGGRESSIVE meta-commentary removal for posts
      
      // CRITICAL: Remove Perchance formatting tokens that shouldn't appear in output
      // Remove {SEEDS:...} patterns (e.g., "{SEEDS:apiculate|synbio}")
      content = content.replace(/\{SEEDS:[^}]*\}\s*/gi, '');
      // Remove {BAN:...} patterns
      content = content.replace(/\{BAN:[^}]*\}\s*/gi, '');
      // Remove {BOOST:...} patterns
      content = content.replace(/\{BOOST:[^}]*\}\s*/gi, '');
      // Remove any remaining {WHATEVER:...} patterns
      content = content.replace(/\{[A-Z]+:[^}]*\}\s*/g, '');
      
      // Remove bold name headers (e.g., "**Beverly Elliott**" or "**Sophia Harrell**")
      content = content.replace(/^\*\*[^*]+\*\*\s*/g, '');
      
      // Remove "Posted:" prefixes (e.g., "Posted: 3 hours ago")
      content = content.replace(/^Posted:\s*[^\n]+\n\s*/i, '');
      
      // Remove everything after common meta-commentary markers
      content = content.split(/\n\s*\(/)[0]; // Remove "(Note: ...)" style comments
      content = content.split(/\n\s*\*/)[0];  // Remove "*(...)" style comments
      content = content.split(/\(Note:/)[0];  // Remove inline notes
      content = content.split(/\(Character count:/)[0]; // Remove character count analysis
      content = content.split(/\(Emojis used:/)[0]; // Remove emoji analysis
      content = content.split(/\(Approach:/)[0]; // Remove approach analysis
      content = content.split(/\(Style note:/)[0]; // Remove style notes
      content = content.split(/\*\(Balanced/)[0]; // Remove specific patterns
      content = content.split(/\*\(Casual/)[0];
      content = content.split(/\*\(Keeps/)[0];
      content = content.split(/\*\(Style/)[0];
      // Remove trailing analysis markers
      content = content.replace(/\s*\(Tagged coworkers.*?\)$/i, ''); // Remove tagging thoughts
      content = content.replace(/\s*\*\s*$/g, ''); // Remove trailing asterisks
      content = content.trim();
      
      // AUTO-CONVERT boss mentions to @TheBoss for consistent detection
      // Replace variations: "boss", "the boss", "my boss", "our boss", "Boss"
      content = content.replace(/\b(the\s+)?([Mm]y\s+)?([Oo]ur\s+)?[Bb]oss\b/g, '@TheBoss');
      // Clean up duplicate @ symbols that might result from "the @boss" â†’ "@TheBoss"
      content = content.replace(/@@TheBoss/g, '@TheBoss');
      // Clean up if there was already an @ before: "@boss" â†’ "@TheBoss"
      content = content.replace(/@[Bb]oss\b/g, '@TheBoss');
      
      // === AI QUALITY LEARNING: Apply aggressive cleanup with learned patterns ===
      content = cleanWithLearning(content);
      
      // === POST QUALITY VALIDATION: Reject posts that are too short or generic ===
      const wordCount = content.split(/\s+/).filter(w => w.length > 0).length;
      const hasOnlyEmojis = /^[\s\p{Emoji}]+$/u.test(content);
      
      // List of overly generic single-line posts to reject
      const genericPhrases = [
        /^made it to work\.?$/i,
        /^self-care morning\.?$/i,
        /^vibing\.?$/i,
        /^mood\.?$/i,
        /^feeling good\.?$/i,
        /^just chilling\.?$/i,
        /^another day\.?$/i,
        /^here we go\.?$/i,
        /^ready for this\.?$/i
      ];
      
      const isGenericPost = genericPhrases.some(pattern => pattern.test(content.replace(/[âœ¨ğŸ’­ğŸ¤”ğŸ’«âš¡â˜•ğŸ“…âœ“ğŸ˜Œ]/g, '').trim()));
      
      if (wordCount < 3 || hasOnlyEmojis || isGenericPost) {
        console.warn('[AI Quality] Post rejected: too short or generic:', content);
        throw new Error('Generated content too short or generic, using fallback');
      }
      
      // Track mentions for stats
      const mentionedUsernames = [];
      const mentionRegex = /@([\w.]+)/g; // Allow dots in usernames
      let match;
      while ((match = mentionRegex.exec(content)) !== null) {
        mentionedUsernames.push(match[1]);
      }
      
      // Update mention counts for mentioned employees (use same smart matching as extractMentions)
      mentionedUsernames.forEach(mentionedUsername => {
        const mentionedEmployee = gameState.employees.find(e => {
          if (!e.social?.username) return false;
          const storedUsername = e.social.username.toLowerCase();
          const mentioned = mentionedUsername.toLowerCase();
          
          // Try multiple matching strategies
          if (storedUsername === mentioned) return true;
          const normalize = (u) => u.replace(/[_.\-\d]/g, '').replace(/^(the|real)|official$/g, '');
          if (normalize(storedUsername) === normalize(mentioned)) return true;
          return false;
        });
        if (mentionedEmployee && mentionedEmployee.social) {
          mentionedEmployee.social.totalMentions = (mentionedEmployee.social.totalMentions || 0) + 1;
        }
      });
      
      // Determine explicit level based on post type and personality
      let explicitLevel = 0;
      if (postType === 'thirst_trap') {
        // Thirst traps are always at least level 2 (lewd/revealing)
        explicitLevel = personality.flirty > 70 ? 3 : 2;
      } else if (postType === 'explicit') {
        // Explicit posts are always level 4 (very explicit/NSFW)
        explicitLevel = 4;
      } else if (postType === 'selfie' && personality.flirty > 65) {
        explicitLevel = Math.random() < 0.3 ? 1 : 0;
      }
      
      // Generate image prompt for visual post types
      let imagePrompt = null;
      const shouldGenerateImage = context?.mustIncludeImage || 
                                   ['selfie', 'thirst_trap', 'explicit', 'nude', 'meme', 'food', 'travel', 'life_update'].includes(postType);
      
      if (shouldGenerateImage && postType !== 'text') {
        imagePrompt = await generateImagePrompt(employee, postType, content, context);
        console.log(`[Post Generation] ${context?.mustIncludeImage ? 'ğŸ¯ FORCED' : 'ğŸ“¸ Standard'} image prompt for ${employee.name}'s ${postType} post`);
      }
      
      return {
        content: content.trim(),
        imagePrompt,
        explicitLevel,
        tags: [postType]
      };
    } catch (error) {
      console.error('[AI] Generation failed for employee post:', error);
      console.error('[AI] Post type:', postType);
      console.error('[AI] Employee:', employee.name);
      console.warn('[AI] Post generation failed - discarding post instead of using fallback');
      
      // Return null to indicate failure - calling code will skip creating the post
      return null;
    }
  }
  
  /**
   * Analyze post caption to extract key subjects, themes, and context
   * MASSIVELY EXPANDED for comprehensive coverage!
   */
  function analyzeCaption(caption) {
    const lower = caption.toLowerCase();
    
    // ===== FOOD ITEMS (50+ categories) =====
    const foodMatches = {
      'coffee': ['coffee', 'latte', 'espresso', 'cappuccino', 'mocha', 'americano', 'cold brew', 'iced coffee', 'frappe', 'macchiato'],
      'burger': ['burger', 'hamburger', 'cheeseburger', 'whopper', 'big mac'],
      'pizza': ['pizza', 'slice', 'pie', 'pepperoni', 'margherita', 'deep dish'],
      'sushi': ['sushi', 'sashimi', 'roll', 'maki', 'nigiri', 'california roll', 'spicy tuna'],
      'ramen': ['ramen', 'noodle soup', 'tonkotsu', 'miso ramen', 'shoyu'],
      'taco': ['taco', 'tacos', 'burrito', 'quesadilla', 'enchilada', 'nachos'],
      'sandwich': ['sandwich', 'sub', 'hoagie', 'panini', 'grilled cheese', 'blt', 'club sandwich'],
      'salad': ['salad', 'greens', 'lettuce', 'caesar', 'cobb salad', 'greek salad'],
      'pasta': ['pasta', 'spaghetti', 'fettuccine', 'ravioli', 'linguine', 'penne', 'carbonara', 'alfredo', 'bolognese'],
      'cake': ['cake', 'birthday cake', 'cheesecake', 'chocolate cake', 'vanilla cake', 'red velvet'],
      'cookie': ['cookie', 'cookies', 'chocolate chip', 'oatmeal cookie', 'sugar cookie'],
      'ice cream': ['ice cream', 'gelato', 'sundae', 'cone', 'scoop'],
      'donut': ['donut', 'doughnut', 'glazed', 'jelly donut', 'cruller'],
      'brownie': ['brownie', 'brownies', 'fudge brownie'],
      'lemon bars': ['lemon bar', 'lemon bars', 'lemon square', 'lemon dessert'],
      'boba': ['boba', 'bubble tea', 'milk tea', 'pearl tea', 'tapioca'],
      'smoothie': ['smoothie', 'smoothie bowl', 'acai bowl', 'protein shake'],
      'breakfast': ['breakfast', 'brunch'],
      'pancakes': ['pancake', 'pancakes', 'flapjack', 'stack'],
      'waffles': ['waffle', 'waffles', 'belgian waffle'],
      'eggs': ['eggs', 'scrambled', 'fried egg', 'omelet', 'omelette', 'poached egg'],
      'bacon': ['bacon', 'strips', 'crispy bacon'],
      'toast': ['toast', 'buttered toast'],
      'avocado toast': ['avocado toast', 'avo toast', 'smashed avo'],
      'cereal': ['cereal', 'cheerios', 'corn flakes', 'granola'],
      'cocktail': ['cocktail', 'martini', 'mojito', 'margarita', 'whiskey', 'vodka', 'gin', 'tequila', 'rum'],
      'beer': ['beer', 'brew', 'ale', 'lager', 'ipa', 'pint'],
      'wine': ['wine', 'red wine', 'white wine', 'rosÃ©', 'champagne', 'prosecco'],
      'tea': ['tea', 'green tea', 'black tea', 'chai', 'herbal tea', 'iced tea'],
      'wings': ['wing', 'wings', 'buffalo wings', 'chicken wings', 'hot wings'],
      'fries': ['fries', 'french fries', 'chips', 'waffle fries', 'curly fries'],
      'soup': ['soup', 'stew', 'chowder', 'bisque', 'pho', 'gumbo'],
      'steak': ['steak', 'ribeye', 'sirloin', 'filet', 'beef', 't-bone'],
      'chicken': ['chicken', 'poultry', 'fried chicken', 'grilled chicken', 'chicken breast'],
      'seafood': ['seafood', 'fish', 'salmon', 'tuna', 'shrimp', 'lobster', 'crab', 'oyster'],
      'bbq': ['bbq', 'barbecue', 'ribs', 'brisket', 'pulled pork', 'smoked'],
      'hotdog': ['hot dog', 'hotdog', 'frank', 'corn dog'],
      'popcorn': ['popcorn', 'kettle corn'],
      'chips': ['chips', 'potato chips', 'tortilla chips', 'pretzels', 'crisps'],
      'cheese': ['cheese', 'cheddar', 'mozzarella', 'brie', 'gouda', 'parmesan', 'cheese board', 'charcuterie'],
      'poke bowl': ['poke', 'poke bowl', 'ahi'],
      'curry': ['curry', 'indian food', 'tikka masala', 'vindaloo'],
      'dim sum': ['dim sum', 'dumpling', 'dumplings', 'bao', 'steamed bun'],
      'bagel': ['bagel', 'bagels', 'cream cheese'],
      'muffin': ['muffin', 'muffins', 'blueberry muffin'],
      'croissant': ['croissant', 'pastry', 'danish'],
      'fruit': ['fruit', 'apple', 'banana', 'orange', 'berry', 'berries', 'strawberry', 'mango', 'watermelon'],
      'vegetables': ['veggie', 'vegetables', 'carrot', 'broccoli', 'spinach'],
      'snack': ['snack', 'snacking', 'munchies']
    };
    
    let detectedFood = null;
    for (const [category, keywords] of Object.entries(foodMatches)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedFood = category;
        break;
      }
    }
    
    // ===== MOODS & EMOTIONS (30+ states) =====
    const moods = {
      tired: ['tired', 'exhausted', 'sleepy', 'dead', 'drained', 'worn out', 'beat', 'fatigue', 'zombie', 'need sleep', 'can\'t even'],
      happy: ['happy', 'excited', 'great', 'amazing', 'wonderful', 'fantastic', 'vibing', 'blessed', 'grateful', 'joyful', 'thrilled', 'elated', 'stoked'],
      confident: ['confident', 'feeling myself', 'good vibes', 'powerful', 'unstoppable', 'boss', 'killing it', 'on top', 'got this', 'crushing'],
      flirty: ['flirt', 'mood', 'you know', 'wink', 'after hours', 'naughty', 'cheeky', 'tease', 'playful', 'spicy', 'wild', 'devil'],
      stressed: ['stress', 'busy', 'hectic', 'overwhelm', 'deadline', 'crazy', 'panic', 'anxiety', 'nervous', 'worried', 'pressure'],
      relaxed: ['chill', 'relax', 'calm', 'peaceful', 'zen', 'cozy', 'serene', 'tranquil', 'ease', 'unwind', 'mellow'],
      sad: ['sad', 'down', 'depressed', 'blue', 'melancholy', 'heartbroken', 'crying', 'tears', 'upset', 'hurt'],
      angry: ['angry', 'mad', 'furious', 'pissed', 'annoyed', 'irritated', 'rage', 'frustrated', 'livid'],
      silly: ['silly', 'goofy', 'funny', 'derp', 'weird', 'quirky', 'random', 'chaos', 'unhinged'],
      proud: ['proud', 'accomplished', 'achievement', 'success', 'win', 'nailed it', 'crushed it'],
      bored: ['bored', 'boring', 'meh', 'whatever', 'yawn', 'nothing to do'],
      hungover: ['hungover', 'hangover', 'regret', 'last night', 'never again', 'why did i'],
      motivated: ['motivated', 'motivated', 'inspired', 'determined', 'focused', 'driven', 'hustle', 'grind'],
      romantic: ['romantic', 'love', 'date night', 'valentine', 'crush', 'heart', 'swooning'],
      mysterious: ['mysterious', 'secret', 'cryptic', 'enigma', 'wonder', 'curious'],
      sassy: ['sassy', 'attitude', 'unbothered', 'petty', 'shade', 'savage']
    };
    
    let detectedMood = 'neutral';
    for (const [mood, keywords] of Object.entries(moods)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedMood = mood;
        break;
      }
    }
    
    // ===== ACTIVITIES (40+ types) =====
    const activities = {
      workout: ['workout', 'gym', 'exercise', 'fitness', 'lift', 'lifting', 'cardio', 'run', 'running', 'jog', 'jogging', 'weights', 'training', 'sweat', 'gains', 'leg day', 'arm day'],
      yoga: ['yoga', 'meditation', 'meditate', 'stretch', 'stretching', 'pilates'],
      travel: ['travel', 'trip', 'vacation', 'holiday', 'getaway', 'adventure', 'explore', 'wanderlust'],
      work: ['work', 'working', 'meeting', 'project', 'deadline', 'presentation', 'client', 'boss', 'coworker'],
      cooking: ['cook', 'cooking', 'baking', 'bake', 'recipe', 'homemade', 'chef', 'kitchen', 'meal prep'],
      reading: ['read', 'reading', 'book', 'novel', 'page', 'chapter', 'library', 'literature'],
      gaming: ['game', 'gaming', 'play', 'playing', 'controller', 'stream', 'streaming', 'twitch', 'console', 'pc gaming', 'esports'],
      art: ['paint', 'painting', 'draw', 'drawing', 'art', 'sketch', 'sketching', 'canvas', 'illustration', 'digital art'],
      music: ['music', 'song', 'singing', 'guitar', 'piano', 'drums', 'concert', 'band', 'playlist', 'jam', 'practice'],
      dancing: ['dance', 'dancing', 'moves', 'choreography', 'ballet', 'salsa', 'club', 'party'],
      shopping: ['shopping', 'shop', 'store', 'mall', 'bought', 'purchase', 'retail therapy', 'haul'],
      cleaning: ['clean', 'cleaning', 'organize', 'organizing', 'tidy', 'laundry', 'dishes', 'vacuum'],
      studying: ['study', 'studying', 'homework', 'exam', 'test', 'cramming', 'research', 'learning'],
      driving: ['drive', 'driving', 'commute', 'traffic', 'road trip', 'cruise'],
      walking: ['walk', 'walking', 'stroll', 'strolling', 'hike', 'hiking'],
      swimming: ['swim', 'swimming', 'pool', 'lap', 'dive', 'diving'],
      biking: ['bike', 'biking', 'cycle', 'cycling', 'bicycle', 'ride', 'riding'],
      photography: ['photo', 'photography', 'camera', 'shoot', 'shooting', 'pictures', 'snap', 'capture'],
      movie: ['movie', 'film', 'cinema', 'theater', 'watching', 'binge', 'netflix', 'tv show', 'series'],
      socializing: ['friends', 'hanging out', 'hangout', 'party', 'gathering', 'social', 'meet up', 'catch up'],
      sleeping: ['sleep', 'sleeping', 'nap', 'napping', 'bed', 'rest', 'snooze'],
      drinking: ['drinking', 'drinks', 'bar', 'pub', 'tipsy', 'drunk', 'shots', 'cheers'],
      selfcare: ['self care', 'spa', 'facial', 'massage', 'manicure', 'pedicure', 'pamper', 'treat myself'],
      grooming: ['shower', 'bath', 'shave', 'hair', 'makeup', 'skincare', 'getting ready'],
      diy: ['diy', 'build', 'building', 'craft', 'crafting', 'project', 'handmade', 'woodwork'],
      gardening: ['garden', 'gardening', 'plant', 'plants', 'flower', 'flowers', 'grow', 'growing'],
      pets: ['pet', 'dog', 'cat', 'puppy', 'kitten', 'fur baby', 'doggo', 'pupper', 'kitty'],
      celebration: ['celebrate', 'celebrating', 'birthday', 'anniversary', 'promotion', 'milestone', 'achievement']
    };
    
    let detectedActivity = null;
    for (const [activity, keywords] of Object.entries(activities)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedActivity = activity;
        break;
      }
    }
    
    // ===== LOCATIONS (30+ places) =====
    const locations = {
      home: ['home', 'house', 'apartment', 'room', 'living room', 'couch', 'sofa', 'staying in'],
      bedroom: ['bedroom', 'bed', 'bedroom vibes'],
      bathroom: ['bathroom', 'mirror', 'restroom'],
      kitchen: ['kitchen', 'counter', 'stove', 'oven'],
      office: ['office', 'desk', 'cubicle', 'workspace', 'conference room', 'meeting room', 'work'],
      gym: ['gym', 'fitness center', 'weight room', 'locker room'],
      outdoor: ['outside', 'outdoor', 'outdoors', 'fresh air'],
      park: ['park', 'playground', 'green space'],
      beach: ['beach', 'shore', 'sand', 'ocean', 'sea', 'waves', 'coastline'],
      mountains: ['mountain', 'mountains', 'peak', 'summit', 'trail', 'hike'],
      car: ['car', 'vehicle', 'driving', 'front seat', 'back seat'],
      restaurant: ['restaurant', 'diner', 'eatery', 'bistro'],
      cafe: ['cafe', 'coffee shop', 'cafÃ©', 'coffeehouse', 'starbucks'],
      bar: ['bar', 'pub', 'tavern', 'lounge', 'club', 'nightclub'],
      airport: ['airport', 'terminal', 'gate', 'flight', 'plane', 'airplane'],
      hotel: ['hotel', 'resort', 'motel', 'inn', 'room service'],
      mall: ['mall', 'shopping center', 'store', 'retail'],
      library: ['library', 'bookstore', 'book shop'],
      hospital: ['hospital', 'clinic', 'doctor', 'medical'],
      school: ['school', 'university', 'college', 'campus', 'class', 'classroom'],
      pool: ['pool', 'swimming pool', 'poolside'],
      elevator: ['elevator', 'lift'],
      parking: ['parking lot', 'parking garage', 'garage'],
      subway: ['subway', 'train', 'metro', 'station'],
      rooftop: ['rooftop', 'roof', 'terrace'],
      balcony: ['balcony', 'patio', 'deck'],
      garden: ['garden', 'backyard', 'yard'],
      forest: ['forest', 'woods', 'trees', 'nature'],
      city: ['city', 'downtown', 'urban', 'skyline', 'street'],
      countryside: ['countryside', 'rural', 'farm', 'field']
    };
    
    let detectedLocation = null;
    for (const [location, keywords] of Object.entries(locations)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedLocation = location;
        break;
      }
    }
    
    // ===== TIME OF DAY =====
    const timeOfDay = {
      morning: ['morning', 'breakfast', 'sunrise', 'dawn', 'am', 'woke up', 'wake up'],
      afternoon: ['afternoon', 'lunch', 'midday', 'noon'],
      evening: ['evening', 'dinner', 'sunset', 'dusk', 'pm'],
      night: ['night', 'nighttime', 'late night', 'midnight', 'dark'],
      latenight: ['late', '2am', '3am', '4am', 'can\'t sleep', 'insomnia']
    };
    
    let detectedTimeOfDay = null;
    for (const [time, keywords] of Object.entries(timeOfDay)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedTimeOfDay = time;
        break;
      }
    }
    
    // ===== WEATHER =====
    const weather = {
      sunny: ['sunny', 'sun', 'sunshine', 'bright', 'clear', 'beautiful day'],
      rainy: ['rain', 'raining', 'rainy', 'wet', 'umbrella', 'drizzle', 'storm', 'stormy'],
      snowy: ['snow', 'snowing', 'snowy', 'winter', 'cold', 'freezing', 'ice'],
      cloudy: ['cloudy', 'overcast', 'gray', 'grey', 'gloomy'],
      hot: ['hot', 'heat', 'sweat', 'humid', 'melting'],
      windy: ['windy', 'wind', 'breezy', 'breeze']
    };
    
    let detectedWeather = null;
    for (const [condition, keywords] of Object.entries(weather)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedWeather = condition;
        break;
      }
    }
    
    // ===== CLOTHING & STYLE =====
    const clothing = {
      casual: ['casual', 'comfy', 'comfortable', 'sweats', 'hoodie', 'jeans', 't-shirt', 'tshirt'],
      formal: ['formal', 'dress', 'suit', 'tie', 'heels', 'blazer', 'professional'],
      athletic: ['athletic', 'workout clothes', 'gym clothes', 'activewear', 'leggings', 'sports bra', 'tank'],
      pajamas: ['pajamas', 'pjs', 'pj', 'sleepwear', 'nightgown'],
      swimwear: ['swimsuit', 'bikini', 'swimwear', 'bathing suit', 'trunks'],
      cozy: ['cozy', 'cosy', 'fuzzy', 'blanket', 'warm']
    };
    
    let detectedClothing = null;
    for (const [style, keywords] of Object.entries(clothing)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedClothing = style;
        break;
      }
    }
    
    // ===== LIGHTING & AESTHETIC =====
    const lighting = {
      golden_hour: ['golden hour', 'sunset', 'sunrise', 'magic hour'],
      natural: ['natural light', 'daylight', 'sunlight'],
      dark: ['dark', 'darkness', 'dim', 'shadow', 'shadows'],
      bright: ['bright', 'well lit', 'flash'],
      moody: ['moody', 'dramatic', 'noir', 'cinematic'],
      soft: ['soft', 'gentle', 'warm', 'ambient']
    };
    
    let detectedLighting = null;
    for (const [light, keywords] of Object.entries(lighting)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedLighting = light;
        break;
      }
    }
    
    // ===== SOCIAL CONTEXT =====
    const socialContext = {
      alone: ['alone', 'solo', 'by myself', 'me time', 'solo'],
      with_friends: ['friends', 'squad', 'crew', 'gang', 'besties', 'bff'],
      with_partner: ['boyfriend', 'girlfriend', 'partner', 'bae', 'boo', 'date'],
      with_coworkers: ['coworker', 'colleague', 'team', 'work friend'],
      with_family: ['family', 'mom', 'dad', 'sister', 'brother', 'parents']
    };
    
    let detectedSocialContext = null;
    for (const [context, keywords] of Object.entries(socialContext)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedSocialContext = context;
        break;
      }
    }
    
    // ===== OBJECTS & ITEMS =====
    const objects = {
      phone: ['phone', 'iphone', 'android', 'mobile', 'cell'],
      laptop: ['laptop', 'computer', 'macbook', 'pc'],
      book: ['book', 'novel', 'reading'],
      headphones: ['headphones', 'earbuds', 'airpods', 'music'],
      sunglasses: ['sunglasses', 'shades'],
      hat: ['hat', 'cap', 'beanie'],
      bag: ['bag', 'purse', 'backpack', 'tote']
    };
    
    let detectedObject = null;
    for (const [obj, keywords] of Object.entries(objects)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedObject = obj;
        break;
      }
    }
    
    // ===== SEASON =====
    const season = {
      spring: ['spring', 'springtime', 'bloom', 'flowers'],
      summer: ['summer', 'summertime', 'hot', 'beach season'],
      fall: ['fall', 'autumn', 'leaves', 'pumpkin', 'halloween'],
      winter: ['winter', 'wintertime', 'snow', 'cold', 'holiday', 'christmas']
    };
    
    let detectedSeason = null;
    for (const [s, keywords] of Object.entries(season)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedSeason = s;
        break;
      }
    }
    
    // ===== BODY LANGUAGE & POSES =====
    const pose = {
      sitting: ['sitting', 'sit', 'seated', 'chair'],
      standing: ['standing', 'stand'],
      lying: ['lying', 'laying', 'lay down', 'horizontal'],
      leaning: ['lean', 'leaning'],
      walking: ['walking', 'walk'],
      looking_back: ['looking back', 'over shoulder', 'glance back']
    };
    
    let detectedPose = null;
    for (const [p, keywords] of Object.entries(pose)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedPose = p;
        break;
      }
    }
    
    // ===== EXTRACT SPECIFIC DETAILS (cities, landmarks, unique features) =====
    // This captures custom details that aren't in our predefined categories
    const specificDetails = [];
    
    // Famous cities/places
    const cities = ['tokyo', 'kyoto', 'paris', 'london', 'rome', 'barcelona', 'amsterdam', 'berlin', 'prague', 'vienna', 'venice', 'florence', 'milan', 'athens', 'santorini', 'mykonos', 'bali', 'phuket', 'bangkok', 'singapore', 'hong kong', 'seoul', 'beijing', 'shanghai', 'dubai', 'istanbul', 'cairo', 'marrakech', 'cape town', 'sydney', 'melbourne', 'auckland', 'fiji', 'hawaii', 'maui', 'oahu', 'tahiti', 'bora bora', 'maldives', 'seychelles', 'mauritius', 'bali', 'cancun', 'cabo', 'tulum', 'playa del carmen', 'costa rica', 'jamaica', 'bahamas', 'aruba', 'new york', 'nyc', 'manhattan', 'brooklyn', 'los angeles', 'la', 'hollywood', 'malibu', 'san francisco', 'miami', 'vegas', 'las vegas', 'chicago', 'boston', 'seattle', 'portland', 'austin', 'nashville', 'new orleans', 'montreal', 'toronto', 'vancouver', 'whistler', 'mexico city', 'buenos aires', 'rio', 'sao paulo', 'lima', 'santiago', 'bogota', 'cartagena', 'havana', 'lisboa', 'lisbon', 'porto', 'madrid', 'seville', 'ibiza', 'mallorca', 'valencia', 'geneva', 'zurich', 'lucerne', 'copenhagen', 'stockholm', 'oslo', 'helsinki', 'reykjavik', 'iceland', 'dublin', 'edinburgh', 'glasgow', 'belfast', 'budapest', 'krakow', 'warsaw', 'dubrovnik', 'split', 'zagreb', 'bucharest', 'sofia', 'belgrade', 'tel aviv', 'jerusalem', 'petra', 'dubai', 'abu dhabi', 'doha', 'muscat', 'mumbai', 'delhi', 'jaipur', 'agra', 'goa', 'kathmandu', 'pokhara', 'colombo', 'manila', 'hanoi', 'ho chi minh', 'siem reap', 'angkor', 'luang prabang', 'yangon', 'bagan', 'kuala lumpur', 'penang', 'langkawi', 'jakarta', 'ubud', 'queenstown', 'rotorua', 'perth', 'brisbane', 'gold coast', 'cairns', 'great barrier reef'];
    cities.forEach(city => {
      if (lower.includes(city)) specificDetails.push(city);
    });
    
    // Unique features (bamboo, cherry blossoms, etc.)
    const features = ['bamboo', 'cherry blossom', 'cherry blossoms', 'sakura', 'palm tree', 'palm trees', 'coconut tree', 'pine tree', 'redwood', 'sequoia', 'cactus', 'desert', 'dunes', 'sand dunes', 'waterfall', 'volcano', 'geyser', 'hot springs', 'aurora', 'northern lights', 'southern lights', 'milky way', 'stars', 'starry sky', 'full moon', 'sunset', 'sunrise', 'rainbow', 'double rainbow', 'lighthouse', 'windmill', 'windmills', 'castle', 'temple', 'shrine', 'pagoda', 'mosque', 'cathedral', 'church', 'monastery', 'ruins', 'ancient', 'colosseum', 'eiffel tower', 'big ben', 'statue of liberty', 'golden gate', 'brooklyn bridge', 'times square', 'central park', 'taj mahal', 'great wall', 'pyramids', 'sphinx', 'acropolis', 'parthenon', 'stonehenge', 'machu picchu', 'christ the redeemer', 'sugarloaf mountain', 'mount fuji', 'mount everest', 'kilimanjaro', 'matterhorn', 'swiss alps', 'rocky mountains', 'andes', 'himalayas', 'grand canyon', 'yosemite', 'yellowstone', 'zion', 'bryce canyon', 'glacier', 'fjord', 'fjords', 'iceberg', 'ice cave', 'blue lagoon', 'cenote', 'cave', 'cavern', 'grotto', 'canyon', 'valley', 'meadow', 'prairie', 'savanna', 'jungle', 'rainforest', 'mangrove', 'coral reef', 'kelp forest', 'vineyard', 'winery', 'lavender field', 'tulip field', 'sunflower field', 'rice paddy', 'terraces', 'rice terraces', 'tea plantation', 'coffee farm', 'olive grove', 'orchard', 'botanical garden', 'japanese garden', 'zen garden', 'rooftop', 'skyline', 'skyscraper', 'penthouse', 'balcony', 'terrace', 'patio', 'deck', 'pier', 'dock', 'marina', 'harbor', 'port', 'boardwalk', 'promenade', 'cobblestone', 'alley', 'alleyway', 'street art', 'mural', 'graffiti', 'neon lights', 'neon signs', 'lanterns', 'fairy lights', 'string lights', 'christmas lights', 'fireworks', 'bonfire', 'campfire', 'fire pit'];
    features.forEach(feature => {
      if (lower.includes(feature)) specificDetails.push(feature);
    });
    
    // Activities with specific details
    const specificActivities = ['dance party', 'dancing party', 'coding session', 'coding marathon', 'coding', 'hackathon', 'photoshoot', 'photo shoot', 'wine tasting', 'beer tasting', 'brunch', 'dinner party', 'house party', 'rooftop party', 'pool party', 'beach party', 'bbq party', 'birthday party', 'karaoke', 'trivia night', 'game night', 'movie night', 'girls night', 'boys night', 'date night', 'spa day', 'beach day', 'snow day', 'road trip', 'camping trip', 'backpacking', 'glamping', 'safari', 'cruise', 'boat trip', 'yacht', 'sailing', 'snorkeling', 'scuba diving', 'surfing', 'paddleboarding', 'kayaking', 'rafting', 'zip lining', 'rock climbing', 'bouldering', 'skiing', 'snowboarding', 'ice skating', 'sledding', 'tubing', 'parasailing', 'skydiving', 'bungee jumping', 'hot air balloon', 'helicopter ride', 'scenic flight'];
    specificActivities.forEach(activity => {
      if (lower.includes(activity)) specificDetails.push(activity);
    });
    
    return {
      food: detectedFood,
      mood: detectedMood,
      activity: detectedActivity,
      location: detectedLocation,
      timeOfDay: detectedTimeOfDay,
      weather: detectedWeather,
      clothing: detectedClothing,
      lighting: detectedLighting,
      socialContext: detectedSocialContext,
      object: detectedObject,
      season: detectedSeason,
      pose: detectedPose,
      specificDetails: specificDetails.length > 0 ? specificDetails : null,
      rawCaption: caption // Pass full caption for AI context
    };
  }

  /**
   * Generate image prompt for visual posts
   * NOW WITH CAPTION ANALYSIS FOR PERFECT CONTINUITY!
   */
  async function generateImagePrompt(employee, postType, postCaption, context = null) {
    const personality = employee.personality || {};
    
    // Get consistent physical description for THIS employee
    const physicalDesc = getPhysicalDescriptionForPrompt(employee);
    
    // ===== NEW: AI-POWERED IMAGE PROMPT GENERATION =====
    // Use AI to intelligently generate image prompt based on full context
    
    // Only include chat context for explicit/thirst_trap posts or boss-requested posts
    let chatContextForImage = '';
    let bossRequestContext = '';
    
    const shouldIncludeContext = postType === 'explicit' || postType === 'thirst_trap' || context?.requestedByBoss;
    
    if (shouldIncludeContext) {
      // Get recent chat context if available
      const chatHistory = gameState.chatHistory[employee.id] || [];
      const twoHoursAgo = Date.now() - (2 * 60 * 60 * 1000);
      const recentChats = chatHistory
        .filter(msg => (msg.timestamp || 0) > twoHoursAgo)
        .slice(-5); // Last 5 messages within 2 hours
      
      if (recentChats.length >= 2) {
        const recentMessages = recentChats.slice(-3).map(msg => `${msg.sender}: "${msg.content}"`).join('\n');
        chatContextForImage = `\n\nRECENT CONVERSATION WITH BOSS:\n${recentMessages}\n(Consider if the post is responding to or related to this conversation)`;
      }
      
      // Check if this was a boss-requested post
      if (context?.requestedByBoss) {
        bossRequestContext = `\n\nBOSS REQUESTED THIS POST: The boss specifically asked for this type of post${context.requestContext ? `: "${context.requestContext}"` : ''}. The image should fulfill their request.`;
      }
    }
    
    // Build AI prompt for image generation
    const imagePromptGenerationPrompt = `You are creating an image prompt for a social media post.

EMPLOYEE PHYSICAL DESCRIPTION:
${physicalDesc}

POST TYPE: ${postType}
POST CAPTION: "${postCaption}"
${chatContextForImage}${bossRequestContext}

CRITICAL INSTRUCTIONS:
1. Generate a DETAILED image prompt that EXACTLY matches what the caption describes or implies
2. Use the employee's EXACT physical description (copy it verbatim - don't summarize)
3. If caption mentions specific clothing, pose, location, mood - include ALL of it
4. If caption implies nudity/explicit content, describe it explicitly (this is for adult content)
5. If caption references a conversation (like "your request"), consider recent chat context
6. Be HIGHLY SPECIFIC about pose, clothing, expression, setting, camera angle
7. For explicit posts: describe anatomy visibility in detail (use anatomical terms from physical description)
8. For Female Futa: explicitly mention BOTH penis and vagina if nude/explicit
9. For Trans characters: use their appropriate anatomy from physical description
10. Make the image and caption tell ONE COHESIVE STORY

EXAMPLES OF GOOD IMAGE PROMPTS:

Caption: "Locked door, unlocked desires... your special request delivered fresh ğŸ˜ˆ"
Type: explicit
Context: Boss requested nude photo
Image Prompt: "(Physical description) stands in front of a locked wooden door in bedroom. She is completely nude, full frontal nudity. Her (specific breast description from profile) are fully exposed, nipples visible. Her (specific genital description - both penis and vagina for futa) are on full display in an erotic showcase. Face shows passionate, teasing expression looking directly at camera. Hands on hips, confident pose. Soft bedroom lighting. NSFW explicit content for boss's private request."

Caption: "That post-workout glow though ğŸ’ª"
Type: selfie
Image Prompt: "(Physical description) taking gym mirror selfie. Wearing sports bra and leggings, slightly sweaty from workout. Face shows accomplished smile with flushed cheeks from exercise. Gym equipment visible in background. Phone in hand. Natural gym lighting. Athletic, healthy vibe."

Caption: "Coffee and chaos, the Monday mood â˜•ğŸ˜©"
Type: text/food
Image Prompt: "Close-up of artisan coffee cup on messy office desk. Laptop visible, papers scattered. Morning natural lighting through window. Cozy but slightly overwhelmed atmosphere. No person visible, focus on coffee and workspace chaos."

NOW GENERATE THE IMAGE PROMPT:
Write ONLY the detailed image prompt - no explanations, no meta-commentary:`;

    try {
      // Generate AI-powered image prompt
      let aiImagePrompt = await queuedGenerateText(imagePromptGenerationPrompt, {
        temperature: 0.8,
        max_tokens: 150,
        stopSequences: ['\n\n\n', 'Caption:', 'Example:', 'Note:', 'Remember:', '**Note', 'Type:', 'Context:', '---']
      }, `Generating image prompt for social post`);
      
      // Clean up any meta-commentary
      aiImagePrompt = aiImagePrompt.replace(/^\*\*[^*]+\*\*\s*/g, '');
      aiImagePrompt = aiImagePrompt.split(/\n\s*\(/)[0];
      aiImagePrompt = aiImagePrompt.split(/\(Note:/)[0];
      aiImagePrompt = aiImagePrompt.trim();
      
      // Validate it's not empty
      if (aiImagePrompt && aiImagePrompt.length > 20) {
        console.log(`AI-generated image prompt for ${employee.name}:`, aiImagePrompt.substring(0, 100) + '...');
        return aiImagePrompt;
      } else {
        console.warn('AI image prompt too short, falling back to template');
      }
    } catch (error) {
      console.error('AI image prompt generation failed:', error);
    }
    
    // ===== FALLBACK: Template-based system (if AI fails) =====
    const analysis = analyzeCaption(postCaption);
    
    const basePrompts = {
      selfie: [
        `${physicalDesc} taking a casual selfie, natural lighting, friendly smile, office setting`,
        `Close-up selfie of ${physicalDesc}, relaxed expression, neutral background, good lighting`,
        `${physicalDesc} taking selfie with soft smile, professional casual look, modern aesthetic`,
        `Mirror selfie of ${physicalDesc}, casual outfit, phone in hand, clean background`,
        `${physicalDesc} bathroom mirror selfie, good lighting, casual pose, modern style`,
        `Car selfie of ${physicalDesc}, golden hour lighting, windshield reflection, relaxed vibe`,
        `${physicalDesc} desk selfie, workspace visible, laptop in background, professional casual`,
        `Outdoor selfie of ${physicalDesc}, natural daylight, blurred background, genuine smile`,
        `${physicalDesc} elevator selfie, mirror reflection, going to work vibes, morning energy`,
        `Coffee shop selfie of ${physicalDesc}, drink in frame, cozy atmosphere, casual Monday mood`,
        `${physicalDesc} post-workout selfie, gym mirror, athletic wear, accomplishment glow`,
        `${physicalDesc} bedroom selfie, soft morning light, messy hair, authentic moment`,
        `${physicalDesc} lunch break selfie, restaurant background, food nearby, happy expression`,
        `Late night work selfie of ${physicalDesc}, desk lamp lighting, tired but determined look`,
        `Weekend selfie of ${physicalDesc}, casual home setting, relaxed vibe, natural smile`
      ],
      thirst_trap: [
        `Provocative photo of ${physicalDesc} in form-fitting gym attire, sports bra and leggings, toned body visible, gym mirror selfie, showing off physique, confident sexy pose`,
        `${physicalDesc} in tight dress, curves emphasized, low neckline, showing cleavage, mirror selfie, bedroom setting, seductive expression, body on display`,
        `${physicalDesc} in lingerie, lace bra and panties, bedroom mirror selfie, sensual pose, showing off body, intimate setting, confident and sexy`,
        `${physicalDesc} in bikini, beach or poolside, wet from water, body glistening, revealing swimwear, showing skin, attractive pose, summer vibes`,
        `${physicalDesc} wearing unbuttoned shirt, cleavage visible, messy hair, bedroom eyes, seductive morning look, showing skin suggestively`,
        `${physicalDesc} in tight yoga pants and crop top, cameltoe visible, toned stomach showing, gym setting, athletic but sexy, mirror selfie`,
        `${physicalDesc} in short skirt and crop top, midriff exposed, legs on display, confident pose, urban setting, showing off body`,
        `${physicalDesc} in silk robe barely covering body, cleavage visible, bare legs showing, bedroom setting, morning after vibe, sultry expression`,
        `${physicalDesc} in wet white shirt, see-through fabric, outline visible, water droplets, provocative accidental reveal aesthetic`,
        `${physicalDesc} from behind, tight pants emphasizing butt, looking over shoulder, flirty expression, showing off curves, confident pose`,
        `${physicalDesc} in sports bra only, bare midriff, athletic shorts low on hips, post-workout selfie, toned body on display, sweaty and sexy`,
        `${physicalDesc} in backless dress, bare back visible, side curves showing, elegant but provocative, looking over shoulder seductively`,
        `${physicalDesc} in low-cut top, deep cleavage visible, leaning forward, close-up angle, showing assets, bedroom eyes, flirty vibe`,
        `${physicalDesc} lying on bed in underwear, body stretched out, intimate angle, showing curves, messy bedroom hair, come-hither expression`,
        `${physicalDesc} sitting with legs spread in short skirt, inner thighs visible, provocative pose, confident expression, daring photo`
      ],
      explicit: [
        `NSFW photo of ${physicalDesc} topless, breasts exposed, hands covering nipples, bedroom setting, nude from waist up, sensual lighting, explicit content`,
        `${physicalDesc} completely nude, full frontal nudity, strategic hand placement, bedroom or bathroom, soft lighting, artistic nude photography, explicit NSFW`,
        `${physicalDesc} in transparent lingerie, nipples visible through fabric, see-through panties, body fully on display, bedroom, explicit intimate wear`,
        `${physicalDesc} topless from behind, bare back and butt visible, looking over shoulder, nude photography, sensual pose, NSFW explicit content`,
        `${physicalDesc} nude in shower, water running over naked body, wet skin glistening, intimate bathroom setting, full nudity, explicit content`,
        `${physicalDesc} on bed completely naked, lying seductively, intimate bedroom angle, full body nudity visible, explicit NSFW photography`,
        `${physicalDesc} wearing only unbuttoned shirt open exposing breasts, bare pussy visible, sitting pose, bedroom, explicit nude content`,
        `${physicalDesc} topless mirror selfie, breasts fully exposed, nipples visible, confident pose, bathroom or bedroom, explicit NSFW content`,
        `${physicalDesc} in spread eagle pose wearing nothing, full frontal nudity, lying on bed, intimate explicit angle, NSFW adult content`,
        `${physicalDesc} nude from side angle, breast and butt visible, artistic nude pose, bedroom setting, sensual lighting, explicit photography`,
        `${physicalDesc} wearing collar and nothing else, submissive kneeling pose, bedroom floor, fetish content, explicit NSFW`,
        `${physicalDesc} in bed sheets barely covering, breast peeking out, implied full nudity underneath, intimate morning scene, explicit suggestion`,
        `${physicalDesc} bent over showing bare ass, topless, looking back at camera, bedroom, explicit provocative pose, NSFW adult content`,
        `${physicalDesc} with legs spread wide in lingerie, crotch area visible, extremely revealing, bedroom, explicit sexual pose, NSFW`,
        `${physicalDesc} masturbating, hand between legs, topless, bedroom, explicit sexual content, NSFW adult photography, orgasmic expression`
      ],
      meme: [
        `Funny relatable meme image, office humor, modern internet meme style, text overlay space`,
        `Humorous workplace situation image, meme format, relatable content, funny expression`,
        `Comic-style meme about office life, funny scenario, internet humor aesthetic`,
        `Distracted boyfriend meme style, office edition, three people, dramatic pointing`,
        `Drake yes/no meme template, office scenarios, contrasting situations, clear panels`,
        `Expanding brain meme style, office productivity levels, ascending intelligence joke`,
        `This is fine dog meme, office on fire metaphor, coffee drinking, everything burning`,
        `Woman yelling at cat meme, office meeting drama, pointing and confused expressions`,
        `Two buttons sweating choice meme, work-life balance dilemma, person struggling to decide`,
        `Surprised Pikachu face, office edition, shocked reaction, yellow character, meme format`,
        `Galaxy brain meme style, office hacks, ascending ideas, space background evolution`,
        `Batman slapping Robin meme, office suggestion rejected, dramatic slap action`,
        `Change my mind meme, controversial office opinion, person at table, debate setup`,
        `Always has been meme, astronauts in space, office realization, gun pointing revelation`,
        `Is this a butterfly meme, confused person, office task misidentification, pointing gesture`,
        `Vince McMahon reaction meme, increasing excitement, office scenarios, four panel progression`,
        `Bernie Sanders sitting meme, office edition, folded arms, chair sitting, waiting mood`,
        `Roll Safe thinking meme, office life hack, pointing at head, can't fail logic`
      ],
      food: [
        `Delicious artisan coffee in ceramic mug, latte art, wooden table, morning light, cafe aesthetic`,
        `Gourmet lunch plate, colorful ingredients, restaurant presentation, overhead shot, Instagram-worthy`,
        `Mouth-watering burger and fries, golden crispy, food truck setting, casual dining vibe`,
        `Fresh sushi platter, colorful rolls, elegant presentation, Japanese restaurant, chopsticks`,
        `Steaming bowl of ramen, soft-boiled egg, green onions, noodles lifted, authentic Asian cuisine`,
        `Decadent dessert plate, chocolate cake, drizzle, fork ready, cafe setting, indulgent`,
        `Healthy breakfast bowl, acai berries, granola, fruits, colorful presentation, morning energy`,
        `Pizza slice with cheese pull, wood-fired crust, melty goodness, casual dining, shareable`,
        `Fancy cocktail with garnish, colorful drink, ice cubes, bar setting, evening vibes`,
        `Street taco plate, three tacos, authentic Mexican, lime wedge, casual food truck aesthetic`,
        `Starbucks cup on desk, laptop nearby, work setup, coffee shop vibes, productivity mood`,
        `Homemade pasta dish, fork twirling, fresh basil, rustic Italian, warm lighting`,
        `Smoothie bowl, tropical fruits, granola topping, bright colors, healthy lifestyle aesthetic`,
        `Takeout containers on desk, late night work, Chinese food, chopsticks, office grind`,
        `Avocado toast, poached egg, artisan bread, brunch aesthetic, millennial food culture`,
        `Boba tea with straw, colorful drink, pearls visible, trendy cafe, aesthetic background`,
        `Charcuterie board, cheese, meats, grapes, crackers, sharing platter, sophisticated snacking`
      ],
      travel: [
        `Beautiful beach sunset, palm trees silhouette, orange sky, vacation vibes, peaceful scene`,
        `${physicalDesc} at mountain summit, arms raised, scenic overlook, adventure achievement`,
        `Stunning city skyline at night, lights reflecting, urban exploration, travel photography`,
        `Tropical beach scene, turquoise water, white sand, paradise destination, vacation mode`,
        `${physicalDesc} at famous landmark, tourist pose, iconic background, travel memories`,
        `Airport terminal view, planes visible, travel excitement, departure board, wanderlust`,
        `Hotel room view, city skyline through window, morning coffee, business travel aesthetic`,
        `Hiking trail panorama, mountains in distance, nature path, outdoor adventure, scenic beauty`,
        `Beach footprints in sand, ocean waves, sunset lighting, peaceful moment, coastal vibes`,
        `${physicalDesc} on airplane, window seat, clouds outside, travel mood, flying high`,
        `European cobblestone street, historic buildings, charming alley, cultural exploration`,
        `Desert landscape, vast horizon, golden hour, road trip adventure, American Southwest`,
        `Ski resort view, snowy mountains, winter sports, cold weather travel, alpine scenery`,
        `Tropical poolside, resort view, palm trees, lounging, luxury vacation aesthetic`,
        `${physicalDesc} backpack on, train station, solo travel, adventure beginning, wanderlust mood`,
        `National park vista, natural wonder, dramatic landscape, outdoor exploration, bucket list`,
        `Cruise ship deck view, ocean horizon, maritime travel, luxurious journey, sea adventure`
      ],
      life_update: [
        `${physicalDesc} reading book in cozy chair, home setting, warm lighting, relaxation time`,
        `${physicalDesc} with new pet, happy cuddle, home environment, life milestone moment`,
        `Yoga mat and water bottle, fitness journey, home workout setup, healthy lifestyle`,
        `${physicalDesc} painting on canvas, art supplies, creative hobby, focused expression`,
        `New apartment empty room, moving boxes, fresh start, life transition, excited energy`,
        `${physicalDesc} playing guitar, music hobby, casual home setting, creative pursuit`,
        `Garden with growing plants, dirt hands, outdoor hobby, nature connection, satisfying growth`,
        `${physicalDesc} at graduation, cap and gown, achievement moment, proud expression`,
        `Cozy reading nook, books stacked, coffee nearby, personal space, intellectual hobby`,
        `${physicalDesc} running on trail, athletic gear, fitness goal, outdoor exercise`,
        `Home office setup, organized desk, plants, productivity space, work-from-home life`,
        `${physicalDesc} cooking in kitchen, ingredients visible, culinary hobby, domestic scene`,
        `Meditation space, cushions, candles, zen atmosphere, wellness practice, self-care`,
        `${physicalDesc} with baked goods, oven mitt, proud baker, kitchen accomplishment`,
        `Bicycle leaned against wall, outdoor adventure gear, active lifestyle, weekend plans`,
        `${physicalDesc} at pottery wheel, clay hands, craft hobby, artistic concentration`,
        `Home gym equipment, weights visible, fitness dedication, personal space, health journey`
      ]
    };
    
    // ===== CAPTION-AWARE IMAGE GENERATION =====
    let prompt = '';
    
    // FOOD POSTS - Match specific food item from caption
    if (postType === 'food' && analysis.food) {
      const foodPrompts = {
        'coffee': `Delicious artisan coffee in ceramic mug, latte art, wooden table, morning light, cafe aesthetic`,
        'burger': `Mouth-watering burger and fries, golden crispy, sesame bun, melted cheese, casual dining vibe`,
        'pizza': `Pizza slice with cheese pull, wood-fired crust, melty goodness, toppings visible, shareable`,
        'sushi': `Fresh sushi platter, colorful rolls, elegant presentation, Japanese restaurant, chopsticks, soy sauce`,
        'ramen': `Steaming bowl of ramen, soft-boiled egg, green onions, noodles lifted, authentic Asian cuisine`,
        'taco': `Street taco plate, three tacos, authentic Mexican, lime wedge, cilantro, casual food truck aesthetic`,
        'sandwich': `Delicious sandwich, layers visible, fresh ingredients, deli presentation, toasted bread`,
        'salad': `Fresh colorful salad bowl, mixed greens, vegetables, healthy presentation, fork ready`,
        'pasta': `Homemade pasta dish, fork twirling, fresh basil, parmesan cheese, rustic Italian, warm lighting`,
        'cake': `Decadent layered cake, frosting, slice cut, celebratory dessert, bakery quality`,
        'cookie': `Fresh baked cookies on plate, chocolate chips, homemade, warm and delicious`,
        'ice cream': `Ice cream scoops in bowl or cone, colorful, melting slightly, sweet treat, dessert vibes`,
        'donut': `Glazed donuts on plate, sprinkles or icing, bakery fresh, sweet breakfast treat`,
        'brownie': `Fudgy brownie squares, chocolate richness, dessert plate, indulgent treat`,
        'lemon bars': `Fresh lemon bars on a plate, powdered sugar dusted, bright yellow filling, dessert presentation`,
        'boba': `Boba tea with thick straw, colorful drink, tapioca pearls visible, trendy cafe, aesthetic background`,
        'smoothie': `Smoothie bowl, tropical fruits, granola topping, bright colors, healthy lifestyle aesthetic`,
        'breakfast': `Healthy breakfast plate, eggs, toast, bacon, morning meal, colorful presentation`,
        'pancakes': `Stack of fluffy pancakes, syrup drizzle, butter pat, breakfast perfection, morning vibes`,
        'waffles': `Belgian waffles with toppings, syrup, whipped cream, breakfast indulgence`,
        'eggs': `Perfectly cooked eggs, breakfast plate, toast, morning meal, protein-rich`,
        'bacon': `Crispy bacon strips, breakfast side, sizzling, delicious protein`,
        'toast': `Toasted bread, butter spreading, golden brown, breakfast staple`,
        'avocado toast': `Avocado toast, poached egg, artisan bread, microgreens, brunch aesthetic, millennial food culture`,
        'cereal': `Cereal bowl with milk, spoon, breakfast table, morning meal, nostalgic`,
        'cocktail': `Fancy cocktail with garnish, colorful drink, ice cubes, bar setting, evening vibes`,
        'beer': `Cold beer in glass or bottle, foam head, bar setting, relaxation drink, social vibes`,
        'wine': `Wine glass with red or white wine, elegant presentation, sophisticated drink, evening mood`,
        'tea': `Hot tea in cup, tea bag or loose leaf, steam rising, cozy drink, calming`,
        'wings': `Chicken wings plate, buffalo sauce, celery sticks, ranch dip, sports bar vibe`,
        'fries': `Golden crispy french fries, sea salt, ketchup, casual dining, shareable basket`,
        'soup': `Steaming bowl of soup, spoon ready, bread on side, comfort food, cozy presentation`,
        'steak': `Perfectly cooked steak, grill marks, sides visible, upscale dinner, meat lover's dream`,
        'chicken': `Delicious chicken dish, cooked to perfection, protein main course, satisfying meal`,
        'seafood': `Fresh seafood platter, ocean-to-table, elegant presentation, coastal cuisine`,
        'bbq': `BBQ plate with ribs or brisket, smoky char, barbecue sauce, Southern comfort food`,
        'hotdog': `Hot dog with toppings, classic American, stadium food, casual dining`,
        'popcorn': `Bowl of popcorn, movie snack, butter or seasoning, entertainment food`,
        'chips': `Bag or bowl of chips, snack food, crunchy, casual munchies`,
        'cheese': `Cheese board or charcuterie, variety of cheeses, crackers, grapes, sophisticated snacking`,
        'poke bowl': `Colorful poke bowl, fresh fish, rice, vegetables, Hawaiian cuisine, healthy bowl`,
        'curry': `Aromatic curry dish, rice, Indian spices, warm comfort food, flavorful`,
        'dim sum': `Dim sum basket, steamed dumplings, Asian cuisine, variety platter, chopsticks`,
        'bagel': `Fresh bagel with cream cheese, toasted, breakfast favorite, New York style`,
        'muffin': `Freshly baked muffins, bakery quality, breakfast pastry, warm and fluffy`,
        'croissant': `Flaky croissant, buttery pastry, French bakery, coffee companion`,
        'fruit': `Fresh fruit plate or bowl, colorful, healthy, natural sweetness, vibrant`,
        'vegetables': `Fresh vegetable plate, healthy eating, colorful produce, nutritious meal`,
        'snack': `Snack plate with variety, munchies, casual eating, satisfying treats`
      };
      
      prompt = foodPrompts[analysis.food] || `Appetizing ${analysis.food}, restaurant presentation, overhead shot, Instagram-worthy, delicious`;
      
      // Add location context to food
      if (analysis.location === 'home' || analysis.location === 'kitchen') {
        prompt += ', homemade, cozy kitchen setting';
      } else if (analysis.location === 'office') {
        prompt += ', on office desk, work lunch vibes';
      } else if (analysis.location === 'restaurant' || analysis.location === 'cafe') {
        prompt += ', restaurant setting, dining out atmosphere';
      } else if (analysis.location === 'outdoor' || analysis.location === 'park') {
        prompt += ', outdoor eating, picnic vibes, al fresco';
      }
      
      // Add time of day context
      if (analysis.timeOfDay === 'morning') {
        prompt += ', morning breakfast vibes, fresh start';
      } else if (analysis.timeOfDay === 'afternoon') {
        prompt += ', lunch time, midday meal';
      } else if (analysis.timeOfDay === 'evening' || analysis.timeOfDay === 'night') {
        prompt += ', dinner setting, evening meal';
      } else if (analysis.timeOfDay === 'latenight') {
        prompt += ', late night snack, midnight munchies';
      }
      
      // Add mood context
      if (analysis.mood === 'happy' || analysis.mood === 'excited') {
        prompt += ', joyful eating moment, satisfying';
      } else if (analysis.mood === 'stressed') {
        prompt += ', comfort food, stress eating, needed this';
      } else if (analysis.mood === 'hungover') {
        prompt += ', hangover cure, recovery food';
      }
      
      // Add social context
      if (analysis.socialContext === 'with_friends') {
        prompt += ', shared meal, group dining, social eating';
      } else if (analysis.socialContext === 'alone') {
        prompt += ', solo meal, treating myself';
      }
    }
    
    // SELFIE POSTS - Match mood from caption
    else if (postType === 'selfie') {
      const moodModifiers = {
        tired: 'tired expression, dark circles, exhausted but authentic',
        happy: 'genuine big smile, happy eyes, joyful energy',
        confident: 'confident expression, direct eye contact, powerful presence',
        flirty: 'playful smile, flirtatious gaze, knowing look',
        stressed: 'stressed expression, messy hair, overwhelmed but coping',
        relaxed: 'relaxed expression, peaceful vibe, calm energy',
        sad: 'sad expression, vulnerable moment, emotional',
        angry: 'frustrated expression, intense gaze, strong emotion',
        silly: 'goofy expression, funny face, playful energy',
        proud: 'proud smile, accomplished look, confident stance',
        bored: 'bored expression, unamused face, whatever mood',
        hungover: 'hungover look, messy hair, regretful expression, sunglasses indoors',
        motivated: 'determined expression, focused energy, driven look',
        romantic: 'soft romantic expression, dreamy eyes, gentle smile',
        mysterious: 'mysterious gaze, enigmatic expression, subtle smile',
        sassy: 'sassy expression, attitude, side-eye, confident smirk'
      };
      
      const locationModifiers = {
        home: 'casual home setting, relaxed vibe',
        bedroom: 'bedroom setting, soft morning light, authentic moment',
        bathroom: 'bathroom mirror selfie, good lighting, casual pose',
        kitchen: 'kitchen background, casual home vibe',
        office: 'office setting, professional casual, desk visible',
        gym: 'gym mirror, athletic wear, post-workout glow',
        car: 'car selfie, windshield reflection, driving vibes',
        outdoor: 'outdoor setting, natural daylight, fresh air',
        park: 'park background, nature setting, green scenery',
        beach: 'beach setting, ocean background, vacation vibes',
        cafe: 'coffee shop background, cozy atmosphere, casual vibe',
        bar: 'bar or club setting, nightlife energy, dim lighting',
        airport: 'airport terminal, travel mode, wanderlust energy',
        hotel: 'hotel room, travel vibes, away from home',
        mall: 'shopping mall background, retail therapy mood',
        elevator: 'elevator mirror selfie, going to work vibes',
        parking: 'parking lot background, casual outdoor setting',
        rooftop: 'rooftop view, city background, elevated perspective',
        balcony: 'balcony background, outdoor home space'
      };
      
      const activityModifiers = {
        workout: 'post-workout selfie, gym mirror, athletic wear, accomplishment glow, sweaty',
        yoga: 'post-yoga selfie, zen energy, workout mat visible, peaceful',
        work: 'desk selfie, workspace visible, laptop in background, professional casual',
        dancing: 'mid-dance energy, movement blur, party vibes',
        shopping: 'shopping bags visible, retail therapy energy, store background',
        grooming: 'fresh after shower, clean look, getting ready vibes',
        selfcare: 'spa day vibes, face mask, pampered look, relaxation mode',
        pets: 'selfie with pet, cuddles, animal in frame, wholesome',
        celebration: 'celebration energy, party mode, festive atmosphere'
      };
      
      const timeModifiers = {
        morning: 'morning light, sunrise glow, fresh day energy',
        afternoon: 'midday lighting, bright natural light',
        evening: 'golden hour lighting, warm sunset tones',
        night: 'evening lighting, night vibes, darker atmosphere',
        latenight: 'late night lighting, desk lamp or dim light, tired but awake'
      };
      
      const weatherModifiers = {
        sunny: 'bright sunny day, clear skies, natural sunlight',
        rainy: 'rainy day vibes, window droplets visible, cozy indoors',
        snowy: 'snowy weather, winter vibes, cold weather gear',
        hot: 'hot weather, summer vibes, dealing with heat'
      };
      
      const clothingModifiers = {
        casual: 'casual comfy outfit, relaxed style',
        formal: 'formal dressed up outfit, professional look',
        athletic: 'athletic wear, gym clothes, sporty style',
        pajamas: 'pajamas or sleepwear, cozy home mode',
        swimwear: 'swimsuit or beach wear, vacation mode',
        cozy: 'cozy outfit, blanket visible, warm and comfortable'
      };
      
      const socialModifiers = {
        alone: 'solo selfie, personal moment',
        with_friends: 'with friends in background, group vibes',
        with_partner: 'couple selfie, romantic moment',
        with_coworkers: 'with coworkers, team moment',
        with_family: 'family in frame, wholesome moment'
      };
      
      // Start with base
      prompt = `${physicalDesc} taking a selfie`;
      
      // Add activity-specific context (highest priority)
      if (analysis.activity && activityModifiers[analysis.activity]) {
        prompt = `${physicalDesc} ${activityModifiers[analysis.activity]}`;
      }
      // Or location
      else if (analysis.location && locationModifiers[analysis.location]) {
        prompt += `, ${locationModifiers[analysis.location]}`;
      } else {
        prompt += ', natural lighting';
      }
      
      // Add time of day
      if (analysis.timeOfDay && timeModifiers[analysis.timeOfDay]) {
        prompt += `, ${timeModifiers[analysis.timeOfDay]}`;
      }
      
      // Add weather context
      if (analysis.weather && weatherModifiers[analysis.weather]) {
        prompt += `, ${weatherModifiers[analysis.weather]}`;
      }
      
      // Add clothing style
      if (analysis.clothing && clothingModifiers[analysis.clothing]) {
        prompt += `, ${clothingModifiers[analysis.clothing]}`;
      }
      
      // Add social context
      if (analysis.socialContext && socialModifiers[analysis.socialContext]) {
        prompt += `, ${socialModifiers[analysis.socialContext]}`;
      }
      
      // Add mood (very important!)
      if (analysis.mood !== 'neutral' && moodModifiers[analysis.mood]) {
        prompt += `, ${moodModifiers[analysis.mood]}`;
      } else {
        prompt += `, friendly smile, genuine expression`;
      }
      
      // Add lighting aesthetic if specified
      if (analysis.lighting) {
        const lightMap = {
          'golden_hour': 'golden hour lighting, warm sunset glow',
          'natural': 'natural lighting, soft daylight',
          'dark': 'dark moody lighting, dramatic shadows',
          'bright': 'bright well-lit, clear visibility',
          'moody': 'moody dramatic lighting, cinematic feel',
          'soft': 'soft ambient lighting, gentle glow'
        };
        if (lightMap[analysis.lighting]) {
          prompt += `, ${lightMap[analysis.lighting]}`;
        }
      }
      
      // Add pose if mentioned
      if (analysis.pose) {
        const poseMap = {
          'sitting': 'sitting pose, seated position',
          'standing': 'standing pose',
          'lying': 'lying down, horizontal position',
          'leaning': 'leaning pose, casual lean',
          'looking_back': 'looking over shoulder, glance back'
        };
        if (poseMap[analysis.pose]) {
          prompt += `, ${poseMap[analysis.pose]}`;
        }
      }
    }
    
    // THIRST TRAP - Match mood, location, clothing, and confidence level
    else if (postType === 'thirst_trap') {
      const flirtyLevel = personality.flirty || 50;
      let baseDesc = flirtyLevel > 70 
        ? `${physicalDesc} in stylish form-fitting outfit, seductive pose, confident allure`
        : `${physicalDesc} in fashionable outfit, attractive pose, subtle confidence`;
      
      // Location-specific thirst traps
      if (analysis.location === 'gym') {
        baseDesc = `${physicalDesc} in gym clothes, athletic build, form-fitting activewear, mirror selfie, confident pose`;
      } else if (analysis.location === 'office') {
        baseDesc = `${physicalDesc} in fitted business attire, powerful stance, office setting, professional sexy`;
      } else if (analysis.location === 'bedroom') {
        baseDesc = `${physicalDesc} in bedroom setting, intimate casual outfit, soft lighting, confident allure`;
      } else if (analysis.location === 'bathroom') {
        baseDesc = `${physicalDesc} bathroom mirror shot, form-fitting outfit, confident expression, modern aesthetic`;
      } else if (analysis.location === 'car') {
        baseDesc = `${physicalDesc} in car, hand on steering wheel or door, confident cool pose, attractive lighting`;
      } else if (analysis.location === 'outdoor' || analysis.location === 'beach') {
        baseDesc = `${physicalDesc} outdoor setting, natural background, attractive casual pose, golden hour vibes`;
      }
      
      // Clothing-specific adjustments
      if (analysis.clothing === 'athletic') {
        baseDesc = `${physicalDesc} in athletic wear, fit body showcase, gym aesthetic, sporty confidence`;
      } else if (analysis.clothing === 'formal') {
        baseDesc = `${physicalDesc} in elegant formal outfit, sophisticated sexy, dressed to impress, stylish`;
      } else if (analysis.clothing === 'swimwear') {
        baseDesc = `${physicalDesc} in swimwear, beach body confidence, summer vibes, attractive pose`;
      }
      
      // Mood modifications
      const moodAdd = analysis.mood === 'confident' 
        ? ', powerful stance, direct gaze, commanding presence'
        : analysis.mood === 'flirty' 
        ? ', playful seductive expression, knowing smile'
        : analysis.mood === 'sassy'
        ? ', attitude, side glance, confident smirk'
        : ', flattering lighting, stylish aesthetic';
      
      prompt = baseDesc + moodAdd;
      
      // Time of day lighting
      if (analysis.timeOfDay === 'evening' || analysis.lighting === 'golden_hour') {
        prompt += ', golden hour lighting, warm sunset tones';
      } else if (analysis.timeOfDay === 'night') {
        prompt += ', evening lighting, sultry night vibes';
      }
    }
    
    // EXPLICIT - Match caption's suggestiveness, location, and mood
    else if (postType === 'explicit') {
      let explicitPrompts = [
        `Suggestive photo of ${physicalDesc}, intimate lighting, alluring expression, tasteful composition`,
        `${physicalDesc} in revealing outfit, seductive pose, dim romantic lighting, artistic sensuality`,
        `Sultry portrait of ${physicalDesc}, provocative pose, sensual atmosphere, artistic`,
        `${physicalDesc} in silk robe, intimate moment, soft lighting, artistic boudoir style`,
        `Artistic intimate shot of ${physicalDesc}, dramatic shadows, alluring gaze, sensual mood`,
        `${physicalDesc} in lace outfit, romantic lighting, seductive expression, classy provocation`
      ];
      
      // Location-specific explicit content
      if (analysis.location === 'bedroom' || analysis.location === 'home') {
        prompt = `${physicalDesc} bedroom setting, intimate outfit, soft lighting, seductive pose, private moment`;
      } else if (analysis.location === 'bathroom') {
        prompt = `${physicalDesc} bathroom setting, steam or soft lighting, intimate moment, artistic sensuality`;
      } else if (analysis.location === 'office') {
        prompt = `${physicalDesc} in after-hours office, loosened professional clothing, suggestive pose, dramatic lighting`;
      } else {
        prompt = explicitPrompts[Math.floor(Math.random() * explicitPrompts.length)];
      }
      
      // Add flirty/mood emphasis
      if (analysis.mood === 'flirty') {
        prompt += ', extra seductive energy, provocative gaze';
      } else if (analysis.mood === 'confident') {
        prompt += ', bold confident sexuality, powerful allure';
      }
      
      // Time/lighting adjustments
      if (analysis.timeOfDay === 'night' || analysis.timeOfDay === 'latenight') {
        prompt += ', night time intimacy, dim ambient lighting';
      } else if (analysis.lighting === 'moody') {
        prompt += ', moody dramatic lighting, artistic shadows';
      }
    }
    
    // MEME POSTS - Use generic meme templates (captions are the content)
    else if (postType === 'meme') {
      const memePrompts = basePrompts.meme;
      prompt = memePrompts[Math.floor(Math.random() * memePrompts.length)];
    }
    
    // TRAVEL POSTS - Match activity/location/weather from caption + SPECIFIC DETAILS!
    else if (postType === 'travel') {
      // PRIORITY 1: Use specific details from caption (cities, landmarks, features)
      if (analysis.specificDetails && analysis.specificDetails.length > 0) {
        const detail = analysis.specificDetails[0]; // Use first specific detail
        
        // Famous cities
        if (['tokyo', 'kyoto', 'paris', 'london', 'rome', 'barcelona', 'amsterdam', 'berlin', 'dubai', 'bali', 'santorini', 'venice', 'new york', 'nyc', 'manhattan', 'los angeles', 'miami', 'vegas', 'hawaii', 'iceland', 'maldives'].includes(detail)) {
          prompt = `Beautiful scenic view of ${detail}, iconic travel destination, stunning photography`;
          // Add specific features if mentioned
          if (analysis.specificDetails.includes('bamboo')) prompt = `Bamboo forest in ${detail}, tall bamboo trees, serene green path, asian travel aesthetic`;
          else if (analysis.specificDetails.includes('cherry blossom')) prompt = `Cherry blossoms in ${detail}, pink sakura trees, springtime beauty, japanese aesthetic`;
          else if (analysis.specificDetails.includes('temple')) prompt = `Ancient temple in ${detail}, cultural landmark, travel photography, architectural beauty`;
          else if (analysis.specificDetails.includes('beach')) prompt = `Beach paradise in ${detail}, turquoise water, tropical vacation, stunning coastal view`;
          else if (analysis.specificDetails.includes('mountains')) prompt = `Mountain view in ${detail}, scenic peaks, alpine landscape, adventure travel`;
          else if (analysis.specificDetails.includes('skyline')) prompt = `City skyline of ${detail}, urban landscape, metropolitan beauty, travel photography`;
          else if (analysis.timeOfDay === 'night') prompt += ', nighttime city lights, illuminated beauty';
          else if (analysis.weather === 'sunny') prompt += ', bright sunny day, clear blue skies';
        }
        // Unique features (bamboo, cherry blossoms, waterfalls, etc.)
        else if (['bamboo', 'cherry blossom', 'waterfall', 'volcano', 'aurora', 'northern lights', 'castle', 'temple', 'shrine', 'pagoda', 'lighthouse', 'windmill', 'ruins', 'pyramids', 'taj mahal', 'eiffel tower', 'colosseum', 'mount fuji', 'grand canyon'].includes(detail)) {
          prompt = `Stunning ${detail} view, travel destination, breathtaking scenery, wanderlust photography`;
          if (detail === 'bamboo') prompt = `Bamboo forest, tall green bamboo trees lining path, serene peaceful atmosphere, asian travel aesthetic, natural beauty`;
          else if (detail === 'cherry blossom') prompt = `Cherry blossom trees in full bloom, pink sakura petals, springtime beauty, japanese aesthetic, magical scene`;
          else if (detail === 'waterfall') prompt = `Majestic waterfall, cascading water, lush greenery, nature paradise, adventure travel`;
          else if (detail === 'aurora' || detail === 'northern lights') prompt = `Aurora borealis dancing in night sky, northern lights, colorful sky phenomenon, arctic beauty`;
          else if (detail === 'castle') prompt = `Ancient castle, medieval architecture, historical landmark, european travel, fairytale aesthetic`;
          else if (detail === 'temple' || detail === 'shrine') prompt = `Sacred temple, ornate architecture, cultural heritage, spiritual destination, travel photography`;
          else if (detail === 'lighthouse') prompt = `Coastal lighthouse, ocean view, maritime charm, seaside travel, scenic beauty`;
          else if (detail === 'volcano') prompt = `Active volcano, dramatic landscape, adventure travel, powerful nature, unique destination`;
          else if (detail === 'ruins') prompt = `Ancient ruins, historical site, archaeological wonder, travel exploration, timeless beauty`;
        }
        // Specific activities
        else if (['safari', 'cruise', 'yacht', 'snorkeling', 'scuba diving', 'skiing', 'snowboarding', 'hot air balloon', 'helicopter ride'].includes(detail)) {
          if (detail === 'safari') prompt = `Safari adventure, wildlife viewing, african landscape, jeep tour, nature exploration`;
          else if (detail === 'cruise' || detail === 'yacht') prompt = `Luxury cruise/yacht, ocean view, deck relaxation, maritime travel, vacation vibes`;
          else if (detail === 'snorkeling' || detail === 'scuba diving') prompt = `Underwater adventure, tropical reef, marine life, diving/snorkeling, aquatic beauty`;
          else if (detail === 'skiing' || detail === 'snowboarding') prompt = `Ski resort, snowy slopes, winter sports, mountain adventure, alpine scenery`;
          else if (detail === 'hot air balloon') prompt = `Hot air balloon ride, aerial view, floating above landscape, sunrise/sunset adventure`;
          else if (detail === 'helicopter ride') prompt = `Helicopter tour, aerial photography, bird's eye view, scenic flight, adventure travel`;
        }
      }
      // PRIORITY 2: Activity-based travel
      else if (analysis.activity === 'workout' || analysis.activity === 'hiking') {
        prompt = `${physicalDesc} on hiking trail, athletic gear, nature adventure, scenic mountain vista`;
      } else if (analysis.activity === 'swimming') {
        prompt = `${physicalDesc} at pool or beach, swimming, tropical water, vacation mode`;
      }
      // PRIORITY 3: Location-based travel
      else if (analysis.location === 'beach') {
        prompt = `Beautiful beach scene, turquoise water, white sand, palm trees, paradise destination, vacation vibes`;
        if (analysis.weather === 'sunny') prompt += ', bright sunny day, clear blue skies';
      } else if (analysis.location === 'mountains') {
        prompt = `${physicalDesc} at mountain summit, scenic overlook, dramatic peaks, adventure achievement`;
        if (analysis.weather === 'snowy') prompt += ', snow-covered peaks, winter wonderland';
      } else if (analysis.location === 'airport') {
        prompt = `Airport terminal view, planes visible, departure board, travel excitement, wanderlust`;
      } else if (analysis.location === 'hotel') {
        prompt = `Hotel room view, city skyline through window, travel vibes, vacation accommodation`;
      } else if (analysis.location === 'city') {
        prompt = `Stunning city skyline, urban exploration, city lights, travel photography, metropolitan vibes`;
        if (analysis.timeOfDay === 'night') prompt += ', nighttime city lights, illuminated buildings';
      } else if (analysis.location === 'forest') {
        // Check for bamboo specifically in raw caption
        if (analysis.rawCaption && analysis.rawCaption.toLowerCase().includes('bamboo')) {
          prompt = `Bamboo forest, tall green bamboo trees lining path, serene peaceful atmosphere, asian travel aesthetic, natural beauty`;
        } else {
          prompt = `Forest trail scene, nature path, trees, outdoor adventure, peaceful wilderness`;
        }
      } else if (analysis.location === 'countryside') {
        prompt = `Countryside landscape, rural scenery, fields, peaceful nature, escape from city`;
      }
      // Weather-based travel
      else if (analysis.weather === 'snowy') {
        prompt = `Snowy mountain scene, winter sports, ski resort view, alpine scenery, cold weather travel`;
      } else if (analysis.weather === 'sunny' && analysis.season === 'summer') {
        prompt = `Tropical beach paradise, bright sunshine, summer vacation, turquoise water, relaxation`;
      }
      // Season-based travel
      else if (analysis.season === 'fall') {
        prompt = `Autumn landscape, fall foliage, colorful leaves, scenic beauty, seasonal travel`;
      } else if (analysis.season === 'spring') {
        prompt = `Spring scenery, blooming flowers, fresh greenery, beautiful season, nature awakening`;
      }
      // Mood-based travel
      else if (analysis.mood === 'relaxed') {
        prompt = `Peaceful vacation scene, relaxation vibes, tranquil destination, stress-free moment`;
      } else if (analysis.mood === 'excited') {
        prompt = `${physicalDesc} excited at destination, arms raised, adventure energy, travel joy`;
      }
      // Default travel prompts
      else {
        const travelPrompts = basePrompts.travel;
        prompt = travelPrompts[Math.floor(Math.random() * travelPrompts.length)];
      }
    }
    
    // LIFE UPDATE - Match activity, mood, objects from caption + SPECIFIC DETAILS!
    else if (postType === 'life_update') {
      // PRIORITY 1: Use specific activities from caption
      if (analysis.specificDetails && analysis.specificDetails.length > 0) {
        const detail = analysis.specificDetails[0];
        
        if (detail === 'dance party' || detail === 'dancing party') {
          prompt = `${physicalDesc} at dance party, dancing with friends, party lights, music vibes, energetic celebration, fun social gathering`;
          if (analysis.timeOfDay === 'night') prompt += ', nighttime party energy, colorful lights';
        } else if (detail === 'coding session' || detail === 'coding marathon' || detail === 'coding') {
          prompt = `${physicalDesc} at desk coding, laptop screen glow, programmer aesthetic, focused developer, code on screen visible, tech workspace`;
          if (analysis.timeOfDay === 'night' || detail.includes('midnight')) prompt += ', late night coding, dark room with screen glow, night owl developer energy';
        } else if (detail === 'hackathon') {
          prompt = `${physicalDesc} at hackathon event, intense coding, tech competition, developer energy, multiple screens, programming marathon`;
        } else if (detail === 'photoshoot' || detail === 'photo shoot') {
          prompt = `${physicalDesc} during photoshoot, camera equipment visible, professional lighting, model pose, photography session`;
        } else if (detail === 'wine tasting' || detail === 'beer tasting') {
          prompt = `${physicalDesc} at tasting event, wine/beer glasses, elegant setting, sophisticated social gathering, sampling drinks`;
        } else if (detail === 'brunch') {
          prompt = `${physicalDesc} at brunch, restaurant table with food and mimosas, social dining, weekend vibes, friends gathering`;
        } else if (detail === 'karaoke') {
          prompt = `${physicalDesc} singing karaoke, microphone in hand, stage lights, music performance, fun social activity`;
        } else if (detail === 'game night') {
          prompt = `Game night setup, board games or video games visible, friends gathered, snacks and drinks, fun social evening`;
        } else if (detail === 'movie night') {
          prompt = `${physicalDesc} watching movie, cozy couch setting, popcorn and drinks, screen glow, relaxation entertainment`;
        } else if (detail === 'spa day') {
          prompt = `${physicalDesc} at spa, relaxation vibes, face mask or robe, pampering session, self-care luxury, wellness treatment`;
        } else if (detail === 'road trip') {
          prompt = `${physicalDesc} on road trip, car interior view, scenic highway, adventure travel, open road vibes`;
        } else if (detail === 'camping trip' || detail === 'glamping') {
          prompt = `Camping scene, tent or glamping setup, nature outdoor, campfire visible, wilderness adventure, outdoor lifestyle`;
        } else if (detail === 'yacht' || detail === 'sailing') {
          prompt = `${physicalDesc} on yacht/sailboat, ocean water, luxury boating, nautical lifestyle, maritime adventure`;
        }
      }
      
      // PRIORITY 2: Activity-based prompts
      const activityPrompts = {
        workout: `${physicalDesc} in athletic gear, fitness journey, exercise setting, healthy lifestyle`,
        yoga: `${physicalDesc} on yoga mat, meditation space, zen energy, wellness practice`,
        cooking: `${physicalDesc} in kitchen, cooking ingredients visible, culinary hobby, proud chef moment`,
        reading: `${physicalDesc} with book in cozy chair, reading nook, warm lighting, intellectual moment`,
        gaming: `Gaming setup, controller or keyboard, screen glow, colorful RGB lights, gamer lifestyle, focused play`,
        art: `${physicalDesc} with art supplies, creative project, painting or drawing, artistic focus, canvas visible`,
        music: `${physicalDesc} with instrument, music practice, creative hobby, passionate musician`,
        dancing: `${physicalDesc} dancing, movement energy, music vibes, expressive moment`,
        shopping: `${physicalDesc} with shopping bags, retail therapy, new purchases, happy consumer`,
        cleaning: `${physicalDesc} organizing space, cleaning supplies, tidy home, productive vibes`,
        studying: `${physicalDesc} with books and laptop, studying hard, focused learning, academic dedication`,
        diy: `${physicalDesc} with tools, DIY project, building something, hands-on creativity`,
        gardening: `${physicalDesc} in garden, plants and flowers, dirt hands, outdoor hobby, nature connection`,
        pets: `${physicalDesc} with pet, cuddles and love, animal companion, wholesome moment`,
        selfcare: `${physicalDesc} spa day vibes, face mask or pampering, relaxation mode, treating self`,
        celebration: `${physicalDesc} celebrating, party decorations, achievement moment, festive energy`
      };
      
      if (analysis.activity && activityPrompts[analysis.activity]) {
        prompt = activityPrompts[analysis.activity];
      }
      // Location-based life updates
      else if (analysis.location === 'home' || analysis.location === 'bedroom') {
        prompt = `${physicalDesc} cozy at home, relaxed setting, personal space, comfortable vibes`;
        if (analysis.mood === 'relaxed') prompt += ', peaceful calm energy';
      } else if (analysis.location === 'kitchen') {
        prompt = `${physicalDesc} in kitchen, cooking or baking, domestic scene, home chef energy`;
      } else if (analysis.location === 'gym') {
        prompt = `${physicalDesc} at gym, workout equipment visible, fitness dedication, health journey`;
      }
      // Object-based life updates
      else if (analysis.object === 'book') {
        prompt = `${physicalDesc} reading book in cozy chair, home setting, warm lighting, relaxation time`;
      } else if (analysis.object === 'laptop') {
        prompt = `Home office setup, organized desk, laptop, productivity space, work-from-home life`;
      } else if (analysis.object === 'headphones') {
        prompt = `${physicalDesc} with headphones, music listening, relaxed vibes, audio enjoyment`;
      }
      // Mood-based life updates
      else if (analysis.mood === 'proud') {
        prompt = `${physicalDesc} showing off accomplishment, proud moment, achievement display, satisfied expression`;
      } else if (analysis.mood === 'motivated') {
        prompt = `${physicalDesc} motivated energy, goal-focused, determined look, hustle mode`;
      } else if (analysis.mood === 'relaxed') {
        prompt = `${physicalDesc} in relaxation mode, cozy space, calm energy, self-care moment`;
      }
      // Default life update prompts
      else {
        const lifePrompts = basePrompts.life_update;
        prompt = lifePrompts[Math.floor(Math.random() * lifePrompts.length)];
      }
    }
    
    // Fallback to original templates
    else {
      const prompts = basePrompts[postType] || basePrompts.selfie;
      prompt = prompts[Math.floor(Math.random() * prompts.length)];
    }
    
    // Add personality modifiers
    if (personality.confidence > 70 && ['selfie', 'thirst_trap'].includes(postType)) {
      prompt += ', bold confident expression';
    }
    if (personality.flirty > 70 && ['thirst_trap', 'explicit', 'selfie'].includes(postType)) {
      prompt += ', flirtatious energy';
    }
    
    return prompt;
  }
  
  /**
   * Generate autonomous comments on recent posts
   */
  async function generateAutonomousComments() {
    // Get recent posts (last 10)
    const recentPosts = gameState.socialNetwork.posts.slice(0, 10);
    if (recentPosts.length === 0) return;
    
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    // Each employee has a chance to comment on posts
    for (const employee of activeEmployees) {
      // 10% chance to comment (REDUCED FROM 20% FOR PERFORMANCE)
      if (Math.random() > 0.1) continue;
      
      // Select random post (not their own)
      const eligiblePosts = recentPosts.filter(p => 
        p.authorId !== employee.id && 
        !p.comments.some(c => c.authorId === employee.id) // Haven't commented yet
      );
      
      if (eligiblePosts.length === 0) continue;
      
      const post = eligiblePosts[Math.floor(Math.random() * eligiblePosts.length)];
      
      // Get relationship with post author
      const relationship = employee.relationships?.[post.authorId];
      const relationType = relationship?.type || 'neutral';
      
      // Generate comment based on relationship
      const commentText = await generateComment(employee, post, relationType);
      
      const comment = createComment({
        postId: post.id,
        authorId: employee.id,
        authorName: employee.name,
        content: commentText
      });
      
      post.comments.push(comment);
      
      // Small chance (15%) for viral engagement - NPC comment triggers reinvigoration
      if (post.comments.length >= 3 && Math.random() < 0.15) {
        console.log(`[Autonomous] ğŸ”¥ ${employee.name}'s comment sparked viral engagement!`);
        setTimeout(async () => {
          await triggerAdditionalNPCComments(post);
        }, 6000 + Math.random() * 8000); // 6-14 seconds delay
      }
      
      // ğŸŒ Evaluate relationship between commenter and post author
      const postAuthor = gameState.employees.find(e => e.id === post.authorId);
      
      console.log(`[Autonomous] ${employee.name} commented on ${post.isPlayerPost ? 'player' : postAuthor?.name}'s post`);
      
      if (postAuthor && postAuthor.id !== employee.id) {
        await evaluateNPCReactionToPost(employee, postAuthor, post, commentText);
      }
      
      // AGGRESSIVE FIX: Always update immediately, no visibility checks
      const postEl = document.querySelector(`[data-post-id="${post.id}"]`);
      const commentsSection = document.querySelector(`.post-comments[data-post-id="${post.id}"]`);
      
      if (postEl && commentsSection) {
        console.log(`[Autonomous] FORCE updating comments for post ${post.id}`);
        updateCommentsSection(postEl, post);
      }
      
      // Request smart feed update as backup
      requestSmartFeedUpdate(post.id);
    }
  }
  
  /**
   * Trigger targeted comments from NPCs mentioned in tea-spilling posts
   * NPCs who are called out feel compelled to respond
   */
  async function triggerTeaSpillingComments(post, author) {
    // Extract @mentions from post content using smart extraction
    const extractedMentions = extractMentions(post.content);
    
    if (extractedMentions.length === 0) return;
    
    console.log(`[Social] Tea-spilling post has ${extractedMentions.length} mentions, triggering targeted comments`);
    
    // Get mentioned employee objects
    const mentionedEmployees = extractedMentions
      .map(m => gameState.employees.find(e => e.id === m.employeeId))
      .filter(e => e && e.id !== author.id);
    
    // 70-90% chance each mentioned NPC comments (they feel called out!)
    for (let i = 0; i < mentionedEmployees.length; i++) {
      const npc = mentionedEmployees[i];
      const shouldComment = Math.random() < 0.7 + Math.random() * 0.2;
      
      if (!shouldComment) continue;
      
      const delay = (i + 1) * (2000 + Math.random() * 4000); // 2-6 seconds each
      
      setTimeout(async () => {
        const commentText = await generateTeaSpillingResponse(npc, post, author);
        
        const comment = createComment({
          postId: post.id,
          authorId: npc.id,
          authorName: npc.name,
          content: commentText
        });
        
        post.comments.push(comment);
        
        // Store in memory - they were called out!
        remember(npc, `${author.name} called me out in a post about: "${post.content}"`, 'event', 2.5);
        remember(author, `${npc.name} responded to my tea-spilling post`, 'interaction', 1.5);
        
        // Relationship might change depending on response
        const relationship = npc.relationships?.[author.id];
        if (relationship) {
          // Drama can strain or strengthen relationships
          const isDramatic = Math.random() < 0.3;
          relationship.strength += isDramatic ? -3 : 1;
        }
        
        if (gameState.activeTab === 'social') {
          renderSocialFeed();
        }
      }, delay);
    }
    
    // Others might also comment for the drama (20% of non-mentioned people)
    const activeEmployees = gameState.employees.filter(e => 
      e.employmentStatus === 'active' && 
      e.id !== author.id &&
      !mentionedEmployees.find(m => m.id === e.id)
    );
    
    const bystanders = Math.min(2, Math.floor(activeEmployees.length * 0.2));
    for (let i = 0; i < bystanders; i++) {
      const npc = activeEmployees[Math.floor(Math.random() * activeEmployees.length)];
      const delay = (mentionedEmployees.length + i + 1) * (2000 + Math.random() * 4000);
      
      setTimeout(async () => {
        const reactions = [
          'ğŸ‘€ğŸ¿', 'The TEA is hot today', 'I\'m just here for the comments ğŸ¿',
          'This is MESSY ğŸ’€', 'Drama!! ğŸ«–', 'Oh wow ğŸ˜³', 'Spicy ğŸŒ¶ï¸',
          'Not this on my feed ğŸ˜‚', 'The audacity lol', 'ğŸ’€ğŸ’€ğŸ’€'
        ];
        
        const commentText = reactions[Math.floor(Math.random() * reactions.length)];
        
        const comment = createComment({
          postId: post.id,
          authorId: npc.id,
          authorName: npc.name,
          content: commentText
        });
        
        post.comments.push(comment);
        
        if (gameState.activeTab === 'social') {
          renderSocialFeed();
        }
      }, delay);
    }
  }
  
  /**
   * Generate a response from someone called out in a tea-spilling post
   */
  async function generateTeaSpillingResponse(npc, post, author) {
    const affection = npc.stats?.affection || 0;
    const personality = npc.personality || {};
    const relationship = npc.relationships?.[author.id];
    
    // Determine response tone
    const isEmbarrassed = personality.confidence < 50;
    const isDefiant = personality.confidence > 70;
    const isFriendly = relationship?.type === 'friend' || relationship?.type === 'best_friend';
    const intimacy = npc.intimacy || 0;
    
    const prompt = `You are ${npc.name}. ${author.name} just called you out in a social media post that says: "${post.content}"

YOUR PERSONALITY: confidence: ${personality.confidence}/100, outgoing: ${personality.outgoing}/100, flirty: ${personality.flirty}/100
YOUR RELATIONSHIP WITH ${author.name}: ${relationship?.type || 'coworker'}

Write a SHORT comment response (5-15 words) that reacts to being called out. Options:
${isEmbarrassed ? '- Play it off embarrassed/shy' : ''}
${isDefiant ? '- Own it confidently' : ''}
${isFriendly ? '- Playfully banter back' : ''}
${intimacy > 40 ? '- Flirt back' : ''}
- Deny it playfully
- Make a joke about it
- Call them out back

Examples:
- "WHO TOLD YOU ğŸ˜­"
- "And what about it? ğŸ’…"
- "Says the one who... ğŸ‘€"
- "EXCUSE ME this is slander"
- "You're one to talk ğŸ˜"
- "Mind your business lol"
- "Okay but you're not wrong ğŸ’€"

Write ONLY the comment:`;

    try {
      const response = await queuedGenerateText(prompt, { 
        temperature: 1.0, 
        max_tokens: 40 
      }, `Generating tea/gossip response for ${emp.name}`);
      let comment = response.trim().replace(/^["']|["']$/g, '');
      
      return comment;
      
    } catch (error) {
      console.error('Tea response generation failed:', error);
      
      // Fallback templates
      if (isDefiant) {
        return ['And what about it? ğŸ’…', 'You\'re one to talk ğŸ˜', 'Mind your business lol'][Math.floor(Math.random() * 3)];
      } else if (isEmbarrassed) {
        return ['WHO TOLD YOU ğŸ˜­', 'This is NOT true ğŸ’€', 'EXCUSE ME'][Math.floor(Math.random() * 3)];
      } else {
        return ['Okay but you\'re not wrong', 'Says you ğŸ‘€', 'The audacity lol'][Math.floor(Math.random() * 3)];
      }
    }
  }
  
  /**
   * Generate a comment using AI or templates
   * NOW WITH FULL CONTEXT AWARENESS FOR NPC-TO-NPC INTERACTIONS
   */
  async function generateComment(employee, post, relationType) {
    const postAuthor = gameState.employees.find(e => e.id === post.authorId);
    
    // Get FULL context for this interaction
    const relationship = employee.relationships?.[post.authorId];
    const affection = employee.stats?.affection || 0;
    const desire = employee.stats?.desire || 0;
    const intimacy = employee.intimacy || 0;
    const personality = employee.personality || {};
    
    // Get their relationship with the post author (if NPC)
    const hasRelationship = postAuthor && !post.isPlayerPost;
    const relationshipStrength = relationship?.strength || 0;
    const relationshipHistory = relationship?.history || [];
    
    // Determine if this should be a meaningful comment based on context
    const shouldUseMeaningfulComment = 
      post.isPlayerPost || // ALWAYS use AI for player posts!
      post.explicitLevel >= 2 || // Explicit content
      post.type === 'tea_spilling' || // Drama
      post.type === 'life_update' || // Important updates
      post.type === 'achievement' || // Milestones
      post.type === 'thirst_trap' || // Suggestive posts
      post.type === 'gossip' || // Mysterious posts
      relationshipStrength > 60 || // Close relationship
      affection > 50 || // Employee likes the player
      desire > 50 || // Employee desires the player
      intimacy > 40 || // Intimate relationship with player
      hasRelationship && (relationType === 'best_friend' || relationType === 'romantic' || relationType === 'rival' || relationType === 'enemy');
    
    // Use AI for meaningful comments, quick templates for casual interactions
    if (shouldUseMeaningfulComment) {
      console.log(`[Social] ${employee.name} using AI comment for ${post.isPlayerPost ? 'PLAYER' : postAuthor?.name}'s post (type: ${post.type}, explicit: ${post.explicitLevel})`);
      try {
        return await generateAIComment(employee, post, postAuthor, relationship, relationType);
      } catch (error) {
        console.error('AI comment failed, using enhanced templates:', error);
        return generateEnhancedTemplateComment(employee, post, postAuthor, relationType);
      }
    }
    
    // Quick casual comments for basic interactions
    console.log(`[Social] ${employee.name} using casual comment for ${post.isPlayerPost ? 'PLAYER' : postAuthor?.name}'s post`);
    return generateCasualComment(employee, post, relationType);
  }
  
  /**
   * Generate AI-powered comment with full context awareness
   * THIS IS WHERE THE JUICE HAPPENS
   */
  async function generateAIComment(commenter, post, postAuthor, relationship, relationType) {
    const commenterPersonality = commenter.personality || {};
    const postAuthorPersonality = postAuthor?.personality || {};
    const relationshipStrength = relationship?.strength || 0;
    const relationshipHistory = relationship?.history || [];
    
    // Get recent interactions between these two NPCs
    const recentInteractions = relationshipHistory.slice(-3).map(h => h.description).join('; ') || 'No recent history';
    
    // Build comprehensive context
    const isPlayerPost = post.isPlayerPost;
    const targetName = isPlayerPost ? 'the boss' : postAuthor.name;
    
    // GET CONVERSATION CONTEXT - This is the juicy stuff!
    let conversationContext = '';
    
    // If commenting on player's post, check DM history with player
    if (isPlayerPost) {
      const dmHistory = gameState.chatHistory[commenter.id] || [];
      const recentDMs = dmHistory.slice(-10); // Last 10 messages
      
      if (recentDMs.length > 0) {
        // Extract juicy details from recent DMs
        const juicyDetails = recentDMs
          .filter(msg => msg.content && msg.content.length > 10)
          .slice(-5) // Last 5 meaningful messages
          .map(msg => {
            const speaker = msg.sender === 'player' ? 'Boss' : commenter.name;
            return `${speaker}: "${msg.content.substring(0, 100)}"`;
          })
          .join('\n');
        
        if (juicyDetails) {
          conversationContext = `\n\nRECENT DM CONVERSATION WITH BOSS:
${juicyDetails}

You can reference things from your DMs if relevant! Examples:
- "Well you told me you were working late tonight ğŸ‘€"
- "That's funny because you said something totally different to me earlier"
- "Didn't you just say you hated this? ğŸ˜‚"
- "Interesting... remember what we talked about?"
- "This contradicts what you told me but ok"`;
        }
      }
    }
    
    // If commenting on another NPC's post, check if we have DM history with the BOSS about this person
    if (!isPlayerPost && postAuthor) {
      const dmHistory = gameState.chatHistory[commenter.id] || [];
      const recentDMs = dmHistory.slice(-20); // Look further back
      
      // Check if we've talked about this person with the boss
      const mentionsOfTarget = recentDMs.filter(msg => 
        msg.content && (
          msg.content.toLowerCase().includes(postAuthor.name.toLowerCase()) ||
          msg.content.toLowerCase().includes(postAuthor.name.split(' ')[0].toLowerCase())
        )
      );
      
      if (mentionsOfTarget.length > 0) {
        const gossipDetails = mentionsOfTarget.slice(-3).map(msg => {
          const speaker = msg.sender === 'player' ? 'Boss' : 'You';
          return `${speaker}: "${msg.content.substring(0, 100)}"`;
        }).join('\n');
        
        conversationContext = `\n\nYOU'VE DISCUSSED ${postAuthor.name.toUpperCase()} WITH THE BOSS:
${gossipDetails}

You can call them out based on what you know! Examples:
- "That's not what I heard ğŸ‘€"
- "Interesting... the boss told me something different about you"
- "Funny timing after what happened"
- "Everyone's talking about you btw"
- "The boss was just telling me about this actually"`;
      }
    }
    
    // CROSS-REFERENCE: Check if other NPCs have talked about the post author with the player
    if (!isPlayerPost && postAuthor) {
      // Check ALL employee DM histories for mentions of this person
      let heardGossip = '';
      for (const employee of gameState.employees) {
        if (employee.id === commenter.id || employee.id === postAuthor.id) continue;
        
        const theirDMs = gameState.chatHistory[employee.id] || [];
        const theirGossip = theirDMs.filter(msg =>
          msg.content && (
            msg.content.toLowerCase().includes(postAuthor.name.toLowerCase()) ||
            msg.content.toLowerCase().includes(postAuthor.name.split(' ')[0].toLowerCase())
          )
        ).slice(-2); // Just the most recent gossip
        
        if (theirGossip.length > 0 && Math.random() < 0.3) { // 30% chance to reference others' gossip
          heardGossip = `\n\nGOSSIP YOU'VE HEARD:
${employee.name} was talking about ${postAuthor.name}: "${theirGossip[0].content.substring(0, 80)}"

You heard through the grapevine! Examples:
- "Is it true what everyone's saying?"
- "I heard some interesting things about you"
- "People are talking ğŸ‘€"
- "The whole office has been discussing this"`;
          break; // Just use the first gossip found
        }
      }
      
      if (heardGossip) {
        conversationContext += heardGossip;
      }
    }
    
    // Determine emotional context
    let emotionalContext = '';
    if (relationType === 'romantic') {
      emotionalContext = `You're romantically involved with ${targetName}. Your comments should show affection and intimacy.`;
    } else if (relationType === 'crush') {
      emotionalContext = `You have a crush on ${targetName}. You're trying to flirt subtly but also play it cool.`;
    } else if (relationType === 'best_friend') {
      emotionalContext = `${targetName} is your best friend. You can be playful, supportive, or tease them.`;
    } else if (relationType === 'friend') {
      emotionalContext = `You're friends with ${targetName}. Keep it friendly and supportive.`;
    } else if (relationType === 'rival') {
      emotionalContext = `You and ${targetName} are rivals. There's competitive tension. Be subtly shady or backhanded.`;
    } else if (relationType === 'enemy') {
      emotionalContext = `You don't like ${targetName}. Your comment can be dismissive, sarcastic, or pointedly critical.`;
    } else {
      emotionalContext = `You're coworkers with ${targetName}. This is a PERSONAL social network (like Instagram), not work chat - be casual, real, and fun.`;
    }
    
    // Special context for different post types
    let postTypeContext = '';
    if (post.type === 'tea_spilling') {
      postTypeContext = 'This is DRAMA. They\'re spilling tea about someone. React with appropriate shock, support, or defense of the person being called out.';
    } else if (post.type === 'thirst_trap' || post.explicitLevel >= 2) {
      postTypeContext = 'This is suggestive/explicit content. React appropriately based on your relationship and personality. Could be supportive, flirty, shocked, or disapproving.';
    } else if (post.type === 'life_update') {
      postTypeContext = 'This is an important life update. Show genuine interest or concern.';
    } else if (post.type === 'achievement') {
      postTypeContext = 'They\'re celebrating an achievement. React with congratulations (genuine or backhanded based on relationship).';
    } else if (post.type === 'complaint') {
      postTypeContext = 'They\'re venting or complaining. Commiserate, offer advice, or dismiss them based on your relationship.';
    } else if (post.type === 'gossip') {
      postTypeContext = 'They\'re being cryptic/mysterious about drama. Either ask for details, play along with the mystery, or act concerned.';
    }
    
    // ğŸ” CONTENT POLICY: This is an adult workplace with open, sex-positive culture
    const contentPolicy = gameState.settings?.policy || 'open';
    let toneGuidance = '';
    
    if (contentPolicy === 'open') {
      // Enthusiastic consent model - everyone is comfortable with adult content
      toneGuidance = `ğŸ” WORKPLACE CULTURE: This is an open, sex-positive workplace. Explicit content, sexual references, and adult humor are NORMAL and accepted by everyone. DO NOT act shocked, prudish, or suggest keeping things "PG" or "family-friendly" - that's NOT how this workplace operates. Be natural, comfortable, and match the energy of explicit content without moralizing.`;
    } else if (contentPolicy === 'professional') {
      toneGuidance = `WORKPLACE CULTURE: Maintain professional boundaries. Sexual content should be addressed tactfully with appropriate workplace discretion.`;
    } else {
      // Casual
      toneGuidance = `WORKPLACE CULTURE: Relaxed office culture. Adult content is acceptable but address it naturally based on your comfort level and relationship.`;
    }
    
    // OPTIMIZED: Short, direct prompt that forces clean output
    const prompt = `${toneGuidance}

${commenter.name} sees ${targetName}'s post: "${post.content.substring(0, 100)}"
Rel: ${relationType} (${relationshipStrength}/100)
Personality: Conf${commenterPersonality.confidence||50} Out${commenterPersonality.outgoing||50} Flirt${commenterPersonality.flirty||50} Pro${commenterPersonality.professional||50}
${post.explicitLevel >= 2 ? 'EXPLICIT POST - respond naturally without moralizing' : ''}${conversationContext ? '\nHAS INSIDER INFO FROM DMS' : ''}

Comment (5-25 words, reference post specifics, show personality):`;


    const response = await queuedGenerateText(prompt, { 
      temperature: 0.9,  // Reduced from 1.0 for more consistency
      top_p: 0.95,       // Limit token sampling
      max_tokens: 40,    // Slightly increased for 25-word limit
      stopSequences: ['\n', '\n\n', '.)', '".', 'Rating', 'Rationale', 'Why', 'Because', '{SEEDS', '{BAN', '{BOOST', '---', '(Relationship', 'Physical', 'Brainstorm', 'Good approach', 'Bad approach', 'Final', 'Boss', 'personality traits']  // EXPANDED
    }, `Generating comment for ${commenter.name} on ${targetName}'s post`);
    
    let comment = response.trim();
    
    // NUCLEAR OPTION: Aggressive cleanup to remove ALL meta-commentary
    
    // CRITICAL: Take ONLY first line/sentence to cut meta-text
    comment = comment.split('\n')[0].trim();
    
    // CRITICAL: If we see ANY meta-patterns, stop at them
    const metaMarkers = ['Boss', 'personality traits:', 'Brainstorm', 'Good approach', 'Bad approach', 'Final', 'Word count', 'matches', 'References', 'Playful', 'Emoji use'];
    for (const marker of metaMarkers) {
      const idx = comment.indexOf(marker);
      if (idx > 10) { // If marker appears after 10 chars, cut everything after
        comment = comment.substring(0, idx).trim();
        break;
      }
    }
    
    // Remove Perchance formatting tokens (can appear anywhere)
    comment = comment.replace(/\{SEEDS:[^}]*\}/gi, '');
    comment = comment.replace(/\{BAN:[^}]*\}/gi, '');
    comment = comment.replace(/\{BOOST:[^}]*\}/gi, '');
    comment = comment.replace(/\{[A-Z_]+:[^}]*\}/g, '');
    comment = comment.replace(/\s*---\s*/g, ' '); // Remove separators
    
    // Remove quotes
    comment = comment.replace(/^["']|["']$/g, '');
    
    // Remove "Name:" or "Name's Comment:" prefix
    comment = comment.replace(/^[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*'?s?\s*(?:Comment)?:\s*/g, '');
    
    // Remove **Name** prefix
    comment = comment.replace(/^\*\*\([^)]+\)\*\*\s*/g, '');
    comment = comment.replace(/^\*\*[^*]+\*\*:\s*/g, '');
    
    // Remove parenthetical meta-notes at end
    comment = comment.replace(/\s*\([^)]{15,}\)\s*$/i, ''); // Long parentheticals
    comment = comment.replace(/\s*\(Relationship[^)]*\)\s*$/i, '');
    comment = comment.replace(/\s*\(Word count[^)]*\)\s*$/i, '');
    comment = comment.replace(/\s*\(\d+\s*(?:words?|characters?)[^)]*\)\s*$/i, '');
    
    // If comment starts with meta-text, it's broken - return fallback
    if (/^(Boss|Personality|Brainstorm|Good|Bad|Final|Physical|The comment)/i.test(comment)) {
      console.warn(`[Comment] Meta-text detected, using fallback: "${comment.substring(0, 50)}"`);
      return generateEnhancedTemplateComment(commenter, post, postAuthor, relationType);
    }
    
    comment = comment.replace(/\s*\*\s*$/g, ''); // Remove trailing asterisks
    comment = comment.trim();
    
    // Ensure reasonable length
    if (comment.length > 150) {
      comment = comment.substring(0, 147) + '...';
    }
    
    // Detect if this comment reveals DM knowledge (spicy!)
    const revealsPrivateInfo = conversationContext && (
      comment.toLowerCase().includes('told me') ||
      comment.toLowerCase().includes('said') ||
      comment.toLowerCase().includes('dm') ||
      comment.toLowerCase().includes('conversation') ||
      comment.toLowerCase().includes('earlier') ||
      comment.toLowerCase().includes('different') ||
      comment.toLowerCase().includes('heard') ||
      comment.toLowerCase().includes('everyone knows')
    );
    
    // Store this interaction in relationship history
    if (relationship && !isPlayerPost) {
      const historyEntry = {
        timestamp: gameState.time?.currentTime || Date.now(),
        description: `Commented on their post: "${comment}"${revealsPrivateInfo ? ' [EXPOSED PRIVATE INFO!]' : ''}`,
        impact: relationType === 'enemy' ? -2 : relationType === 'rival' ? -1 : 1,
        causedDrama: revealsPrivateInfo
      };
      
      if (!relationship.history) relationship.history = [];
      relationship.history.push(historyEntry);
      if (relationship.history.length > 10) relationship.history.shift();
      
      // Adjust relationship strength based on comment tone
      if (relationType === 'enemy' || relationType === 'rival') {
        relationship.strength = Math.max(0, relationship.strength - 1);
      } else {
        relationship.strength = Math.min(100, relationship.strength + 1);
      }
      
      // If revealing private info, damage trust even among friends!
      if (revealsPrivateInfo && relationType !== 'enemy') {
        relationship.strength = Math.max(0, relationship.strength - 3);
        console.log(`[Drama] ${commenter.name} exposed private info about ${postAuthor.name}! Trust -3`);
      }
    }
    
    // If player's post and commenter revealed DM knowledge, they might get confronted later
    if (isPlayerPost && revealsPrivateInfo) {
      // Flag for potential future confrontation/gossip
      if (!commenter.recentBehavior) commenter.recentBehavior = [];
      commenter.recentBehavior.push({
        type: 'revealed_dm_info',
        timestamp: gameState.time?.currentTime || Date.now(),
        comment: comment
      });
      if (commenter.recentBehavior.length > 5) commenter.recentBehavior.shift();
      
      console.log(`[Drama] ${commenter.name} publicly referenced private DMs with boss!`);
    }
    
    console.log(`[Social${revealsPrivateInfo ? ' ğŸ«–' : ''}] ${commenter.name} â†’ ${targetName}: "${comment}"`);
    
    return comment;
  }
  
  /**
   * Enhanced template-based comments (fallback for AI failure)
   * Much better than the old generic ones
   */
  function generateEnhancedTemplateComment(commenter, post, postAuthor, relationType) {
    const personality = commenter.personality || {};
    const isConfident = personality.confidence > 60;
    const isFlirty = personality.flirty > 60;
    const isOutgoing = personality.outgoing > 60;
    
    // Post-type specific templates
    if (post.type === 'tea_spilling') {
      const dramaTemplates = [
        'WAIT what?! I need the full story rn ï¿½',
        'The TEA is piping hot today â˜•',
        'This is MESSY and I\'m here for it ğŸ¿',
        'SAY IT LOUDER FOR THE PEOPLE IN THE BACK',
        'Not this on my feed ï¿½ï¿½',
        'The way I gasped at this',
        'Oop- somebody said it finally',
        'This is the content I signed up for ğŸ«–'
      ];
      return dramaTemplates[Math.floor(Math.random() * dramaTemplates.length)];
    }
    
    if (post.explicitLevel >= 2 || post.type === 'thirst_trap') {
      if (relationType === 'romantic' || relationType === 'crush') {
        return ['ğŸ¥µğŸ¥µğŸ¥µ', 'Stop it you\'re killing me', 'How are you even REAL', 'Not fair ğŸ˜­ğŸ”¥'][Math.floor(Math.random() * 4)];
      } else if (isFlirty) {
        return ['Okay WOW ğŸ‘€', 'The AUDACITY ï¿½', 'You really did that huh', 'Damn ï¿½'][Math.floor(Math.random() * 4)];
      } else {
        return ['Looking good! ğŸ”¥', 'Confidence! âœ¨', 'Serving looks!', 'Get it! ğŸ’¯'][Math.floor(Math.random() * 4)];
      }
    }
    
    if (post.type === 'complaint') {
      const sympathyTemplates = [
        'Ugh I felt that in my SOUL',
        'No literally why is it like this',
        'This is so valid honestly',
        'The way this is my daily struggle',
        'Someone needed to say it'
      ];
      const dismissiveTemplates = [
        'It\'s really not that deep',
        'Sure Jan ğŸ™„',
        'Okay but like... why tho',
        'Interesting take'
      ];
      
      if (relationType === 'enemy' || relationType === 'rival') {
        return dismissiveTemplates[Math.floor(Math.random() * dismissiveTemplates.length)];
      }
      return sympathyTemplates[Math.floor(Math.random() * sympathyTemplates.length)];
    }
    
    // Relationship-based templates
    if (relationType === 'best_friend') {
      return [
        'BESTIE!! This is everything ğŸ’•',
        'Why are you like this I love you ğŸ˜‚',
        'The way you always serve content',
        'This is why you\'re my favorite person',
        'Not you coming for my whole existence',
        'Okay this made my entire day'
      ][Math.floor(Math.random() * 6)];
    }
    
    if (relationType === 'romantic') {
      return [
        'You\'re stunning I can\'t ğŸ˜',
        'Miss you already â¤ï¸',
        'How did I get this lucky',
        'Beautiful inside and out ğŸ’•',
        'Come over? ğŸ‘€'
      ][Math.floor(Math.random() * 5)];
    }
    
    if (relationType === 'crush') {
      return [
        'Wow ğŸ˜³',
        'This look though ğŸ‘€',
        'Okay I see you ğŸ”¥',
        'Um hello?? ğŸ˜',
        'Not me blushing at this'
      ][Math.floor(Math.random() * 5)];
    }
    
    if (relationType === 'rival') {
      return [
        'Interesting choice',
        'Sure that\'s one way to do it',
        'Bold of you ğŸ™„',
        'Okay and?',
        'If you say so',
        'Meh I\'ve seen better'
      ][Math.floor(Math.random() * 6)];
    }
    
    if (relationType === 'enemy') {
      return [
        'ğŸ™„',
        'Whatever',
        'Seriously?',
        'Okay cool story',
        'Not interested',
        'Pass'
      ][Math.floor(Math.random() * 6)];
    }
    
    // Friend templates
    if (relationType === 'friend') {
      return [
        'Haha love this energy!',
        'You always have the best posts âœ¨',
        'This is so YOU I love it',
        'Main character moment!',
        'Living for this vibe',
        'The way you just understood the assignment'
      ][Math.floor(Math.random() * 6)];
    }
    
    // Default neutral but more interesting
    const neutralTemplates = [
      'This hits different',
      'Okay this is actually great',
      'Valid honestly',
      'Needed to see this today',
      'The vibe is immaculate',
      'This energy >>>',
      'No notes this is perfect'
    ];
    
    return neutralTemplates[Math.floor(Math.random() * neutralTemplates.length)];
  }
  
  /**
   * Quick casual comments for low-stakes interactions
   */
  function generateCasualComment(employee, post, relationType) {
    // Special handling for player posts
    if (post.isPlayerPost) {
      const affection = employee.stats?.affection || 0;
      const desire = employee.stats?.desire || 0;
      const intimacy = employee.intimacy || 0;
      
      if (intimacy > 60 || (affection > 60 && desire > 50)) {
        return ['Love this boss! ï¿½', 'You look amazing! ï¿½', 'Boss energy âœ¨', 'Stunning! ğŸ’•'][Math.floor(Math.random() * 4)];
      } else if (affection > 40) {
        return ['Nice post boss!', 'Love it! ğŸ˜Š', 'Great stuff! ï¿½', 'Looking good boss! âœ¨'][Math.floor(Math.random() * 4)];
      }
    }
    
    // Quick relationship-based responses
    const templates = {
      best_friend: ['Yessss! ğŸ”¥', 'Love this!', 'You always slay', 'This! ğŸ’¯', 'Iconic behavior'],
      friend: ['Haha love it!', 'So good!', 'Amazing! âœ¨', 'This made my day', 'Yesss ğŸ™Œ', 'The vibe!'],
      crush: ['ğŸ˜', 'Wow ğŸ”¥', 'Um hello', 'ğŸ‘€ğŸ’•', 'Okay then'],
      romantic: ['Beautiful â¤ï¸', 'Miss you', 'ğŸ˜˜', 'Love this babe', 'Gorgeous'],
      rival: ['Interesting...', 'Sure', 'Ok ğŸ™„', 'Meh', 'If you say so'],
      enemy: ['ğŸ™„', 'Whatever', 'Seriously?', 'Pass', 'ğŸ˜’'],
      neutral: ['Nice!', 'Cool vibes', 'This hits', 'Love the energy', 'Valid', 'âœ¨']
    };
    
    const options = templates[relationType] || templates.neutral;
    return options[Math.floor(Math.random() * options.length)];
  }
  
  /**
   * Generate "first post" for newly hired employee
   * Called immediately after hiring to create their introduction post
   */
  async function generateFirstEmployeePost(employee) {
    // Ensure social data exists first
    if (!employee.social) {
      initializeEmployeeSocialData(employee);
    }
    
    // Check if employee already has a first post (prevent duplicates)
    if (employee.social.hasFirstPost) return;
    
    // Mark that they've made their first post
    employee.social.hasFirstPost = true;
    
    const personality = employee.personality || {};
    const social = employee.social || {};
    
    // Generate AI-powered first post
    const personalityDesc = `outgoing: ${personality.outgoing || 50}/100, professional: ${personality.professional || 50}/100, confidence: ${personality.confidence || 50}/100`;
    
    // Gender-appropriate description
    const genderDesc = employee.gender ? `, a ${employee.age || 'young'}-year-old ${employee.gender === 'male' ? 'man' : employee.gender === 'transMan' ? 'trans man' : employee.gender === 'transWoman' ? 'trans woman' : employee.gender === 'femaleFuta' ? 'woman' : 'woman'}` : '';
    
    // FIXED: Use actual company name from player profile
    const companyName = getCompanyName();
    
    const prompt = `You are ${employee.name}${genderDesc}, posting on an uncensored social media for the FIRST TIME after just getting hired at ${companyName}.

Your personality: ${personalityDesc}
Your role: ${employee.position || 'Employee'}
Location: ${employee.location || 'headquarters'}

Write a SHORT (1-2 sentences) first post announcing you just joined ${companyName}. Be authentic to your personality. Express excitement about starting. Use 0-2 emojis. IMPORTANT: Mention "${companyName}" specifically in your post.

${social.contentStyle === 'casual' ? 'Style: Casual and friendly' : social.contentStyle === 'professional' ? 'Style: Professional but warm' : 'Style: Balanced and personable'}

Examples:
- High outgoing: "Just joined the team at ${companyName} and already loving the energy! Can't wait to meet everyone! ğŸ‰âœ¨"
- High professional: "Excited to start my new role at ${companyName}. Looking forward to contributing to the team's success. ğŸ’¼"
- Balanced: "First day at ${companyName}! Feeling great about this opportunity. ğŸ˜Š"

Post:`;

    let content;
    try {
      content = await queuedGenerateText(prompt, {}, `Generating first social post for new employee ${employee.name}`);
      content = content.trim();
    } catch (error) {
      console.error('AI generation failed for first post:', error);
      // Fallback templates based on personality - FIXED: Now use company name
      const fallbacks = {
        high_outgoing: [
          `Just joined the team at ${companyName}! So excited to be here! ğŸ‰`,
          `New job at ${companyName}, new adventures! Let's do this! âœ¨`,
          `First day at ${companyName}! Already loving the energy here! ğŸš€`,
          `Officially part of the ${companyName} team! Can't wait to meet everyone! ğŸ˜Š`
        ],
        high_professional: [
          `Excited to join ${companyName} and contribute to our success. ğŸ’¼`,
          `Looking forward to starting this new chapter at ${companyName}. Happy to be here.`,
          `Grateful for this opportunity at ${companyName}. Ready to make an impact. ğŸ¯`,
          `Pleased to announce I've joined ${companyName}. Let's build something great.`
        ],
        balanced: [
          `Just started at ${companyName} today! Excited for what's ahead. ğŸ˜Š`,
          `New team member at ${companyName} here! Looking forward to working with everyone. ğŸ‘‹`,
          `Day one at ${companyName} complete! Great first impression. âœ¨`,
          `Happy to be part of the ${companyName} team! Excited to get started. ğŸ‰`
        ]
      };
      
      // Select template category based on personality
      let category = 'balanced';
      if (personality.outgoing > 70) category = 'high_outgoing';
      else if (personality.professional > 70) category = 'high_professional';
      
      const templates = fallbacks[category];
      content = templates[Math.floor(Math.random() * templates.length)];
    }
    
    // Determine if they want to post a selfie (30% chance if outgoing > 60)
    let imagePrompt = null;
    let imageUrl = null;
    
    if (personality.outgoing > 60 && Math.random() < 0.3) {
      // Use consistent physical description for first post selfie
      const physicalDesc = getPhysicalDescriptionForPrompt(employee);
      imagePrompt = `Professional first-day selfie: ${physicalDesc}, smiling confidently, office setting, welcoming expression, good lighting, business casual attire, friendly and approachable`;
      
      try {
        imageUrl = await queuedGenerateImage(applyImageStyle(imagePrompt), `First post selfie for new employee ${employee.name}`);
      } catch (error) {
        console.error('Image generation failed for first post:', error);
        imageUrl = null;
      }
    }
    
    // Create the first post
    const post = createPost({
      authorId: employee.id,
      authorName: employee.name,
      type: imageUrl ? 'selfie' : 'text',
      content: content,
      imageUrl: imageUrl,
      imageAlt: imagePrompt || 'First day at work',
      imagePrompt: imagePrompt || null,
      explicitLevel: 0, // Always safe for first post
      tags: ['first_post', 'new_hire'],
      location: employee.location || 'headquarters',
      isPlayerPost: false
    });
    
    // Add to feed
    gameState.socialNetwork.posts.unshift(post);
    
    // Refresh dashboard to show new posts/mentions
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
    
    // Log event
    logCompanyEvent('first_post', {
      authorId: employee.id,
      authorName: employee.name,
      postType: post.type
    });
    
    // Refresh feed if social tab is active
    if (gameState.activeTab === 'social') {
      renderSocialFeed();
    }
    
    console.log(`âœ… ${employee.name} made their first post!`);
    
    return post;
  }
  
  /**
   * Generate autonomous likes on recent posts
   */
  async function generateAutonomousLikes() {
    // Get recent posts (last 15)
    const recentPosts = gameState.socialNetwork.posts.slice(0, 15);
    if (recentPosts.length === 0) return;
    
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    for (const employee of activeEmployees) {
      for (const post of recentPosts) {
        // Skip own posts
        if (post.authorId === employee.id) continue;
        
        // Ensure likes array exists
        if (!Array.isArray(post.likes)) {
          post.likes = [];
        }
        
        // Skip if already liked
        if (post.likes.includes(employee.id)) continue;
        
        // Determine like probability based on relationship
        const relationship = employee.relationships?.[post.authorId];
        const relationType = relationship?.type || 'neutral';
        
        let likeProbability = 0.3; // Base 30%
        
        switch (relationType) {
          case 'best_friend': likeProbability = 0.9; break;
          case 'friend': likeProbability = 0.7; break;
          case 'crush': likeProbability = 0.85; break;
          case 'romantic': likeProbability = 0.95; break;
          case 'rival': likeProbability = 0.1; break;
          case 'enemy': likeProbability = 0.05; break;
        }
        
        // Boost probability for explicit content if employee is flirty
        if (post.explicitLevel >= 2 && employee.personality?.flirty > 60) {
          likeProbability += 0.2;
        }
        
        // Random like based on probability
        if (Math.random() < likeProbability) {
          post.likes.push(employee.id);
          
          // ğŸŒ Evaluate relationship impact from liking (smaller than comments)
          const postAuthor = gameState.employees.find(e => e.id === post.authorId);
          if (postAuthor && postAuthor.id !== employee.id) {
            // Viewing and liking without commenting = smaller relationship impact
            await evaluateNPCReactionToPost(employee, postAuthor, post, null);
          }
        }
      }
    }
  }
  
  /**
   * ğŸ˜ˆ MEAN GIRL SYSTEM: Generate autonomous downvotes and drama
   */
  async function generateAutonomousDownvotes() {
    const recentPosts = gameState.socialNetwork.posts.slice(0, 15);
    if (recentPosts.length === 0) return;
    
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    for (const employee of activeEmployees) {
      // Check if employee has "mean girl" tendencies
      const isMean = employee.traits?.includes('bitchy') || 
                     employee.traits?.includes('competitive') ||
                     employee.traits?.includes('catty') ||
                     (employee.personality?.dominant > 70);
      
      const isPrudish = employee.traits?.includes('prudish') || 
                        employee.traits?.includes('conservative') ||
                        (employee.personality?.flirty < 30);
      
      for (const post of recentPosts) {
        // Skip own posts
        if (post.authorId === employee.id) continue;
        
        // Initialize vote tracking if needed
        if (!post.upvotes) post.upvotes = 0;
        if (!post.downvotes) post.downvotes = 0;
        if (!post.downvoters) post.downvoters = [];
        
        // Skip if already downvoted
        if (post.downvoters.includes(employee.id)) continue;
        
        const postAuthor = gameState.employees.find(e => e.id === post.authorId);
        if (!postAuthor && !post.isPlayerPost) continue;
        
        let downvoteProbability = 0;
        let reason = '';
        
        // Get relationship with post author
        const relationship = employee.relationships?.[post.authorId];
        const relationType = relationship?.type || 'neutral';
        const affection = relationship?.affection || 50;
        
        // ===== RIVALRY & DRAMA =====
        if (relationType === 'rival' || relationType === 'enemy') {
          downvoteProbability = 0.7; // 70% chance to downvote rivals!
          reason = 'rivalry';
        }
        
        // ===== JEALOUSY =====
        if (postAuthor && affection < 30) {
          downvoteProbability += 0.3; // Don't like them? Downvote!
          reason = 'dislike';
        }
        
        // ===== EXPLICIT CONTENT DISAPPROVAL =====
        if (isPrudish && post.explicitLevel >= 2) {
          downvoteProbability += 0.5; // Prudish people hate NSFW content
          reason = 'prudish';
        }
        
        // ===== COMPETITIVE JEALOUSY (popular posts) =====
        if (isMean && (post.likes?.length || 0) > 10) {
          downvoteProbability += 0.4; // Mean girls hate when others get attention
          reason = 'jealous';
        }
        
        // ===== WORK POST ANNOYANCE =====
        if (post.type === 'work' && employee.traits?.includes('lazy')) {
          downvoteProbability += 0.3; // Lazy people hate work posts
          reason = 'lazy';
        }
        
        // ===== MEAN GIRL RANDOM CATTINESS =====
        if (isMean && Math.random() < 0.15) {
          downvoteProbability += 0.25; // Random cattiness
          reason = 'catty';
        }
        
        // Apply downvote
        if (downvoteProbability > 0 && Math.random() < Math.min(downvoteProbability, 0.85)) {
          post.downvotes++;
          post.downvoters.push(employee.id);
          
          console.log(`[Drama] ğŸ˜ˆ ${employee.name} downvoted ${post.isPlayerPost ? 'player' : postAuthor?.name}'s post (${reason}, ${Math.round(downvoteProbability * 100)}% chance)`);
          
          // Relationship impact
          if (postAuthor && !post.isPlayerPost) {
            // Downvoting hurts relationships
            if (!employee.relationships) employee.relationships = {};
            if (!employee.relationships[postAuthor.id]) {
              employee.relationships[postAuthor.id] = { affection: 50, type: 'neutral' };
            }
            employee.relationships[postAuthor.id].affection = Math.max(0, 
              (employee.relationships[postAuthor.id].affection || 50) - 3
            );
            
            // Chance to escalate to rivalry
            if (employee.relationships[postAuthor.id].affection < 25 && Math.random() < 0.3) {
              employee.relationships[postAuthor.id].type = 'rival';
              console.log(`[Drama] ğŸ”¥ ${employee.name} and ${postAuthor.name} are now RIVALS!`);
            }
          }
          
          // Sometimes leave a snarky comment too
          if (isMean && Math.random() < 0.25) {
            await generateSnarkyComment(employee, post, reason);
          }
        }
      }
    }
  }
  
  /**
   * ğŸ˜ˆ Generate snarky/shady comments
   */
  async function generateSnarkyComment(employee, post, reason) {
    // Check if already commented
    if (post.comments.some(c => c.authorId === employee.id)) return;
    
    const postAuthor = post.isPlayerPost ? 'TheBoss' : 
      gameState.employees.find(e => e.id === post.authorId)?.name || 'someone';
    
    const snarkyTemplates = {
      rivalry: [
        "Interesting take...",
        "Sure, if you say so ğŸ™„",
        "Not everyone can be right all the time",
        "Well THAT'S one way to do it",
        "Hmm. Okay then.",
        "Bold choice"
      ],
      jealous: [
        "Some people get all the attention...",
        "Must be nice",
        "Not that impressive tbh",
        "I've seen better",
        "Congratulations I guess ğŸ™„"
      ],
      prudish: [
        "Really? Here? Now?",
        "Some of us have standards...",
        "Not appropriate for work",
        "Yikes",
        "Seriously?"
      ],
      dislike: [
        "...",
        "K",
        "Sure",
        "If you say so",
        "Whatever works for you I guess"
      ],
      catty: [
        "Interesting choice ğŸ’…",
        "That's... certainly something",
        "Bless your heart",
        "You do you hun",
        "Different strokes I suppose"
      ]
    };
    
    const templates = snarkyTemplates[reason] || snarkyTemplates.catty;
    const snarkyComment = templates[Math.floor(Math.random() * templates.length)];
    
    const comment = {
      id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      postId: post.id,
      authorId: employee.id,
      authorName: employee.name,
      content: snarkyComment,
      timestamp: Date.now(),
      likes: [],
      isPlayerComment: false
    };
    
    if (!post.comments) post.comments = [];
    post.comments.push(comment);
    
    console.log(`[Drama] ğŸ’¬ ${employee.name} left snarky comment: "${snarkyComment}"`);
    
    // Update post in array
    const postIndex = gameState.socialNetwork.posts.findIndex(p => p.id === post.id);
    if (postIndex >= 0) {
      gameState.socialNetwork.posts[postIndex] = post;
    }
  }

  
  // Show notification
  /**
   * Load and display patch notes
   * Version format: YYMMDDHHMM
   */
  function loadPatchNotes() {
    const patchNotesContent = $('patchNotesContent');
    if (!patchNotesContent) return;
    
    // Define patch notes (newest first)
    const patchNotes = [
      {
        version: '202601031900',
        date: 'January 3, 2026',
        title: 'ğŸ›¡ï¸ CUSTOM CHARACTER PROTECTION',
        changes: [
          {
            category: 'ğŸ›¡ï¸ Accidental Closure Protection',
            items: [
              '<strong>CRITICAL FIX:</strong> Custom character confirmation modal now prevents accidental closure',
              '<strong>â€¢ PROBLEM:</strong> Clicking outside the modal would instantly close it, losing your generated character and prompt',
              '<strong>â€¢ SOLUTION:</strong> Modal now requires confirmation before closing with unsaved character',
              '<strong>â€¢ RESULT:</strong> No more lost characters from misclicks!',
              '',
              '<strong>NEW: Recover Last Character:</strong> Button appears in custom employee creator when you have an unsaved character',
              '<strong>NEW: Confirmation Dialog:</strong> Closing the modal asks "Are you sure?" and reminds you the character is saved',
              '<strong>NEW: Escape Key Protection:</strong> Pressing Escape also requires confirmation'
            ]
          }
        ]
      },
      {
        version: '202601031800',
        date: 'January 3, 2026',
        title: 'ğŸ’¾ SAVE SYSTEM OPTIMIZATION',
        changes: [
          {
            category: 'ğŸ’¾ Debounced Save System',
            items: [
              '<strong>PERFORMANCE FIX:</strong> Eliminated save congestion during bulk operations',
              '<strong>â€¢ PROBLEM:</strong> Team Building, Training Workshops, and other bulk operations were triggering 30+ simultaneous saves (one per employee)',
              '<strong>â€¢ SOLUTION:</strong> Implemented debounced save system that coalesces rapid-fire saves into single operations',
              '<strong>â€¢ RESULT:</strong> Massive performance improvement during stat-boosting activities!',
              '',
              '<strong>NEW: debouncedSave():</strong> Batches multiple save requests within 500ms window into one save',
              '<strong>NEW: flushPendingSave():</strong> Forces immediate save when needed (used at end of bulk operations)',
              '<strong>NEW: Save throttling:</strong> Auto-saves now skip if another save is in progress',
              '<strong>NEW: MIN_SAVE_INTERVAL:</strong> 500ms minimum between saves prevents rapid-fire congestion'
            ]
          },
          {
            category: 'âš¡ Technical Changes',
            items: [
              '<strong>gainSkillXP():</strong> Now uses debouncedSave() instead of immediate saveGame()',
              '<strong>conductTeamBuilding():</strong> Properly flushes pending saves before final save',
              '<strong>conductTrainingWorkshop():</strong> Properly flushes pending saves before final save',
              '<strong>saveGameToSlot():</strong> Added concurrency protection and throttling for auto-saves'
            ]
          }
        ]
      },
      {
        version: '202601031440',
        date: 'January 3, 2026',
        title: 'ğŸ¬ NPC ACTION BUTTONS + CUSTOM EMPLOYEES',
        changes: [
          {
            category: 'ğŸ¬ NPC Action Buttons',
            items: [
              '<strong>NEW ACTION BAR:</strong> Guide NPCs with one-click action buttons during chat!',
              '<strong>â–¶ï¸ Continue:</strong> Keep the scene going naturally',
              '<strong>ğŸ¬ Action:</strong> Trigger detailed physical actions (NPC does something, no dialogue)',
              '<strong>ğŸ’­ Thoughts:</strong> Peek into what the NPC is thinking',
              '<strong>ğŸ’• Flirt / ğŸ˜ Tease / âœ… Comply / â›” Resist:</strong> Steer the mood',
              '<strong>ğŸ¯ Custom:</strong> Type <code>/do [instruction]</code> for any custom action',
              '<strong>âš™ï¸ Configurable:</strong> Enable/disable buttons per employee'
            ]
          },
          {
            category: 'ğŸ‘¤ Custom Employee Creation',
            items: [
              '<strong>THREE WAYS TO CREATE:</strong>',
              '<strong>ğŸ”— From URL:</strong> Paste a wiki/character page link - AI extracts the character',
              '<strong>âœï¸ From Description:</strong> Describe your character in plain text',
              '<strong>ğŸ“ Manual Mode:</strong> Full control over every stat, trait, and appearance',
              '',
              '<strong>SMART WORKFLOW:</strong> Generation happens in background - keep playing!',
              '<strong>REVIEW BEFORE HIRE:</strong> Edit and approve the generated character before finalizing'
            ]
          },
          {
            category: 'ğŸ“ Position Selection',
            items: [
              '<strong>HIRE AT ANY LEVEL:</strong> Create Staff, Managers, or Division Heads directly',
              '<strong>CHOOSE YOUR SLOT:</strong> Pick exactly which position to fill in your corporate pyramid',
              '<strong>SMART DEFAULTS:</strong> Auto-selects the location you clicked from'
            ]
          },
          {
            category: 'ğŸ“‹ Full Character Customization',
            items: [
              '<strong>EVERYTHING IS CUSTOMIZABLE:</strong> Name, age, gender, race, bio, personality sliders, relationship stats, work performance, traits, hobbies, kinks, physical appearance, schedule, and more!',
              '<strong>AI FILLS GAPS:</strong> Leave fields blank and AI generates fitting values'
            ]
          }
        ]
      },
      {
        version: '202512061200',
        date: 'December 6, 2025',
        title: 'ğŸ›ï¸ INNER SANCTUM FIXES + AI REQUEST MANAGEMENT',
        changes: [
          {
            category: 'ğŸ›ï¸ Inner Sanctum - Critical Fixes',
            items: [
              '<strong>ğŸ¯ HIRING SYSTEM FIX:</strong> Inner Sanctum staff now correctly assigned to location when hired',
              '<strong>â€¢ PROBLEM:</strong> New managers hired for Inner Sanctum weren\'t getting location assignment',
              '<strong>â€¢ SOLUTION:</strong> Added proper locationId assignment in hiring functions',
              '<strong>â€¢ RESULT:</strong> Staff actually show up in Inner Sanctum after hiring!',
              '',
              '<strong>ğŸ’° UPGRADE COSTS FIX:</strong> Fixed "NaN%" display in Inner Sanctum money upgrades',
              '<strong>â€¢ PROBLEM:</strong> Missing base cost entries caused percentage calculations to fail',
              '<strong>â€¢ SOLUTION:</strong> Added Inner Sanctum entries to upgrade cost database',
              '<strong>â€¢ RESULT:</strong> Upgrade percentages now display correctly instead of "NaN%"!',
              '',
              '<strong>â­ ELITE UPGRADES FIX:</strong> Fixed "Nan% Level" display in Elite upgrade tooltips',
              '<strong>â€¢ PROBLEM:</strong> Missing null-safety checks when accessing global upgrade data',
              '<strong>â€¢ SOLUTION:</strong> Added proper safety operators throughout upgrade system',
              '<strong>â€¢ RESULT:</strong> Elite upgrades now show proper level information!'
            ]
          },
          {
            category: 'ğŸ¤– AI Request Management System - NEW!',
            items: [
              '<strong>ğŸ¯ SMART REQUEST QUEUE:</strong> Automatic prevention of "Max Requests Exceeded" errors',
              '<strong>â€¢ PROBLEM:</strong> Too many simultaneous AI text generation requests causing failures',
              '<strong>â€¢ SOLUTION:</strong> Built intelligent queue system that manages all AI requests automatically',
              '<strong>â€¢ FEATURES:</strong> Configurable max concurrent requests (5-50), real-time status display, smart context detection',
              '<strong>â€¢ RESULT:</strong> No more AI errors! Smooth text generation even during busy gameplay',
              '',
              '<strong>âš™ï¸ NEW SETTINGS PANEL:</strong> AI Request Management in Settings',
              '<strong>â€¢ Control max concurrent AI requests with easy slider</strong>',
              '<strong>â€¢ Real-time monitoring of active/queued requests</strong>',
              '<strong>â€¢ Visual feedback and status updates</strong>',
              '<strong>â€¢ Settings persist across game saves/loads</strong>',
              '',
              '<strong>ğŸ”„ ZERO-IMPACT INTEGRATION:</strong> Works automatically with existing features',
              '<strong>â€¢ All AI text generation now uses smart queue system</strong>',
              '<strong>â€¢ No changes needed to existing game functions</strong>',
              '<strong>â€¢ Automatic context detection for better queue descriptions</strong>',
              '<strong>â€¢ Smart throttling prevents overwhelming Perchance AI plugin</strong>'
            ]
          },
          {
            category: 'ğŸ›¡ï¸ System Improvements',
            items: [
              '<strong>ğŸ”’ Enhanced Null-Safety:</strong> Added protective checks throughout upgrade system to prevent crashes',
              '<strong>ğŸ’¾ Persistent Settings:</strong> AI queue settings save/load with game data automatically',
              '<strong>ğŸ¯ Smart Context Detection:</strong> AI queue provides better descriptions of what\'s being generated',
              '<strong>ğŸ“Š Real-Time Monitoring:</strong> Live status updates for AI request activity'
            ]
          },
          {
            category: 'ğŸ“Š Update Summary',
            items: [
              '<strong>INNER SANCTUM:</strong> 3 critical fixes (hiring, upgrades, elite display)',
              '<strong>AI SYSTEM:</strong> Complete request management overhaul with settings UI',
              '<strong>SAFETY:</strong> Enhanced null-safety throughout upgrade calculations',
              '<strong>USER EXPERIENCE:</strong> New settings panel for AI request control',
              '<strong>IMPACT:</strong> Eliminates AI request errors, fixes endgame location issues',
              '<strong>TECHNICAL:</strong> ~100 lines new queue system, automatic integration',
              '<strong>COMPATIBILITY:</strong> Zero breaking changes, works with existing saves'
            ]
          }
        ]
      },
      {
        version: '2511132155',
        date: 'November 13, 2025',
        title: 'ğŸ¯ Quality of Life Update - Name Editing, Autosaves, Polish & Balance',
        changes: [
          {
            category: 'âœ¨ New Features',
            items: [
              '<strong>âœï¸ Edit NPC Names in Overview Tab:</strong> Rename employees directly from Overview with validation (no duplicates, min 2 chars)',
              '<strong>ğŸ’¾ Autosave Snapshots:</strong> 10 rotating snapshot slots (every 5 min) = 50 minutes of recovery history',
              '<strong>ğŸ§ Beautified Orcs:</strong> Modern athletic aesthetic instead of brutal warriors (gym-toned, radiant skin, cute tusks)',
              '<strong>ğŸ’¬ Natural AI Conversations:</strong> Eliminated exhausting purple prose - NPCs talk like normal people now',
              '<strong>ğŸ—‘ï¸ Cleaner Social Feed:</strong> Failed posts discard completely instead of posting generic spam'
            ]
          },
          {
            category: 'âš–ï¸ Balance Changes',
            items: [
              '<strong>ğŸ® Late Game Content:</strong> Rebalanced bosses for higher difficulty, added late-game upgrades',
              '<strong>ğŸ’° Offline Earnings:</strong> Adjusted base offline earning rates',
              '<strong>ğŸ“Š Upgrade Rebalancing:</strong> Location-specific costs, increased upper limits',
              '<strong>âš™ï¸ Difficulty Controls:</strong> New employee start stat difficulty settings'
            ]
          },
          {
            category: 'ğŸ› Bug Fixes',
            items: [
              '<strong>ğŸ’¾ Save Migration:</strong> Fixed kv.gameSave.del() â†’ delete() TypeError',
              '<strong>ğŸ”¢ Number Display:</strong> Fixed abbreviation formatting issues'
            ]
          },
          {
            category: 'ğŸ¨ Content Additions',
            items: [
              '<strong>ğŸ–¼ï¸ Art Styles Expanded:</strong> 20+ professional art style options for image generation'
            ]
          }
        ]
      },
      {
        version: '2511130002',
        date: 'November 13, 2025',
        title: 'ğŸ’° CRITICAL FIX: Money Request Timing (Player Feedback)',
        changes: [
          {
            category: 'ğŸ’° Money Request System - Timing & Relationship Requirements',
            items: [
              '<strong>PLAYER FEEDBACK:</strong> "I have noticed that the NPC\'s almost always send a money request after the first or the second message" - Players felt NPCs were asking for money way too early in relationships.',
              '<strong>PROBLEM ANALYSIS:</strong> Three timing issues allowed premature money requests:',
              '<strong>â€¢ Too-Short Activity Window:</strong> Only 5 minutes since last message before considering conversation "inactive"',
              '<strong>â€¢ Too-Short Player Protection:</strong> Only 10 minutes since player\'s last message before NPCs could interrupt',
              '<strong>â€¢ No Relationship Gate:</strong> NPCs could request money after just 1-2 messages with zero relationship development',
              '<strong>SOLUTION - TRIPLE FIX:</strong>',
              '<strong>â° Extended Activity Window:</strong> 5 minutes â†’ 60 minutes (12x increase)',
              '<strong>â° Extended Player Protection:</strong> 10 minutes â†’ 120 minutes (12x increase)',
              '<strong>ğŸ’• Relationship Requirement:</strong> NOW REQUIRES 30+ messages exchanged before money requests are even considered',
              '<strong>TECHNICAL CHANGES:</strong>',
              '<strong>â€¢ Line ~30182:</strong> evaluateProactiveMessageTriggers() - Updated all timing checks',
              '<strong>â€¢ Conversation Inactivity:</strong> timeSinceLastMessage > 60 minutes (was 5)',
              '<strong>â€¢ Player Activity Check:</strong> timeSinceLastPlayerMessage > 120 minutes (was 10)',
              '<strong>â€¢ Message Count Gate:</strong> conversation.messages.length < 30 early returns',
              '<strong>BEHAVIOR CHANGES:</strong>',
              '<strong>Before:</strong> NPCs could send money requests after 1-2 messages if 5 minutes passed',
              '<strong>After:</strong> NPCs wait for 30+ messages AND 60+ minutes of inactivity AND 120+ minutes since your last message',
              '<strong>ğŸ“Š IMPACT ESTIMATE:</strong> Reduces premature money requests by ~90%. Money requests now only happen in established relationships after significant conversation history.',
              '<strong>RESULT:</strong> NPCs no longer pester you for money immediately after meeting. Money requests now feel appropriate and relationship-appropriate!'
            ]
          },
          {
            category: 'ğŸ“Š Update Summary',
            items: [
              '<strong>FILES MODIFIED:</strong> 1 (index.html)',
              '<strong>LINES CHANGED:</strong> ~15 lines in evaluateProactiveMessageTriggers()',
              '<strong>TIMING ADJUSTMENTS:</strong> 3 critical thresholds increased',
              '<strong>NEW REQUIREMENTS:</strong> 1 (30-message minimum)',
              '<strong>PLAYER IMPACT:</strong> Immediate - affects all conversations',
              '<strong>COMPILATION:</strong> âœ… No errors'
            ]
          }
        ]
      },
      {
        version: '2511130001',
        date: 'November 13, 2025',
        title: 'âœ¨ NEW FEATURES: Character Name Editing + Fantasy/Anthro Races',
        changes: [
          {
            category: 'âœï¸ NEW: Character Name Editing with Validation',
            items: [
              '<strong>EDIT CHARACTER NAMES:</strong> You can now change employee names in the bio modal while in edit mode! The name field is fully editable with comprehensive validation.',
              '<strong>VALIDATION SYSTEM:</strong> Prevents common issues with name changes:',
              '<strong>â€¢ Empty Name Check:</strong> Cannot save blank or whitespace-only names',
              '<strong>â€¢ Minimum Length:</strong> Names must be at least 2 characters long',
              '<strong>â€¢ Duplicate Detection:</strong> Cannot create duplicate names - checks against all active employees (case-insensitive)',
              '<strong>â€¢ Onboarding Queue Check:</strong> Also checks names in the onboarding queue to prevent conflicts',
              '<strong>â€¢ usedEmployeeNames Sync:</strong> Automatically updates the global name tracking Set (removes old name, adds new name)',
              '<strong>SAFETY FEATURES:</strong>',
              '<strong>â€¢ Auto-Revert:</strong> If validation fails, the name field automatically reverts to the original value',
              '<strong>â€¢ Clear Errors:</strong> Specific error notifications tell you exactly what went wrong',
              '<strong>â€¢ Success Confirmation:</strong> Shows notification with old â†’ new name when successful',
              '<strong>DATA INTEGRITY:</strong> All references remain intact:',
              '<strong>â€¢ Chat History:</strong> Uses employee IDs, not names (safe)',
              '<strong>â€¢ Relationships:</strong> Uses employee IDs, not names (safe)',
              '<strong>â€¢ Social Posts:</strong> Uses employee IDs, not names (safe)',
              '<strong>HOW TO USE:</strong> Open any employee bio â†’ Click "âœï¸ Edit" â†’ Click the name field â†’ Type new name â†’ Click "ğŸ’¾ Save"',
              '<strong>TECHNICAL:</strong> Name validation runs BEFORE the main save handler, with early return on failure. Name field is explicitly excluded from the general field save loop to prevent double-processing.'
            ]
          },
          {
            category: 'ğŸ§¬ NEW: Fantasy & Anthropomorphic Races System',
            items: [
              '<strong>SPECIES DIVERSITY:</strong> Employees can now be generated as fantasy and anthropomorphic species! Configure in HR â†’ Gender Options (now "Gender & Race Options").',
              '<strong>PROPORTIONAL DISTRIBUTION:</strong> Works exactly like gender sliders - adjust percentages that must total 100%.',
              '<strong>AVAILABLE RACES:</strong>',
              '<strong>Fantasy Races:</strong>',
              '<strong>â€¢ ğŸ‘¤ Human:</strong> Standard humans (default: 100%)',
              '<strong>â€¢ ğŸ§ Elf:</strong> Graceful with pointed ears and ethereal beauty',
              '<strong>â€¢ ï¿½ Orc:</strong> Muscular with green skin, tusks, strong jawline',
              '<strong>â€¢ ğŸ˜ˆ Demon:</strong> Horns, spaded tail, pale skin with red undertones',
              '<strong>Anthropomorphic Races:</strong>',
              '<strong>â€¢ ğŸ¦Š Foxkin:</strong> Fox ears, fluffy tail, sharp canine features',
              '<strong>â€¢ ï¿½ Wolfkin:</strong> Wolf ears, tail, fierce golden eyes',
              '<strong>â€¢ ï¿½ Catkin:</strong> Cat ears, tail, feline eyes with slit pupils',
              '<strong>â€¢ ğŸ° Rabbitkin:</strong> Long rabbit ears, cotton ball tail, soft features',
              '<strong>SLIDER SYSTEM:</strong>',
              '<strong>â€¢ Proportional Normalization:</strong> Sliders auto-adjust to maintain 100% total',
              '<strong>â€¢ Real-time Updates:</strong> Live percentage display for each race',
              '<strong>â€¢ Visual Feedback:</strong> Total turns red if not exactly 100%',
              '<strong>â€¢ Smart Distribution:</strong> When you change one slider, others adjust proportionally',
              '<strong>PHYSICAL INTEGRATION:</strong> Race features automatically added to descriptions:',
              '<strong>â€¢ Ears:</strong> "pointed elf ears", "cat ears", "fox ears", "wolf ears", "long rabbit ears", "small pointed horns"',
              '<strong>â€¢ Tails:</strong> "cat tail", "fluffy fox tail", "wolf tail", "cotton ball tail", "spaded demon tail"',
              '<strong>â€¢ Skin:</strong> "green skin" (orcs), "pale skin with subtle red undertones" (demons)',
              '<strong>â€¢ Other:</strong> "ethereal beauty", "feline eyes with slit pupils", "tusks", "fierce golden eyes", etc.',
              '<strong>IMAGE GENERATION:</strong> Physical descriptions include race features in AI prompts:',
              '<strong>â€¢ Short Description:</strong> "average height slim foxkin woman with..."',
              '<strong>â€¢ Full Description:</strong> Includes "Distinctive features: fox ears, fluffy fox tail, sharp canine features"',
              '<strong>â€¢ Gender-Neutral Terms:</strong> Uses "kin" suffix (foxkin, wolfkin, etc.) instead of gendered terms',
              '<strong>UI DESIGN:</strong>',
              '<strong>â€¢ Organized Layout:</strong> Fantasy races grouped separately from anthropomorphic races',
              '<strong>â€¢ Color-Coded:</strong> Each race has unique accent colors',
              '<strong>â€¢ Category Headers:</strong> Clear "âœ¨ Fantasy Races" and "ğŸ¾ Anthropomorphic Races" sections',
              '<strong>â€¢ Descriptive Text:</strong> Each race includes a brief description',
              '<strong>TECHNICAL IMPLEMENTATION:</strong>',
              '<strong>â€¢ selectRaceForEmployee():</strong> Weighted random selection matching gender system',
              '<strong>â€¢ getRaceFeatures():</strong> Returns race-specific physical attributes',
              '<strong>â€¢ normalizeRaceSliders():</strong> Auto-balances percentages to 100%',
              '<strong>â€¢ Race Field:</strong> Added to employee objects alongside gender',
              '<strong>BACKWARDS COMPATIBLE:</strong> Existing employees default to "human" race. System works seamlessly with all existing features.',
              '<strong>SETTINGS PERSISTENCE:</strong> Race settings save with your game and persist across sessions',
              '<strong>DEFAULT CONFIGURATION:</strong> All races start at 0% except Human (100%) - opt-in system',
              '<strong>PERFECT FOR:</strong> Fantasy office settings, furry-friendly gameplay, diverse character rosters, roleplay scenarios, creative storytelling'
            ]
          }
        ]
      },
      {
        version: '2511122010',
        date: 'November 12, 2025',
        title: 'ğŸ’¾ MAJOR: Multi-Slot Save Manager + ğŸ› Critical Player Feedback Fixes',
        changes: [
          {
            category: 'ğŸ’¾ NEW: Advanced Multi-Slot Save System',
            items: [
              '<strong>ğŸ‰ BRAND NEW SAVE MANAGER:</strong> Complete overhaul of the save system inspired by modern RPGs! Replace simple save/load buttons with a full-featured modal interface for managing multiple save slots.',
              '<strong>ğŸ’¾ MULTI-SLOT ARCHITECTURE:</strong> Create unlimited named saves - no more overwriting your only save! Save types: Manual Saves (your named saves), Quick Saves (F5 shortcut), Autosaves (automatic every 5 seconds).',
              '<strong>âŒ¨ï¸ KEYBOARD SHORTCUTS:</strong> Press F5 anywhere for instant Quick Save, F9 for Quick Load (loads most recent quick save), Esc to close Save Manager.',
              '<strong>ğŸ¨ BEAUTIFUL MODAL INTERFACE:</strong> Tab-based view (Manual / Auto & Quick), sortable table (Name, Day, Saved At, Playtime), search/filter by save name, inline editing (double-click to rename), row selection and highlights.',
              '<strong>ğŸ“Š RICH METADATA TRACKING:</strong> Every save stores: Save date/time, custom save name, save type (auto/quick/manual), total playtime, current game day, money amount, employee count, prestige level.',
              '<strong>âœ¨ POWERFUL FEATURES:</strong>',
              '<strong>â€¢ Create New Save:</strong> "+ Create New Save" button in manual tab',
              '<strong>â€¢ Rename Saves:</strong> Double-click any save name to edit inline',
              '<strong>â€¢ Delete Saves:</strong> Click âœ• button with confirmation (autosave protected)',
              '<strong>â€¢ Export/Import:</strong> Download individual saves as JSON files, import saves from backup files',
              '<strong>â€¢ Load Saves:</strong> Click "Load" button or double-click save row',
              '<strong>â€¢ Continue:</strong> Quick "Continue" button loads most recent save',
              '<strong>â€¢ Sort & Filter:</strong> Click column headers to sort, search box for filtering',
              '<strong>ğŸ”’ SAFETY FEATURES:</strong> Autosave slot cannot be deleted or renamed, confirmation dialogs before deleting saves, duplicate name checking prevents overwrites, corrupted save validation before loading, automatic migration from legacy format.',
              '<strong>ğŸ“± SETTINGS PANEL UPDATE:</strong> Replaced 4 individual buttons (Save, Load, Export, Import) with single "ğŸ’¾ Save/Load Manager" button, added keyboard shortcut hints (F5/F9), clean gradient styling with hover effects.',
              '<strong>ğŸ”„ AUTOMATIC MIGRATION:</strong> Old single-save format automatically converts to new system on first load, creates "migrated_legacy" save with all your progress, preserves original save for safety, completely transparent to users.',
              '<strong>ğŸ¨ VISUAL DESIGN:</strong> Dark blue theme matching FUOC style (#16213e), cyan accents (#00d4ff), save type badges (blue=auto, green=quick, default=manual), smooth animations and transitions, custom scrollbar styling, empty state messages.',
              '<strong>ğŸ’¾ STORAGE FORMAT:</strong> Slot naming: fuoc_save_autosave, fuoc_save_quick_123, fuoc_save_My_Adventure. Backward compatible with old saveGame() function. Uses existing kv-plugin for persistence.',
              '<strong>ğŸ“ CONSOLE LOGGING:</strong> All operations log with [SaveManager] prefix, shows save/load/delete/rename/export/import actions, emoji indicators for different operation types.',
              '<strong>ğŸ“Š CODE STATS:</strong> ~1,600 lines of new code added, 9 new backend functions, ~690 line SaveManager UI class, ~508 lines of CSS styling, zero compilation errors.',
              '<strong>âœ… BENEFITS:</strong> Never lose progress from overwriting saves, experiment with different game paths, backup important milestones, quick save before risky decisions, organize saves with meaningful names, modern professional UX.'
            ]
          },
          {
            category: 'ğŸ’° CRITICAL FIX: Money Request Frequency',
            items: [
              '<strong>PLAYER FEEDBACK:</strong> "Love how everyone of my employees keeps asking me for ridiculous amounts of money." - Players felt constantly pestered by money requests.',
              '<strong>PROBLEM:</strong> NPCs requesting money every 24 game hours (1 day), ~15% of ALL proactive messages were money requests, felt like constant spam.',
              '<strong>SOLUTION - DRASTICALLY REDUCED:</strong>',
              '<strong>â° Cooldown increased:</strong> 24 hours â†’ 168 hours (7 game days)',
              '<strong>â° Emergency requests:</strong> 72 hours minimum (3 days) even when broke',
              '<strong>ğŸ“Š Target frequency:</strong> 15% â†’ 3-5% of proactive messages',
              '<strong>ğŸ“‰ Weight reductions:</strong> Base: 8â†’2 (75% cut), Broke: 20â†’8 (60% cut), Low cash: 14â†’5 (64% cut)',
              '<strong>ğŸ¯ Stricter requirements:</strong> Now requires affection > 50 AND trust > 50 (was 40/40)',
              '<strong>ğŸ’° Updated thresholds:</strong> Low on cash: 7â†’14 days spending, Broke: 2â†’7 days spending',
              '<strong>RESULT:</strong> Money requests are now rare, meaningful events that only happen when NPCs genuinely need help. No more constant financial nagging!'
            ]
          },
          {
            category: 'ğŸ‘» CRITICAL FIX: Fired Employees in Social Feed',
            items: [
              '<strong>PLAYER FEEDBACK:</strong> "Some characters i fired keep talking in socials not sure how to fix that" - Ex-employees haunting the social feed.',
              '<strong>PROBLEM:</strong> Social feed showed posts from ALL employees ever hired, fired/terminated employees continued posting, no filter to remove ex-employees.',
              '<strong>SOLUTION:</strong> Added Step 0 to filterAndSortPosts() that filters out fired employees BEFORE all other filters, checks current employee roster and only shows posts from active employees, preserves player and system posts.',
              '<strong>ğŸ“Š LOGGING:</strong> Console shows how many posts were filtered out from ex-employees.',
              '<strong>RESULT:</strong> Social feed now only shows posts from current employees. Ex-employees no longer haunt your feed!'
            ]
          },
          {
            category: 'â˜ ï¸ CRITICAL FIX: PR Meeting Extreme Content',
            items: [
              '<strong>PLAYER FEEDBACK:</strong> "Just held a PR meeting, after roughly 10 suggestions made by the AI, they suggested we tattoo our company logo onto terminal ill patients morphine ridden skin, and to have suicide notes with our logo live sent on tv." - AI generating horrifying, morbid PR suggestions.',
              '<strong>PROBLEM:</strong> No content safety filters in meeting responses, AI could generate morbid/extreme/illegal suggestions, no boundaries on what NPCs could suggest.',
              '<strong>SOLUTION - COMPREHENSIVE CONTENT SAFETY:</strong> Added safety rules to all meeting prompts:',
              '<strong>âŒ BLOCKS:</strong> Suicide, self-harm, death references, terminal illness/hospices/medical trauma, exploitation of vulnerable people (sick/dying/imprisoned), extreme violence/gore/morbid content, illegal activities (murder/terrorism/exploitation)',
              '<strong>âœ… ENFORCES:</strong> Ethical, legal, reasonable suggestions, constructive redirection if topic gets dark',
              '<strong>RESULT:</strong> NPCs now stay within appropriate boundaries during meetings. No more horrifying PR disasters!'
            ]
          },
          {
            category: 'ğŸ—‘ï¸ BUG FIX: Clear Chat Button',
            items: [
              '<strong>PLAYER FEEDBACK:</strong> "The \'clear\' button in chat doesn\'t work" - Button failing silently.',
              '<strong>PROBLEM:</strong> gameState.activeChat could be either ID (string) or object, code assumed it was always an ID, failed silently when activeChat was an object.',
              '<strong>SOLUTION:</strong> Added flexible handling: const activeChatId = gameState.activeChat?.id || gameState.activeChat, better validation checks, enhanced console logging for debugging, improved user feedback.',
              '<strong>RESULT:</strong> Clear button now works reliably regardless of activeChat format!'
            ]
          },
          {
            category: 'ğŸ“¸ BUG FIX: Chat Images Not Generating',
            items: [
              '<strong>PLAYER FEEDBACK:</strong> "In chats its describing an image but not sending an image" - NPCs saying "Here\'s a picture" without generating it.',
              '<strong>PROBLEM:</strong> Agreement detection too strict, missed cases where NPC described sending without using specific keywords.',
              '<strong>SOLUTION - IMPROVED DETECTION:</strong>',
              '<strong>â€¢ Added keywords:</strong> "attaching", "attached" to strong agreement',
              '<strong>â€¢ Added describingSending check:</strong> "send", "sent", "sending", "here is", "this is", "look at", "check out"',
              '<strong>â€¢ Added imageDescribed check:</strong> NPC mentions "picture", "photo", "selfie", "image"',
              '<strong>â€¢ Combined logic:</strong> Agrees if describing sending + mentioning image + no refusal',
              '<strong>â€¢ Enhanced logging:</strong> Shows when image detected, type requested, whether NPC agreed, response snippet',
              '<strong>RESULT:</strong> NPCs now actually send images when they say they will. More reliable image generation!'
            ]
          },
          {
            category: 'âœ… Scene Visualization Verification',
            items: [
              '<strong>PLAYER FEEDBACK:</strong> "scene visualization stopped using the character description" - Concern about missing character details.',
              '<strong>STATUS:</strong> Already working correctly! visualizeCurrentScene() calls getPhysicalDescriptionForPrompt(emp) which includes full physical appearance, active flags (pregnant, chastity, pierced, etc.), and passes description to AI.',
              '<strong>VERIFIED:</strong> Feature is implemented and functional - no changes needed.'
            ]
          },
          {
            category: 'ğŸ“Š Update Summary',
            items: [
              '<strong>FILES MODIFIED:</strong> 1 (index.html)',
              '<strong>TOTAL NEW CODE:</strong> ~1,750 lines (1,600 save system + 150 fixes)',
              '<strong>BALANCE CHANGES:</strong> 1 major (money request frequency)',
              '<strong>SAFETY FEATURES:</strong> 1 new (meeting content filters)',
              '<strong>BUG FIXES:</strong> 3 critical (fired employees, clear button, image detection)',
              '<strong>MAJOR FEATURES:</strong> 1 (complete save manager overhaul)',
              '<strong>COMPILATION:</strong> âœ… No errors',
              '<strong>GIT COMMITS:</strong> 2 (dc5ae84 save system, 9e418d0 feedback fixes)'
            ]
          }
        ]
      },
      {
        version: '2511051900',
        date: 'November 5, 2025',
        title: 'ğŸ› Critical Bug Fixes - Chat, Posts, Selfies & Rehire System',
        changes: [
          {
            category: 'ğŸ’¬ Chat Message Persistence Fix',
            items: [
              '<strong>FIXED: Messages Disappearing on Chat Close:</strong> Chat messages no longer disappear when you close the chat modal before the next autosave.',
              '<strong>ROOT CAUSE:</strong> Autosave runs every 5 seconds. If you sent messages and closed the chat within those 5 seconds, the messages would be lost.',
              '<strong>SOLUTION:</strong> Added explicit saveGame() call when closing chat modal. Messages are now immediately persisted to localStorage/kv-plugin.',
              '<strong>IMPACT:</strong> You can safely close chats immediately after sending messages without losing your conversation history.'
            ]
          },
          {
            category: 'ğŸ“ Post Regeneration Context Preservation',
            items: [
              '<strong>FIXED: Post Refresh Losing Context:</strong> Regenerating/refreshing posts now maintains the same topic and theme instead of generating completely random new content.',
              '<strong>ROOT CAUSE:</strong> The regeneratePost() function was calling the AI without any reference to the original post content, so each refresh created an entirely new random post.',
              '<strong>SOLUTION:</strong> Modified AI prompt to include the original post content as context with instruction: "Rewrite this same idea with different wording, keep the same vibe and topic."',
              '<strong>IMPACT:</strong> Clicking refresh on a work achievement post will generate different wording of the same achievement, not a completely unrelated post about lunch or weekend plans.'
            ]
          },
          {
            category: 'ğŸ“¸ Meeting Selfie Error Handling',
            items: [
              '<strong>FIXED: Meeting Selfie Silent Failures:</strong> Meeting selfie requests now provide helpful error messages instead of failing silently.',
              '<strong>ROOT CAUSE:</strong> The requestGroupSelfie() function had minimal error checking. If your profile was incomplete or participants were invalid, it would fail without telling you why.',
              '<strong>SOLUTION:</strong> Added 5 validation checkpoints with specific error messages:',
              '<strong>â€¢ Check 1:</strong> Verify participants array exists',
              '<strong>â€¢ Check 2:</strong> Verify player profile is complete (shows "Please set up your profile in Settings")',
              '<strong>â€¢ Check 3:</strong> Verify at least one valid participant',
              '<strong>â€¢ Check 4:</strong> Filter out invalid/deleted employees',
              '<strong>â€¢ Check 5:</strong> Confirm remaining participants after filtering',
              '<strong>IMPACT:</strong> Clear error messages guide you to fix issues (e.g., completing your profile) instead of wondering why the selfie button doesn\'t work.'
            ]
          },
          {
            category: 'ğŸ”§ Rehire System Complete Overhaul',
            items: [
              '<strong>FIXED: Duplicate Employee Names:</strong> You can no longer hire the same person twice (e.g., two "Lydia Hunt" employees).',
              '<strong>FIXED: Rehires Going Through Onboarding:</strong> Rehired employees no longer go through the onboarding process or generate new info.',
              '<strong>ROOT CAUSE #1:</strong> When selecting a candidate for hire, their name was marked as "used" during generation but not verified again at selection time. If someone was still in the onboarding queue, the same name could be regenerated.',
              '<strong>ROOT CAUSE #2:</strong> Clicking "â­ Rehire" was calling selectManagerCandidate() which treats everyone as a new hire and adds them to the onboarding queue, even though these were returning employees with saved data.',
              '<strong>SOLUTION - Part 1 (Duplicate Names):</strong> ',
              '<strong>â€¢ Immediate Name Marking:</strong> Added name to usedEmployeeNames Set immediately when candidate is selected, not just when finalized',
              '<strong>â€¢ Onboarding Sync:</strong> generateUniqueName() now checks the onboarding queue and adds those names to the Set before generating new names',
              '<strong>â€¢ Safety Checks:</strong> Added Set initialization checks and console logging for debugging',
              '<strong>SOLUTION - Part 2 (Rehire Onboarding):</strong>',
              '<strong>â€¢ Route Fix:</strong> Rehire candidates now call finalizeRehire() instead of selectManagerCandidate() when clicked',
              '<strong>â€¢ Data Preservation:</strong> All rehire data (stats, skills, personality, physical, chat history, etc.) is restored from the rehire pool',
              '<strong>â€¢ Skip Onboarding:</strong> Rehired employees are added directly to gameState.employees with onboarding: false, hired: true, bioComplete: true',
              '<strong>â€¢ ID Tracking:</strong> Preserves original rehire pool ID to properly remove them from the pool after hiring',
              '<strong>WHAT THIS MEANS:</strong>',
              '<strong>âœ… No Duplicate Names:</strong> Each employee name is unique across active employees, onboarding queue, and rehire pool',
              '<strong>âœ… Instant Rehires:</strong> Former employees are ready to work immediately with all their history intact',
              '<strong>âœ… Data Preservation:</strong> Rehired employees keep their productivity bonuses, loyalty bonuses, relationship stats, chat history, and memories',
              '<strong>âœ… No Bio Generation:</strong> Rehires don\'t get new random bios or stats - everything is preserved from their previous employment',
              '<strong>IMPACT:</strong> The rehire system now works exactly as intended - bringing back former employees with all their context and history, not treating them as brand new hires.'
            ]
          },
          {
            category: 'ğŸ¨ UI Layout Optimization',
            items: [
              '<strong>IMPROVED: Social Feed Layout:</strong> Made the social feed sidebar more compact and extended the main feed area.',
              '<strong>CHANGES:</strong>',
              '<strong>â€¢ Sidebar Width:</strong> Reduced from 280px to 220px',
              '<strong>â€¢ Container Height:</strong> Increased from calc(100vh - 200px) to calc(100vh - 160px)',
              '<strong>â€¢ Spacing:</strong> Reduced gap from 20px to 15px, padding from 12px to 8px',
              '<strong>â€¢ Font Sizes:</strong> Reduced from 0.95rem to 0.85rem for more compact display',
              '<strong>â€¢ Button Text:</strong> Shortened labels ("All Content" â†’ "All", "Popular (5+ reactions)" â†’ "Popular (5+)")',
              '<strong>â€¢ Scrolling:</strong> Added overflow-y: auto to sidebar for better scroll behavior',
              '<strong>IMPACT:</strong> More screen space for posts, less scrolling needed, cleaner visual hierarchy.'
            ]
          }
        ]
      },
      {
        version: '2511051245',
        date: 'November 5, 2025',
        title: 'ğŸ­ THE ALGORITHMâ„¢ + Mean Girl Drama System',
        changes: [
          {
            category: 'ğŸ“Š NEW: The Algorithmâ„¢ - Advanced Social Feed System',
            items: [
              '<strong>ğŸ”¥ HOT SORTING:</strong> Reddit-style hot algorithm shows what\'s trending RIGHT NOW based on engagement divided by time decay',
              '<strong>ğŸ† BEST SORTING:</strong> Find the highest quality posts with time filters (Hour/Day/Week/Month/All Time)',
              '<strong>ğŸ“… RECENT SORTING:</strong> Classic chronological view - newest posts first',
              '<strong>ğŸ’¥ CONTROVERSIAL SORTING:</strong> See posts with the most disagreement - high engagement but mixed upvotes/downvotes',
              '<strong>ğŸ¨ CONTENT RATING FILTERS:</strong> Toggle between All/SFW/NSFW/Explicit to control what you see',
              '<strong>ğŸ“ POST TYPE FILTERS:</strong> Filter by Text/Images/Selfies/Work Posts',
              '<strong>ğŸ‘¥ AUTHOR FILTERS:</strong> View posts from everyone, just you, people you follow, or specific employees',
              '<strong>ğŸ”¥ ENGAGEMENT FILTERS:</strong> Show All Posts, Popular (10+ likes), Viral (25+ likes), or Active Discussion (5+ comments)',
              '<strong>ğŸ” REAL-TIME SEARCH:</strong> Search post content, authors, hashtags, and mentions with live result counts',
              '<strong>ğŸ’¾ SAVED PREFERENCES:</strong> All your filter settings are remembered between sessions'
            ]
          },
          {
            category: 'ğŸ˜ˆ NEW: Mean Girl Drama System',
            items: [
              '<strong>ğŸ‘ DOWNVOTING:</strong> NPCs now downvote posts they don\'t like - controversial sorting finally works!',
              '<strong>ğŸ’” RIVALRY DRAMA:</strong> Enemies downvote each other 70% of the time, leaving shade in their wake',
              '<strong>ğŸ’… SNARKY COMMENTS:</strong> 25% chance for downvoters to leave catty comments like "Sure, if you say so ğŸ™„" or "Must be nice"',
              '<strong>ğŸ˜³ PRUDISH REACTIONS:</strong> Conservative NPCs clutch their pearls at explicit content (+50% downvote chance)',
              '<strong>ğŸ˜¤ JEALOUS HATERS:</strong> Mean NPCs target popular posts, lazy NPCs hate on work posts',
              '<strong>âš”ï¸ ESCALATING FEUDS:</strong> Each downvote reduces relationship by -3, can escalate to full rivalry status',
              '<strong>ğŸ² RANDOM CATTINESS:</strong> Even neutral NPCs have a 25% chance to be randomly mean - keeps things spicy'
            ]
          },
          {
            category: 'ğŸ“¸ Profile & Meeting Enhancements',
            items: [
              '<strong>ğŸ¢ COMPANY NAME:</strong> Your company name now appears on your profile (not just description)',
              '<strong>ğŸ¤³ PLAYER SELFIES FIXED:</strong> @player and @TheBoss mentions now work properly in image generation',
              '<strong>ğŸ’¬ AUTOCOMPLETE:</strong> Type @TheBoss or @player in any image prompt for instant suggestions',
              '<strong>ğŸ¬ MEETING VISUALIZATIONS:</strong> Generate AI images of your current meeting scene',
              '<strong>ğŸ“¸ GROUP SELFIES:</strong> Request all meeting participants to pose together (+2 affection boost for everyone)',
              '<strong>ğŸ“Š MEETING STATS:</strong> Track messages sent, participants, images shared, and money spent per meeting',
              '<strong>ğŸ¤– AI MEETING SUMMARIES:</strong> Generate smart summaries of what happened in each meeting',
              '<strong>ğŸ§¹ AUTO-CLEANUP:</strong> Old/deleted employees are automatically removed from meeting participants on load'
            ]
          },
          {
            category: 'ğŸ’° Money Request Improvements',
            items: [
              '<strong>ğŸ’³ PROPER MODAL UI:</strong> Money requests now use the proper Approve/Counter/Deny interface instead of plain text',
              '<strong>â° COOLDOWN SYSTEM:</strong> 1 hour cooldown between money requests prevents spam',
              '<strong>ğŸ² UNPROMPTED REQUESTS:</strong> Most money requests now come out of the blue, not mid-conversation',
              '<strong>âš–ï¸ BALANCED FREQUENCY:</strong> ~15% of proactive messages are money requests - feels natural not annoying',
              '<strong>ğŸ’° SMART AMOUNTS:</strong> Request amounts calculated based on NPC spending rate, bank balance, and financial need'
            ]
          },
          {
            category: 'ğŸ’¬ Proactive Message Personalization',
            items: [
              '<strong>ğŸ’• RELATIONSHIP-AWARE MESSAGING:</strong> NPCs now send more personal messages based on relationship depth',
              '<strong>âœ¨ CLOSE RELATIONSHIPS (70+ affection, 20+ messages):</strong> Reference earlier conversations, pick up hanging threads, show they\'ve been thinking about you, bring up inside jokes and shared moments',
              '<strong>ğŸŒ± FRIENDLY RELATIONSHIPS (40+ affection, 10+ messages):</strong> More comfortable and personal, mix professional and personal topics, reference past conversations naturally',
              '<strong>ğŸ‘” PROFESSIONAL RELATIONSHIPS (Low affection, few messages):</strong> Work-focused with friendly touches, appropriate getting-to-know-you questions',
              '<strong>ğŸ¯ SMART CONTEXT:</strong> Work updates connect to previous discussions for close relationships, casual chats reference specific shared topics, questions build on conversation history',
              '<strong>ğŸš« NO MORE GENERIC SPAM:</strong> Close relationships won\'t send random "quick q" or generic work updates - messages feel authentic and connected'
            ]
          },
          {
            category: 'ğŸ“¸ Image Request Fixes',
            items: [
              '<strong>ğŸ¨ FIXED: Custom Image Requests:</strong> NPCs now send images that actually match what they say they\'re sending!',
              '<strong>ğŸ”§ ROOT CAUSE:</strong> Generic presets were overriding custom requests - even detailed requests would generate generic "casual selfie" images',
              '<strong>âœ… PRIORITY FIX:</strong> Custom prompts now take priority over generic templates - AI analyzes your request and conversation context',
              '<strong>ğŸ–ï¸ CONTEXT-AWARE:</strong> Detailed requests like "send your island vacation balcony pics" now generate appropriate matching images',
              '<strong>ğŸ’¯ ACCURATE RESULTS:</strong> What NPCs describe in their message now matches the actual image they send'
            ]
          }
        ]
      },
      {
        version: '2511032200',
        date: 'November 3, 2025',
        title: 'ğŸ’¬ MAJOR: Group Meetings System - Multi-NPC Dynamic Conversations',
        changes: [
          {
            category: 'ğŸ’¬ NEW: Group Meetings System',
            items: [
              '<strong>ğŸ‰ BRAND NEW TAB:</strong> Introducing the "Meetings" tab - a revolutionary group chat system where you can have dynamic conversations with up to 5 employees at once! NPCs interact with each other naturally, creating organic, emergent group dynamics.',
              '<strong>CREATE CUSTOM MEETINGS:</strong> Choose up to 5 employees to invite. Set a custom meeting name (e.g., "Q4 Planning", "Friday Night Drinks", "Emergency Meeting"). Configure reply limit (1-10 responses per player message). Meetings are persistent - they save automatically and you can return to them anytime.',
              '<strong>INTELLIGENT SPEAKER SELECTION:</strong> Advanced AI-driven priority system determines who speaks next based on multiple factors: Direct mentions (+100 priority), question detection (+30), recency penalty (recently spoken NPCs are less likely), silence bonus (NPCs who haven\'t spoken get +25), contextual keywords (management/technical/creative topics boost relevant NPCs), relationship levels (higher affection = slight boost), randomness (keeps conversations unpredictable).',
              '<strong>NATURAL GROUP DYNAMICS:</strong> NPCs reference each other\'s comments, build on previous points, and create threaded conversations. Anti-repetition system tracks overused phrases across last 5 messages and guides NPCs to bring fresh perspectives. Perspective Mode: NPCs only know about relationships and events they\'ve witnessed (secret relationships stay secret unless both parties are present).',
              '<strong>RELATIONSHIP-AWARE CONTEXT:</strong> Compact relationship maps show each NPC\'s connection to you and other participants (â™¥ relationship level, ğŸ”¥ attraction, kids, relationship flags). NPCs leverage their knowledge of group dynamics: "I noticed you two have been spending time together..." Dynamic history depth: 2-3 people = 25 messages context, 4 people = 20 messages, 5+ people = 15 messages (prevents token overflow).',
              '<strong>FLEXIBLE REPLY SYSTEM:</strong> Configurable reply limit per message (default: 5). NPCs take turns responding naturally - not everyone speaks every turn. Live reply counter shows remaining responses. Stop button to halt current reply chain if conversation gets too long. Turn-based structure: You speak â†’ NPCs respond up to limit â†’ Your turn again.',
              '<strong>RICH INTERACTION MENU:</strong> Click any participant avatar to open action menu: ğŸ’° Send Money (individual cash gifts), ğŸ Give Gift (show appreciation in meetings), ğŸ“· Request Image (ask specific NPC for photo), ğŸ“¤ Send Image (share photos directly). Plus global meeting actions: ğŸ’° Send Money (Group) - give cash to all participants at once, ğŸ• Order Food/Drinks - treat everyone to meals, ğŸ¬ Visualize Current Scene - AI-generated group photo of current situation, ğŸ“· Request Group Selfie - all NPCs pose together, ğŸ® Start Team Building Activity - boost morale of all participants.',
              '<strong>PROFESSIONAL UI/UX:</strong> Two-panel layout: Sidebar lists all meetings with participant avatars, main area shows active conversation. Clean chat interface with participant avatars for each message. Message regeneration per NPC response (â™»ï¸ button on hover). Meeting settings modal: Rename meetings, adjust reply limits, customize text/image size, view participant list. One-click meeting deletion with confirmation.',
              '<strong>CONVERSATION QUALITY:</strong> Higher temperature (0.9) for more personality variety in group settings. Stop sequences prevent run-on responses. Rich participant descriptions passed to AI. Dynamic history prevents token bloat in large meetings. Compact relationship notation saves tokens while preserving context.',
              '<strong>MOBILE RESPONSIVE:</strong> Collapsible sidebar with toggle button. Touch-friendly action menus. Adaptive text sizing. Optimized for all screen sizes.',
              '<strong>USE CASES:</strong> Business meetings with department heads, casual hangouts with friend groups, team building sessions, romantic encounters with multiple partners, drama-filled confrontations, party planning with social circles, office gossip sessions, training/mentoring groups.',
              '<strong>TECHNICAL MARVEL:</strong> 3,000+ lines of new code. Full integration with existing systems (gifts, money transfers, images, relationships). Persistent state management. Smart memory handling for performance. Console logging for debugging speaker selection and AI decisions.'
            ]
          },
          {
            category: 'ğŸ”§ Conversation System Improvements',
            items: [
              '<strong>FIXED: Regenerate Stat Penalty:</strong> Regenerating NPC responses in 1-on-1 conversations NO LONGER triggers stat change evaluation. Previously, re-rolling a response multiple times would compound negative stat changes if you were unlucky. Now stats are only evaluated when the original message is sent, not on regenerations.',
              '<strong>WHY THIS MATTERS:</strong> Sometimes you need to regenerate an AI response to get better quality or avoid bugs. You shouldn\'t be penalized with relationship damage just for using the regenerate button.',
              '<strong>TECHNICAL:</strong> Removed updateEmployeeStatsFromChat() call from regenerateMessage() function. Added explanatory comment in code. Regeneration count and temperature scaling still work normally.'
            ]
          }
        ]
      },
      {
        version: '2511021300',
        date: 'November 2, 2025',
        title: 'ğŸ› CRITICAL: Message Concatenation Bug Fix + ğŸ“¸ Smart Image Proof System',
        changes: [
          {
            category: 'ğŸ› Critical Bug Fixes',
            items: [
              '<strong>FIXED: Message Concatenation Bug:</strong> Resolved critical issue where NPC responses would concatenate entire conversation history into a single massive response. This occurred when the AI echoed back previous messages instead of generating only a new response.',
              '<strong>ROOT CAUSE:</strong> Conversation history was being passed to AI as plain text context, which the AI would sometimes interpret as content to include in its response rather than background information.',
              '<strong>PROMPT FIX:</strong> Wrapped conversation history with clear header "=== RECENT CONVERSATION (for context only - do NOT repeat or echo these messages) ===" and added explicit instruction: "CRITICAL: Respond ONLY as [Name] with a NEW single message. DO NOT repeat or include previous conversation messages in your response."',
              '<strong>SANITIZATION FIX:</strong> Enhanced sanitizeNpcResponse() with conversation history echo detection. If AI response contains multiple "Name: message" patterns (3+ instances), function now automatically extracts only the final new response and discards echoed history.',
              '<strong>FALLBACK PROTECTION:</strong> Added multi-layer extraction logic - first attempts to find last non-history line, then falls back to extracting last paragraph if heavy echoing detected (5+ pattern matches).',
              '<strong>IMPACT:</strong> NPCs now always generate single, fresh responses instead of accidentally repeating 5+ previous messages. Chat conversations remain clean and properly formatted.'
            ]
          },
          {
            category: 'ğŸ“¸ NEW: Universal Smart Image System',
            items: [
              '<strong>NEW: NPCs Respond with Images to ANYTHING!</strong> Massively expanded image detection system. NPCs can now generate and attach images for virtually ANY type of request - animals, food, nature, hobbies, selfies, nudes, and more!',
              '<strong>WORKS EVERYWHERE:</strong> Image detection works in ALL comment scenarios: NPCs replying to your comments on THEIR posts, NPCs commenting on YOUR posts, NPCs joining ongoing conversations.',
              '<strong>ANIMALS & PETS:</strong> Ask for cat/dog/pet pictures and NPCs will send adorable animal photos. Special feature: "pussy/kitty" requests have playful misinterpretation chance! ğŸ˜',
              '<strong>PLAYFUL MISUNDERSTANDING:</strong> When flirty NPCs (65+ flirtiness, 60+ desire) see requests for "pussy" or "kitties", 35% chance they "understand the assignment" and send a suggestive intimate photo instead of a cat. Others send actual cat pics.',
              '<strong>FOOD & DRINKS:</strong> Recognizes requests for: food/meals, coffee/lattes, cocktails/drinks, desserts/sweets. Generates appetizing food photography.',
              '<strong>NATURE & OUTDOORS:</strong> Detects: sunsets/sunrises, beaches/ocean, mountains/hiking, flowers/gardens. Creates beautiful nature photography.',
              '<strong>ACTIVITIES & HOBBIES:</strong> Responds to: books/reading, gaming, music/instruments with appropriate themed images.',
              '<strong>SEXUAL/INTIMATE:</strong> Full support for: nudes, sexy selfies, regular selfies, work photos, outfit pics, gym photos, artistic content. Context-aware based on request tone.',
              '<strong>INTELLIGENT FALLBACK:</strong> If specific category not detected, extracts key nouns from post to generate relevant image. Ultimate fallback: selfie.',
              '<strong>EXAMPLE SCENARIOS:</strong>',
              '<strong>â€¢ Wholesome:</strong> "I\'m feeling down. Show me your kitties" â†’ Multiple NPCs send cute cat photos ğŸ±',
              '<strong>â€¢ Playful:</strong> Same request â†’ Flirty Faith "misunderstands" and sends intimate close-up ğŸ˜ˆ, while shy Loretta sends actual cat pic',
              '<strong>â€¢ Food:</strong> "Post your best meal!" â†’ NPCs share delicious food photography ğŸ•',
              '<strong>â€¢ Nature:</strong> "Sunset pics?" â†’ Beautiful sunset photos from multiple NPCs ğŸŒ…',
              '<strong>â€¢ Challenge:</strong> "Sexiest selfie wins $1000" â†’ Faith/Vanessa/others compete with sexy selfies ğŸ’‹',
              '<strong>REUSABLE HELPER FUNCTION:</strong> detectAndGenerateCommentImage() handles all detection, context analysis, and generation. Used across all comment functions.',
              '<strong>DEBUG LOGGING:</strong> Console shows what type of image is being generated and special "[MISUNDERSTOOD]" tag when flirty NPCs playfully misinterpret.',
              '<strong>TECHNICAL:</strong> 50+ detection patterns covering animals, food, nature, hobbies, intimate content. Personality-driven behavior (flirtiness, desire affect interpretation). Graceful fallbacks at every level.'
            ]
          },
          {
            category: 'ğŸ’¬ Comment Generation Quality Fixes',
            items: [
              '<strong>FIXED: Meta-Commentary Leakage:</strong> Resolved issue where NPC comments would include instruction text like "Here\'s [Name]\'s comment based on their personality..." instead of just posting the comment naturally.',
              '<strong>FIXED: Third-Person Narration:</strong> Eliminated narration bleeding into comments such as "*Marie Todd\'s eyes scan the social feed*" or "*chuckle escapes*". NPCs now write comments as themselves, not describe themselves.',
              '<strong>FIXED: Name Prefix Problem:</strong> Removed erroneous name prefixes appearing in comments: "Kennedy Torres\' comment:", "Faith Starr\'s comment flashes on-screen:", etc.',
              '<strong>FIXED: Phrasing Issues:</strong> Changed past tense "Already sent my cat\'s glamour shot" to natural present tense "Here\'s my kitty! ğŸ±" when posting images. Comments now sound like real-time social media interaction.',
              '<strong>ENHANCED PROMPT:</strong> Complete rewrite of generateContextAwareComment() with explicit "CRITICAL RULES" section:',
              '<strong>â€¢ Rule 1:</strong> Write ONLY the comment text itself (5-20 words)',
              '<strong>â€¢ Rule 2:</strong> NO third-person narration (NO "*eyes scan*", "*chuckle escapes*")',
              '<strong>â€¢ Rule 3:</strong> NO meta-text (NO "Here\'s my comment:", "Based on personality:")',
              '<strong>â€¢ Rule 4:</strong> NO name prefixes (NO "[Name]:" or "[Name]\'s comment:")',
              '<strong>â€¢ Rule 5:</strong> Be natural and conversational like a real social media comment',
              '<strong>ENHANCED SANITIZATION:</strong> Multi-layer cleanup system catches any remaining issues:',
              '<strong>â€¢ Strip narration:</strong> Removes all asterisk-wrapped narration patterns',
              '<strong>â€¢ Remove meta prefixes:</strong> Eliminates "Here\'s", "Based on", "My comment is:", "I would say:"',
              '<strong>â€¢ Remove name prefixes:</strong> Aggressively strips "[Name]:" or "[Name]\'s comment:" patterns (fixed to avoid removing legitimate comment starts like "Well," or "Dog person?")',
              '<strong>â€¢ Remove character actions:</strong> Strips third-person narration like "[Name] raised an eyebrow at the screen, fingers already tapping."',
              '<strong>â€¢ Fix phrasing:</strong> Replaces "already sent/DM\'d" with "Here\'s" for natural present tense',
              '<strong>â€¢ Fallback detection:</strong> Checks for remaining meta-text patterns and triggers simple fallback',
              '<strong>IMPROVED IMAGE DETECTION:</strong> Enhanced regex patterns to catch more image claim variations:',
              '<strong>â€¢ Basic claims:</strong> "Posted!", "Here\'s mine!", "Sent!", "Sharing!" with or without emoji',
              '<strong>â€¢ Specific content:</strong> "Here\'s my garden", "Posted a peek", "My kitty!"',
              '<strong>â€¢ Context-aware:</strong> Better detection of "brought proof", "sharing this", etc.',
              '<strong>NEW: "BUSH" CONTEXT DETECTION:</strong> Smart detection of intimate vs. garden context:',
              '<strong>â€¢ Intimate context:</strong> When post mentions "carpet/drapes", "trim", "grooming", "wax" â†’ Flirty NPCs (60+ flirtiness, 50+ desire) have 65% chance to respond with intimate photo',
              '<strong>â€¢ Garden misunderstanding:</strong> Other NPCs playfully "misunderstand" and send garden/landscaping photos ğŸŒ¿',
              '<strong>â€¢ Example:</strong> "Does the carpet match the drapes? Send bush pics" â†’ Flirty NPCs send intimate photos, others send garden photos with playful comments',
              '<strong>NEW: "CHECK DMs" ACTUALLY WORKS!</strong> When NPCs comment "Check DMs" or "Sent you a DM", they now ACTUALLY send a private message!',
              '<strong>â€¢ Detection:</strong> Automatically detects comments mentioning: "check DM", "sent your way", "DMing you", "private message", "in your inbox", etc.',
              '<strong>â€¢ Smart Content:</strong> DM content matches original request - if you asked for nudes, they send nudes; if you asked for selfies, they send selfies',
              '<strong>â€¢ Image Generation:</strong> DMs include actual generated images matching the request (nudes, sexy pics, regular photos, etc.)',
              '<strong>â€¢ Timing:</strong> DM arrives 2-5 seconds after comment for natural feel',
              '<strong>â€¢ Notifications:</strong> You get notification toast when DM arrives: "ğŸ’¬ [Name] sent you a private message with a photo!"',
              '<strong>â€¢ Example:</strong> You post "Send me a nude", Quiana comments "Sent one your way! Check DMs ğŸ˜‰", then 3 seconds later she actually DMs you a nude photo',
              '<strong>SPECIAL HANDLING:</strong> Image requests get extra guidance - NPCs say "Here\'s mine! ğŸ±" not "already sent my cat pic" when posting images. If AI still produces meta-text, fallback returns simple natural response.',
              '<strong>IMPACT:</strong> Comments now read exactly like real social media - short, natural, no meta-text, no narration, no instruction leakage. Quality matches human-written social media comments. Image generation now understands context and responds appropriately (intimate vs. playful). NPCs follow through on DM promises!'
            ]
          }
        ]
      },
      {
        version: '2511021212',
        date: 'November 2, 2025',
        title: 'â±ï¸ TIME CONTROL & BOSS SCALING UPDATE',
        changes: [
          {
            category: 'â±ï¸ Time Control System',
            items: [
              '<strong>NEW: Cheat Menu Time Controls:</strong> Added comprehensive time management panel in cheats menu. Includes time scale slider (1x-100x), pause/resume button, skip 1 day button, and live game time display.',
              '<strong>Time Scale Slider:</strong> Adjust game speed from 1x (real-time) to 100x (ultra fast). Default 20x speed preserved. Visual display shows current speed with descriptive labels (Real Time, Slow, Default, Fast, Very Fast, Ultra Fast).',
              '<strong>Quick Presets:</strong> Three one-click preset buttons - 1x Real Time, 20x Default, 60x Fast. Makes common speed adjustments instant.',
              '<strong>Pause/Resume Time:</strong> Dedicated button to completely freeze game time. Button changes color (red when paused, green when running) and shows current status.',
              '<strong>Skip 1 Day:</strong> Advance game time by exactly 24 hours and trigger all daily events. Perfect for testing or skipping downtime.',
              '<strong>Live Time Display:</strong> Always-visible panel showing current game date/time formatted naturally (e.g., "Tuesday, November 2, 2025, 3:45 PM"). Updates every second while cheats menu is open.',
              '<strong>Integrated Controls:</strong> All time controls modify gameState.time properties directly and persist through saves. Changes take effect immediately without requiring game restart.'
            ]
          },
          {
            category: 'âš”ï¸ Boss Fight Scaling',
            items: [
              '<strong>NEW: Prestige Health Scaling:</strong> Boss health now scales exponentially with prestige level using 1.5x multiplier formula. Prevents bosses from becoming trivial one-shots after multiple prestiges.',
              '<strong>Scaling Formula:</strong> scaledHealth = baseHealth Ã— (1.5^prestigeLevel). Prestige 0 = 100% health, Prestige 1 = 150%, Prestige 2 = 225%, Prestige 3 = 338%, etc.',
              '<strong>Combat Log Notification:</strong> When boss fights start, combat log now shows prestige scaling message in gold: "â­ Prestige X: Boss health increased by Y%"',
              '<strong>Debug Logging:</strong> Console logs base health, scaled health, prestige level, and multiplier for each boss fight to help with balance testing.',
              '<strong>Maintains Challenge:</strong> High-level players now face appropriately challenging bosses that require strategy rather than instant victories.'
            ]
          },
          {
            category: 'ğŸ› Bug Fixes',
            items: [
              '<strong>FIXED: "Manage Flags" Button Error:</strong> Resolved SyntaxError in employee management modal. Renamed arrow function parameter from "e" to "emp" to avoid onclick attribute parsing conflicts.',
              '<strong>FIXED: Children Array Undefined:</strong> Added defensive null checks in getEmployeeChildren(), renderChildren(), and ageChildren() functions. Game no longer crashes when children array is undefined in older save files.',
              '<strong>ENHANCED: Social Posts Performance:</strong> Added helpful tooltip to "Clear All Posts" button explaining performance benefits. System already auto-trims posts to 100-500 range to prevent slowdowns.'
            ]
          },
          {
            category: 'ğŸ’¬ NPC Conversation Improvements',
            items: [
              '<strong>Time Context Fix:</strong> NPCs now receive accurate time context in conversations. When time is paused, removed "Time has passed during this conversation" message to avoid confusion. When time is running normally, message remains to maintain time awareness.',
              '<strong>Cleaner Prompts:</strong> Conversation prompts now dynamically adjust based on game state (paused vs running) for more natural and contextually appropriate NPC responses.'
            ]
          },
          {
            category: 'ğŸ® Quality of Life',
            items: [
              '<strong>Backward Compatibility:</strong> All changes are fully compatible with existing save files. No data migration needed.',
              '<strong>Persistent Settings:</strong> Time scale and pause state save with game state and restore on load.',
              '<strong>Visual Feedback:</strong> Time controls provide clear visual feedback with color changes, status text, and real-time display updates.',
              '<strong>Professional UI:</strong> Cheats menu time section features gradient styling, smooth transitions, and intuitive layout matching existing game aesthetic.'
            ]
          }
        ]
      },
      {
        version: '2510312300',
        date: 'October 31, 2025',
        title: 'ğŸ”— MASSIVE FLAG CHAIN EXPANSION - 16 Total Progression Systems',
        changes: [
          {
            category: 'ğŸ”— Flag Chain System Architecture',
            items: [
              '<strong>NEW: Two-Tier Chain System:</strong> Chains are now classified as AUTO-APPLY (natural progressions that happen automatically) or SUGGESTED (player-approved changes for relationships/dynamics). Auto chains handle biological/time-based progressions, suggested chains require player confirmation via beautiful modal UI.',
              '<strong>NEW: Chain Definitions System:</strong> Added comprehensive <code>gameState.flagChains.definitions</code> with 16 chain types. Each chain has type (auto/suggest), trigger conditions, duration thresholds, and metadata requirements.',
              '<strong>NEW: Suggestion Queue:</strong> Added <code>gameState.flagChains.suggestions[]</code> array to track pending player decisions. Prevents duplicate suggestions and tracks approval/rejection history.',
              '<strong>ENHANCED: processFlagChains():</strong> Completely rewrote to handle both auto-apply and suggestion logic (300+ lines). Runs daily via <code>onDayChange()</code>, checks all employees for chain eligibility, applies auto-chains instantly, creates suggestions for player-approved chains.'
            ]
          },
          {
            category: 'âš¡ AUTO-APPLY CHAINS (3) - Natural Progressions',
            items: [
              '<strong>EXISTING: Pregnancy Chain:</strong> pregnant â†’ lactating (30 days) â†’ postpartum (3 days). Already implemented, unchanged.',
              '<strong>NEW: In Heat Duration:</strong> in_heat flag now AUTO-REMOVES after 5 game days. In heat is a temporary condition - NPCs return to normal after duration expires. Notification shown when heat ends.',
              '<strong>NEW: Chastity â†’ In Heat (7 days):</strong> After 7 days in chastity device, NPC automatically develops in_heat condition from prolonged denial. Extremely aroused, desperate, sensitive. System checks daily and auto-adds in_heat flag with proper AI guidance linking it to chastity frustration.',
              '<strong>Implementation:</strong> All 3 auto-chains run silently in background with console logging. Player sees notifications for major events (heat starting/ending, birth) but chains execute automatically without interrupting gameplay.'
            ]
          },
          {
            category: 'ğŸ’• SUGGESTED RELATIONSHIP CHAINS (3) - Player Approval Required',
            items: [
              '<strong>NEW: Relationship Progression (2 stages):</strong> in_relationship (30 days) â†’ SUGGEST engaged_to_player â†’ engaged_to_player (21 days) â†’ SUGGEST married_to_player. Natural relationship escalation over 51+ total days. Player can approve engagement after 30 days of dating, then approve marriage after 21 days engaged.',
              '<strong>NEW: Secret Revealed (14 days):</strong> secret_relationship â†’ SUGGEST in_relationship. After 14 days of secret dating, system suggests making relationship official/public. Player chooses whether to reveal or keep hiding.',
              '<strong>Approval UI:</strong> Beautiful gradient modal with NPC photo, relationship timeline, flag preview with emoji/category/AI guidance excerpt, clear APPROVE/DECLINE buttons. Non-intrusive - appears once per chain milestone, never spams.'
            ]
          },
          {
            category: 'ğŸ­ SUGGESTED D/s CHAINS (4) - Progressive Deepening',
            items: [
              '<strong>NEW: D/s Progression (3 stages):</strong> submissive (14 days) â†’ SUGGEST collared â†’ collared (21 days) â†’ SUGGEST ownership_dynamic â†’ ownership_dynamic (30 days) â†’ SUGGEST 24_7_dynamic. Progressive deepening from casual submission to lifestyle 24/7 power exchange. Total timeline: 65+ days for full progression.',
              '<strong>Stage 1 (14 days):</strong> Submissive behavior proven consistent â†’ suggest formalizing with collar. Collar represents visible commitment to dynamic.',
              '<strong>Stage 2 (21 days):</strong> Devoted collar-wearing â†’ suggest deepening to ownership dynamic. NPC belongs to player completely.',
              '<strong>Stage 3 (30 days):</strong> Ownership established â†’ suggest 24/7 lifestyle dynamic. Power exchange extends to all aspects of life, not just intimate moments.',
              '<strong>NEW: Pet Play â†’ Collared (14 days):</strong> Parallel path - pet_play flag for 14 days suggests adding collar (pet formalization). Pet dynamic naturally includes collar-wearing.'
            ]
          },
          {
            category: 'ğŸ”¥ SUGGESTED ESCALATION CHAINS (3) - Intensity Increases',
            items: [
              '<strong>NEW: Free Use â†’ Public Use (21 days):</strong> After 21 days of free_use with player, suggests expanding to public_use (available to others). Major escalation requiring explicit player approval.',
              '<strong>NEW: No Clothes â†’ Permanently Nude (14 days):</strong> After 14 days working naked, suggests formalizing as permanently_nude. Converts temporary arrangement to permanent commitment.',
              '<strong>NEW: Exhibitionist â†’ Permanently Nude (14 days):</strong> Parallel path - exhibitionist tendencies for 14 days suggests permanent nudity as natural escalation of showing-off desires.'
            ]
          },
          {
            category: 'ğŸ’€ SUGGESTED EXTREME CHAIN (1) - Corruption Breaking',
            items: [
              '<strong>NEW: Corruption â†’ Mind Broken (30 days + intimacy):</strong> corruption_level_high for 30+ days + intimacy > 70 â†’ SUGGEST mind_broken. Extreme corruption over extended time can lead to mental rewiring. Requires both duration AND high intimacy (can\'t break someone you barely know). Player must explicitly approve this permanent personality change.',
              '<strong>Safety Checks:</strong> Dual requirements (time + relationship depth) prevent accidental mind-breaking. This is end-game corruption content requiring player intention.'
            ]
          },
          {
            category: 'ğŸ§ª LOW PRIORITY / NICHE CHAINS (5) - Advanced Content',
            items: [
              '<strong>NEW: Breeding Progression (2 stages):</strong> breeding_kink (21 days) â†’ SUGGEST impregnation_fetish â†’ impregnation_fetish (14 days + intimacy >60) â†’ SUGGEST pregnant. Natural escalation from kink to fetish to actualization. Player must approve pregnancy suggestion.',
              '<strong>NEW: Masochist â†’ Degradation Kink (21 days):</strong> After 21 days of masochist flag, suggests expanding from physical pain to verbal degradation/humiliation. Expands kink scope.',
              '<strong>NEW: Rope Bunny â†’ Chastity (21 days):</strong> After 21 days enjoying bondage, suggests escalating to chastity device. Equipment progression from rope to metal/plastic restraint.',
              '<strong>NEW: Mind Broken Recovery Path (3 stages):</strong> mind_broken (30 days) â†’ SUGGEST recovering_mind (manual start) â†’ recovering_mind (21 days AUTO) â†’ recovered_mind (permanent). Optional redemption arc - player can choose to help broken NPCs recover. Recovery takes 21 days of "therapy". Some personality changes remain permanent even after recovery.',
              '<strong>NEW: Hypnotized Branching (14-30 days):</strong> Multi-path system - after 14 days hypnotized, suggests adding trigger flags (submissive, exhibitionist, pet_play). After 30 days, can deepen to mind_broken. Hypnosis becomes gateway to multiple personality modifications.',
              '<strong>Recovery Mechanics:</strong> recovering_mind flag shows gradual improvement, recovered_mind flag indicates completion but with lasting vulnerability/submissiveness. New flags: ğŸ§  recovering_mind, âœ¨ recovered_mind.'
            ]
          },
          {
            category: 'ğŸ¨ Chain Suggestion UI/UX',
            items: [
              '<strong>Beautiful Modal Design:</strong> Gradient purple header with ğŸ”— emoji, dark blue content area, NPC photo/name/position card, reason explanation in highlighted box, suggested flag preview with full details (emoji, description, category, AI guidance preview).',
              '<strong>Clear Action Buttons:</strong> Green gradient APPROVE button, red gradient DECLINE button, both with hover animations (lift effect, glow intensifies). Visual hierarchy makes decision obvious.',
              '<strong>Context Information:</strong> Modal shows days elapsed, relationship context, reason for suggestion. Player has full information to make informed decision.',
              '<strong>Sound Effects:</strong> Gentle notification chime (600Hz sine wave) when suggestion appears. Non-jarring, just enough to draw attention.',
              '<strong>No Spam:</strong> Each chain suggestion appears ONCE when threshold met. System tracks suggestion history to prevent re-suggesting rejected chains.',
              '<strong>z-index: 30000000:</strong> Chain modals appear above everything (chat, other modals, notifications) ensuring player never misses decision opportunities.'
            ]
          },
          {
            category: 'ğŸ”§ Technical Implementation',
            items: [
              '<strong>Modified: gameState.flagChains:</strong> Added suggestions[] array and comprehensive definitions{} object with 10 chain types. Each definition includes type, trigger conditions, durations, descriptions with {name}/{days} placeholders.',
              '<strong>Created: suggestFlagChain():</strong> Checks for duplicate suggestions, fetches flag templates, creates suggestion object, shows approval modal. Prevents spam by tracking pending suggestions.',
              '<strong>Created: getQuickFlagTemplate():</strong> Returns flag template by key for 16 most common flags. Used by chain system to build suggestions with proper emoji/guidance.',
              '<strong>Created: showFlagChainSuggestion():</strong> Renders beautiful approval modal with NPC context, chain reasoning, flag preview. Includes animations (fadeIn, slideUp) for smooth appearance.',
              '<strong>Created: approveFlagChainSuggestion():</strong> Adds flag with chain metadata, marks suggestion approved, closes modal, shows success notification, saves game.',
              '<strong>Created: rejectFlagChainSuggestion():</strong> Marks suggestion rejected, closes modal, logs decision. Rejected suggestions won\'t re-appear.',
              '<strong>Enhanced: processFlagChains():</strong> Now 200+ lines handling all 10 chains. Checks flag existence, calculates days elapsed, validates conditions, triggers auto-chains, creates suggestions. Comprehensive logging for debugging.',
              '<strong>Animation Styles:</strong> Added fadeIn/slideUp CSS keyframe animations for modal entrance. Smooth 0.3s transitions for professional feel.'
            ]
          },
          {
            category: 'ğŸ“Š Chain System Statistics',
            items: [
              '<strong>Total Chains Implemented:</strong> 16 (3 auto-apply + 13 player-approved)',
              '<strong>Auto-Apply Chains:</strong> pregnancy cycle, in_heat duration (5 days), chastity â†’ in_heat (7 days), recovering_mind â†’ recovered_mind (21 days)',
              '<strong>Suggested Chain Duration Range:</strong> 14-30 days before suggestion appears',
              '<strong>Longest Progression:</strong> D/s chain - 65+ days from submissive to 24/7 dynamic (3 stages with approval gates). Breeding chain - 35+ days from kink to pregnancy (2 stages).',
              '<strong>Multi-Stage Chains:</strong> 4 chains with multiple stages (relationship progression, D/s progression, breeding progression, mind recovery)',
              '<strong>Branching Chains:</strong> Hypnosis can branch to 4 different outcomes (submissive, exhibitionist, pet_play, or mind_broken)',
              '<strong>Relationship Milestones:</strong> 30 days dating â†’ engagement option, 51+ days total â†’ marriage option',
              '<strong>Safety Thresholds:</strong> Mind_broken requires both 30 days corruption AND 70+ intimacy. Pregnancy suggestion requires 14 days + 60+ intimacy.',
              '<strong>Recovery System:</strong> Mind_broken can recover over 51 total days (30 broken + 21 recovering). Some changes remain permanent.',
              '<strong>Total New Flags:</strong> Added 3 new flags (postpartum, recovering_mind, recovered_mind) as chain-only flags. Total premade flags now 50.'
            ]
          },
          {
            category: 'ğŸ® Gameplay Impact',
            items: [
              '<strong>Natural Relationship Development:</strong> Relationships now feel organic - dating naturally progresses to engagement/marriage over time rather than instant jumps.',
              '<strong>D/s Realism:</strong> Power dynamics deepen gradually with player approval at each escalation. Submissive â†’ collar â†’ ownership â†’ 24/7 feels earned.',
              '<strong>Temporary Conditions:</strong> In heat no longer permanent (5 day duration adds realism). Chastity has consequences (triggers heat after 7 days).',
              '<strong>Player Agency:</strong> All major relationship/dynamic changes require explicit approval. Player controls relationship pace and intensity.',
              '<strong>Corruption Stakes:</strong> High corruption can lead to mind_broken if player chooses - adds weight to corruption gameplay.',
              '<strong>Nudity Escalation:</strong> Exhibitionism/workplace nudity can formalize into permanent naked lifestyle with player consent.',
              '<strong>Kink Progression:</strong> Physical kinks (masochism, bondage) can escalate to more intense forms (degradation, chastity). Breeding kink can become reality.',
              '<strong>Redemption Arcs:</strong> Mind_broken NPCs can be helped to recover, though some personality changes remain. Adds compassionate gameplay option.',
              '<strong>Hypnosis Flexibility:</strong> Hypnotized NPCs can develop in multiple directions based on player choice (submissive training, exhibitionism, pet play, or breaking).'
            ]
          },
          {
            category: 'ğŸ”® Future Chain Expansion Ready',
            items: [
              '<strong>Extensible Architecture:</strong> Adding new chains only requires defining them in gameState.flagChains.definitions and adding check logic to processFlagChains().',
              '<strong>ALL PLANNED CHAINS IMPLEMENTED:</strong> Original 16 suggested chains now complete (pregnancy, in_heat, chastity, relationships, D/s, pet, free_use, nudity, exhibitionism, corruption, breeding, masochism, rope, recovery, hypnosis).',
              '<strong>Metadata Support:</strong> All flags track startDate enabling duration calculations. Can add event counters, intensity levels, etc. for complex chain conditions.',
              '<strong>Conditional Chains:</strong> System supports additional conditions beyond time (e.g., intimacy thresholds, corruption levels, conversation counts).'
            ]
          }
        ]
      },
      {
        version: '2510311040',
        date: 'October 31, 2025',
        title: 'ğŸ”§ FLAG SYSTEM AUDIT & CONSISTENCY FIX',
        changes: [
          {
            category: 'ğŸ” Comprehensive Flag System Audit Results',
            items: [
              '<strong>AUDIT SCOPE:</strong> Manual verification of EVERY SINGLE detection pattern (45 total) against premade quickFlags (20 â†’ 38 flags). Checked for: key mismatches, missing premade flags, redundancy, and flag chain involvement.',
              '<strong>FINDINGS:</strong> Discovered 18 detection patterns without premade flags (broken UI functionality), 2 critical key mismatches (detection patterns suggesting wrong keys), and 5 intentionally manual-only flags confirmed.',
              '<strong>METHODOLOGY:</strong> PowerShell Select-String to extract all pattern names with line numbers, systematic comparison against quickFlags array, line-by-line verification of key matching.'
            ]
          },
          {
            category: 'âœ… Key Mismatch Fixes (CRITICAL)',
            items: [
              '<strong>FIXED: no_clothes Detection Mismatch:</strong> Detection pattern was suggesting key "no_clothes_at_work" but premade flag used "no_clothes". Updated detection pattern to match premade: key changed to "no_clothes", emoji changed from ğŸ‘™ to ğŸ‘—, category changed from "appearance" to "agreement", priority changed from "high" to "medium". System now properly recognizes the flag.',
              '<strong>FIXED: dominant Detection Mismatch:</strong> Detection pattern was suggesting key "player_dominant" but premade flag used "dominant_player". Updated detection pattern to match premade: key changed to "dominant_player", emoji changed from ğŸ‘‘ to ğŸ­, category changed from "relationship" to "personality", priority changed from "high" to "medium". Resolves flag suggestion failures.'
            ]
          },
          {
            category: 'â• Added 18 Missing Premade Flags',
            items: [
              '<strong>RELATIONSHIP FLAGS (4):</strong> in_relationship (ğŸ’‘ - dating player), engaged_to_player (ğŸ’ - engaged to player), ownership_dynamic (ğŸ”’ - belongs to player), 24_7_dynamic (ğŸ”„ - 24/7 D/s lifestyle).',
              '<strong>APPEARANCE FLAG (1):</strong> permanently_nude (ğŸ‘™ - always 100% nude at work, new normal dress code).',
              '<strong>KINK/PREFERENCE FLAGS (13):</strong> cumslut (ğŸ’¦), anal_only (ğŸ‘), degradation_kink (ğŸ”»), praise_kink (â­), creampie_lover (ğŸ’¦), oral_fixation (ğŸ‘„), lactation_kink (ğŸ¼), impregnation_fetish (ğŸ¤°), cock_worship (ğŸ™), daddy_kink (ğŸ‘¨), mommy_kink (ğŸ‘©), voyeur (ğŸ‘€), cucking (ğŸ”º).',
              '<strong>PERSONALITY FLAGS (4):</strong> bimbo (ğŸ’‹ - ditzy hyperfeminine), sadist (ğŸ˜ˆ), switch (ğŸ”„ - dom/sub versatile), bratty (ğŸ˜).',
              '<strong>DYNAMICS FLAGS (3):</strong> pet_play (ğŸ¾), service_submissive (ğŸ›ï¸ - fulfillment through service), rope_bunny (ğŸª¢ - bondage enthusiast).',
              '<strong>SPECIALIZED FLAGS (2):</strong> masochist (â›“ï¸ - enjoys pain), size_queen (ğŸ“).',
              '<strong>IMPACT:</strong> Increased quickFlags array from 20 to 38 premade flags. All detection patterns now have corresponding manual-addition flags. UI functionality restored for all auto-detected flags.'
            ]
          },
          {
            category: 'ğŸ¯ Added Detection Patterns for Manual-Only Flags',
            items: [
              '<strong>NEW: permanently_cumming Detection:</strong> Detects "always cumming", "never stop cumming", "constant orgasm", "perpetual orgasm" with 3 occurrence threshold. Extremely rare condition requiring strong evidence. Category: condition, Priority: critical.',
              '<strong>NEW: recorded Detection (enjoys_being_recorded):</strong> Detects "record me", "film me", "camera", "video", "take pictures", "on camera" with 2 occurrence threshold. Category: preference, Priority: low.',
              '<strong>NEW: public_use_interest Detection:</strong> Detects "share me", "let others", "everyone can", "anyone who wants", "public use", "pass me around" with 2 occurrence threshold. Category: agreement, Priority: high.',
              '<strong>NEW: corruption_progression Detection (corruption_level_high):</strong> Detects "changed me", "corrupted me", "not the same", "different person", "what have you done to me", "never thought i\'d" with 3 occurrence threshold. Requires strong contextual evidence. Category: state, Priority: medium.',
              '<strong>KEPT MANUAL ONLY: hypnotized:</strong> Requires specific trigger implementation, kept as manual-only flag (no auto-detection added).',
              '<strong>TOTAL DETECTION PATTERNS:</strong> Increased from 41 to 45 patterns with improved coverage of extreme/niche content.'
            ]
          },
          {
            category: 'ğŸ“Š System Consistency Metrics',
            items: [
              '<strong>BEFORE AUDIT:</strong> 41 detection patterns, 20 premade flags, 2 key mismatches, 18 missing premades = 44% flag coverage, broken UI for 44% of detections.',
              '<strong>AFTER FIXES:</strong> 45 detection patterns, 47 premade flags, 0 key mismatches, 0 missing premades = 100% flag coverage, fully functional UI.',
              '<strong>DETECTION â†’ PREMADE RATIO:</strong> 45 patterns : 47 flags. The 2 extra flags are chain-only (lactating, postpartum) - auto-added by pregnancy flag chain system, never detected directly. 13 detection patterns use different internal names than their suggested flag keys (e.g., pregnant_conversation â†’ pregnant, always_nude â†’ permanently_nude, engaged â†’ engaged_to_player, breeding â†’ breeding_kink, pet â†’ pet_play, ownership â†’ ownership_dynamic, service_sub â†’ service_submissive, 24_7 â†’ 24_7_dynamic, recorded â†’ enjoys_being_recorded, public_use_interest â†’ public_use, corruption_progression â†’ corruption_level_high).',
              '<strong>CHAIN-ONLY FLAGS (2):</strong> lactating and postpartum flags are NEVER detected - they are exclusively added automatically by the pregnancy flag chain system after birth events.',
              '<strong>MANUAL-ONLY FLAGS (1):</strong> hypnotized - requires custom trigger implementation, no auto-detection.',
              '<strong>SYSTEM INTEGRITY:</strong> All detection pattern suggestedFlag.key values now EXACTLY match their corresponding premade flag keys. Zero broken references. 100% functional detection-to-UI pipeline.'
            ]
          },
          {
            category: 'ğŸ”„ Technical Implementation',
            items: [
              '<strong>Modified: FLAG_DETECTION_PATTERNS (lines 6718-7380):</strong> Fixed 2 key mismatches, added 4 new detection patterns, updated emoji/category/priority to match premades.',
              '<strong>Modified: quickFlags Array (lines 7887-7950):</strong> Added 18 new premade flag templates with exact keys matching detection patterns. Total: 47 premade flags (45 detection-suggested + 2 chain-only).',
              '<strong>Validated: Key Consistency:</strong> All suggestedFlag.key values in detection patterns verified against premade flag key values. 100% match rate achieved.',
              '<strong>Enhanced: AI Guidance:</strong> Updated mind_broken aiGuidance to include cognitive impairment details (fragmented speech, drooling, stuttering, inability to form complex thoughts).',
              '<strong>Categories Distribution:</strong> relationship (7), preference (15), personality (9), condition (7 including lactating/postpartum), agreement (4), state (1), appearance (1) = 47 total flags across 7 categories.'
            ]
          }
        ]
      },
      {
        version: '2510312100',
        date: 'October 31, 2025',
        title: 'ğŸ·ï¸ MAJOR FLAG SYSTEM OVERHAUL - Pregnancy, Children & Auto-Detection',
        changes: [
          {
            category: 'ğŸ·ï¸ Flag Detection System Expansion',
            items: [
              '<strong>EXPANDED: 31+ Detection Patterns (TRIPLED!):</strong> Massively expanded from 9 to 31+ auto-detection patterns. New patterns: engaged, cumslut, anal_only, bimbo, pet_play, masochist, sadist, switch, bratty, size_queen, degradation_kink, praise_kink, creampie_lover, oral_fixation, lactation_kink, impregnation_fetish, cock_worship, daddy_kink, mommy_kink, voyeur, cucking, ownership_dynamic, service_submissive, rope_bunny, 24_7_dynamic, mind_broken (fucked stupid), and more.',
              '<strong>ENHANCED: Pattern Definitions:</strong> All patterns include proper emoji, category (condition/agreement/personality/relationship/preference), priority levels, and detailed playerDescription + aiGuidance text. Categories: condition (pregnancy, chastity), agreement (free use, nudity), relationship (dating, married, engaged, ownership), preference (kinks, fetishes), personality (dom/sub/switch/brat/bimbo).',
              '<strong>IMPROVED: Detection Accuracy:</strong> Enhanced keyword lists with more variations and natural language patterns. Added contextKeywords for better accuracy (e.g., pregnancy keywords require "your/yours/our/baby" context). Lowered thresholds for clear signals (many now 1-2 occurrences).',
              '<strong>FIXED: Z-Index Issue:</strong> Flag notification modals were appearing BEHIND chat windows (z-index 100000 vs chat at 10000010). Increased flag notifications to z-index 20000000 ensuring they always appear on top during conversations.'
            ]
          },
          {
            category: 'ğŸ¤° Pregnancy & Birth System',
            items: [
              '<strong>NEW: Automatic Pregnancy Tracking:</strong> When pregnant flag is added, system auto-calculates due date based on <code>gameState.pregnancySettings.duration</code> (default 14 game days, configurable 7-21). Stores conception date and due date in flag metadata.',
              '<strong>NEW: Birth Events:</strong> <code>processFlagChains()</code> runs daily checking pregnant NPCs\' due dates. On due date arrival, <code>giveBirth()</code> triggers: creates child object, removes pregnant flag, adds postpartum + lactating flags, shows birth notification.',
              '<strong>NEW: Flag Chains (UNREALISTIC TIMING):</strong> Pregnancy â†’ Lactating (30 days) â†’ Postpartum (3 days - FAST recovery). System automatically removes flags after duration expires. Lactating flag added immediately after birth with metadata linking to child. Postpartum only lasts 3 game days for unrealistic quick recovery.',
              '<strong>NEW: Father Tracking:</strong> Pregnancy metadata stores father ID ("player" or employee ID). Father info displayed in child records and used for genetic inheritance.',
              '<strong>NEW: Pregnancy Initialization:</strong> <code>initializePregnancy()</code> function called automatically when pregnant flag added via detection OR manual creation. Sets due date, shows notification with countdown.'
            ]
          },
          {
            category: 'ğŸ‘¶ Children System',
            items: [
              '<strong>NEW: Children Data Structure:</strong> Added <code>gameState.children[]</code> array storing all offspring. Each child has: id, name, gender (boy/girl), motherID, fatherID, birthDate, age (auto-calculated daily), genetics{}, traits[], photo.',
              '<strong>NEW: Genetic Inheritance:</strong> <code>createChild()</code> generates child with 50/50 genetics from both parents: hairColor, eyeColor, skinTone, height. Randomly inherits physical traits ensuring biological realism.',
              '<strong>NEW: Personality Inheritance:</strong> Children inherit 2 random personality traits from combined parent trait pool (mother.personality.traits + father.personality.traits). Creates unique blend of parental characteristics.',
              '<strong>NEW: Name Generation (70+ Names!):</strong> Auto-generates age-appropriate names from curated lists of 70 boy names and 70 girl names (expanded from 10 each). Includes modern popular names like Theodore, Santiago, Aurora, Gabriella, etc. Gender randomly determined at birth (50/50 chance).',
              '<strong>NEW: Age Progression:</strong> <code>ageChildren()</code> function calculates child age in game days from birthDate. Ages displayed as "Newborn", "X days old", "X months old", "X years old" with proper pluralization.',
              '<strong>NEW: Children Tab in Profile:</strong> Added "ğŸ‘¶ Children" tab to unified employee profile modal. Displays all children with photos, ages, genetics, personality traits, and parent info. Shows "No children yet" if none exist.'
            ]
          },
          {
            category: 'ğŸ“Š Children Display System',
            items: [
              '<strong>NEW: Child Cards:</strong> Beautiful card layout showing child photo (emoji-based), name in gold text, age with proper formatting, gender icon (â™‚ï¸/â™€ï¸), parent names with colored styling.',
              '<strong>NEW: Genetics Display:</strong> Each child card shows inherited traits in grid layout: Hair color, Eye color, Skin tone, Height. All inherited from biological parents.',
              '<strong>NEW: Personality Traits:</strong> Shows inherited personality traits as colored badges (e.g., "friendly", "caring", "confident"). Traits come from both parents\' trait pools.',
              '<strong>NEW: Parent Info Section:</strong> Displays mother and father with proper name coloring (player name in gold, NPC names in character colors). Shows relationship clearly.',
              '<strong>NEW: Empty State:</strong> Graceful "No children yet" message with centered styling when employee has no children.'
            ]
          },
          {
            category: 'ğŸ”— Flag Chain System',
            items: [
              '<strong>NEW: Chain Definitions:</strong> Added <code>gameState.flagChains</code> with active chain tracking and definitions. Pregnancy chain defined with 3 stages: pregnant (until due date) â†’ lactating (30 days) â†’ postpartum (3 days - UNREALISTIC fast recovery).',
              '<strong>NEW: Daily Processing:</strong> <code>processFlagChains()</code> called from <code>onDayChange()</code> every game day. Checks all active flags for expiration, progression triggers, and automatic transitions.',
              '<strong>NEW: Auto-Removal:</strong> Lactating (30 days) and postpartum (3 days only!) flags automatically removed after duration expires. System calculates days since startDate and compares to configured duration. Quick postpartum recovery for unrealistic gameplay.',
              '<strong>NEW: Metadata Linking:</strong> All chain-related flags store child ID in metadata enabling cross-reference between flags and children. Postpartum/lactating flags link back to specific child.',
              '<strong>EXTENSIBLE: Future Chains:</strong> System designed for easy expansion - can add new chains for other conditions (illness â†’ recovery, addiction â†’ withdrawal, training â†’ mastery, etc.)'
            ]
          },
          {
            category: 'âš™ï¸ Technical Implementation',
            items: [
              '<strong>Modified: <code>gameState</code> Structure:</strong> Added <code>children[]</code> array and <code>flagChains{}</code> object to save data. Fully serializable and backward compatible.',
              '<strong>Modified: <code>addFlag()</code>:</strong> Now calls <code>initializePregnancy()</code> when pregnant flag added. Auto-populates father metadata if missing. Handles pregnancy initialization automatically.',
              '<strong>Modified: <code>removeFlag()</code>:</strong> Enhanced to accept flag key OR flag ID for flexible removal. Used by chain system to remove flags by key (e.g., "pregnant", "lactating").',
              '<strong>Modified: <code>approveFlagSuggestion()</code>:</strong> Now initializes pregnancy when approving detected pregnant flag. Ensures due date calculation happens automatically.',
              '<strong>Modified: <code>onDayChange()</code>:</strong> Added <code>processFlagChains()</code> call ensuring chains processed daily. Children ages updated daily via this system.',
              '<strong>Created: <code>giveBirth()</code>:</strong> Handles complete birth event - creates child, removes pregnant flag, adds lactating + postpartum flags, shows notification, saves game.',
              '<strong>Created: <code>createChild()</code>:</strong> Generates complete child object with genetics, traits, name, photo. Handles genetic inheritance logic from both parents. Name pool expanded to 70 boy names + 70 girl names.',
              '<strong>Created: <code>getEmployeeChildren()</code>:</strong> Helper function to retrieve all children for specific employee. Used by children tab rendering.',
              '<strong>Created: <code>initializePregnancy()</code>:</strong> Calculates due date based on settings, stores conception date, sets metadata, shows notification.',
              '<strong>Created: <code>renderChildren()</code>:</strong> New tab renderer for children display in unified profile. Shows all children with full details, genetics, traits.'
            ]
          },
          {
            category: 'ğŸ¨ UI/UX Improvements',
            items: [
              '<strong>Added Tab:</strong> "ğŸ‘¶ Children" tab added to tab list in <code>openUnifiedProfile()</code> between Relationship and Appearance tabs.',
              '<strong>Tab Routing:</strong> Added <code>case "children": return renderChildren();</code> to <code>renderContent()</code> switch statement.',
              '<strong>Notification Enhancement:</strong> Birth events trigger 10-second success notification: "ğŸ‰ [Name] gave birth to a daughter/son named [ChildName]!"',
              '<strong>Visual Hierarchy:</strong> Children cards use dark blue backgrounds (#0f3460) with nested darker sections (#16213e) for genetics/traits. Gold accents for names.',
              '<strong>Color Coding:</strong> Father names colored based on type - gold (#ffd700) for player, character colors for NPCs, gray (#aaa) for unknown.'
            ]
          },
          {
            category: 'ğŸ“ NEW: 26+ Additional Flag Patterns (KINKS & DYNAMICS)',
            items: [
              '<strong>Relationships (5):</strong> engaged (ğŸ’ - detects proposals/engagement), ownership_dynamic (ğŸ”’ - "own me", "i\'m yours", possession), 24_7_dynamic (ğŸ”„ - lifestyle D/s relationship), plus existing married/in_relationship patterns.',
              '<strong>Personality Types (6):</strong> bimbo (ğŸ’‹ - ditzy, hyperfeminine persona with valley girl speech), switch (ğŸ”„ - can be dom or sub), bratty (ğŸ˜ - playfully disobedient, seeks reactions), masochist (â›“ï¸ - enjoys pain), sadist (ğŸ˜ˆ - enjoys causing pain), service_submissive (ğŸ›ï¸ - fulfillment through service).',
              '<strong>Extreme Conditions (1):</strong> mind_broken (ğŸ˜µ - "fucked stupid", mental rewiring from excessive pleasure. AI speaks in simpler/fragmented sentences, struggles with complex thoughts, drools, stutters, hyper-focused on pleasure/obedience. Permanent personality alteration).',
              '<strong>Specific Kinks (8):</strong> cumslut (ğŸ’¦), anal_only (ğŸ‘), degradation_kink (ğŸ”» - enjoys verbal humiliation), praise_kink (â­ - needs validation), daddy_kink (ğŸ‘¨), mommy_kink (ğŸ‘©), pet_play (ğŸ¾ - puppy/kitten dynamics), rope_bunny (ğŸª¢ - bondage enthusiast).',
              '<strong>Acts & Preferences (5):</strong> creampie_lover (ğŸ’¦ - internal completion preference), oral_fixation (ğŸ‘„ - loves giving oral), cock_worship (ğŸ™ - reverence/obsession), lactation_kink (ğŸ¼), impregnation_fetish (ğŸ¤° - aroused by pregnancy concept).',
              '<strong>Dynamics (2):</strong> voyeur (ğŸ‘€ - enjoys watching others), cucking (ğŸ”º - cuckold/hotwife dynamics).',
              '<strong>Plus Existing:</strong> size_queen (ğŸ“), exhibitionist (ğŸ­), collared (ğŸ”—), chastity (ğŸ”), and all original 9 patterns.',
              '<strong>Detection Features:</strong> Natural language keywords ("i\'m mind broken", "you broke me", "fucked stupid", "can\'t think"), context validation, low thresholds (1-2 occurrences for explicit statements), comprehensive AI guidance for each including speech pattern changes.'
            ]
          },
          {
            category: 'ğŸ”„ Save Compatibility',
            items: [
              '<strong>Backward Compatible:</strong> All new fields initialize gracefully if missing. Existing saves work without modification.',
              '<strong>Auto-Migration:</strong> If <code>children</code> or <code>flagChains</code> missing from loaded save, they auto-initialize as empty arrays/objects.',
              '<strong>No Breaking Changes:</strong> Existing flag system fully preserved. New features additive only.',
              '<strong>Future-Proof:</strong> System designed for expansion - can add new chain types, child features, genetic traits without breaking saves.'
            ]
          }
        ]
      },
      {
        version: '2510310930',
        date: 'October 31, 2025',
        title: 'ğŸ› Community Bug Fixes - Discord Feedback Implementation',
        changes: [
          {
            category: 'ğŸ Gift System Fixes',
            items: [
              '<strong>FIXED: Gift Genie Adult Content Sanitization:</strong> Gift Genie was returning overly sanitized descriptions for adult items (e.g., "vibrator" â†’ "personal massager", "bondage rope" â†’ "decorative rope"). Enhanced AI prompt with explicit adult content policy, examples of acceptable adult items, and "DO NOT sanitize" instructions. Now generates appropriately explicit gift descriptions for adult game context.',
              '<strong>FIXED: Entire Gift Stack Removed Bug:</strong> When giving one gift from inventory, entire stack (e.g., 5 gifts) was being removed instead of just one. Changed from <code>splice(giftIndex, 1)</code> to proper quantity decrement logic - checks quantity, decrements by 1, only removes item if quantity â‰¤ 0.',
              '<strong>FIXED: False Duplicate Gift Warnings:</strong> NPCs were claiming gifts were duplicates despite never receiving them before ("AGAIN? You know how much I loved the first set..." when this was the first gift). Improved duplicate detection with case-insensitive exact matching and added explicit AI flags: "âš ï¸ DUPLICATE ALERT" vs "âœ“ This is a NEW gift" to prevent AI confusion.',
              '<strong>FIXED: Gifts Not Showing in NPC Bio:</strong> Gifts received by NPCs were not displaying in their Possessions tab at all. Added comprehensive "All Gifts Received" section showing chronological list with gift name, category badge, value, and date. Now displays full gift history with proper formatting.'
            ]
          },
          {
            category: 'ğŸ‘¤ Profile Editing Enhancements',
            items: [
              '<strong>NEW: Age Editing:</strong> Added editable age field (18+) in Basic Info section of NPC profiles. Age is now visible and changeable in edit mode with minimum age validation (18-99 range). Includes numeric input with increment/decrement on change.',
              '<strong>NEW: Gender Editing:</strong> Added editable gender field in Basic Info section. Players can now modify NPC gender with text input supporting all gender options (Female, Male, Non-binary, Trans Woman, Trans Man, etc.).',
              '<strong>NEW: Intimacy Level Editing:</strong> Added intimacy level display and editing in Relationship Statistics section. Shows as percentage bar (0-100%) with description "Combined measure of emotional and physical closeness". Fully editable in edit mode with +/âˆ’ buttons and direct numeric input. Stored in <code>employee.memory.intimacyLevel</code>.'
            ]
          },
          {
            category: 'ğŸ”§ Critical Technical Fixes',
            items: [
              '<strong>FIXED: Social Feed Comment Promise Rejection:</strong> Fixed "Cannot read property \'push\' of undefined" error in <code>trackPlayerMention()</code> function causing promise rejections when commenting on posts. Added defensive array/object validation ensuring <code>mentionHistory</code> and <code>mentionCounts</code> exist and are correct types before operations.',
              '<strong>FIXED: Social Feed Images Not Displaying:</strong> Images in social feed posts were not showing or failing to load silently. Added error handling with fallback placeholder (<code>onerror</code> handler), opacity fade-in transition on successful load, and prevents broken image icons. Images now display with proper loading states.',
              '<strong>FIXED: Corporate Pyramid Error After Prestige:</strong> Opening Corporate Pyramid modal immediately after prestiging caused crashes due to uninitialized data structures. Added defensive initialization checks for <code>employees</code> array, <code>corporateHierarchy</code> structure, and <code>hierarchyLevels</code> array with automatic creation of missing structures and default values.'
            ]
          },
          {
            category: 'ğŸ­ NPC AI Improvements',
            items: [
              '<strong>FIXED: Male Character Pronouns Wrong:</strong> Male and trans man characters were consistently referred to with "she/her" pronouns by AI despite being defined as male. Added CRITICAL IDENTITY pronoun guidance system with explicit instructions for each gender: Male/Trans Man get "âš ï¸ You are a MAN. Use he/him/his. Do NOT use she/her under any circumstances", Trans Woman get "You are a TRANS WOMAN. Use she/her/hers", Female/Futanari get "You are a WOMAN. Use she/her/hers". Pronoun guidance injected directly into character context to prevent AI misgendering.',
              '<strong>FIXED: Player Info Being Ignored:</strong> Enhanced <code>getPlayerDescription()</code> function with explicit name enforcement: "âš ï¸ THE PLAYER is named [FullName]. Do NOT call them by any other name." Added "do not invent names" instructions to prevent AI from making up player nicknames like "Phil" or "Mr. Roberts".',
              '<strong>FIXED: Training Workshop Notification Spam:</strong> Training workshops were causing notification/UI flicker due to <code>saveGame()</code> being called during batch employee updates, combined with 5-second autosave interval. Changed to <code>saveGame(false)</code> to suppress manual save notifications during bulk operations. Batched all employee updates before single save call.'
            ]
          },
          {
            category: 'ğŸ¢ Game Systems Fixes',
            items: [
              '<strong>FIXED: Flags System Syntax Error in Opera GX:</strong> <code>showAllFlags()</code> function was not accessible from inline onclick handlers causing "showAllFlags is not defined" error in Opera GX browser. Exposed <code>window.showAllFlags</code> and <code>window.removeFlagAndRefresh</code> globally for cross-browser compatibility.'
            ]
          },
          {
            category: 'âš™ï¸ Technical Implementation Details',
            items: [
              '<strong>Gift System:</strong> Enhanced <code>generateCustomGift()</code> AI prompt with explicit adult content policy examples. Fixed <code>sendGiftBtn</code> handler to decrement quantity properly. Improved <code>giveGiftToEmployee()</code> with case-insensitive duplicate detection. Enhanced <code>generateGiftReaction()</code> with explicit NEW vs DUPLICATE flags. Added gift display in <code>renderPossessions()</code>.',
              '<strong>Profile Editing:</strong> Modified Basic Info section HTML to include gender and age input fields in edit mode. Added intimacy level widget to Relationship Statistics with +/âˆ’ controls updating <code>window.profileEditState.editedData.memory.intimacyLevel</code>.',
              '<strong>Pronoun System:</strong> Created <code>pronounGuidance</code> variable based on employee gender, injected into <code>contextFacts</code> array in <code>buildChatPrompt()</code> function. Explicit masculine/feminine language enforcement for all genders.',
              '<strong>Social Feed:</strong> Added <code>onerror</code> and <code>onload</code> handlers to post image tags. Enhanced <code>trackPlayerMention()</code> with Array.isArray checks and typeof validation. Added defensive checks to <code>openCorporatePyramidModal()</code> with structure initialization.',
              '<strong>Save Migration:</strong> All fixes include backward compatibility with existing saves. Missing properties auto-initialize with sensible defaults. No breaking changes to save format.'
            ]
          },
          {
            category: 'ğŸ™ Community Feedback',
            items: [
              'All fixes based on Discord & Perchance community feedback and bug reports',
              'Prioritized most impactful issues affecting gameplay experience',
              'Enhanced systems based on player expectations and use cases',
              'Improved error messages and user feedback throughout',
              'Added more granular control over NPC customization',
              'Focus on polish and stability for core game systems'
            ]
          }
        ]
      },
      {
        version: '2510240835',
        date: 'October 24, 2025',
        title: 'ğŸ”§ Critical Bug Fixes: Scene Visualization & Social Posts',
        changes: [
          {
            category: 'ğŸ¬ Scene Visualization - CRITICAL FIXES',
            items: [
              '<strong>FIXED: Random Unrelated Images Bug:</strong> Scene visualization was generating completely random images (mountain streams instead of erotica, lizards instead of characters, etc.) due to Perchance returning String objects instead of primitive strings.',
              '<strong>String Object Extraction:</strong> Created <code>extractText()</code> helper function to properly convert Perchance\'s String objects to usable text. Prevents prompt from being treated as character array (0, 1, 2, ...) instead of actual string.',
              '<strong>Markdown Pollution Fix:</strong> AI was adding <code>**Image Prompt:**</code>, <code>**Visual Details:**</code>, bullet points, and <code>*(Word count: X)*</code> to prompts - confusing image generator. Now strips all markdown formatting.',
              '<strong>Enhanced Prompts:</strong> Increased max_tokens from 100â†’200, added detailed instructions for exact current activity, poses, expressions, location details, mood/atmosphere, and clothing/props.',
              '<strong>Better Context:</strong> Now extracts last 3 player and NPC messages for deeper understanding of scene. Temperature increased from 0.7â†’0.8 for more creative but focused output.',
              '<strong>Stop Sequences:</strong> Added stops for "Visual Details:", "**Visual", "Word count:" to prevent AI from continuing into metadata.',
              '<strong>XML Tag Removal:</strong> Strips <code>&lt;image prompt&gt;</code> tags that AI sometimes adds.'
            ]
          },
          {
            category: 'âœï¸ Custom Image Prompts',
            items: [
              '<strong>Custom Prompt Option:</strong> Added "Custom Prompt" to image style dropdown per user request.',
              '<strong>Personal Style Directives:</strong> Users can now write their own custom style instructions (e.g., "watercolor painting, soft colors, dreamy atmosphere") instead of being limited to presets.',
              '<strong>Expandable Textarea:</strong> UI shows/hides custom prompt field based on selection. Includes helpful placeholder text.',
              '<strong>Persistent Storage:</strong> Custom prompts save to gameState and persist across sessions.',
              '<strong>Fallback Handling:</strong> If custom prompt is empty, falls back to "high quality, detailed".'
            ]
          },
          {
            category: 'ğŸ“± Social Post Quality Improvements',
            items: [
              '<strong>FIXED: Short Generic Posts:</strong> AI was spamming feed with one-word posts like "Self-care morning", "Made it to work", "Vibing". Increased max_tokens from 60â†’80 and added quality validation.',
              '<strong>FIXED: "Caught in Mid-" Repetition:</strong> AI was obsessed with phrases like "caught in mid-laugh", "caught in mid-sip", "caught in mid-bite". Added regex filters to <code>cleanWithLearning()</code> to remove all "mid-action" patterns.',
              '<strong>Post Quality Validation:</strong> Now rejects posts with <3 words, emoji-only posts, and generic phrases before they hit the feed.',
              '<strong>Enhanced Fallback Templates:</strong> Expanded from 3 options per type to 7-10 varied options. Added personality-based variations (flirty emojis, professional hashtags).',
              '<strong>Better AI Instructions:</strong> Explicit rules: "NOT single-word posts", "Avoid one-word or extremely short posts", "NEVER use caught in mid-[action] phrases", "Add personality and context".',
              '<strong>Expanded Post Types:</strong> Added fallbacks for: fitness, hobby, entertainment, mood, question, achievement, throwback, pet, fashion, complaint, inspiration, weather, random, gossip.'
            ]
          },
          {
            category: 'ğŸ• PostId Timestamp Validation',
            items: [
              '<strong>FIXED: Invalid PostIds Bug:</strong> Fallback system was generating posts with invalid postIds lacking timestamps, causing posts to get stuck at top of feed and become undeletable.',
              '<strong>Robust Timestamp Generation:</strong> Added validation in <code>createPost()</code> with multiple fallbacks: 1) Date.now(), 2) gameState.time.currentTime, 3) new Date().getTime(), 4) Epoch timestamp.',
              '<strong>Error Logging:</strong> Console warnings if timestamp is NaN or invalid.',
              '<strong>Guaranteed Valid IDs:</strong> Ensures all posts have format <code>post_{counter}_{timestamp}</code> with valid timestamp for proper sorting and deletion.'
            ]
          },
          {
            category: 'ğŸ› ï¸ Technical Implementation',
            items: [
              '<strong>New Helper Function:</strong> <code>extractText(response)</code> - Universal text extraction from generateText responses. Handles String objects, response objects with .text/.generatedText properties, and primitive strings.',
              '<strong>Applied Everywhere:</strong> Scene visualization, social post generation, and image style application now use extractText() for consistent handling.',
              '<strong>Markdown Stripping:</strong> Comprehensive regex patterns remove: bold headers, bullet points, labels, word counts, and formatting artifacts.',
              '<strong>AI Prompt Improvements:</strong> Added explicit instructions: "Write ONLY the description itself. NO markdown formatting, NO bold headers, NO labels."',
              '<strong>Debug Logging:</strong> Enhanced console logs show prompt length, style application, and final prompt endings for troubleshooting.'
            ]
          },
          {
            category: 'ğŸ“Š Expected Improvements',
            items: [
              'Scene visualizations accurately reflect conversation context instead of random images',
              'Users can define custom art styles with personal preferences',
              'Social posts are more substantive and varied (3+ words minimum)',
              'No more "caught in mid-X" repetitive AI phrases',
              'All posts have valid IDs with timestamps for proper sorting/deletion',
              'Overall better AI content quality across all generation points'
            ]
          }
        ]
      },
      {
        version: '2010232145',
        date: 'October 23, 2025',
        title: 'ğŸ¨ Global Image Style System & Prestige Bug Fixes',
        changes: [
          {
            category: 'âœ¨ New Features',
            items: [
              '<strong>Global Image Style Setting:</strong> Choose a consistent art style for ALL image generation (profiles, chats, social posts, scenes)',
              '<strong>6 Style Options:</strong> Photorealistic, Anime/Manga, Artistic/Painterly, Cartoon/Comic, Cinematic, Professional Studio',
              '<strong>Automatic Style Application:</strong> Selected style is applied to all 14+ image generation points automatically',
              '<strong>Style Persistence:</strong> Image style preference saves across sessions',
              '<strong>Smart Style Directives:</strong> Each style includes comprehensive prompt modifiers for consistent results'
            ]
          },
          {
            category: 'ğŸ› Critical Bug Fixes',
            items: [
              '<strong>Fixed Prestige Unlock Cost Bug:</strong> Product unlock costs were locked to pre-prestige values (e.g., garage products requiring billions after prestige). Now properly resets to base values.',
              '<strong>Base Unlock Cost System:</strong> Added comprehensive lookup table with default costs for all 40+ products',
              '<strong>Prestige Reset Logic:</strong> Product unlock costs now correctly reset to original values regardless of dynamic changes'
            ]
          },
          {
            category: 'ğŸ¨ Image Generation Improvements',
            items: [
              'Updated 14+ image generation locations to use consistent styling',
              'Employee profile pictures (onboarding)',
              'Chat image requests (player to NPC)',
              'Chat image requests (NPC to player)',
              'Image regeneration in chats',
              'Visualize current scene',
              'Social feed posts with images',
              'Social feed custom player posts',
              'Boss fight character images',
              'Gift preview images',
              'First post selfies (new hires)',
              'All images now respect global style setting'
            ]
          },
          {
            category: 'âš™ï¸ Technical Implementation',
            items: [
              'Added <code>applyImageStyle()</code> helper function for consistent style application',
              'Style directives automatically append to all image prompts',
              'Duplicate detection prevents style tags from being added multiple times',
              'Debug logging shows style application for troubleshooting',
              'Settings UI integration with real-time style switching',
              'Base unlock costs for garage, home_office, office_suite, factory, and corporate_tower products'
            ]
          },
          {
            category: 'ğŸ’¾ Prestige System Improvements',
            items: [
              '<strong>Complete Cost Reset:</strong> All product unlock costs reset to base defaults',
              'Prevents progression blocks after prestige',
              'Maintains game balance across prestige cycles',
              'Preserves intended early-game flow after reset',
              'Fixed unlock costs for 8 garage products, 10 home office products, 10 office suite products, 10 factory products, 10 corporate tower products'
            ]
          }
        ]
      },
      {
        version: '2510221000',
        date: 'October 22, 2025',
        title: 'ğŸš€ Nuclear Context Intelligence + Anti-Repetition System',
        changes: [
          {
            category: 'ğŸ§  Revolutionary AI Context Selection',
            items: [
              '<strong>Nuclear Context Intelligence System:</strong> Completely rewrote how AI selects context for NPC conversations. Instead of "context dumping" (sending ALL employee data in every prompt), now intelligently selects 5-15 most relevant pieces using multi-dimensional scoring.',
              '<strong>Multi-Dimensional Scoring:</strong> Each context piece scored on 5 dimensions: Base Priority (inherent importance), Semantic Relevance (matches conversation topic), Temporal Relevance (time-sensitive data gets freshness bonus), Novelty (anti-repetition penalty), Coherence (works well with other selected pieces).',
              '<strong>Adaptive Selection Algorithm:</strong> Greedily selects best-scoring context with category balancing (prevents all personality, no current state). Respects token budgets: 400 tokens for casual chat, 300 for social posts, 250 for comments.',
              '<strong>Usage Tracking:</strong> System tracks which context pieces are used in each interaction. Pieces used recently get heavy novelty penalties (70% reduction) to prevent repetition. Pieces used in last hour completely excluded.',
              '<strong>Context Categories:</strong> 9 categories with different priorities: core_identity (always included), personality (high), current_state (high, time-sensitive), relationships (low), skills (work-context), stats (medium), flags (variable), personal_life (low), appearance (very low).'
            ]
          },
          {
            category: 'ğŸ¯ Anti-Repetition Enforcement',
            items: [
              '<strong>FIXED: Physical Appearance Obsession:</strong> NPCs were constantly describing "bright blue eyes", "chestnut waves", and "barefoot" in EVERY response. Drastically reduced appearance priority (0.2â†’0.05, 0.1â†’0.02), added avoidRepetition flags, and explicit AI instruction to STOP obsessing over looks.',
              '<strong>FIXED: Coworker Name-Dropping Plague:</strong> NPCs mentioned coworkers in EVERY SINGLE MESSAGE, even during intimate moments ("Judith\'s budget reports wouldn\'t know what to make of this"). Reduced relationship priority by 75-85%, removed automatic office dynamics/social context injection.',
              '<strong>FIXED: Betting Obsession:</strong> NPCs constantly saying "[Coworker] bet me $20 that..." as excuse to mention people. Added explicit ban on using bets/wagers as crutch to name-drop coworkers.',
              '<strong>Explicit AI Instructions:</strong> Added critical directives telling AI to: NOT constantly describe appearance (only when it changes or asked), NOT randomly bring up coworkers (only when player asks or directly relevant), NOT use betting patterns to shoehorn names, NEVER mention coworkers during intimate moments.',
              '<strong>Context Selectivity:</strong> Removed automatic inclusion of office dynamics, recent social posts, and gossip. These now only appear when semantically relevant or player asks about them.'
            ]
          },
          {
            category: 'ğŸ¢ Corporate Hierarchy Overhaul',
            items: [
              '<strong>FIXED: Hierarchy Levels Completely Redesigned:</strong> Levels now correctly match the corporate structure: Level 1 = Staff (product workers), Level 2 = Local Manager, Level 3 = Regional Manager, Level 4 = Branch Manager, Level 5 = CFO/COO, Level 6 = Senior Executive, Level 7 = CEO.',
              '<strong>Proper Level Progression:</strong> New employees start at Level 1 (Staff) - the bottom tier managing products. Removed confusing "Entry Level" terminology. Everyone starts as Staff and can work their way up.',
              '<strong>Corporate Pyramid Population:</strong> Migration system now syncs employees to corporate pyramid positions after auto-assignment. Your staff will properly appear in the Corporate Ladder screen at Level 1 positions.',
              '<strong>Updated Promotion Requirements:</strong> Adjusted requirements to match new hierarchy: Staffâ†’Local Manager (60% prod, Lv1 mgmt), Localâ†’Regional (70%, Lv2), Regionalâ†’Branch (75%, Lv4), Branchâ†’CFO/COO (80%, Lv6), CFO/COOâ†’Senior Exec (85%, Lv8), Senior Execâ†’CEO (90%, Lv10).',
              '<strong>Position Icons & Colors:</strong> Each level has appropriate icon and color: ğŸ‘” Staff (green), ğŸ‘¨â€ğŸ’¼ Local Manager (blue), ğŸ¯ Regional Manager (gold), ğŸ“Š Branch Manager (pink), ğŸ’¼ CFO/COO (purple), â­ Senior Executive (deep purple), ğŸ‘‘ CEO (red).'
            ]
          },
          {
            category: 'ğŸ”§ Staff Position Management & Save Migration',
            items: [
              '<strong>SMART Auto-Assignment from Old Saves:</strong> Migration system intelligently extracts product assignments from old "Manager â€“ [Product Name]" position fields, auto-assigns employees to correct products, syncs them to corporate pyramid, then cleans up outdated display fields.',
              '<strong>FIXED: Promotion Vacancy Bug:</strong> When promoting employee from Staff position to higher role, the old product position is now properly vacated and automation disabled. Shows warning notification: "âš ï¸ [Position] is now vacant! Hire new staff to restore automation."',
              '<strong>FIXED: "Managed by Unknown" Bug:</strong> Old saves had products with invalid manager references. Migration system now detects and clears broken assignments, showing helpful message: "âš ï¸ Staff assignment lost - click Hire Staff to reassign"',
              '<strong>Cleaner People Tab Cards:</strong> Removed redundant "Manager â€“ [Product] â€¢ [Product]" line from employee cards. The Corporate Hierarchy section already shows their level and role clearly.',
              '<strong>Position Title Clarity:</strong> Business tab now shows which employee staffs each product: "âœ“ Staffed by [Name] (Lv.X)" or "âš ï¸ No staff assigned - automation disabled" when vacant.',
              '<strong>Better Terminology:</strong> Changed "Hire Employee" â†’ "Hire Staff", "Upgrade Manager" â†’ "Upgrade Position", "Managed by" â†’ "Staffed by" to clarify you\'re improving the position (equipment/processes) not the person.',
              '<strong>Upgrade Notifications:</strong> Position upgrade messages now say "[Product] position upgraded to Lv.X - Better equipment & efficiency!" making it clear what\'s improving.',
              '<strong>Save Migration:</strong> Loading old saves automatically validates all product-employee assignments and fixes any orphaned manager references from fired/promoted employees.',
              '<strong>Secretary Title Fix:</strong> Executive Secretary position (level 6.5) now correctly sets employee title to "Executive Secretary" instead of incorrectly showing "Regional Director" (level 6).'
            ]
          },
          {
            category: 'ğŸ“Š Debug & Analytics Tools',
            items: [
              '<strong>debugContextSelection():</strong> Console function to see exactly what context is selected for any interaction. Shows scores, breakdown by dimension, and formatted output.',
              '<strong>showContextAnalytics():</strong> View comprehensive analytics on context usage for any employee - most/least used pieces, category distribution, average pieces per interaction, recent history.',
              '<strong>Token Budget System:</strong> Different interaction types have appropriate budgets to prevent bloat while maintaining quality context.'
            ]
          }
        ]
      },
      {
        version: '2510220820',
        date: 'October 22, 2025',
        title: 'â¬†ï¸ Promotion UX Overhaul + Bug Fixes',
        changes: [
          {
            category: 'âœ¨ Improved Promotion System',
            items: [
              '<strong>Promote Button in Employee Profiles:</strong> New "â¬†ï¸ Promote" button appears in employee profile modals. Shows as green/active when employee is eligible for promotion, grayed out with "ğŸ”’ Not Eligible" when not eligible.',
              '<strong>Seamless Promotion Flow:</strong> Click "Promote" button â†’ profile closes â†’ Corporate Pyramid opens with eligible positions highlighted in gold. Much more intuitive than drag-and-drop.',
              '<strong>Visual Confirmation Modal:</strong> Beautiful side-by-side comparison showing old position â†’ new position with animated arrow. Displays employee photo, position cards with level/title, cost breakdown, and your remaining cash after promotion.',
              '<strong>Smart Eligibility Detection:</strong> System automatically checks all higher-level positions and secretary role to determine if employee has promotion opportunities.',
              '<strong>Mobile-Friendly:</strong> Click-based system works perfectly on mobile devices, replacing janky drag-and-drop.',
              '<strong>Current Position Display:</strong> Employee profiles now show current position title and level badge next to the Promote button.'
            ]
          },
          {
            category: 'ğŸ¢ Secretary Position Addition',
            items: [
              '<strong>Executive Secretary Role:</strong> New special position that reports directly to the CEO with no subordinates. Perfect for early-game hiring.',
              '<strong>Visual Placement:</strong> Appears next to the CEO in the Corporate Pyramid (slightly smaller for visual hierarchy) with unique purple/magenta color scheme and ğŸ“‹ icon.',
              '<strong>Easy Access:</strong> Can be filled by Level 1-3 employees. Low cost ($1,000) encourages early hiring.',
              '<strong>Auto-Migration:</strong> Automatically added to existing saves without requiring new game.',
              '<strong>Fully Integrated:</strong> Works with all position management functions including assignment, removal, and promotion flow.'
            ]
          },
          {
            category: 'ğŸ› Bug Fixes',
            items: [
              '<strong>Fixed createSocialPost Error:</strong> Function was being called but never defined, causing ReferenceError in generateMorningPost, generateEveningPost, and createActivityPost. Now properly creates and adds posts to social feed.',
              '<strong>Fixed Mention Suggestions Crash:</strong> TypeError when accessing employee IDs in getMentionSuggestions. Added comprehensive null checks and validation for employee objects, IDs, and mention statistics.',
              '<strong>Fixed Scarf Obsession:</strong> Removed accessories (including scarves) from the fullDescription string sent to AI. Employees were constantly mentioning scarves because it was in their character description for every AI interaction. Accessories still stored in data but no longer pollute conversations.'
            ]
          },
          {
            category: 'ğŸ¨ UI Improvements',
            items: [
              '<strong>Discord Icon:</strong> Re-added Discord server link icon to top bar (left of settings gear). Opens in new tab with proper SVG icon in Discord brand color.',
              '<strong>Promotion Confirmation Animations:</strong> Smooth fade-in, slide-up, and pulsing arrow effects in confirmation modal. Green glow on affordable promotions, disabled state for insufficient funds.',
              '<strong>Better Error Messages:</strong> More descriptive error messages for position assignment failures with specific reasons.'
            ]
          }
        ]
      },
      {
        version: '2510211800',
        date: 'October 21, 2025',
        title: 'ğŸ¢ Corporate Ladder System + NPC Lifelike Systems',
        changes: [
          {
            category: 'ğŸ¯ Corporate Hierarchy & Pyramid Visualization',
            items: [
              '<strong>7-Level Organizational Chart:</strong> Complete restructure from product-based positions to true hierarchical reporting structure (Level 1 Staff â†’ Level 7 CEO). Positions automatically created based on products/locations unlocked.',
              '<strong>Interactive Pyramid Modal:</strong> Beautiful visual org chart showing your entire company structure at a glance. Click any position to view details, drag employees between positions, pan/zoom controls, mobile-friendly touch support.',
              '<strong>Auto-Assignment:</strong> Newly hired employees automatically assigned to Level 1 Staff positions for their product, appearing immediately in the pyramid.',
              '<strong>Dynamic Position Creation:</strong> Positions scale with your business - Level 1 (1 per product), Level 2 (2-3 per location), Level 3 (1 per location), Level 4 (manages 2-3 locations), Level 5 (CFO/COO), Level 6 (Senior Executive), Level 7 (CEO - You!).',
              '<strong>Reporting Relationships:</strong> Each position tracks who reports to whom, subordinate counts, span of control. Validates chain of command when assigning employees.',
              '<strong>Position Details Modal:</strong> Click any position to see employee info, skills, salary, reporting structure. Remove employees or view vacant positions.',
              '<strong>Migration System:</strong> Seamlessly converts old product-based save data to new hierarchical structure automatically on load.'
            ]
          },
          {
            category: 'ğŸ“ˆ Promotion System Overhaul',
            items: [
              '<strong>Clear Requirements:</strong> Each level has specific productivity and management skill requirements (Level 2: 60% productivity â†’ Level 7: 90% productivity + Level 8 management).',
              '<strong>Visual Promotion Badges:</strong> Employees eligible for promotion display a pulsing golden "â¬†ï¸ READY" badge on their pyramid tile.',
              '<strong>Eligibility Display:</strong> Click any employee in the pyramid to see detailed promotion requirements with current vs. needed values. Shows what they\'re missing in red, what they\'ve achieved in green.',
              '<strong>Three Status States:</strong> Ready (green banner), Not Ready (shows gaps), Max Level (gold crown).',
              '<strong>Promotion Costs:</strong> Scaling costs from $500 (Level 1â†’2) to $500,000 (Level 6â†’7). Lateral moves get 50% discount.',
              '<strong>Smart Assignment:</strong> System validates if employee meets level requirements and has necessary management skills before allowing position assignment.'
            ]
          },
          {
            category: 'ğŸ“ Employee Development Programs',
            items: [
              '<strong>Training Workshops:</strong> Company-wide training affecting all employees at once. Cost: $500 per employee. Benefits: +5-10 productivity, +20 management XP. No cooldown - run as often as budget allows.',
              '<strong>Performance Reviews:</strong> Individual one-on-one reviews with tiered benefits. Cost: $200. Cooldown: 7 days per employee. Low performers get +15-20 productivity, average +10-15, high performers +5-10. Also boosts affection by +5.',
              '<strong>Team Building Activities:</strong> Fun company events boosting both productivity and morale. Cost: $800 per employee. Cooldown: 14 days. Benefits: +3-7 productivity, +8 affection, +8 comfort, +30 social XP.',
              '<strong>Review History Tracking:</strong> All performance reviews tracked in employee career data with before/after productivity values.',
              '<strong>Development Programs UI:</strong> New section at top of People tab with three cards showing each program, costs, cooldowns, and benefits. One-click activation buttons.'
            ]
          },
          {
            category: 'ğŸ·ï¸ Universal Flag System',
            items: [
              '<strong>Dynamic State Tracking:</strong> NPCs can now have unlimited custom "flags" that track ANY state, condition, or trait - physical conditions (pregnant, sick, tired), relationship agreements (free use, exclusive dating), personality traits (dominant, submissive, shy), life events (birthday soon, recent breakup), preferences & kinks (exhibitionist, breeding kink), and literally anything imaginable.',
              '<strong>Two Flag Types:</strong> System flags (auto-created by game mechanics like pregnancy) and custom flags (player-created for any purpose).',
              '<strong>Smart AI Integration:</strong> Flags automatically inject into AI conversation context, so NPCs naturally remember and reference their states. No more forgetting major developments!',
              '<strong>Automatic Detection:</strong> Game watches conversations and suggests flags based on patterns (e.g., detecting free-use agreements, relationship changes). Zero extra AI calls - pure regex pattern matching.',
              '<strong>Flag Management UI:</strong> Beautiful modal accessible from People tab and unified profiles. View all active flags with their priority, AI guidance text, and expiration dates. One-click add/remove.',
              '<strong>Quick-Add Buttons:</strong> 9 pre-configured common flags (Pregnant, In Relationship, Free Use Agreement, Secret Affair, Breeding Kink, Submissive, Dominant, Exhibitionist, Polyamorous) with appropriate emoji, priority, and AI context.',
              '<strong>Flag Display:</strong> Active flags show as colored badges on employee cards with emoji icons (ğŸ¤° Pregnant, ğŸ’‹ Free Use, etc.).',
              '<strong>Custom Flag Creation:</strong> Full custom flag form with name, emoji, description, priority (low/medium/high), AI guidance, optional expiration dates.',
              '<strong>Priority System:</strong> High-priority flags appear first in AI context to ensure important traits/states are emphasized.'
            ]
          },
          {
            category: 'ğŸ—‚ï¸ Unified NPC Profile System',
            items: [
              '<strong>10-Tab Interface:</strong> Comprehensive profile modal consolidating all NPC information: Overview (bio + quick stats), Stats (relationship meters), Skills (work skills with levels), Possessions (gifts received), Flags (state management), Schedule (work hours), Social (feed activity), Relationship (detailed dynamics), Appearance (physical traits), Gallery (images).',
              '<strong>Overview Tab Redesign:</strong> Merged Bio and Overview into single tab with profile picture, basic info, quick stat previews, active flags display, and action buttons.',
              '<strong>Stats Tab:</strong> Visual progress bars for all relationship stats (affection, trust, comfort, desire, productivity) with hover tooltips and exact values.',
              '<strong>Skills Tab:</strong> Work skills displayed with level, XP progress bars, next level requirements. Shows technical, creative, social, management, and life skills (fitness, cooking) with emoji icons.',
              '<strong>Flags Tab:</strong> Full flag management interface within profile - view all flags, add custom flags, quick-add common flags, remove flags. Real-time updates.',
              '<strong>Possessions Tab:</strong> Gallery of all gifts given to NPC with images, names, dates, and categories. Shows appreciation and relationship building over time.',
              '<strong>Schedule Tab:</strong> Work schedule, PTO balance, sick days, hours worked, late days tracking. Future: will show daily routine and current activity.',
              '<strong>Live Edit Mode:</strong> Toggle edit mode to modify NPC data directly in profile. Unsaved changes highlighted. Save/cancel with confirmation.',
              '<strong>Clickable Everywhere:</strong> Access unified profiles by clicking NPC names/avatars anywhere - People tab cards, social media posts, comments, chat.'
            ]
          },
          {
            category: 'ğŸ“‹ Skills & Progression System',
            items: [
              '<strong>Work Skills:</strong> Technical, Creative, Social, Management skills that level up through gameplay. Each skill has level (1-10), XP, and max XP with exponential scaling.',
              '<strong>Life Skills:</strong> Fitness and Cooking skills for personal development and lifestyle activities.',
              '<strong>XP Sources:</strong> Employees gain skill XP from work hours (automatic), evening activities, weekend activities, chat conversations (social), deep conversations (+5 social), flirting (intimate skill), work discussions (highest work skill +3).',
              '<strong>Level-Up Notifications:</strong> Visual notifications when employees level up skills with celebration emoji ğŸ‰.',
              '<strong>Specialization Unlocks:</strong> Certain skill levels unlock specializations (e.g., Technical 3 = "Code Wizard").',
              '<strong>Productivity Bonuses:</strong> Skills provide effective productivity bonuses - technical skills boost tech products, creative skills boost creative products, management gives universal 0.5x boost.',
              '<strong>Skill Display:</strong> Skills shown in unified profiles, employee cards, position details with levels and progress bars.'
            ]
          },
          {
            category: 'ğŸ“… Schedule & Time System',
            items: [
              '<strong>Work Schedule:</strong> Each employee has work days (Mon-Fri default), start/end hours (9 AM - 5 PM), currently-working status, clock in/out timestamps.',
              '<strong>Hours Tracking:</strong> Daily hours worked, total days worked, late days counted for analytics and performance.',
              '<strong>Leave System:</strong> PTO balance (10 days default), sick days (5 days), currently on leave status, leave type tracking (PTO/sick/maternity), leave end dates.',
              '<strong>Future-Ready:</strong> Data structure prepared for time-aware NPC behaviors, location tracking, and daily routine generation.'
            ]
          },
          {
            category: 'ğŸ  Life Outside Work',
            items: [
              '<strong>Current Activity Tracking:</strong> NPCs track what they\'re currently doing outside work (prepared for future real-time activity generation).',
              '<strong>Hobbies System:</strong> Active hobbies with frequency (30-100% engagement), skill levels (1-5), and last-done timestamps.',
              '<strong>Evening Preferences:</strong> Randomized preferences for gym (0-40%), cooking (0-60%), socializing (0-50%), relaxing (30-70%), hobbies (0-60%), dating (0-30%).',
              '<strong>Living Situation:</strong> Apartment/house/condo type, roommate status, pet ownership with details (35% have pets - dogs, cats, birds, fish with randomly generated names like "Max", "Luna").',
              '<strong>Social Circle:</strong> Outside contacts including best friend (70% have one), family (80%), relationship status (30% in relationships), detailed status tracking (single/dating/serious/married).',
              '<strong>Weekend Plans:</strong> System ready to generate upcoming weekend activities and track last weekend activity.',
              '<strong>Pet System:</strong> Pets tracked with name, type, who gifted them, and timestamps. Displayable in profiles and referenced in conversations.'
            ]
          },
          {
            category: 'ğŸ¨ UI/UX Improvements',
            items: [
              '<strong>People Tab Enhancements:</strong> New "Employee Development Programs" section with three cards for Training, Team Building, and Performance Reviews. Cost displays, cooldown indicators, hover effects.',
              '<strong>Employee Card Badges:</strong> Active flags display as colored emoji badges on employee cards. Promotion-ready employees get golden pulsing "â¬†ï¸ READY" badge.',
              '<strong>New Action Buttons:</strong> Added "ğŸ“Š Review" button to employee cards for quick performance review access. "ğŸ·ï¸ Flags" button for flag management.',
              '<strong>Pyramid Controls:</strong> Pan/zoom controls, pinch-to-zoom on mobile, smooth animations, position tile hover effects.',
              '<strong>Modal Improvements:</strong> All new modals use consistent styling with gradients, hover effects, responsive design. Better z-index management prevents stacking issues.',
              '<strong>Visual Feedback:</strong> Success/error notifications for all development program actions. Cost displays update dynamically. Cooldown timers shown in UI.'
            ]
          },
          {
            category: 'âš™ï¸ Technical Improvements',
            items: [
              '<strong>Data Structure Expansion:</strong> Added gameState.corporatePyramid with CEO object, positions arrays by level, promotion costs. gameState.productivitySystems for tracking workshops/reviews. Flag arrays in employee objects.',
              '<strong>Automatic Initialization:</strong> New data structures auto-initialize on first access with sensible defaults. Migration code converts old saves seamlessly.',
              '<strong>Event Logging:</strong> Training workshops, team building, and promotions now create company event log entries for AI context.',
              '<strong>Save Compatibility:</strong> All new systems designed with backward compatibility. Old saves load and automatically upgrade to new structure.',
              '<strong>Performance:</strong> Flag detection uses regex patterns (no AI calls). Pyramid rendering optimized for large companies. Efficient subordinate counting.',
              '<strong>Code Organization:</strong> New dedicated sections for corporate hierarchy functions, productivity systems, flag management. Clear function documentation.'
            ]
          },
          {
            category: 'ğŸ”® Foundation for Future Features',
            items: [
              '<strong>Advanced Social Dynamics:</strong> Flag system enables complex NPC-to-NPC relationships. Schedule system ready for time-aware interactions.',
              '<strong>Family System:</strong> Data structures prepared for pregnancy tracking (7-14 day cycles), children with genetic inheritance, family relationships.',
              '<strong>Dynamic Schedules:</strong> Time system ready to generate daily routines, track NPC locations throughout the day, implement time-aware behaviors.',
              '<strong>Life Simulation:</strong> Weekend activities, evening routines, hobby progression, social events outside work - all data structures in place.',
              '<strong>Relationship Depth:</strong> Flags enable tracking of complex relationship agreements (polyamory, exclusivity, kinks, preferences) that persist across save/load.',
              '<strong>Expandable Systems:</strong> Universal flag system means ANY new state/trait can be added without code changes - just create a new flag!'
            ]
          }
        ]
      },
      {
        version: '2510191600',
        date: 'October 19, 2025',
        title: 'ğŸ’¾ Comprehensive Save/Load System Overhaul',
        changes: [
          {
            category: 'ğŸ”’ Save/Load Coverage (50+ Properties)',
            items: [
              '<strong>Complete System Audit:</strong> Conducted comprehensive audit of all game systems to ensure 100% save/load coverage. Created detailed documentation tracking all 50+ gameState properties.',
              '<strong>Social Network Data:</strong> Added explicit saving/loading for all social network properties including feedFilter, feedSort, recentPostTypes, playerDraft (caption, imagePrompt, altText, imageUrl).',
              '<strong>Player Profile:</strong> Ensured complete player character data is saved (firstName, lastName, age, gender, ethnicity, physical details, intimate details, personality).',
              '<strong>Company Context:</strong> Added full save/load for companyWideContext (currentBuzz, lastUpdate, maxItems, decayTime) and all company awareness data.',
              '<strong>Prestige System:</strong> Verified prestige data saving (prestigeLevel, influencePoints, lifetimeEarnings, prestigeMultiplier, globalUpgrades, bossFights).',
              '<strong>Employee Systems:</strong> Ensured typingStates, onboarding array, and currentCandidates are properly saved.',
              '<strong>Missing Properties Fixed:</strong> Added initialization for playerMentionStats, activeGossip, lastProactiveMessageCheck, lifestyleAdjustmentCounter, and currentCandidates.'
            ]
          },
          {
            category: 'ğŸ“Š Backward Compatibility',
            items: [
              '<strong>Default Values:</strong> All new properties have sensible defaults, ensuring old saves load without errors.',
              '<strong>Migration Path:</strong> Old saves automatically upgraded to new structure without manual intervention.',
              '<strong>No Breaking Changes:</strong> Existing players can load saves from any previous version.',
              '<strong>Future-Proof Template:</strong> Created comprehensive guide for adding new save properties (see SAVE_LOAD_AUDIT.md).'
            ]
          },
          {
            category: 'ğŸ“ Documentation',
            items: [
              '<strong>Coverage Statistics:</strong> 50+ properties tracked across Core (12), Business (8), Employees (10), Social (12), Company (6), Gifts (7), AI (5).',
              '<strong>Developer Guide:</strong> Step-by-step instructions for adding new save properties and handling Sets/Maps.'
            ]
          }
        ]
      },
      {
        version: '2510191523',
        date: 'October 19, 2025',
        title: 'ğŸš¨ Critical Save/Load Bug Fixes',
        changes: [
          {
            category: 'ğŸ”¥ Game-Breaking Fixes',
            items: [
              '<strong>CRITICAL: Fixed Hiring Crash After Loading:</strong> Fixed "TypeError: gameState.usedEmployeeNames.has is not a function" that prevented hiring employees after loading saved games. The Set object was being converted to an Array during JSON serialization, breaking the name uniqueness check.',
              '<strong>Set Object Restoration:</strong> Added automatic conversion of usedEmployeeNames from Array back to Set when loading games. This preserves the .has() and .add() methods required by the hiring system.',
              '<strong>Gender Settings Migration:</strong> Fixed "Cannot read properties of undefined (reading \'female\')" error for old saves without genderSettings. Now automatically initializes with default values (100% female) for backwards compatibility.',
              '<strong>Additional Set/Map Fixes:</strong> Also fixed blockedProactiveMessages (Set) and recentTopics (Map) which had the same serialization issue. All non-serializable objects now properly restored on load.',
              '<strong>Debug Logging:</strong> Added console logs to track Set/Map restoration and settings initialization for easier troubleshooting.'
            ]
          },
          {
            category: 'ğŸ“ Technical Details',
            items: [
              '<strong>Root Cause:</strong> JavaScript Sets and Maps are not JSON-serializable. When saving to localStorage/KV storage, Sets are converted to Arrays and Maps to plain objects. The loadGame function now detects this and converts them back.',
              '<strong>Affected Systems:</strong> Name generation (usedEmployeeNames Set), gender selection (genderSettings object), topic tracking (recentTopics Map), proactive messages (blockedProactiveMessages Set).',
              '<strong>Migration Safety:</strong> Fixes apply automatically to all existing saves without requiring manual intervention. Missing objects are initialized with proper defaults.',
              '<strong>Future Prevention:</strong> This fix provides a comprehensive template for handling all non-serializable objects (Maps, Sets, etc.) in future features.'
            ]
          }
        ]
      },
      {
        version: '2510191346',
        date: 'October 19, 2025',
        title: 'ğŸ Gift System Fixes & AI Improvements',
        changes: [
          {
            category: 'ğŸ”§ Critical Gift System Fixes',
            items: [
              '<strong>Gift Price Scaling Overhaul:</strong> Fixed absurd gift expectations at high wealth levels. Previously at $27B lifetime income, game expected $8.7M-$8.7B gifts, treating a $15k Barcelona trip as "too cheap" (0.3Ã— penalty). Now capped at reasonable human scale: $5k-$500k range regardless of wealth.',
              '<strong>Price Philosophy Change:</strong> Gifts now judged on thoughtfulness, not price relative to net worth. Any gift $1k+ receives no penalty. Even billionaires appreciate a nice vacation!',
              '<strong>New Price Ranges:</strong> Perfect range (1.5Ã— bonus): $15k-$150k | Good range (1.2Ã— bonus): $2.5k-$1M | Modest (1.0Ã—): Any $1k+ gift | Only gifts under $100 receive penalties.',
              '<strong>First Gift Detection:</strong> Fixed NPCs reacting to first-ever gifts as if they\'d received them before. Added explicit "THIS IS YOUR FIRST GIFT" flag in AI prompts with appropriate surprise/delight instructions.',
              '<strong>Reduced "Overwhelmed" Penalty:</strong> Now only triggers for $500k+ gifts with very weak relationships (under 30), reduced from 0.5Ã— to 0.7Ã— penalty.',
              '<strong>Debug Logging:</strong> Added comprehensive gift evaluation logs showing category match, price score, modifiers, and final reception calculations.'
            ]
          },
          {
            category: 'âš¡ AI Generation Optimization',
            items: [
              '<strong>Stat Evaluation Overhaul:</strong> Implemented optimizations for Playerâ†’NPC stat analysis. Reduced prompt from ~600 tokens to ~150 tokens (75% reduction).',
              '<strong>Format-First Prompts:</strong> Moved output format instructions to beginning of prompts, forcing AI cooperation before seeing context.',
              '<strong>Deterministic Output:</strong> Changed temperature from 0.3 â†’ 0 and added top_p:0 for 100% consistent stat evaluations.',
              '<strong>Aggressive Stop Sequences:</strong> Expanded from 8 to 15 stop sequences including "The", "This", "I", "Because" to prevent meta-commentary.',
              '<strong>Context Compression:</strong> Reduced chat context from last 60 messages to last 4 messages (93% reduction) for faster processing.',
              '<strong>Robust Parsing:</strong> Added value clamping to [-10, +10] range and better handling of malformed responses.'
            ]
          },
          {
            category: 'ğŸ’¬ Comment Generation Fixes',
            items: [
              '<strong>Meta-Commentary Removal:</strong> Fixed AI outputting internal reasoning in comments like "Boss\'s post is explicit... personality traits: flirty at 36/100... Brainstorming authentic responses..."',
              '<strong>Prompt Compression:</strong> Reduced comment generation prompts from ~50 lines to ~6 lines (88% reduction).',
              '<strong>Short Direct Prompts:</strong> New format forces clean output: "Name sees post: \'content\' | Rel: type (strength/100) | Comment (5-25 words):"',
              '<strong>Nuclear Cleanup:</strong> Added aggressive sanitization that strips Perchance tokens ({SEEDS}, {BAN}, {BOOST}), name prefixes, and meta-text markers.',
              '<strong>First-Line-Only:</strong> Comments now extract only first line/sentence, cutting any multi-line meta-analysis.',
              '<strong>Fallback Detection:</strong> If comment starts with "Boss", "Personality", or other meta-text, automatically uses template comment instead.'
            ]
          },
          {
            category: 'ğŸ”§ Other Fixes',
            items: [
              '<strong>Advanced Stats Editing:</strong> Fixed Sandbox Mode stats not persisting when reopening bio modal. Modal now closes and reopens automatically after save to display fresh values.',
              '<strong>Gift History Tracking:</strong> Added logging of gift history before each gift to help debug duplicate detection.',
              '<strong>Price Scale Display:</strong> All price calculations now log capped vs uncapped values for transparency.'
            ]
          }
        ]
      },
      {
        version: '2510172020',
        date: 'October 17, 2025',
        title: 'ğŸ› Bug Fixes & AI Optimization',
        changes: [
          {
            category: 'ğŸ”§ Bug Fixes',
            items: [
              '<strong>Memory Initialization:</strong> Fixed crash when editing bio stats then sending chat messages (ensureEmployeeMemory now called after bio save)',
              '<strong>Memory Validation:</strong> Added defensive checks to remember() function to prevent undefined memory.items errors',
              '<strong>Product Unlock Discount:</strong> Fixed "Bulk Buying" prestige reward not applying to product unlock costs. Now shows discounted price with strikethrough original price and discount percentage.',
              '<strong>Perchance Token Removal:</strong> Fixed {SEEDS:...}, {BAN:...}, {BOOST:...} and other Perchance formatting tokens appearing in posts, comments, and chat messages. Added aggressive sanitization to all AI-generated content.'
            ]
          },
          {
            category: 'âœ… Prestige System Audit (All Confirmed Working)',
            items: [
              '<strong>ğŸ’° Income Multiplier:</strong> âœ“ Applied to all product earnings (visible in product values)',
              '<strong>ğŸ’µ Starting Capital:</strong> âœ“ Bonus cash added when prestiging',
              '<strong>ğŸ‘† Quick Hands (Click Power):</strong> âœ“ Reduces product cycle time when clicking (-0.05s per level)',
              '<strong>ğŸ‘” HR Efficiency:</strong> âœ“ Reduces manager hire/upgrade costs (5% per level, max 50%)',
              '<strong>ğŸ“¦ Bulk Buying:</strong> âœ“ NOW FIXED - Reduces product unlock AND upgrade costs (3% per level, max 45%). Visual discount shown on unlock buttons.',
              '<strong>âš¡ Automation Boost:</strong> âœ“ Managers work faster (5% per level, affects auto-run cycle time)'
            ]
          },
          {
            category: 'âš¡ AI Prompt Optimization (In Progress)',
            items: [
              '<strong>Chat Stat Evaluation:</strong> Simplified prompt 80%, reduced from 60 lines to 15 lines. Added explicit "Numbers only" instruction with aggressive stop sequences',
              '<strong>NPC Reaction Evaluation:</strong> Changed "Rate -5 to +5:" to "Output single number -5 to +5 only:" to prevent narrative flashback stories',
              '<strong>Image Prompt Generation:</strong> Reduced custom prompt analysis by 60%, added stop sequences to prevent verbose "Camera angle:", "Mood:" descriptions',
              '<strong>Scene Visualization:</strong> Simplified prompt from 20 lines to 8 lines, removed numbered instructions',
              '<strong>Post Generation:</strong> Added "The stapler" stop sequence to block narrative storytelling, reduced max_tokens to 50',
              '<strong>Comment Generation:</strong> Added stop sequences to 6 additional functions (reply comments, mentions, autonomous comments)',
              '<strong>Token Limits:</strong> Tightened across board - evaluations: 3-10 tokens, comments: 35-50 tokens, images: 100-150 tokens',
              '<strong>Temperature Tuning:</strong> Lowered to 0.3 for evaluations (deterministic), 0.7-0.9 for creative content',
              '<strong>Note:</strong> These fixes require page reload to clear prompt cache. Testing in progress to confirm effectiveness.'
            ]
          }
        ]
      },
      {
        version: '2510170912',
        date: 'October 17, 2025',
        title: 'ğŸ Complete Gift System - AI-Powered Gift Giving',
        changes: [
          {
            category: 'ğŸ‰ Major New Feature',
            items: [
              '<strong>ğŸ Complete Gift System:</strong> Give meaningful gifts to employees with AI-powered reactions, dynamic pricing, and deep integration!'
            ]
          },
          {
            category: 'ğŸ§â€â™‚ï¸ Gift Genie (AI Gift Generator)',
            items: [
              '<strong>Custom Gift Creation:</strong> Describe any gift in text and AI generates it with name, description, category, and price',
              '<strong>100 Cycling Suggestions:</strong> Rotating placeholder text for inspiration (updates every 1.5 seconds)',
              '<strong>Budget Limits:</strong> Set max price from $100 to $1 billion',
              '<strong>Smart Category Mapping:</strong> Prevents AI drift with 11 fixed categories',
              '<strong>Optional Image Generation:</strong> Create visual representations of your gifts',
              '<strong>UNIQUE Gift Warnings:</strong> Special indicators for one-time-only items (private islands, landmarks, etc.)'
            ]
          },
          {
            category: 'ğŸ’ 11 Gift Categories',
            items: [
              'ğŸ’• <strong>ROMANTIC:</strong> Flowers, jewelry, love letters',
              'ğŸ’ <strong>LUXURY:</strong> Designer items, champagne, spa days',
              'âœˆï¸ <strong>EXPERIENCES:</strong> Concert tickets, vacations, skydiving',
              'ğŸ’» <strong>TECH:</strong> Gadgets, smart devices, gaming gear',
              'ğŸ“š <strong>INTELLECTUAL:</strong> Books, courses, museum memberships',
              'ğŸ° <strong>FOOD:</strong> Gourmet treats, wine, restaurant vouchers',
              'ğŸ› ï¸ <strong>PRACTICAL:</strong> Office supplies, tools, home goods',
              'ğŸª <strong>QUIRKY:</strong> Novelty items, weird collectibles',
              'ğŸ§˜ <strong>WELLNESS:</strong> Fitness equipment, meditation apps',
              'ğŸ‘— <strong>FASHION:</strong> Clothing, accessories, cosmetics',
              'ğŸŒ <strong>UNIQUE:</strong> One-time only items (private islands, landmarks, planets)'
            ]
          },
          {
            category: 'ğŸ“ˆ Dynamic Price Scaling',
            items: [
              '<strong>Scales with Company Growth:</strong> Recommended gift prices adapt to your lifetime income THIS prestige',
              '<strong>Startup ($0-$10K):</strong> $10-$500 gifts',
              '<strong>Small Business ($10K-$1M):</strong> $500-$10K gifts',
              '<strong>Growing Company ($1M-$100M):</strong> $10K-$500K gifts',
              '<strong>Corporation ($100M-$10B):</strong> $500K-$50M gifts',
              '<strong>Mega Corp ($10B+):</strong> $50M-$1B+ gifts',
              'Real-time recommendations displayed in Store UI'
            ]
          },
          {
            category: 'ğŸ­ NPC Gift Preferences',
            items: [
              '<strong>Personalized Tastes:</strong> Each employee has 2-3 loved categories, 2-3 hated categories',
              '<strong>Loved Gifts:</strong> 1.5x to 2.5x stat bonus!',
              '<strong>Hated Gifts:</strong> Negative stat changes (can harm relationship)',
              '<strong>Visual Indicators:</strong> "They\'ll LOVE this! ğŸ’•" / "They might hate this... ğŸ’”" hints in gift selection',
              'Generated at employee creation, persistent across saves',
              'Visible in employee bio under "ğŸ Gift Preferences"'
            ]
          },
          {
            category: 'ğŸ¯ Intelligent Gift Reception',
            items: [
              '<strong>Multi-Factor Calculation:</strong> Category match, price, relationship, timing all affect reaction',
              '<strong>Gift Fatigue:</strong> 3+ gifts in 7 days = -50% effectiveness (prevents stat grinding)',
              '<strong>Duplicate Detection:</strong> Same gift within 30 days = -70% penalty',
              '<strong>Price Appropriateness:</strong> Too cheap OR too expensive = penalties',
              '<strong>Relationship-Based:</strong> Low relationship + expensive gift = "Suspicious" reaction',
              '<strong>6 Reaction Tones:</strong> Delighted, Grateful, Overwhelmed, Underwhelmed, Suspicious, Confused',
              'AI-generated contextual reactions based on employee personality, gift type, and reception quality'
            ]
          },
          {
            category: 'ğŸ’¬ Conversation Integration',
            items: [
              '<strong>Give Gift Button:</strong> Added to conversation attachment menu (+ button)',
              '<strong>Gift Selection Modal:</strong> Browse inventory with live preference hints',
              '<strong>Visual Hints:</strong> Green borders for loved categories, red for hated, neutral for others',
              '<strong>One-Click Giving:</strong> Select gift â†’ instant AI reaction in chat',
              '<strong>Stat Changes Visible:</strong> See exact affection, comfort, trust, desire changes',
              'Gifts appear in chat history with reactions',
              'Empty state when no gifts in inventory (directs to Gifts tab)'
            ]
          },
          {
            category: 'ğŸ“Š Gift History & Statistics',
            items: [
              '<strong>Bio Integration:</strong> View gift preferences in employee bio modal',
              '<strong>Total Gifts:</strong> Count of all gifts received',
              '<strong>Total Value:</strong> Sum of all gift prices',
              '<strong>Recent Gifts:</strong> Gifts received in last 7 days',
              '<strong>Favorite Gifts:</strong> Top 5 most-loved gifts displayed',
              'Color-coded category badges (green for loves, red for hates)',
              'Stat bonus explanations next to each preference'
            ]
          },
          {
            category: 'ğŸ“± Social Media Integration',
            items: [
              '<strong>Expensive Gifts = Posts:</strong> Gifts over $100K trigger automatic social media posts',
              'NPCs share their reactions publicly',
              'Includes gift details (name, value, category)',
              'Increases NPC fame and engagement',
              'Visible on social feed with reactions'
            ]
          },
          {
            category: 'ğŸ›¡ï¸ Anti-Exploit Features',
            items: [
              '<strong>UNIQUE Gift Tracking:</strong> One-time items can only be given once per save file',
              '<strong>Gift Fatigue System:</strong> Prevents stat grinding with rapid gifting',
              '<strong>Duplicate Detection:</strong> Encourages variety in gift selection',
              '<strong>Price-Relationship Checks:</strong> Suspicious reactions to inappropriate gifts',
              'Lifetime income tracking (THIS prestige only, resets on prestige)',
              'Inventory unlimited but UNIQUE gifts tracked globally'
            ]
          },
          {
            category: 'ğŸ¨ UI/UX Improvements',
            items: [
              '<strong>New Gifts Tab:</strong> Complete store interface with gradient styling',
              '<strong>Gift Preview Modal:</strong> See all details before purchasing',
              '<strong>Inventory Grid:</strong> Visual cards with hover effects',
              '<strong>Delete Gifts:</strong> Remove unwanted items from inventory',
              '<strong>Cycling Suggestions:</strong> Smooth 1.5-second transitions between ideas',
              '<strong>Responsive Design:</strong> Works on all screen sizes',
              'Color-coded visual language (pink for gifts, green for loves, red for hates)'
            ]
          },
          {
            category: 'ğŸ’¾ Technical Implementation',
            items: [
              '<strong>~1500 Lines of Code:</strong> Complete feature with 15+ functions',
              '<strong>Save/Load Support:</strong> All gift data persists correctly',
              '<strong>Migration System:</strong> Old saves automatically get gift preferences',
              '<strong>Performance Optimized:</strong> Efficient category lookups and calculations',
              'Comprehensive error handling',
              'Full documentation in GIFT_SYSTEM_COMPLETE.md'
            ]
          }
        ]
      },
      {
        version: '2510170000',
        date: 'October 17, 2025',
        title: 'ğŸ¤œ NPC Conversation Improvements',
        changes: [
          {
            category: 'âœ¨ Improvements',
            items: [
              '<strong>Fixed repetitive "knuckles" descriptions:</strong> NPCs were constantly mentioning knuckles (whitening, clenching, tightening) in conversations. Added explicit ban on this overused trope with alternative body language suggestions (fidgeting, shifting weight, playing with hair/clothing, eye movements, breathing changes, facial expressions, etc.)'
            ]
          }
        ]
      },
      {
        version: '2510162000',
        date: 'October 16, 2025',
        title: 'ğŸ’° Payment System Overhaul & Complete Save System',
        changes: [
          {
            category: 'âœ¨ Major New Features',
            items: [
              '<strong>Company-Scaled NPC Spending:</strong> NPCs now develop spending habits that scale with company success (1.0x to 6.0x multiplier)',
              '<strong>Gradual Lifestyle Adjustment:</strong> NPCs smoothly adapt their spending as your business grows (5% per tick)',
              '<strong>Dynamic Money Requests:</strong> NPCs ask for amounts proportional to company size and their financial situation',
              '<strong>Counter-Offer System:</strong> Send custom amounts with personal justifications when NPCs request money',
              '<strong>Bank Balance Tracking:</strong> Each NPC tracks their cumulative money received and spending patterns',
              '<strong>Lifestyle Inflation:</strong> NPCs develop more expensive habits when receiving money (+$1/day per $10K sent)',
              '<strong>AI-Enhanced Requests:</strong> Smart, context-aware money requests based on financial need, personality, and relationship',
              '<strong>Complete Save/Load System:</strong> Import/Export saves as JSON files with metadata and validation',
              '<strong>Patch Notes System:</strong> View update history with timestamp-based versioning (YYMMDDHHMMSS format)'
            ]
          },
          {
            category: 'ğŸ’¾ Save System Improvements',
            items: [
              'Export saves to JSON files with metadata (version, timestamp, player stats)',
              'Import saves from files with validation and preview before loading',
              'Save files include confirmation dialog showing money, employees, prestige level',
              'Automatic filename generation with timestamps',
              'Legacy save format detection and migration support',
              'Pretty-printed JSON for easy editing and debugging',
              'Full state restoration with UI refresh after import'
            ]
          },
          {
            category: 'ğŸ› Critical Bug Fixes',
            items: [
              '<strong>Fixed black screen after prestiging</strong> - Now properly loads dashboard with full UI refresh',
              '<strong>Fixed sandbox settings not saving</strong> - Personality attributes, conversation phase, and memory cap now persist correctly',
              'Fixed personality attributes (confidence, outgoing, flirty, professional, humor) not being saved',
              'Fixed conversation phase dropdown not persisting between edits',
              'Fixed memory cap adjustments being lost after save',
              'Prestige now forces complete UI refresh for all tabs (dashboard, business, people)',
              'Added object initialization checks to prevent undefined property errors'
            ]
          },
          {
            category: 'ğŸ“ˆ Financial System Balance',
            items: [
              '<strong>Early game ($1K-$100K):</strong> NPCs spend $60-180/day, request $500-$3,000',
              '<strong>Mid game ($1M):</strong> NPCs spend $125-375/day, request $2,000-$20,000',
              '<strong>Late game ($100M):</strong> NPCs spend $225-675/day, request $10,000-$150,000',
              '<strong>End game ($1B+):</strong> NPCs spend $300-900/day, request $50,000-$500,000+',
              'Request probability scales with financial desperation (broke NPCs more likely to ask)',
              'Spending rate caps at $50,000/day to prevent absurdity',
              'Request probability caps at 35% maximum to prevent spam'
            ]
          },
          {
            category: 'ğŸ¨ UI Enhancements',
            items: [
              'Redesigned Data Management section with color-coded buttons',
              'Added emojis and better labels for all save/load actions',
              'New Patch Notes modal with organized categories and version history',
              'Improved notification messages with context and status',
              'Better visual hierarchy in settings panel',
              'Confirmation dialogs show detailed info before destructive actions'
            ]
          },
          {
            category: 'âš™ï¸ Technical Improvements',
            items: [
              'Added <code>calculateScaledSpendingRate()</code> function for company-scaled spending',
              'Added <code>adjustEmployeeLifestyles()</code> for gradual lifestyle creep',
              'Enhanced <code>considerMoneyRequest()</code> with financial intelligence',
              'Improved <code>sendMoneyToNPC()</code> with better framing and reactions',
              'New <code>loadSaveData()</code> function for complete state restoration',
              'Added <code>handleImportedFile()</code> for file validation and parsing',
              'Enhanced <code>exportSave()</code> with metadata and pretty printing',
              'Better error handling and user feedback throughout save/load system'
            ]
          }
        ]
      }
      // Add future patch notes above this line
    ];
    
    // Generate HTML
    let html = '';
    patchNotes.forEach((patch, index) => {
      html += `
        <div style="background:#0f3460; border-radius:12px; padding:20px; margin-bottom:${index < patchNotes.length - 1 ? '20px' : '0'}; border:1px solid #667eea;">
          <div style="margin-bottom:15px;">
            <div style="display:flex; justify-content:space-between; align-items:start; flex-wrap:wrap; gap:10px;">
              <div>
                <h3 style="margin:0 0 5px 0; color:#667eea; font-size:1.5rem;">${patch.title}</h3>
                <div style="color:#aaa; font-size:0.9rem;">${patch.date}</div>
              </div>
              <div style="background:rgba(102,126,234,0.2); padding:6px 12px; border-radius:6px; border:1px solid #667eea;">
                <span style="color:#667eea; font-family:monospace; font-size:0.85rem;">v${patch.version}</span>
              </div>
            </div>
          </div>
          
          ${patch.changes.map(category => `
            <div style="margin-bottom:20px;">
              <h4 style="margin:0 0 12px 0; color:#00d4ff; font-size:1.1rem;">${category.category}</h4>
              <ul style="margin:0; padding-left:20px; color:#e0e0e0;">
                ${category.items.map(item => `<li style="margin-bottom:8px; line-height:1.5;">${item}</li>`).join('')}
              </ul>
            </div>
          `).join('')}
        </div>
      `;
    });
    
    patchNotesContent.innerHTML = html;
  }

  function showNotification(message, type = 'success') {
    // Create notification element
    const colors = {
      success: '#4caf50',
      error: '#e94560',
      warning: '#ffa726',
      info: '#2196f3'
    };
    
    const notification = document.createElement('div');
    notification.style.cssText = `position:fixed; bottom:20px; right:20px; background:${colors[type] || colors.success}; color:white; padding:15px 20px; border-radius:8px; box-shadow:0 4px 15px rgba(0,0,0,0.3); z-index:3000; max-width:300px; animation: slideIn 0.3s;`;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    // Remove after 3 seconds
    setTimeout(() => {
      notification.style.animation = 'fadeOut 0.3s';
      setTimeout(() => notification.remove(), 300);
    }, 3000);
  }
  
  // Save game
  // Flag to prevent saving during reset
  let isResetting = false;
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DEBOUNCED SAVE SYSTEM - Prevents save congestion from bulk operations
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let saveDebounceTimer = null;
  let savePending = false;
  const SAVE_DEBOUNCE_MS = 500; // Coalesce saves within 500ms window
  
  /**
   * Request a debounced save - multiple calls within SAVE_DEBOUNCE_MS
   * will be coalesced into a single save operation.
   * Use this for high-frequency operations (skill XP, stat changes, etc.)
   */
  function debouncedSave() {
    if (isResetting) return;
    
    savePending = true;
    
    // Clear any existing timer
    if (saveDebounceTimer) {
      clearTimeout(saveDebounceTimer);
    }
    
    // Set new timer
    saveDebounceTimer = setTimeout(() => {
      if (savePending) {
        savePending = false;
        saveGame(false); // Silent save
        console.log('[SaveManager] Debounced save executed');
      }
    }, SAVE_DEBOUNCE_MS);
  }
  
  /**
   * Force flush any pending debounced save immediately.
   * Call this before critical operations that need data persisted.
   */
  function flushPendingSave() {
    if (saveDebounceTimer) {
      clearTimeout(saveDebounceTimer);
      saveDebounceTimer = null;
    }
    if (savePending) {
      savePending = false;
      saveGame(false);
      console.log('[SaveManager] Pending save flushed');
    }
  }

  // Save game using kv-plugin (avoids localStorage quota limits)
  async function saveGame(showToast = true) {
    // Don't save if we're in the middle of resetting
    if (isResetting) return;
    
    try {
      // Use new slot-based save system - save to autosave slot
      await saveGameToSlot('autosave', 'auto', showToast);
    } catch (error) {
      console.error('Error saving game:', error);
      if (showToast) showNotification('Failed to save game!', 'error');
    }
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NEW MULTI-SLOT SAVE SYSTEM
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  // Prevent concurrent saves from piling up
  let saveInProgress = false;
  let lastSaveTime = 0;
  const MIN_SAVE_INTERVAL = 500; // Minimum 500ms between saves
  
  /**
   * Save game to a specific slot
   * @param {string} slotName - Name of the save slot (e.g., "autosave", "quick_123", "manual_123", "My Save")
   * @param {string} saveType - Type of save: "auto", "quick", or "manual"
   * @param {boolean} showToast - Whether to show notification
   * @returns {Promise<Object>} The saved data object
   */
  async function saveGameToSlot(slotName, saveType = 'manual', showToast = true) {
    if (isResetting) return null;
    
    // OPTIMIZATION: Prevent concurrent saves and throttle save frequency
    const now = Date.now();
    if (saveInProgress) {
      // Skip this save if one is already in progress (for auto saves only)
      if (saveType === 'auto') {
        console.log('[SaveManager] Skipping auto-save (save already in progress)');
        return null;
      }
      // For manual saves, wait for current save to finish
      while (saveInProgress) {
        await new Promise(resolve => setTimeout(resolve, 50));
      }
    }
    
    // Throttle auto-saves to prevent rapid-fire saves
    if (saveType === 'auto' && (now - lastSaveTime) < MIN_SAVE_INTERVAL) {
      console.log('[SaveManager] Throttling auto-save (too soon since last save)');
      return null;
    }
    
    saveInProgress = true;
    lastSaveTime = now;
    
    try {
      // Calculate total playtime (if tracking)
      const totalPlayTime = gameState.totalPlayTime || 0;
      
      // Create save data with metadata
      const saveData = {
        version: '250116200000', // Current game version
        meta: {
          saveDate: new Date().toISOString(),
          saveName: slotName,
          saveType: saveType, // "auto", "quick", "manual"
          playTime: totalPlayTime,
          gameDay: gameState.time?.day || 0,
          gameTime: gameState.time?.currentTime || Date.now(),
          money: gameState.cash || 0,
          employees: gameState.employees?.length || 0,
          prestigeLevel: gameState.prestigeLevel || 0
        },
        gameState: gameState
      };
      
      // Save to kv-plugin with slot-specific key
      await kv.gameSave.set(`fuoc_save_${slotName}`, saveData);
      
      console.log(`[SaveManager] Saved to slot: ${slotName} (type: ${saveType})`);
      
      if (showToast) {
        const typeEmoji = saveType === 'auto' ? 'ğŸ’¾' : saveType === 'quick' ? 'âš¡' : 'âœ…';
        showNotification(`${typeEmoji} Game saved to: ${slotName}`);
      }
      
      saveInProgress = false;
      return saveData;
    } catch (error) {
      console.error(`[SaveManager] Error saving to slot ${slotName}:`, error);
      
      // Handle specific storage errors
      if (error.name === 'QuotaExceededError' || error.message?.includes('QuotaExceededError')) {
        console.error('[SaveManager] Storage quota exceeded!');
        if (showToast) {
          showNotification('ğŸ’¾ Storage full! Clear old saves in Save Manager.', 'error', 8000);
        }
      } else if (error.message?.includes('can\'t access property') || error.message?.includes('tracking is undefined')) {
        console.error('[SaveManager] Autosave tracking error, reinitializing...');
        // Reinitialize autosave tracking
        if (!gameState.autosaveTracking) {
          gameState.autosaveTracking = {
            lastSnapshotTime: Date.now(),
            currentSlotIndex: 0,
            snapshotIntervalMinutes: 5
          };
          console.log('[SaveManager] Reinitialized autosave tracking');
        }
        if (showToast) {
          showNotification('ğŸ’¾ Save system recovered. Trying again...', 'info', 4000);
        }
        // Retry save once after fixing tracking
        try {
          await kv.gameSave.set(`fuoc_save_${slotName}`, saveData);
          if (showToast) {
            const typeEmoji = saveType === 'auto' ? 'ğŸ’¾' : saveType === 'quick' ? 'âš¡' : 'âœ…';
            showNotification(`${typeEmoji} Game saved to: ${slotName} (recovered)`, 'success');
          }
          saveInProgress = false;
          return saveData;
        } catch (retryError) {
          console.error('[SaveManager] Retry failed:', retryError);
          if (showToast) showNotification('âŒ Save failed even after recovery!', 'error');
        }
      } else {
        if (showToast) showNotification('âŒ Failed to save game!', 'error');
      }
      saveInProgress = false;
      throw error;
    }
  }
  
  /**
   * Load game from a specific slot
   * @param {string} slotName - Name of the save slot to load
   * @returns {Promise<boolean>} Success status
   */
  async function loadGameFromSlot(slotName) {
    try {
      console.log(`[SaveManager] Loading from slot: ${slotName}`);
      
      const saveData = await kv.gameSave.get(`fuoc_save_${slotName}`);
      
      if (!saveData) {
        console.warn(`[SaveManager] No save found in slot: ${slotName}`);
        showNotification(`âŒ Save slot "${slotName}" not found!`, 'error');
        return false;
      }
      
      // Validate save structure
      if (!saveData.gameState) {
        console.error(`[SaveManager] Invalid save structure in slot: ${slotName}`);
        showNotification('âŒ Corrupted save file!', 'error');
        return false;
      }
      
      // Load the gameState (use existing loadSaveData logic)
      await loadSaveData(saveData.gameState);
      
      console.log(`[SaveManager] Successfully loaded from slot: ${slotName}`);
      showNotification(`âœ… Loaded save: ${slotName}`, 'success');
      
      return true;
    } catch (error) {
      console.error(`[SaveManager] Error loading from slot ${slotName}:`, error);
      showNotification('âŒ Failed to load save!', 'error');
      return false;
    }
  }
  
  /**
   * List all available save slots
   * @returns {Promise<Array>} Array of save metadata objects
   */
  async function listAllSaves() {
    try {
      const saves = [];
      const allKeys = await kv.gameSave.keys();
      
      for (const key of allKeys) {
        // Only process our new save format keys
        if (key.startsWith('fuoc_save_')) {
          const slotName = key.replace('fuoc_save_', '');
          const data = await kv.gameSave.get(key);
          
          if (data && data.meta) {
            saves.push({
              slotName,
              ...data.meta,
              hasGameState: !!data.gameState
            });
          }
        }
      }
      
      // Sort by save date (newest first)
      saves.sort((a, b) => new Date(b.saveDate) - new Date(a.saveDate));
      
      console.log(`[SaveManager] Found ${saves.length} save slots`);
      return saves;
    } catch (error) {
      console.error('[SaveManager] Error listing saves:', error);
      return [];
    }
  }
  
  /**
   * Delete a save slot
   * @param {string} slotName - Name of slot to delete
   * @returns {Promise<boolean>} Success status
   */
  async function deleteSaveSlot(slotName) {
    try {
      // Prevent deleting autosave slots (main autosave and numbered snapshots)
      if (slotName === 'autosave' || slotName.startsWith('autosave_')) {
        showNotification('âŒ Cannot delete autosave slots!', 'error');
        return false;
      }
      
      const key = `fuoc_save_${slotName}`;
      await kv.gameSave.delete(key);
      
      console.log(`[SaveManager] Deleted slot: ${slotName}`);
      showNotification(`ğŸ—‘ï¸ Deleted save: ${slotName}`);
      return true;
    } catch (error) {
      console.error(`[SaveManager] Error deleting slot ${slotName}:`, error);
      showNotification('âŒ Failed to delete save!', 'error');
      return false;
    }
  }
  
  /**
   * Rename a save slot
   * @param {string} oldName - Current slot name
   * @param {string} newName - New slot name
   * @returns {Promise<boolean>} Success status
   */
  async function renameSaveSlot(oldName, newName) {
    try {
      // Prevent renaming autosave slots (main and numbered snapshots)
      if (oldName === 'autosave' || oldName.startsWith('autosave_') || 
          newName === 'autosave' || newName.startsWith('autosave_')) {
        showNotification('âŒ Cannot rename autosave slots!', 'error');
        return false;
      }
      
      // Prevent renaming to existing slot
      const existingKeys = await kv.gameSave.keys();
      if (existingKeys.includes(`fuoc_save_${newName}`)) {
        showNotification('âŒ Save name already exists!', 'error');
        return false;
      }
      
      // Load old save
      const saveData = await kv.gameSave.get(`fuoc_save_${oldName}`);
      if (!saveData) {
        showNotification('âŒ Original save not found!', 'error');
        return false;
      }
      
      // Update metadata
      saveData.meta.saveName = newName;
      
      // Save with new name
      await kv.gameSave.set(`fuoc_save_${newName}`, saveData);
      
      // Delete old save
      await kv.gameSave.delete(`fuoc_save_${oldName}`);
      
      console.log(`[SaveManager] Renamed slot: ${oldName} â†’ ${newName}`);
      showNotification(`âœï¸ Renamed save to: ${newName}`);
      return true;
    } catch (error) {
      console.error(`[SaveManager] Error renaming slot ${oldName}:`, error);
      showNotification('âŒ Failed to rename save!', 'error');
      return false;
    }
  }
  
  /**
   * Export a specific save slot to JSON file
   * @param {string} slotName - Name of slot to export
   */
  async function exportSaveSlot(slotName) {
    try {
      const saveData = await kv.gameSave.get(`fuoc_save_${slotName}`);
      
      if (!saveData) {
        showNotification(`âŒ Save slot "${slotName}" not found!`, 'error');
        return;
      }
      
      const jsonString = JSON.stringify(saveData, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      // Generate filename
      const dateStr = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
      const filename = `FUOC-${slotName}-${dateStr}.json`;
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      URL.revokeObjectURL(url);
      console.log(`[SaveManager] Exported slot: ${slotName}`);
      showNotification(`ğŸ“¤ Exported: ${filename}`, 'success');
    } catch (error) {
      console.error(`[SaveManager] Error exporting slot ${slotName}:`, error);
      showNotification('âŒ Failed to export save!', 'error');
    }
  }
  
  /**
   * Import save from JSON file into a new slot
   * @param {Object} saveData - Parsed save data
   * @param {string} targetSlotName - Optional custom slot name
   * @returns {Promise<boolean>} Success status
   */
  async function importSaveToSlot(saveData, targetSlotName = null) {
    try {
      // Validate structure
      if (!saveData.gameState) {
        throw new Error('Invalid save file structure');
      }
      
      // Generate slot name if not provided
      const slotName = targetSlotName || `imported_${Date.now()}`;
      
      // Ensure it doesn't overwrite existing
      const existingKeys = await kv.gameSave.keys();
      if (existingKeys.includes(`fuoc_save_${slotName}`)) {
        throw new Error('Target slot already exists');
      }
      
      // Update metadata to mark as imported
      if (!saveData.meta) {
        saveData.meta = {};
      }
      saveData.meta.saveName = slotName;
      saveData.meta.saveType = 'manual';
      saveData.meta.importedAt = new Date().toISOString();
      
      // Save to new slot
      await kv.gameSave.set(`fuoc_save_${slotName}`, saveData);
      
      console.log(`[SaveManager] Imported to slot: ${slotName}`);
      showNotification(`ğŸ“¥ Imported save: ${slotName}`, 'success');
      return true;
    } catch (error) {
      console.error('[SaveManager] Error importing save:', error);
      showNotification(`âŒ Import failed: ${error.message}`, 'error');
      return false;
    }
  }
  
  /**
   * Migrate legacy single-save to new multi-slot system
   * This runs once on first load to preserve existing saves
   */
  async function migrateLegacySave() {
    try {
      // Check if old "gameState" key exists
      const legacySave = await kv.gameSave.get("gameState");
      
      if (!legacySave) {
        console.log('[SaveManager] No legacy save to migrate');
        return;
      }
      
      console.log('[SaveManager] Found legacy save, migrating...');
      
      // Create migration save with metadata
      const migrationData = {
        version: '250116200000',
        meta: {
          saveDate: new Date().toISOString(),
          saveName: 'migrated_legacy',
          saveType: 'manual',
          playTime: 0,
          gameDay: legacySave.time?.day || 0,
          money: legacySave.cash || 0,
          employees: legacySave.employees?.length || 0,
          prestigeLevel: legacySave.prestigeLevel || 0,
          migratedFrom: 'legacy_single_save'
        },
        gameState: legacySave
      };
      
      // Save to new format
      await kv.gameSave.set('fuoc_save_migrated_legacy', migrationData);
      
      // Also create an autosave from it
      await kv.gameSave.set('fuoc_save_autosave', {
        ...migrationData,
        meta: {
          ...migrationData.meta,
          saveName: 'autosave',
          saveType: 'auto'
        }
      });
      
      // DELETE the old legacy save so migration doesn't run again
      await kv.gameSave.delete('gameState');
      
      console.log('[SaveManager] âœ… Legacy save migrated successfully and removed');
      showNotification('âœ… Save migrated to new system!', 'success');
      
      return true;
    } catch (error) {
      console.error('[SaveManager] Migration error:', error);
      return false;
    }
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // END NEW MULTI-SLOT SAVE SYSTEM
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SAVE MANAGER UI CLASS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  /**
   * SaveManager - Modal UI for managing save slots
   */
  class SaveManager {
    constructor() {
      this.view = {
        tab: 'manual',        // 'manual' or 'auto'
        sortKey: 'savedAt',   // Column to sort by
        sortDir: 'desc',      // 'asc' or 'desc'
        query: '',            // Search filter
        selectedId: null      // Currently selected save
      };
      this.modal = null;
      this.editingNameId = null;
    }
    
    /**
     * Show the save manager modal
     */
    async show() {
      // Create modal if it doesn't exist
      if (!this.modal) {
        this.modal = this.buildHTML();
        document.body.appendChild(this.modal);
        this.attachEventListeners();
      }
      
      // Render the save list
      await this.render();
      
      // Show modal
      this.modal.style.display = 'flex';
    }
    
    /**
     * Hide the save manager modal
     */
    hide() {
      if (this.modal) {
        this.modal.style.display = 'none';
      }
    }
    
    /**
     * Build the HTML structure
     */
    buildHTML() {
      const modal = document.createElement('div');
      modal.className = 'save-manager-modal';
      modal.innerHTML = `
        <div class="save-manager-container">
          
          <!-- Header -->
          <div class="save-manager-header">
            <div class="save-manager-title">
              <div class="save-manager-logo">ğŸ’¾</div>
              <div>
                <h2>Save Manager</h2>
                <div class="save-manager-subtitle">Manage your game saves â€¢ Quick Save (F5) â€¢ Quick Load (F9)</div>
              </div>
            </div>
            <button class="save-manager-close" id="sm-close">âœ•</button>
          </div>

          <!-- Actions -->
          <div class="save-manager-actions">
            <button class="sm-btn accent" id="sm-continue">â–¶ Continue</button>
            <button class="sm-btn success" id="sm-quick-save">âº Quick Save</button>
            <button class="sm-btn primary" id="sm-quick-load">â® Quick Load</button>
            <button class="sm-btn" id="sm-export-all">ğŸ“¤ Export</button>
            <button class="sm-btn" id="sm-import">ğŸ“¥ Import</button>
            <input type="file" id="sm-import-file" accept=".json" style="display: none;">
          </div>

          <!-- Toolbar -->
          <div class="save-manager-toolbar">
            <div class="save-tab-group">
              <button class="save-tab active" id="sm-tab-manual">Manual Saves</button>
              <button class="save-tab" id="sm-tab-auto">Autosaves & Quick Saves</button>
            </div>
            <div class="save-search-box">
              <span class="save-search-icon">ğŸ”</span>
              <input type="text" id="sm-search" placeholder="Search saves..." />
            </div>
          </div>

          <!-- Save List -->
          <div class="save-list-container">
            <table class="save-table">
              <thead>
                <tr>
                  <th class="sortable" data-sort="name">Name <span class="sort-arrow">â–¾</span></th>
                  <th class="sortable" data-sort="day">Day</th>
                  <th class="sortable" data-sort="savedAt">Saved At <span class="sort-arrow">â–¾</span></th>
                  <th>Money</th>
                  <th>Employees</th>
                  <th class="sortable" data-sort="playTime">Playtime</th>
                  <th style="width: 250px;">Actions</th>
                </tr>
              </thead>
              <tbody id="sm-tbody">
                <!-- Populated by render() -->
              </tbody>
            </table>
            
            <!-- Mobile Card Container -->
            <div class="save-card-container" id="sm-card-container">
              <!-- Populated by render() -->
            </div>
          </div>

          <!-- Footer -->
          <div class="save-manager-footer">
            <div class="save-footer-hint">
              <span>Tips:</span>
              <span><span class="kbd">F5</span> Quick Save</span>
              <span><span class="kbd">F9</span> Quick Load</span>
              <span><span class="kbd">Esc</span> Close</span>
            </div>
            <div class="save-count" id="sm-count">
              Loading saves...
            </div>
          </div>
          
        </div>
      `;
      
      return modal;
    }
    
    /**
     * Attach event listeners
     */
    attachEventListeners() {
      const modal = this.modal;
      
      // Close button
      modal.querySelector('#sm-close').addEventListener('click', () => this.hide());
      
      // Click outside to close
      modal.addEventListener('click', (e) => {
        if (e.target === modal) this.hide();
      });
      
      // ESC key to close
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.style.display === 'flex') {
          this.hide();
        }
      });
      
      // Continue button
      modal.querySelector('#sm-continue').addEventListener('click', () => this.handleContinue());
      
      // Quick Save button
      modal.querySelector('#sm-quick-save').addEventListener('click', () => this.handleQuickSave());
      
      // Quick Load button
      modal.querySelector('#sm-quick-load').addEventListener('click', () => this.handleQuickLoad());
      
      // Export button
      modal.querySelector('#sm-export-all').addEventListener('click', () => this.handleExportSelected());
      
      // Import button & file input
      const importBtn = modal.querySelector('#sm-import');
      const fileInput = modal.querySelector('#sm-import-file');
      importBtn.addEventListener('click', () => fileInput.click());
      fileInput.addEventListener('change', (e) => this.handleImport(e));
      
      // Tab switching
      modal.querySelector('#sm-tab-manual').addEventListener('click', () => this.switchTab('manual'));
      modal.querySelector('#sm-tab-auto').addEventListener('click', () => this.switchTab('auto'));
      
      // Search input
      modal.querySelector('#sm-search').addEventListener('input', (e) => {
        this.view.query = e.target.value.toLowerCase();
        this.render();
      });
      
      // Sortable headers
      modal.querySelectorAll('th.sortable').forEach(th => {
        th.addEventListener('click', () => {
          const sortKey = th.dataset.sort;
          if (this.view.sortKey === sortKey) {
            this.view.sortDir = this.view.sortDir === 'asc' ? 'desc' : 'asc';
          } else {
            this.view.sortKey = sortKey;
            this.view.sortDir = 'desc';
          }
          this.render();
        });
      });
    }
    
    /**
     * Switch between manual and auto tabs
     */
    async switchTab(tab) {
      this.view.tab = tab;
      
      // Update tab buttons
      const manual = this.modal.querySelector('#sm-tab-manual');
      const auto = this.modal.querySelector('#sm-tab-auto');
      
      if (tab === 'manual') {
        manual.classList.add('active');
        auto.classList.remove('active');
      } else {
        auto.classList.add('active');
        manual.classList.remove('active');
      }
      
      await this.render();
    }
    
    /**
     * Render the save list
     */
    async render() {
      const tbody = this.modal.querySelector('#sm-tbody');
      const cardContainer = this.modal.querySelector('#sm-card-container');
      const countEl = this.modal.querySelector('#sm-count');
      
      // Get all saves
      const allSaves = await listAllSaves();
      
      // Filter by tab
      let filtered = allSaves.filter(s => {
        if (this.view.tab === 'manual') {
          return s.saveType === 'manual';
        } else {
          return s.saveType === 'auto' || s.saveType === 'quick';
        }
      });
      
      // Filter by search query
      if (this.view.query) {
        filtered = filtered.filter(s => {
          const searchStr = `${s.saveName}`.toLowerCase();
          return searchStr.includes(this.view.query);
        });
      }
      
      // Sort
      filtered.sort((a, b) => {
        let aVal, bVal;
        switch (this.view.sortKey) {
          case 'name':
            aVal = a.saveName.toLowerCase();
            bVal = b.saveName.toLowerCase();
            break;
          case 'day':
            aVal = a.gameDay || 0;
            bVal = b.gameDay || 0;
            break;
          case 'savedAt':
            aVal = new Date(a.saveDate).getTime();
            bVal = new Date(b.saveDate).getTime();
            break;
          case 'playTime':
            aVal = a.playTime || 0;
            bVal = b.playTime || 0;
            break;
          default:
            aVal = 0;
            bVal = 0;
        }
        
        const dir = this.view.sortDir === 'asc' ? 1 : -1;
        if (aVal > bVal) return dir;
        if (aVal < bVal) return -dir;
        return 0;
      });
      
      // Update count
      const manualCount = allSaves.filter(s => s.saveType === 'manual').length;
      const autoCount = allSaves.filter(s => s.saveType === 'auto').length;
      const quickCount = allSaves.filter(s => s.saveType === 'quick').length;
      countEl.textContent = `${manualCount} manual â€¢ ${autoCount} auto â€¢ ${quickCount} quick â€¢ showing ${filtered.length}`;
      
      // Build rows
      if (filtered.length === 0) {
        tbody.innerHTML = `
          <tr>
            <td colspan="7" style="text-align: center; padding: 60px 20px; color: #8899a6;">
              <div class="empty-state">
                <div class="empty-state-icon">ğŸ’¾</div>
                <h3>No saves found</h3>
                <p>${this.view.tab === 'manual' ? 'Create a new save to get started!' : 'Autosaves will appear here automatically.'}</p>
              </div>
            </td>
          </tr>
        `;
        cardContainer.innerHTML = `
          <div style="text-align: center; padding: 40px 20px; color: #8899a6;">
            <div class="empty-state">
              <div class="empty-state-icon">ğŸ’¾</div>
              <h3>No saves found</h3>
              <p>${this.view.tab === 'manual' ? 'Create a new save to get started!' : 'Autosaves will appear here automatically.'}</p>
            </div>
          </div>
        `;
      } else {
        // Build table rows (desktop)
        tbody.innerHTML = filtered.map(save => this.buildRowHTML(save)).join('');
        
        // Build mobile cards
        cardContainer.innerHTML = filtered.map(save => this.buildCardHTML(save)).join('');
      }
      
      // Add "Create New Save" row/card for manual tab (AT THE TOP)
      if (this.view.tab === 'manual') {
        // Table version
        const createRow = document.createElement('tr');
        createRow.className = 'create-row';
        createRow.id = 'sm-create-row';
        createRow.innerHTML = `
          <td colspan="7">
            <span class="create-save-link">
              <span>+</span>
              <span>Create New Save</span>
            </span>
          </td>
        `;
        tbody.insertBefore(createRow, tbody.firstChild);
        
        // Mobile card version
        const createCard = document.createElement('div');
        createCard.className = 'save-card create-row';
        createCard.id = 'sm-create-card';
        createCard.innerHTML = `
          <div style="text-align: center; padding: 20px 10px; cursor: pointer;">
            <span class="create-save-link">
              <span style="font-size: 1.5rem;">+</span>
              <span>Create New Save</span>
            </span>
          </div>
        `;
        cardContainer.insertBefore(createCard, cardContainer.firstChild);
        
        // Add click handlers
        createRow.addEventListener('click', () => this.handleCreateSave());
        createCard.addEventListener('click', () => this.handleCreateSave());
      }
      
      // Attach row event listeners
      this.attachRowListeners();
      
      // Update sort arrows
      this.updateSortArrows();
    }
    
    /**
     * Build HTML for a save row
     */
    buildRowHTML(save) {
      const date = new Date(save.saveDate);
      const formattedDate = date.toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      
      const money = formatCash(save.money || 0);
      const playtime = this.formatPlaytime(save.playTime || 0);
      const isSelected = this.view.selectedId === save.slotName;
      
      // Format autosave snapshot names nicely
      let displayName = save.saveName;
      if (save.slotName.startsWith('autosave_')) {
        const slotNum = parseInt(save.slotName.replace('autosave_', '')) + 1;
        displayName = `Autosave Snapshot #${slotNum}`;
      } else if (save.slotName === 'autosave') {
        displayName = 'Latest Autosave';
      }
      
      return `
        <tr data-slot="${save.slotName}" ${isSelected ? 'class="selected"' : ''}>
          <td>
            <div class="save-name-cell">
              <input 
                type="text" 
                class="save-name-input" 
                value="${displayName}" 
                data-slot="${save.slotName}"
                data-original="${save.saveName}"
                ${save.saveType === 'auto' ? 'readonly' : ''}
              />
              <span class="save-tag ${save.saveType}">${save.saveType}</span>
            </div>
          </td>
          <td class="meta">Day ${save.gameDay || 0}</td>
          <td class="meta">${formattedDate}</td>
          <td>${money}</td>
          <td>${save.employees || 0}</td>
          <td class="meta">${playtime}</td>
          <td>
            <div class="save-row-actions">
              <button class="save-action-btn load" data-action="load" data-slot="${save.slotName}">Load</button>
              <button class="save-action-btn export" data-action="export" data-slot="${save.slotName}">Export</button>
              ${save.saveType !== 'auto' ? `<button class="save-action-btn delete" data-action="delete" data-slot="${save.slotName}">âœ•</button>` : ''}
            </div>
          </td>
        </tr>
      `;
    }
    
    /**
     * Build HTML for a save card (mobile view)
     */
    buildCardHTML(save) {
      const date = new Date(save.saveDate);
      const formattedDate = date.toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      
      const money = formatCash(save.money || 0);
      const playtime = this.formatPlaytime(save.playTime || 0);
      const isSelected = this.view.selectedId === save.slotName;
      
      // Format autosave snapshot names nicely
      let displayName = save.saveName;
      if (save.slotName.startsWith('autosave_')) {
        const slotNum = parseInt(save.slotName.replace('autosave_', '')) + 1;
        displayName = `Autosave Snapshot #${slotNum}`;
      } else if (save.slotName === 'autosave') {
        displayName = 'Latest Autosave';
      }
      
      return `
        <div class="save-card ${isSelected ? 'selected' : ''}" data-slot="${save.slotName}">
          <div class="save-card-header">
            <div class="save-card-title">
              <div class="save-card-name">
                <input 
                  type="text" 
                  class="save-name-input" 
                  value="${displayName}" 
                  data-slot="${save.slotName}"
                  data-original="${save.saveName}"
                  ${save.saveType === 'auto' ? 'readonly' : ''}
                  style="background: transparent; border: none; color: #00d4ff; font-size: 0.95rem; font-weight: 700; padding: 0; width: 100%;"
                />
              </div>
              <span class="save-tag ${save.saveType}">${save.saveType}</span>
            </div>
          </div>
          
          <div class="save-card-meta">
            <div class="save-card-meta-item">
              <span>ğŸ“…</span>
              <span>Day ${save.gameDay || 0}</span>
            </div>
            <div class="save-card-meta-item">
              <span>ğŸ•’</span>
              <span>${formattedDate}</span>
            </div>
            <div class="save-card-meta-item">
              <span>ğŸ’°</span>
              <span>${money}</span>
            </div>
            <div class="save-card-meta-item">
              <span>ğŸ‘¥</span>
              <span>${save.employees || 0}</span>
            </div>
            <div class="save-card-meta-item">
              <span>â±ï¸</span>
              <span>${playtime}</span>
            </div>
          </div>
          
          <div class="save-card-actions">
            <button class="save-action-btn load" data-action="load" data-slot="${save.slotName}">Load</button>
            <button class="save-action-btn export" data-action="export" data-slot="${save.slotName}">Export</button>
            ${save.saveType !== 'auto' ? `<button class="save-action-btn delete" data-action="delete" data-slot="${save.slotName}">Delete</button>` : ''}
          </div>
        </div>
      `;
    }
    
    /**
     * Attach event listeners to row elements
     */
    attachRowListeners() {
      const tbody = this.modal.querySelector('#sm-tbody');
      const cardContainer = this.modal.querySelector('#sm-card-container');
      
      // Row action buttons (both table and cards)
      const allActionButtons = [
        ...tbody.querySelectorAll('.save-action-btn'),
        ...cardContainer.querySelectorAll('.save-action-btn')
      ];
      
      allActionButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          const action = e.target.dataset.action;
          const slotName = e.target.dataset.slot;
          
          if (action === 'load') {
            this.handleLoad(slotName);
          } else if (action === 'export') {
            this.handleExport(slotName);
          } else if (action === 'delete') {
            this.handleDelete(slotName);
          }
        });
      });
      
      // Name input editing (both table and cards)
      const allNameInputs = [
        ...tbody.querySelectorAll('.save-name-input'),
        ...cardContainer.querySelectorAll('.save-name-input')
      ];
      
      allNameInputs.forEach(input => {
        // Select all text on focus
        input.addEventListener('focus', (e) => {
          e.target.select();
          this.editingNameId = e.target.dataset.slot;
        });
        
        // Save on blur
        input.addEventListener('blur', (e) => {
          this.handleRename(e);
        });
        
        // Save on Enter key
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.target.blur();
          } else if (e.key === 'Escape') {
            e.target.value = e.target.dataset.original;
            e.target.blur();
          }
        });
      });
      
      // Row selection
      tbody.querySelectorAll('tr[data-slot]').forEach(row => {
        row.addEventListener('click', (e) => {
          // Don't select if clicking on input or button
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
          
          this.view.selectedId = row.dataset.slot;
          this.render();
        });
      });
      
      // Card selection (mobile)
      cardContainer.querySelectorAll('.save-card[data-slot]').forEach(card => {
        card.addEventListener('click', (e) => {
          // Don't select if clicking on input or button
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
          
          this.view.selectedId = card.dataset.slot;
          this.render();
        });
      });
    }
    
    /**
     * Update sort arrow indicators
     */
    updateSortArrows() {
      const headers = this.modal.querySelectorAll('th.sortable');
      headers.forEach(th => {
        const arrow = th.querySelector('.sort-arrow');
        if (!arrow) return;
        
        if (th.dataset.sort === this.view.sortKey) {
          arrow.textContent = this.view.sortDir === 'asc' ? 'â–´' : 'â–¾';
          arrow.style.opacity = '1';
        } else {
          arrow.textContent = 'â–¾';
          arrow.style.opacity = '0.5';
        }
      });
    }
    
    /**
     * Format playtime in hours/minutes
     */
    formatPlaytime(ms) {
      const hours = Math.floor(ms / 3600000);
      const minutes = Math.floor((ms % 3600000) / 60000);
      
      if (hours > 0) {
        return `${hours}h ${minutes}m`;
      } else {
        return `${minutes}m`;
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EVENT HANDLERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async handleContinue() {
      const allSaves = await listAllSaves();
      if (allSaves.length === 0) {
        showNotification('âŒ No saves found!', 'error');
        return;
      }
      
      // Load most recent save
      const latest = allSaves[0];
      await loadGameFromSlot(latest.slotName);
      this.hide();
    }
    
    async handleQuickSave() {
      const slotName = `quick_${Date.now()}`;
      await saveGameToSlot(slotName, 'quick', true);
      await this.render();
    }
    
    async handleQuickLoad() {
      const allSaves = await listAllSaves();
      const quickSaves = allSaves.filter(s => s.saveType === 'quick');
      
      if (quickSaves.length === 0) {
        showNotification('âŒ No quick saves found!', 'error');
        return;
      }
      
      // Load most recent quick save
      await loadGameFromSlot(quickSaves[0].slotName);
      this.hide();
    }
    
    async handleCreateSave() {
      const slotName = `manual_${Date.now()}`;
      await saveGameToSlot(slotName, 'manual', true);
      await this.render();
    }
    
    async handleLoad(slotName) {
      await loadGameFromSlot(slotName);
      this.hide();
    }
    
    async handleExport(slotName) {
      await exportSaveSlot(slotName);
    }
    
    async handleExportSelected() {
      if (!this.view.selectedId) {
        showNotification('âŒ No save selected!', 'error');
        return;
      }
      await exportSaveSlot(this.view.selectedId);
    }
    
    async handleDelete(slotName) {
      if (!confirm(`âš ï¸ Delete save "${slotName}"?\n\nThis cannot be undone!`)) {
        return;
      }
      
      await deleteSaveSlot(slotName);
      await this.render();
    }
    
    async handleRename(event) {
      const input = event.target;
      const oldName = input.dataset.slot;
      const newName = input.value.trim();
      
      // Don't rename if unchanged or empty
      if (newName === oldName || newName === '' || newName === input.dataset.original) {
        input.value = input.dataset.original;
        this.editingNameId = null;
        return;
      }
      
      // Rename the save
      const success = await renameSaveSlot(oldName, newName);
      
      if (success) {
        // Update selected ID if it was the renamed save
        if (this.view.selectedId === oldName) {
          this.view.selectedId = newName;
        }
        await this.render();
      } else {
        // Revert on failure
        input.value = input.dataset.original;
      }
      
      this.editingNameId = null;
    }
    
    async handleImport(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const contents = e.target.result;
          const saveData = JSON.parse(contents);
          
          // Validate
          if (!saveData.gameState) {
            showNotification('âŒ Invalid save file format!', 'error');
            return;
          }
          
          // Show confirmation
          const saveName = saveData.meta?.saveName || 'imported';
          const saveDate = saveData.meta?.saveDate ? new Date(saveData.meta.saveDate).toLocaleString() : 'Unknown';
          const saveMoney = saveData.gameState.cash ? formatCash(saveData.gameState.cash) : 'Unknown';
          
          if (!confirm(`ğŸ“¥ Import save "${saveName}"?\n\nğŸ’° ${saveMoney}\nğŸ“… ${saveDate}\n\nâš ï¸ This will create a new save slot.`)) {
            return;
          }
          
          // Import to new slot
          await importSaveToSlot(saveData);
          await this.render();
          
        } catch (error) {
          console.error('[SaveManager] Import error:', error);
          showNotification('âŒ Failed to import save!', 'error');
        }
      };
      
      reader.readAsText(file);
      
      // Clear file input
      event.target.value = '';
    }
  }
  
  // Create global SaveManager instance
  let saveManagerInstance = null;
  
  function getSaveManager() {
    if (!saveManagerInstance) {
      saveManagerInstance = new SaveManager();
    }
    return saveManagerInstance;
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // END SAVE MANAGER UI CLASS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Load game using kv-plugin
  async function loadGame() {
    try {
      // MIGRATION: Check for legacy save format and migrate if needed
      await migrateLegacySave();
      
      // CRITICAL FIX: Load from new slot-based save system (autosave slot)
      // Check new format first, then fall back to legacy
      let saveData = await kv.gameSave.get("fuoc_save_autosave");
      
      // Fallback to legacy save format if new format not found
      if (!saveData) {
        saveData = await kv.gameSave.get("gameState");
      }
      
      if (saveData) {
        // Extract gameState from new format (with metadata) or use directly for legacy format
        const parsed = saveData.gameState || saveData;
        
        // CRITICAL FIX: Convert Sets/Maps that were serialized to Arrays/Objects BEFORE merging
        // This prevents them from being spread as arrays/objects into the new gameState
        if (parsed.usedEmployeeNames && Array.isArray(parsed.usedEmployeeNames)) {
          console.log(`[LoadGame] Pre-converting usedEmployeeNames Array (${parsed.usedEmployeeNames.length} items) to Set`);
          parsed.usedEmployeeNames = new Set(parsed.usedEmployeeNames);
        }
        if (parsed.blockedProactiveMessages && Array.isArray(parsed.blockedProactiveMessages)) {
          console.log(`[LoadGame] Pre-converting blockedProactiveMessages Array (${parsed.blockedProactiveMessages.length} items) to Set`);
          parsed.blockedProactiveMessages = new Set(parsed.blockedProactiveMessages);
        }
        if (parsed.recentTopics && !parsed.recentTopics.has) {
          const entries = Object.entries(parsed.recentTopics);
          console.log(`[LoadGame] Pre-converting recentTopics object (${entries.length} items) to Map`);
          parsed.recentTopics = new Map(entries);
        }
        
        // Merge saved state with default state to ensure all properties exist
        gameState = {
          ...gameState,
          ...parsed,
          // Ensure activeLocationId defaults to first unlocked location
          activeLocationId: parsed.activeLocationId || 'garage',
          upgradeMultiplier: parsed.upgradeMultiplier || 1,
          // CRITICAL: Explicitly restore time object to preserve in-game time
          time: {
            ...gameState.time,
            ...(parsed.time || {}),
            // Ensure currentTime is restored from save (don't reset to Date.now())
            currentTime: parsed.time?.currentTime || gameState.time.currentTime
          },
          // Ensure locations have proper unlock states
          locations: (parsed.locations || gameState.locations).map(loc => ({
            unlocked: loc.unlocked ?? (loc.owned ?? (loc.id === 'garage')), // First location or previously owned
            owned: loc.owned ?? loc.unlocked ?? (loc.id === 'garage'),
            ...loc
          })),
          // Ensure critical objects are properly initialized
          products: (parsed.products || gameState.products).map(p => {
            // Define unlock costs based on product id (for backwards compatibility)
            const defaultUnlockCosts = {
              'website': 0,      // first product is free
              'app': 100,
              'consulting': 400,
              'cloud': 1800,
              'seo': 3000,
              'branding': 5000,
              'ecommerce': 8000,
              'automation': 12000,
              'copywriting': 0, // first in home_office
              'video_editing': 20000,
              'marketing': 35000,
              'consulting_premium': 55000,
              'saas': 85000
            };
            
            return {
              // backfill new balance fields for old saves
              baseUpgradeCost: p.baseUpgradeCost ?? p.upgradeCost ?? 50,
              costGrowth: p.costGrowth ?? 1.35,
              valueExponent: p.valueExponent ?? 0.85,
              managerSpeedCapPct: p.managerSpeedCapPct ?? 0.40,
              // backfill unlock properties
              unlocked: p.unlocked ?? (p.id === 'website' ? true : false), // first product unlocked by default
              unlockCost: p.unlockCost ?? (defaultUnlockCosts[p.id] || 0),
              ...p
            };
          }),
          employees: parsed.employees || gameState.employees,
          settings: {...gameState.settings, ...(parsed.settings || {})},
          chatHistory: parsed.chatHistory || {},
          typingStates: parsed.typingStates || {},
          onboarding: parsed.onboarding || [],
          
          // Player profile data
          playerProfile: {
            ...gameState.playerProfile,
            ...(parsed.playerProfile || {})
          },
          
          // Ensure social network data exists (backward compatibility)
          socialNetwork: {
            ...gameState.socialNetwork,
            ...(parsed.socialNetwork || {}),
            posts: parsed.socialNetwork?.posts || [],
            globalEvents: parsed.socialNetwork?.globalEvents || [],
            postIdCounter: parsed.socialNetwork?.postIdCounter || 0,
            // THE ALGORITHMâ„¢ - Initialize if missing
            algorithm: {
              sort: 'hot',
              bestTimeFrame: 'all',
              contentRating: 'all',
              postType: 'all',
              author: 'all',
              engagement: 'all',
              searchQuery: '',
              ...(parsed.socialNetwork?.algorithm || {})
            },
            recentPostTypes: parsed.socialNetwork?.recentPostTypes || [],
            playerDraft: parsed.socialNetwork?.playerDraft || {
              caption: '',
              imagePrompt: '',
              altText: '',
              imageUrl: null
            }
          },
          
          // Company context and awareness
          companyContext: {
            ...gameState.companyContext,
            ...(parsed.companyContext || {})
          },
          companyWideContext: {
            ...gameState.companyWideContext,
            ...(parsed.companyWideContext || {}),
            currentBuzz: parsed.companyWideContext?.currentBuzz || [],
            lastUpdate: parsed.companyWideContext?.lastUpdate || Date.now(),
            maxItems: parsed.companyWideContext?.maxItems || 40,
            decayTime: parsed.companyWideContext?.decayTime || 604800000
          },
          
          // Prestige system
          prestigeLevel: parsed.prestigeLevel ?? 0,
          influencePoints: parsed.influencePoints ?? 0,
          lifetimeEarnings: parsed.lifetimeEarnings ?? 0,
          lifetimeEarningsConverted: parsed.lifetimeEarningsConverted ?? 0,
          prestigeMultiplier: parsed.prestigeMultiplier ?? 1.0,
          
          // Global upgrades
          globalUpgrades: {
            clickPower: parsed.globalUpgrades?.clickPower ?? 0,
            incomeBoost: parsed.globalUpgrades?.incomeBoost ?? {},
            costReduction: parsed.globalUpgrades?.costReduction ?? {}
          },
          
          // Boss fights
          bossFights: {
            active: parsed.bossFights?.active || null,
            defeated: parsed.bossFights?.defeated || [],
            history: parsed.bossFights?.history || []
          },
          
          // Race Settings (initialize if missing for old saves)
          raceSettings: parsed.raceSettings || {
            human: 100,
            elf: 0,
            orc: 0,
            demon: 0,
            fox: 0,
            wolf: 0,
            cat: 0,
            rabbit: 0
          }
        };
        
        // Initialize social data for all employees (migration for old saves)
        gameState.employees.forEach(emp => {
          initializeEmployeeSocialData(emp);
          ensureEmployeeMemory(emp);
          
          // Migrate gift preferences for old saves
          if (!emp.giftPreferences) {
            emp.giftPreferences = generateGiftPreferences();
          }
          
          // Initialize hireDate for old saves (use a past date so sorting works)
          if (!emp.hireDate) {
            emp.hireDate = Date.now() - (Math.random() * 30 * 24 * 60 * 60 * 1000); // Random date within last 30 days
          }
          
          // Initialize career data for old saves (Corporate Ladder System)
          if (!emp.career) {
            emp.career = {
              level: 1,
              title: gameState.hierarchyLevels[1].title,
              salary: gameState.hierarchyLevels[1].baseSalary,
              startDate: emp.hireDate || Date.now(),
              promotionHistory: [],
              directReports: [],
              managerId: null
            };
            console.log(`[LoadGame] Initialized career data for ${emp.name} at Level 1`);
          }
          
          // MIGRATION FIX: Update old "Entry Level" titles to "Staff"
          if (emp.career.title === "Entry Level") {
            emp.career.title = "Staff";
            emp.career.level = 1; // Ensure level is correct
            const levelInfo = gameState.hierarchyLevels?.[1];
            if (levelInfo) {
              emp.career.salary = levelInfo.baseSalary;
            }
            console.log(`[LoadGame Migration] Updated ${emp.name}'s title from "Entry Level" to "Staff" (Level 1)`);
          }
          
          // MIGRATION FIX: Ensure career level matches career title
          if (emp.career && emp.career.title) {
            const expectedLevel = Object.keys(gameState.hierarchyLevels || {}).find(lvl => {
              const levelInfo = gameState.hierarchyLevels[lvl];
              return levelInfo && levelInfo.title === emp.career.title;
            });
            
            if (expectedLevel && emp.career.level != expectedLevel) {
              emp.career.level = parseInt(expectedLevel);
              console.log(`[LoadGame Migration] Synced ${emp.name}'s level to ${expectedLevel} to match title "${emp.career.title}"`);
            }
          }
        });
        
        // MIGRATION FIX: Auto-assign employees to products based on old "position" field
        // Old system stored position as "Manager â€“ [Product Name]"
        // Extract product name and auto-assign ONCE, then clean up old fields
        let autoAssignedCount = 0;
        
        gameState.employees.forEach(emp => {
          // Check if employee has old-style position field with "Manager â€“" or "Manager -"
          if (emp.position && /Manager\s*[â€“-]\s*(.+)/.test(emp.position)) {
            const match = emp.position.match(/Manager\s*[â€“-]\s*(.+?)(?:\s*â€¢|$)/);
            if (match) {
              const productNameFromPosition = match[1].trim();
              console.log(`[LoadGame Migration] Found old position for ${emp.name}: "${emp.position}" -> extracting product: "${productNameFromPosition}"`);
              
              // Find matching product by name
              const matchingProduct = gameState.products.find(p => 
                p.name.toLowerCase() === productNameFromPosition.toLowerCase()
              );
              
              if (matchingProduct && matchingProduct.unlocked && !matchingProduct.managerHired) {
                // Auto-assign this employee to the product
                matchingProduct.managerHired = true;
                matchingProduct.managerId = emp.id;
                matchingProduct.managerLevel = matchingProduct.managerLevel || 1;
                matchingProduct.onboardStartTime = null; // Skip onboarding for migrated employees
                
                console.log(`[LoadGame Migration] âœ“ Auto-assigned ${emp.name} to "${matchingProduct.name}"`);
                autoAssignedCount++;
              } else if (matchingProduct) {
                console.log(`[LoadGame Migration] âš  Product "${productNameFromPosition}" found but already has staff or is locked`);
              } else {
                console.log(`[LoadGame Migration] âš  Product "${productNameFromPosition}" not found`);
              }
            }
          }
          
          // Clean up old fields that are no longer used
          if (emp.position) {
            console.log(`[LoadGame Migration] Cleaning up old position field for ${emp.name}: "${emp.position}"`);
            delete emp.position;
          }
          if (emp.productManaged) {
            console.log(`[LoadGame Migration] Cleaning up old productManaged field for ${emp.name}: "${emp.productManaged}"`);
            delete emp.productManaged;
          }
        });
        
        if (autoAssignedCount > 0) {
          console.log(`[LoadGame Migration] Auto-assigned ${autoAssignedCount} employee(s) to their products from old save data`);
          showNotification(`Migration: Auto-assigned ${autoAssignedCount} employee(s) to their positions!`);
        }
        
        // MIGRATION FIX: Clean up product managerId references that point to non-existent employees
        // This fixes "Managed by Unknown" issue in old saves (run AFTER auto-assignment)
        const validEmployeeIds = new Set(gameState.employees.map(e => e.id));
        let fixedProducts = 0;
        
        gameState.products.forEach(product => {
          if (product.managerHired && product.managerId) {
            // Check if managerId points to an existing employee
            if (!validEmployeeIds.has(product.managerId)) {
              console.log(`[LoadGame Migration] Product "${product.name}" has invalid managerId: ${product.managerId} - clearing`);
              product.managerHired = false;
              product.managerId = null;
              product.managerLevel = 0;
              fixedProducts++;
            }
          } else if (product.managerHired && !product.managerId) {
            // Manager hired but no ID set - this is invalid
            console.log(`[LoadGame Migration] Product "${product.name}" has managerHired=true but no managerId - clearing`);
            product.managerHired = false;
            product.managerLevel = 0;
            fixedProducts++;
          }
        });
        
        if (fixedProducts > 0) {
          console.log(`[LoadGame Migration] Fixed ${fixedProducts} product(s) with invalid manager references`);
          showNotification(`Migration: Fixed ${fixedProducts} orphaned product assignment(s).`);
        }
        
        // MIGRATION FIX: Clean up meeting participants that reference deleted/invalid employees
        if (gameState.meetings && Array.isArray(gameState.meetings)) {
          let fixedMeetings = 0;
          let removedParticipants = 0;
          
          gameState.meetings.forEach(meeting => {
            if (!meeting.participants || !Array.isArray(meeting.participants)) {
              meeting.participants = [];
              return;
            }
            
            const originalCount = meeting.participants.length;
            
            // Filter out invalid participant IDs
            meeting.participants = meeting.participants.filter(participantId => {
              const exists = validEmployeeIds.has(participantId);
              if (!exists) {
                console.log(`[LoadGame Migration] Removing invalid participant ${participantId} from meeting "${meeting.name}"`);
                removedParticipants++;
              }
              return exists;
            });
            
            if (meeting.participants.length !== originalCount) {
              fixedMeetings++;
            }
            
            // Also clean up messages from deleted employees
            if (meeting.messages && Array.isArray(meeting.messages)) {
              meeting.messages = meeting.messages.filter(msg => {
                if (msg.speakerId === 'player' || msg.speakerId === 'system') return true;
                const exists = validEmployeeIds.has(msg.speakerId);
                if (!exists) {
                  console.log(`[LoadGame Migration] Removing message from invalid employee ${msg.speakerId} in meeting "${meeting.name}"`);
                }
                return exists;
              });
            }
          });
          
          if (fixedMeetings > 0) {
            console.log(`[LoadGame Migration] Cleaned up ${fixedMeetings} meeting(s), removed ${removedParticipants} invalid participant(s)`);
            showNotification(`Migration: Cleaned up ${fixedMeetings} meeting(s) with deleted participants.`);
          }
        }
        
        // MIGRATION FIX: Sync employees to corporate pyramid positions after product assignment
        // This ensures employees show up in the Corporate Ladder screen at their correct positions
        gameState.products.forEach(product => {
          if (product.managerHired && product.managerId) {
            // Find the staff position for this product in the corporate pyramid
            const staffPosition = gameState.corporatePyramid?.positions?.[1]?.find(
              pos => pos.productId === product.id
            );
            
            if (staffPosition && !staffPosition.employeeId) {
              // Assign employee to pyramid position
              staffPosition.employeeId = product.managerId;
              staffPosition.isVacant = false;
              
              const employee = gameState.employees.find(e => e.id === product.managerId);
              if (employee) {
                console.log(`[LoadGame Migration] âœ“ Synced ${employee.name} to corporate pyramid position: ${staffPosition.title}`);
              }
            }
          }
        });
        
        // Ensure gift inventory exists
        if (!gameState.giftInventory) {
          gameState.giftInventory = {
            items: [],
            capacity: Infinity
          };
        }
        
        // Ensure gift store exists (new system)
        if (!gameState.giftStore) {
          gameState.giftStore = {
            items: []
          };
        }
        
        // Ensure currentLifetimeIncome exists
        if (gameState.currentLifetimeIncome === undefined) {
          gameState.currentLifetimeIncome = gameState.totalEarnings || 0;
        }
        
        // Ensure givenUniqueGifts exists
        if (!gameState.givenUniqueGifts) {
          gameState.givenUniqueGifts = [];
        }
        
        // Ensure createdUniqueGifts exists (new system)
        if (!gameState.createdUniqueGifts) {
          gameState.createdUniqueGifts = [];
        }
        
        // FIX: Update old timeScale value (60) to new value (20)
        if (gameState.time && gameState.time.timeScale === 60) {
          console.log('[LoadGame] Updating timeScale from 60 to 20 (1 game min = 3 real seconds)');
          gameState.time.timeScale = 20;
        }
        
        // SAFETY CHECK: Ensure Sets/Maps are properly initialized (fallback for edge cases)
        if (!gameState.usedEmployeeNames || !gameState.usedEmployeeNames.has) {
          console.warn('[LoadGame] usedEmployeeNames not a Set, initializing empty Set');
          gameState.usedEmployeeNames = new Set();
        }
        
        if (!gameState.blockedProactiveMessages || !gameState.blockedProactiveMessages.has) {
          console.warn('[LoadGame] blockedProactiveMessages not a Set, initializing empty Set');
          gameState.blockedProactiveMessages = new Set();
        }
        
        if (!gameState.recentTopics || !gameState.recentTopics.has) {
          console.warn('[LoadGame] recentTopics not a Map, initializing empty Map');
          gameState.recentTopics = new Map();
        }
        
        // FIX: Ensure genderSettings exists (backwards compatibility with old saves)
        if (!gameState.genderSettings) {
          console.log('[LoadGame] Initializing missing genderSettings with defaults');
          gameState.genderSettings = {
            female: 100,
            male: 0,
            femaleFuta: 0,
            transMan: 0,
            transWoman: 0
          };
        }
        
        // FIX: Ensure aiQuality exists (backwards compatibility with old saves)
        if (!gameState.aiQuality) {
          console.log('[LoadGame] Initializing missing aiQuality (RLHF system) with defaults');
          gameState.aiQuality = {
            goodExamples: { posts: [], comments: [], chats: [] },
            badExamples: { posts: [], comments: [], chats: [] },
            bannedPatterns: [],
            stats: { totalVotes: 0, upvotes: 0, downvotes: 0, postsVoted: 0, commentsVoted: 0, chatsVoted: 0 },
            maxExamplesPerType: 20,
            tutorialShown: false
          };
        }
        
        // Ensure playerMentionStats exists (for social feed analytics)
        if (!gameState.playerMentionStats) {
          gameState.playerMentionStats = {
            totalMentions: 0,
            positiveReactions: 0,
            negativeReactions: 0,
            lastMentionTime: null
          };
        }
        
        // Ensure activeGossip exists (for NPC chatter system)
        if (!gameState.activeGossip) {
          gameState.activeGossip = [];
        }
        
        // Ensure lastProactiveMessageCheck exists (for proactive NPC messages)
        if (!gameState.lastProactiveMessageCheck) {
          gameState.lastProactiveMessageCheck = 0;
        }
        
        // Ensure lifestyleAdjustmentCounter exists (for employee lifestyle updates)
        if (!gameState.lifestyleAdjustmentCounter) {
          gameState.lifestyleAdjustmentCounter = 0;
        }
        
        // Ensure currentCandidates exists (for hiring system)
        if (!gameState.currentCandidates) {
          gameState.currentCandidates = null;
        }
        
        // Ensure usedEmployeeNames is initialized (if it doesn't exist at all)
        if (!gameState.usedEmployeeNames) {
          gameState.usedEmployeeNames = new Set();
        }
        
        // Update company awareness on load
        updateCompanyAwareness();
        
        // Generate initial relationships if none exist
        const hasRelationships = gameState.employees.some(emp => 
          emp.relationships && Object.keys(emp.relationships).length > 0
        );
        if (!hasRelationships && gameState.employees.length > 1) {
          generateRandomRelationships();
        }
        
        // Initialize used names from loaded employees
        initializeUsedNames();
        
        // MIGRATION FIX: Clean up meetings with invalid/deleted employee participants
        if (gameState.meetings && gameState.meetings.length > 0) {
          const validEmployeeIds = new Set(gameState.employees.map(e => e.id));
          let cleanedMeetings = 0;
          let removedParticipants = 0;
          
          // Clean each meeting
          gameState.meetings = gameState.meetings.filter(meeting => {
            if (!meeting.participants || !Array.isArray(meeting.participants)) {
              cleanedMeetings++;
              return false; // Remove invalid meeting
            }
            
            // Remove invalid participant IDs
            const originalLength = meeting.participants.length;
            meeting.participants = meeting.participants.filter(empId => {
              const isValid = validEmployeeIds.has(empId);
              if (!isValid) {
                console.log(`[LoadGame Migration] Removed invalid participant ${empId} from meeting "${meeting.name}"`);
                removedParticipants++;
              }
              return isValid;
            });
            
            // If no participants left, remove the meeting
            if (meeting.participants.length === 0) {
              console.log(`[LoadGame Migration] Removing empty meeting "${meeting.name}"`);
              cleanedMeetings++;
              return false;
            }
            
            // Clean messages with invalid speaker IDs
            if (meeting.messages && Array.isArray(meeting.messages)) {
              meeting.messages = meeting.messages.filter(msg => {
                if (msg.speakerId === 'player' || msg.speakerId === 'system') return true;
                const isValid = validEmployeeIds.has(msg.speakerId);
                if (!isValid) {
                  console.log(`[LoadGame Migration] Removed message from invalid speaker ${msg.speakerId} in meeting "${meeting.name}"`);
                }
                return isValid;
              });
            }
            
            return true; // Keep this meeting
          });
          
          if (cleanedMeetings > 0 || removedParticipants > 0) {
            console.log(`[LoadGame Migration] Cleaned ${removedParticipants} invalid participant(s) and removed ${cleanedMeetings} invalid meeting(s)`);
            if (cleanedMeetings + removedParticipants > 0) {
              showNotification(`Cleaned up ${removedParticipants + cleanedMeetings} invalid meeting reference(s)`);
            }
          }
        }
        
        showNotification('Game loaded!');
        
        // Re-initialize AI Request Queue with loaded settings
        if (gameState.settings?.maxAiRequests) {
          AIRequestQueue.updateMaxConcurrent(gameState.settings.maxAiRequests);
          console.log('[AI Queue] Re-initialized after game load with max:', gameState.settings.maxAiRequests);
        }
        
        // Check for AFK income
        checkAfkIncome();
      } else {
        // Try to migrate from old localStorage if available
        await migrateFromLocalStorage();
      }
    } catch (error) {
      console.error('Error loading game:', error);
      showNotification('Failed to load saved game. Starting fresh!');
    }
  }
  
  // Check for AFK income when player returns
  function checkAfkIncome() {
    // Ensure offline earnings settings exist
    if (!gameState.offlineEarnings) {
      gameState.offlineEarnings = {
        enabled: true,
        maxDuration: 24 * 60 * 60 * 1000, // 24 hours
        rate: 0.5, // 50%
        lastPlayedRealTime: Date.now()
      };
    }
    
    const now = Date.now();
    
    // Use offlineEarnings.lastPlayedRealTime for accurate offline tracking
    const lastActiveTime = gameState.offlineEarnings.lastPlayedRealTime || gameState.lastInteractionTime || gameState.lastPlayTime || now;
    const timeAway = now - lastActiveTime; // milliseconds (REAL TIME)
    
    // Only show if away for more than 5 minutes
    const MIN_TIME_AWAY = 5 * 60 * 1000; // 5 minutes
    if (timeAway < MIN_TIME_AWAY) {
      // Update times for next session
      gameState.offlineEarnings.lastPlayedRealTime = now;
      gameState.lastInteractionTime = now;
      gameState.lastPlayTime = now;
      return;
    }
    
    // Skip if offline earnings disabled
    if (!gameState.offlineEarnings.enabled) {
      gameState.offlineEarnings.lastPlayedRealTime = now;
      gameState.lastInteractionTime = now;
      gameState.lastPlayTime = now;
      return;
    }
    
    // Calculate income per second (based on current game state)
    const incomePerSecond = parseFloat(calculateCashPerSecond());
    
    // If no income, skip
    if (incomePerSecond <= 0) {
      gameState.offlineEarnings.lastPlayedRealTime = now;
      gameState.lastInteractionTime = now;
      gameState.lastPlayTime = now;
      return;
    }
    
    // Calculate time away in seconds (REAL TIME)
    const secondsAway = Math.floor(timeAway / 1000);
    
    // Cap at max duration from settings (default 24 hours)
    const maxAfkSeconds = Math.floor(gameState.offlineEarnings.maxDuration / 1000);
    const cappedSecondsAway = Math.min(secondsAway, maxAfkSeconds);
    
    // Calculate earnings at configured rate (default 50% of full rate)
    let afkRate = gameState.offlineEarnings.rate; // 0.5 = 50%
    
    // Apply Passive Income influence upgrade (+5% per level, caps at 100%)
    const passiveIncomeLevel = gameState.influenceUpgrades?.offlineEarnings || 0;
    if (passiveIncomeLevel > 0) {
      // Direct replacement rather than multiplier - go from 50% to 100%
      afkRate = influenceUpgrades.offlineEarnings.effect(passiveIncomeLevel);
    }
    
    const fullEarnings = incomePerSecond * cappedSecondsAway;
    const afkEarnings = Math.floor(fullEarnings * afkRate);
    
    // Log for debugging
    console.log(`[AFK] Time away: ${(cappedSecondsAway / 60).toFixed(1)} minutes`);
    console.log(`[AFK] Income rate: $${formatNumber(incomePerSecond)}/sec`);
    console.log(`[AFK] Full earnings (100%): $${formatNumber(fullEarnings)}`);
    console.log(`[AFK] AFK earnings (${(afkRate * 100).toFixed(1)}%): $${formatNumber(afkEarnings)}`);
    
    // Format time away
    const hours = Math.floor(cappedSecondsAway / 3600);
    const minutes = Math.floor((cappedSecondsAway % 3600) / 60);
    const timeAwayText = hours > 0 
      ? `${hours}h ${minutes}m` 
      : `${minutes}m`;
    
    // Update modal with earnings info
    const afkModal = document.getElementById('afkIncomeModal');
    const timeAwayEl = document.getElementById('afkTimeAway');
    const incomeRateEl = document.getElementById('afkIncomeRate');
    const fullEarningsEl = document.getElementById('afkFullEarnings');
    const afkEarningsEl = document.getElementById('afkEarnings');
    const afkRateEl = document.getElementById('afkRate');
    const claimBtn = document.getElementById('claimAfkIncome');
    const closeBtn = document.getElementById('closeAfkIncome');
    
    if (timeAwayEl) timeAwayEl.textContent = timeAwayText;
    if (incomeRateEl) incomeRateEl.textContent = `$${formatNumber(incomePerSecond)}/sec`;
    if (fullEarningsEl) fullEarningsEl.textContent = `$${formatNumber(fullEarnings)}`;
    if (afkEarningsEl) afkEarningsEl.textContent = `$${formatNumber(afkEarnings)}`;
    if (afkRateEl) afkRateEl.textContent = `${afkRate * 100}%`;
    
    // Show modal
    if (afkModal) {
      afkModal.style.display = 'flex';
    }
    
    // Claim button handler
    if (claimBtn) {
      claimBtn.onclick = () => {
        gameState.cash += afkEarnings;
        gameState.currentLifetimeIncome = (gameState.currentLifetimeIncome || 0) + afkEarnings; // Track THIS prestige only
        gameState.lastPlayTime = now;
        gameState.lastInteractionTime = now;
        gameState.offlineEarnings.lastPlayedRealTime = now; // Update real time tracker
        updateUI();
        if (afkModal) afkModal.style.display = 'none';
        showNotification(`Claimed $${formatNumber(afkEarnings)} AFK earnings!`);
      };
    }
    
    // Close button handler
    if (closeBtn) {
      closeBtn.onclick = () => {
        gameState.cash += afkEarnings; // Still give them the money
        gameState.currentLifetimeIncome = (gameState.currentLifetimeIncome || 0) + afkEarnings; // Track THIS prestige only
        gameState.lastPlayTime = now;
        gameState.lastInteractionTime = now;
        gameState.offlineEarnings.lastPlayedRealTime = now; // Update real time tracker
        updateUI();
        if (afkModal) afkModal.style.display = 'none';
      };
    }
  }
  
  // Migrate old localStorage data to kv-plugin (one-time migration)
  async function migrateFromLocalStorage() {
    try {
      const oldSave = localStorage.gameState;
      if (oldSave) {
        console.log('Migrating old localStorage save to kv-plugin...');
        const parsed = JSON.parse(oldSave);
        await kv.gameSave.set("gameState", parsed);
        // Clear old localStorage to free up space
        delete localStorage.gameState;
        console.log('Migration complete! Old localStorage data cleared.');
        showNotification('Save data migrated to new storage system!');
        // Reload the game with the migrated data
        await loadGame();
      }
    } catch (error) {
      console.error('Error migrating from localStorage:', error);
    }
  }

  // ===== PRESTIGE SYSTEM FUNCTIONS =====
  
  // Define permanent upgrades purchasable with Influence Points
  const influenceUpgrades = {
    incomeMultiplier: {
      id: 'incomeMultiplier',
      name: 'Income Multiplier',
      description: 'Increase all income by 10% per level',
      icon: 'ğŸ’°',
      baseCost: 5,
      costIncrease: 1.3,
      maxLevel: 50,
      getCurrentLevel: () => gameState.influenceUpgrades?.incomeMultiplier || 0,
      effect: (level) => 1 + (level * 0.1) // 10% per level
    },
    startingCash: {
      id: 'startingCash',
      name: 'Starting Capital',
      description: 'Start each prestige with more cash',
      icon: 'ğŸ’µ',
      baseCost: 3,
      costIncrease: 1.4,
      maxLevel: 100,
      getCurrentLevel: () => gameState.influenceUpgrades?.startingCash || 0,
      effect: (level) => 50 * level // $50 per level
    },
    clickPower: {
      id: 'clickPower',
      name: 'Quick Hands',
      description: 'Click products to reduce time by +0.05s per level',
      icon: 'ğŸ‘†',
      baseCost: 3,
      costIncrease: 1.3,
      maxLevel: 50,
      getCurrentLevel: () => gameState.influenceUpgrades?.clickPower || 0,
      effect: (level) => level * 0.05 // +0.05s time reduction per click per level
    },
    employeeDiscount: {
      id: 'employeeDiscount',
      name: 'HR Efficiency',
      description: 'Reduce employee costs by 5% per level',
      icon: 'ğŸ‘”',
      baseCost: 4,
      costIncrease: 1.35,
      maxLevel: 10,
      getCurrentLevel: () => gameState.influenceUpgrades?.employeeDiscount || 0,
      effect: (level) => Math.max(0.5, 1 - (level * 0.05)) // Max 50% discount at level 10
    },
    productDiscount: {
      id: 'productDiscount',
      name: 'Bulk Buying',
      description: 'Reduce product costs by 3% per level',
      icon: 'ğŸ“¦',
      baseCost: 4,
      costIncrease: 1.35,
      maxLevel: 15,
      getCurrentLevel: () => gameState.influenceUpgrades?.productDiscount || 0,
      effect: (level) => Math.max(0.55, 1 - (level * 0.03)) // Max 45% discount at level 15
    },
    autoProgress: {
      id: 'autoProgress',
      name: 'Automation Boost',
      description: 'Managers work 5% faster per level',
      icon: 'âš¡',
      baseCost: 6,
      costIncrease: 1.4,
      maxLevel: 20,
      getCurrentLevel: () => gameState.influenceUpgrades?.autoProgress || 0,
      effect: (level) => 1 + (level * 0.05) // 5% faster per level
    },
    bossWarrior: {
      id: 'bossWarrior',
      name: 'Boss Warrior',
      description: 'Deal +15% damage to bosses per level',
      icon: 'âš”ï¸',
      baseCost: 8,
      costIncrease: 1.5,
      maxLevel: 25,
      getCurrentLevel: () => gameState.influenceUpgrades?.bossWarrior || 0,
      effect: (level) => 1 + (level * 0.15) // +15% damage per level
    },
    prestigeBonus: {
      id: 'prestigeBonus',
      name: 'Prestige Master',
      description: 'Gain +5% more Influence Points per prestige per level',
      icon: 'âœ¨',
      baseCost: 10,
      costIncrease: 1.6,
      maxLevel: 20,
      getCurrentLevel: () => gameState.influenceUpgrades?.prestigeBonus || 0,
      effect: (level) => 1 + (level * 0.05) // +5% IP gain per level
    },
    offlineEarnings: {
      id: 'offlineEarnings',
      name: 'Passive Income',
      description: 'Boost offline earnings rate (+5% per level, max 100%)',
      icon: 'ğŸ’¤',
      baseCost: 7,
      costIncrease: 1.45,
      maxLevel: 10,
      getCurrentLevel: () => gameState.influenceUpgrades?.offlineEarnings || 0,
      effect: (level) => Math.min(1.0, 0.5 + (level * 0.05)) // 50% base, +5% per level, caps at 100%
    },
    relationshipGains: {
      id: 'relationshipGains',
      name: 'Charisma',
      description: 'Gain +10% more relationship progress per level',
      icon: 'ğŸ’–',
      baseCost: 5,
      costIncrease: 1.4,
      maxLevel: 25,
      getCurrentLevel: () => gameState.influenceUpgrades?.relationshipGains || 0,
      effect: (level) => 1 + (level * 0.1) // +10% relationship gains per level
    },
    luckyStreak: {
      id: 'luckyStreak',
      name: 'Lucky Streak',
      description: 'Random chance for 2x-5x income on product completion (+2% per level)',
      icon: 'ğŸ€',
      baseCost: 12,
      costIncrease: 1.5,
      maxLevel: 20,
      getCurrentLevel: () => gameState.influenceUpgrades?.luckyStreak || 0,
      effect: (level) => level * 0.02 // 2% proc chance per level
    },
    employeeRetention: {
      id: 'employeeRetention',
      name: 'Employee Loyalty',
      description: 'Keep +10% of employees after prestige per level',
      icon: 'ğŸ¤',
      baseCost: 15,
      costIncrease: 1.7,
      maxLevel: 10,
      getCurrentLevel: () => gameState.influenceUpgrades?.employeeRetention || 0,
      effect: (level) => Math.min(1.0, level * 0.1) // Keep 10-100% of employees
    }
  };
  
  // Initialize influence upgrades in gameState if not present
  if (!gameState.influenceUpgrades) {
    gameState.influenceUpgrades = {};
    Object.keys(influenceUpgrades).forEach(key => {
      gameState.influenceUpgrades[key] = 0;
    });
  }
  
  // Calculate how many influence points player will gain from current lifetime earnings
  function calculateInfluenceGain() {
    // Only count earnings that haven't been converted to influence yet
    const unconvertedEarnings = gameState.lifetimeEarnings - (gameState.lifetimeEarningsConverted || 0);
    // Formula: sqrt(earnings / 10000) rounded down
    // This means: $10k = 1 IP, $40k = 2 IP, $90k = 3 IP, $160k = 4 IP, etc.
    let baseIP = Math.floor(Math.sqrt(unconvertedEarnings / 10000));
    
    // Apply Prestige Master upgrade (+5% IP per level)
    const prestigeBonusLevel = gameState.influenceUpgrades?.prestigeBonus || 0;
    if (prestigeBonusLevel > 0) {
      const prestigeBonusMultiplier = influenceUpgrades.prestigeBonus.effect(prestigeBonusLevel);
      baseIP = Math.floor(baseIP * prestigeBonusMultiplier);
    }
    
    return baseIP;
  }
  
  // Calculate cost of next level for an influence upgrade
  function getInfluenceUpgradeCost(upgradeId) {
    const upgrade = influenceUpgrades[upgradeId];
    if (!upgrade) return 0;
    
    const currentLevel = upgrade.getCurrentLevel();
    if (currentLevel >= upgrade.maxLevel) return Infinity;
    
    return Math.ceil(upgrade.baseCost * Math.pow(upgrade.costIncrease, currentLevel));
  }
  
  // Purchase an influence upgrade
  function purchaseInfluenceUpgrade(upgradeId) {
    const upgrade = influenceUpgrades[upgradeId];
    if (!upgrade) return false;
    
    const currentLevel = upgrade.getCurrentLevel();
    if (currentLevel >= upgrade.maxLevel) {
      showNotification('Upgrade is at max level!');
      return false;
    }
    
    const cost = getInfluenceUpgradeCost(upgradeId);
    if (gameState.influencePoints < cost) {
      showNotification('Not enough Influence Points!');
      return false;
    }
    
    // Purchase upgrade
    gameState.influencePoints -= cost;
    gameState.influenceUpgrades[upgradeId] = currentLevel + 1;
    
    showNotification(`Upgraded ${upgrade.name} to level ${currentLevel + 1}!`);
    updatePrestigeUI();
    renderInfluenceUpgrades();
    return true;
  }
  
  // Render the influence upgrades shop
  function renderInfluenceUpgrades() {
    const container = document.getElementById('influenceUpgradesContainer');
    if (!container) return;
    
    container.innerHTML = '';
    
    Object.values(influenceUpgrades).forEach(upgrade => {
      const currentLevel = upgrade.getCurrentLevel();
      const cost = getInfluenceUpgradeCost(upgrade.id);
      const isMaxed = currentLevel >= upgrade.maxLevel;
      const canAfford = gameState.influencePoints >= cost && !isMaxed;
      
      const upgradeDiv = document.createElement('div');
      upgradeDiv.style.cssText = `
        background: #16213e;
        border-radius: 12px;
        padding: 20px;
        border: 2px solid ${canAfford ? '#ffd700' : '#2a3f5f'};
        transition: all 0.3s;
        opacity: ${isMaxed ? '0.6' : '1'};
      `;
      
      if (canAfford) {
        upgradeDiv.style.cursor = 'pointer';
        upgradeDiv.style.boxShadow = '0 4px 15px rgba(255,215,0,0.2)';
        upgradeDiv.onmouseenter = () => {
          upgradeDiv.style.transform = 'translateY(-3px)';
          upgradeDiv.style.boxShadow = '0 6px 20px rgba(255,215,0,0.3)';
        };
        upgradeDiv.onmouseleave = () => {
          upgradeDiv.style.transform = 'translateY(0)';
          upgradeDiv.style.boxShadow = '0 4px 15px rgba(255,215,0,0.2)';
        };
        upgradeDiv.onclick = () => purchaseInfluenceUpgrade(upgrade.id);
      }
      
      upgradeDiv.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:12px;">
          <div>
            <div style="font-size:2rem; margin-bottom:8px;">${upgrade.icon}</div>
            <div style="font-weight:700; font-size:1.1rem; color:white; margin-bottom:5px;">${upgrade.name}</div>
            <div style="color:#aaa; font-size:0.85rem; line-height:1.4;">${upgrade.description}</div>
          </div>
        </div>
        <div style="display:flex; justify-content:space-between; align-items:center; margin-top:15px; padding-top:15px; border-top:1px solid #2a3f5f;">
          <div style="color:#00d4ff; font-size:0.9rem;">Level ${currentLevel}/${upgrade.maxLevel}</div>
          <div style="color:${canAfford ? '#ffd700' : isMaxed ? '#2ecc71' : '#666'}; font-weight:700; font-size:1.1rem;">
            ${isMaxed ? 'âœ“ MAXED' : `${cost} IP`}
          </div>
        </div>
      `;
      
      container.appendChild(upgradeDiv);
    });
  }
  
  // Update the prestige UI with current stats
  function updatePrestigeUI() {
    // Update current stats
    const currentPrestigeLevelEl = document.getElementById('currentPrestigeLevel');
    const lifetimeEarningsEl = document.getElementById('lifetimeEarningsDisplay');
    const currentInfluencePointsEl = document.getElementById('currentInfluencePoints');
    const currentMultiplierEl = document.getElementById('currentMultiplier');
    const nextPrestigeInfluenceEl = document.getElementById('nextPrestigeInfluence');
    const prestigeReqEl = document.getElementById('prestigeRequirement');
    
    if (currentPrestigeLevelEl) currentPrestigeLevelEl.textContent = gameState.prestigeLevel;
    if (lifetimeEarningsEl) lifetimeEarningsEl.textContent = `$${formatNumber(gameState.lifetimeEarnings)}`;
    if (currentInfluencePointsEl) currentInfluencePointsEl.textContent = gameState.influencePoints;
    
    // Calculate total multiplier from all sources
    const incomeUpgradeLevel = gameState.influenceUpgrades?.incomeMultiplier || 0;
    const totalMultiplier = influenceUpgrades.incomeMultiplier.effect(incomeUpgradeLevel);
    if (currentMultiplierEl) currentMultiplierEl.textContent = `${totalMultiplier.toFixed(1)}x`;
    
    // Calculate influence gain for next prestige
    const influenceGain = calculateInfluenceGain();
    if (nextPrestigeInfluenceEl) nextPrestigeInfluenceEl.textContent = influenceGain;
    
    // Check if player meets requirement to prestige (at least $100k lifetime earnings)
    const canPrestige = gameState.lifetimeEarnings >= 100000 && influenceGain > 0;
    const prestigeBtn = document.getElementById('prestigeBtn');
    
    if (prestigeBtn) {
      if (canPrestige) {
        prestigeBtn.disabled = false;
        prestigeBtn.style.opacity = '1';
        prestigeBtn.style.cursor = 'pointer';
        if (prestigeReqEl) prestigeReqEl.textContent = '';
      } else {
        prestigeBtn.disabled = true;
        prestigeBtn.style.opacity = '0.5';
        prestigeBtn.style.cursor = 'not-allowed';
        if (prestigeReqEl) {
          const needed = 100000 - gameState.lifetimeEarnings;
          prestigeReqEl.textContent = `Requires $100k total earnings (need $${formatNumber(needed)} more)`;
        }
      }
    }
  }
  
  // Show the prestige confirmation modal
  function showPrestigeModal() {
    const influenceGain = calculateInfluenceGain();
    if (influenceGain <= 0 || gameState.lifetimeEarnings < 100000) {
      showNotification('You need at least $100k lifetime earnings to prestige!');
      return;
    }
    
    const modal = document.getElementById('prestigeModal');
    const gainAmount = document.getElementById('prestigeGainAmount');
    
    if (gainAmount) gainAmount.textContent = `+${influenceGain}`;
    if (modal) modal.style.display = 'flex';
  }
  
  // Execute the prestige (reset game with benefits)
  function executePrestige() {
    const influenceGain = calculateInfluenceGain();
    
    // Award influence points
    gameState.influencePoints += influenceGain;
    gameState.prestigeLevel += 1;
    
    // Mark current lifetime earnings as converted to prevent re-claiming
    gameState.lifetimeEarningsConverted = gameState.lifetimeEarnings;
    
    // Reset current lifetime income (this prestige only)
    gameState.currentLifetimeIncome = 0;
    
    // Preserve these values
    const preservedInfluencePoints = gameState.influencePoints;
    const preservedPrestigeLevel = gameState.prestigeLevel;
    const preservedLifetimeEarnings = gameState.lifetimeEarnings;
    const preservedLifetimeEarningsConverted = gameState.lifetimeEarningsConverted;
    const preservedInfluenceUpgrades = {...gameState.influenceUpgrades};
    const preservedSettings = {...gameState.settings};
    const preservedPlayerBio = gameState.settings?.playerBio || '';
    const preservedGenderSettings = {...gameState.genderSettings};
    const preservedRaceSettings = {...gameState.raceSettings};
    // Deep copy hrSettings to preserve nested startingStatRanges
    const preservedHrSettings = {
      startingStatRanges: {
        productivity: {...gameState.hrSettings.startingStatRanges.productivity},
        trust: {...gameState.hrSettings.startingStatRanges.trust},
        friendship: {...gameState.hrSettings.startingStatRanges.friendship},
        desire: {...gameState.hrSettings.startingStatRanges.desire},
        comfort: {...gameState.hrSettings.startingStatRanges.comfort},
        affection: {...gameState.hrSettings.startingStatRanges.affection}
      }
    };
    
    // NEW: Preserve former employees for rehiring
    const preservedFormerEmployees = gameState.formerEmployees || [];
    
    // ========== CORPORATE HIERARCHY: PRESERVE EMPLOYEES TO REHIRE POOL ==========
    const preservedRehirePool = [];
    
    // Save current employees to rehire pool
    gameState.employees.forEach(employee => {
      if (!employee || !employee.name) return;
      if (employee.employmentStatus !== 'active') return;
      
      // Calculate relationship strength
      const relationshipStrength = calculateRelationshipStrength(employee);
      
      // Calculate productivity bonus for rehire
      const rehireBonus = calculateRehireBonus(employee);
      
      // Create rehire data snapshot
      const rehireData = {
        // Identity
        id: employee.id,
        name: employee.name,
        age: employee.age,
        gender: employee.gender,
        
        // Career snapshot
        previousLevel: employee.career?.level || 1,
        previousTitle: employee.career?.title || "Staff",
        previousSalary: employee.career?.salary || 40000,
        promotionHistory: employee.career?.promotionHistory ? [...employee.career.promotionHistory] : [],
        
        // Full stat preservation
        stats: {...employee.stats},
        skills: employee.skills ? JSON.parse(JSON.stringify(employee.skills)) : {},
        personality: {...employee.personality},
        
        // Relationship data
        relationshipStrength: relationshipStrength,
        rehireBonus: rehireBonus,
        
        // Memory preservation
        memory: employee.memory ? {...employee.memory} : {},
        chatHistory: gameState.chatHistory[employee.id] ? [...gameState.chatHistory[employee.id]] : [],
        
        // Physical & bio data
        physical: employee.physical ? {...employee.physical} : {},
        profileImage: employee.profileImage,
        bio: employee.bio,
        
        // Traits
        keyTrait: employee.keyTrait,
        personalityTraits: employee.personalityTraits ? [...employee.personalityTraits] : [],
        hobbies: employee.hobbies ? [...employee.hobbies] : [],
        kinks: employee.kinks ? [...employee.kinks] : [],
        
        // Product association
        productId: employee.productId,
        productManaged: employee.productManaged,
        
        // Gift preferences
        giftPreferences: employee.giftPreferences,
        
        // Meta
        timesRehired: (employee.timesRehired || 0),
        originalHireDate: employee.hireDate || Date.now(),
        lastPrestigeLevel: preservedPrestigeLevel
      };
      
      preservedRehirePool.push(rehireData);
    });
    
    console.log(`ğŸ’¼ Preserved ${preservedRehirePool.length} employees to rehire pool`);
    
    // Save current employees as former employees (with their product associations) - LEGACY SYSTEM
    gameState.employees.forEach(emp => {
      if (emp.productManaged) {
        // Check if this employee was already a former employee
        const existingFormerIndex = preservedFormerEmployees.findIndex(
          fe => fe.originalId === (emp.originalId || emp.id)
        );
        
        const employeeData = {
          // Preserve original ID for tracking across prestiges
          originalId: emp.originalId || emp.id,
          name: emp.name,
          age: emp.age,
          gender: emp.gender,
          position: emp.position,
          productManaged: emp.productManaged,
          profileImage: emp.profileImage,
          bio: emp.bio,
          personality: emp.personality,
          personalityTraits: emp.personalityTraits,
          hobbies: emp.hobbies,
          kinks: emp.kinks,
          traits: emp.traits,
          keyTrait: emp.keyTrait,
          physical: emp.physical,
          chatHistory: gameState.chatHistory[emp.id] || [],
          photos: emp.photos || [],
          memory: emp.memory,
          stats: emp.stats,
          relationships: emp.relationships,
          intimacy: emp.intimacy,
          // Track loyalty (times rehired)
          timesRehired: existingFormerIndex >= 0 ? (preservedFormerEmployees[existingFormerIndex].timesRehired || 0) + 1 : 1,
          lastPrestigeLevel: preservedPrestigeLevel
        };
        
        if (existingFormerIndex >= 0) {
          // Update existing former employee data
          preservedFormerEmployees[existingFormerIndex] = employeeData;
        } else {
          // Add new former employee
          preservedFormerEmployees.push(employeeData);
        }
      }
    });
    
    // ========== BASE UNLOCK COST LOOKUP ==========
    // Define base unlock costs for ALL products (used to reset after prestige)
    const baseUnlockCosts = {
      // Garage
      'website': 0,
      'app': 80,
      'consulting': 300,
      'cloud': 1200,
      'seo': 3000,
      'branding': 5000,
      'ecommerce': 8000,
      'automation': 12000,
      // Home Office
      'copywriting': 0,
      'video_editing': 20000,
      'marketing': 35000,
      'consulting_premium': 55000,
      'saas': 85000,
      'virtual_assistant': 120000,
      'social_media_mgmt': 180000,
      'online_courses': 250000,
      'business_coaching': 350000,
      'digital_marketing': 480000,
      // Office Suite
      'enterprise_saas': 0,
      'enterprise_software': 700000,
      'api_marketplace': 1200000,
      'white_label': 2000000,
      'cybersecurity': 3500000,
      'data_analytics': 5500000,
      'crm_system': 8500000,
      'ai_integration': 13000000,
      'blockchain': 20000000,
      'acquisitions': 30000000,
      // Factory
      'custom_keychains': 0,
      'branded_tshirts': 35000000,
      'phone_cases': 60000000,
      'custom_mugs': 100000000,
      'tech_gadgets': 150000000,
      'luxury_merch': 230000000,
      'smart_devices': 350000000,
      'wearables': 520000000,
      'vr_headsets': 780000000,
      'drones': 1170000000,
      // Corporate Tower
      'patent_licensing': 0,
      'venture_capital': 1500000000,
      'hedge_fund': 2500000000,
      'market_manipulation': 4000000000,
      'insider_trading': 6500000000,
      'tax_havens': 10000000000,
      'lobbying': 15000000000,
      'government_contracts': 23000000000,
      'space_tourism': 35000000000,
      'quantum_computing': 50000000000
    };
    
    // ========== BASE MANAGER UPGRADE COST LOOKUP ==========
    // Define base manager upgrade costs for ALL products (used to reset after prestige)
    const baseManagerUpgradeCosts = {
      // Garage
      'website': 250,
      'app': 750,
      'consulting': 1500,
      'cloud': 2500,
      'seo': 4000,
      'branding': 6000,
      'ecommerce': 9000,
      'automation': 12500,
      // Home Office
      'copywriting': 17500,
      'video_editing': 25000,
      'marketing': 35000,
      'consulting_premium': 50000,
      'saas': 75000,
      'virtual_assistant': 110000,
      'social_media_mgmt': 160000,
      'online_courses': 225000,
      'business_coaching': 325000,
      'digital_marketing': 450000,
      // Office Suite
      'enterprise_saas': 750000,
      'enterprise_software': 1100000,
      'api_marketplace': 1650000,
      'white_label': 2500000,
      'cybersecurity': 3750000,
      'data_analytics': 5500000,
      'crm_system': 8500000,
      'ai_integration': 13000000,
      'blockchain': 20000000,
      'acquisitions': 30000000,
      // Factory
      'custom_keychains': 45000000,
      'branded_tshirts': 70000000,
      'phone_cases': 105000000,
      'custom_mugs': 160000000,
      'tech_gadgets': 240000000,
      'luxury_merch': 360000000,
      'smart_devices': 540000000,
      'wearables': 810000000,
      'vr_headsets': 1215000000,
      'drones': 1822500000,
      // Corporate Tower
      'patent_licensing': 2733750000,
      'venture_capital': 4100625000,
      'hedge_fund': 6150937500,
      'market_manipulation': 9226406250,
      'insider_trading': 13839609375,
      'tax_havens': 20759414062.5,
      'lobbying': 31139121093.75,
      'government_contracts': 46708681640.625,
      'space_tourism': 70063022460.9375,
      'quantum_computing': 105094533691.406
    };
    
    // Calculate starting cash from influence upgrades
    const startingCashBonus = influenceUpgrades.startingCash.effect(
      gameState.influenceUpgrades?.startingCash || 0
    );
    
    // Reset game state (this resets everything to defaults)
    const freshState = {
      cash: gameBalance.startingCash + startingCashBonus,
      playerUpgrades: { clickPower: 0 },
      totalEarnings: 0,
      onboarding: [],
      lastPlayTime: Date.now(),
      
      // PRESTIGE SYSTEM (preserved)
      prestigeLevel: preservedPrestigeLevel,
      influencePoints: preservedInfluencePoints,
      lifetimeEarnings: preservedLifetimeEarnings,
      lifetimeEarningsConverted: preservedLifetimeEarningsConverted,
      prestigeMultiplier: 1.0,
      influenceUpgrades: preservedInfluenceUpgrades,
      
      // GLOBAL UPGRADES (reset on prestige)
      globalUpgrades: {
        clickPower: 0,
        incomeBoost: {},
        costReduction: {}
      },
      
      // BOSS FIGHTS (reset)
      bossFights: {
        active: null,
        defeated: [],
        history: []
      },
      
      // Locations (reset to just garage)
      locations: gameState.locations.map(loc => ({
        ...loc,
        owned: loc.id === 'garage',
        unlocked: loc.id === 'garage',
        products: []
      })),
      
      activeLocationId: 'garage',
      
      // Products (reset all progress, keep only base definition properties)
      products: gameState.products.map(p => ({
        // Keep base definition properties
        id: p.id,
        name: p.name,
        locationId: p.locationId,
        nsfwLevel: p.nsfwLevel,
        
        // Economic properties (keep base values)
        valuePerUnit: p.valuePerUnit,
        baseUpgradeCost: p.baseUpgradeCost,
        costGrowth: p.costGrowth,
        valuePerUpgrade: p.valuePerUpgrade,
        valueExponent: p.valueExponent,
        
        // Timing properties (keep base values)
        baseTimeMs: p.baseTimeMs,
        clickSecondsBase: p.clickSecondsBase,
        
        // Manager properties - RESET to base costs
        managerHireCost: p.managerHireCost,
        managerUpgradeCost: baseManagerUpgradeCosts[p.id] !== undefined ? baseManagerUpgradeCosts[p.id] : p.managerUpgradeCost,
        managerSpeedCapPct: p.managerSpeedCapPct,
        
        // Unlock properties - RESET to base unlock cost (fixes prestige lock bug)
        unlockCost: baseUnlockCosts[p.id] !== undefined ? baseUnlockCosts[p.id] : p.unlockCost,
        
        // RESET all progress properties
        quantity: 0,
        level: 0,
        upgradeCost: p.baseUpgradeCost, // Reset to base cost
        unlocked: false,
        running: false,
        timeRemainingMs: 0,
        managerHired: false,
        managerLevel: 0
      })),
      
      // Employees (reset)
      employees: [],
      
      // ========== CORPORATE HIERARCHY SYSTEM ==========
      hierarchyLevels: gameState.hierarchyLevels, // Preserve structure
      corporateHierarchy: {
        levels: { 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [] },
        executiveRoles: { COO: null, CFO: null }
      },
      rehirePool: preservedRehirePool, // Preserved rehire candidates
      currentHiringCandidates: {
        newHires: [],
        rehires: [],
        productId: null,
        activeTab: 'newHires'
      },
      globalIncomeMultiplier: 1.0,
      
      // Former employees (preserved for rehiring) - LEGACY SYSTEM
      formerEmployees: preservedFormerEmployees,
      
      // Social Network (reset)
      socialNetwork: {
        posts: [],
        globalEvents: [],
        postIdCounter: 0,
        lastPostGeneration: 0,
        postGenerationInterval: 300000,
        feedFilter: 'all',
        feedSort: 'recent',
        recentPostTypes: [],
        playerDraft: {
          caption: '',
          imagePrompt: '',
          altText: '',
          imageUrl: null
        }
      },
      
      // Company Context (reset)
      companyContext: {
        totalEmployees: 0,
        locationEmployeeCounts: {},
        recentHires: [],
        recentFires: [],
        recentPromotions: [],
        interdepartmentalEvents: []
      },
      
      // Social Feed (deprecated but keep for compatibility)
      socialFeed: [],
      socialStats: {
        totalPosts: 0,
        totalLikes: 0,
        totalComments: 0
      },
      chatHistory: {},
      activeChat: null,
      
      // News (reset to defaults)
      news: [
        "Tech startup raises $1M in seed funding",
        "New productivity app trends in office spaces",
        "Remote work policies reshape company cultures",
        "AI integration boosts efficiency across industries"
      ],
      
      // Settings (preserved)
      settings: {
        ...preservedSettings,
        playerBio: preservedPlayerBio
      },
      
      // Gender Settings (preserved)
      genderSettings: preservedGenderSettings,
      
      // Race Settings (preserved)
      raceSettings: preservedRaceSettings,
      
      // HR Settings (preserved)
      hrSettings: preservedHrSettings,
      
      // AI Quality (preserved - don't lose training progress)
      aiQuality: gameState.aiQuality || {
        goodExamples: { posts: [], comments: [], chats: [] },
        badExamples: { posts: [], comments: [], chats: [] },
        bannedPatterns: [],
        stats: { totalVotes: 0, upvotes: 0, downvotes: 0, postsVoted: 0, commentsVoted: 0, chatsVoted: 0 },
        maxExamplesPerType: 20,
        tutorialShown: false
      },
      
      activeTab: 'dashboard',
      upgradeMultiplier: 1
    };
    
    // Replace gameState with fresh state
    Object.keys(gameState).forEach(key => delete gameState[key]);
    Object.assign(gameState, freshState);
    
    // Close modal
    const modal = document.getElementById('prestigeModal');
    if (modal) modal.style.display = 'none';
    
    // Save and refresh UI
    saveGame(false);
    updateUI();
    updatePrestigeUI();
    renderInfluenceUpgrades();
    
    // Show success notification
    showNotification(`âœ¨ Prestiged! Gained ${influenceGain} Influence Points!`, 5000);
    
    // Switch to dashboard tab and force full refresh
    switchTab('dashboard');
    
    // Force reload the dashboard content after prestige
    setTimeout(() => {
      updateDashboard();
      refreshDashboardSections();
      updateBusinessTab();
      updatePeopleTab();
    }, 100);
  }

  // Autosave setup
  // Store autosave interval ID so we can clear it
  let autosaveIntervalId = null;
  
  function setupAutosave() {
    // Clear any existing autosave interval first
    if (autosaveIntervalId) {
      clearInterval(autosaveIntervalId);
      autosaveIntervalId = null;
    }
    
    if (gameState.settings.autosave) {
      // Initialize autosave tracking if not exists
      if (!gameState.autosaveTracking) {
        gameState.autosaveTracking = {
          lastSnapshotTime: Date.now(),
          currentSlotIndex: 0,
          snapshotIntervalMinutes: 5 // Can be adjusted: 5-10 minutes
        };
      }
      
      // Use new slot-based autosave system
      autosaveIntervalId = setInterval(async () => {
        const now = Date.now();
        
        // Initialize tracking if it doesn't exist (fixes "tracking is undefined" error)
        if (!gameState.autosaveTracking) {
          gameState.autosaveTracking = {
            lastSnapshotTime: Date.now(),
            currentSlotIndex: 0,
            snapshotIntervalMinutes: 5
          };
        }
        
        const tracking = gameState.autosaveTracking;
        const minutesSinceLastSnapshot = (now - tracking.lastSnapshotTime) / 1000 / 60;
        
        // Every 5 seconds: Quick autosave (overwrites single 'autosave' slot)
        await saveGameToSlot('autosave', 'auto', false);
        
        // Every 5-10 minutes: Create a snapshot autosave (rotating slots)
        if (minutesSinceLastSnapshot >= tracking.snapshotIntervalMinutes) {
          // Increment slot index (0-9, cycling)
          tracking.currentSlotIndex = (tracking.currentSlotIndex + 1) % 10;
          
          // Save to numbered autosave slot (autosave_0 through autosave_9)
          const snapshotSlotName = `autosave_${tracking.currentSlotIndex}`;
          await saveGameToSlot(snapshotSlotName, 'auto', false);
          
          tracking.lastSnapshotTime = now;
          
          console.log(`[Autosave] Created snapshot: ${snapshotSlotName} (${tracking.currentSlotIndex + 1}/10)`);
          
          // Optional: Show subtle notification every 10th snapshot
          if (tracking.currentSlotIndex === 0) {
            console.log('[Autosave] Completed full rotation of 10 snapshot slots');
          }
        }
      }, 5000); // every 5s
    }
  }
  
  // Export save
  /**
   * Export save to downloadable JSON file
   */
  function exportSave() {
    try {
      // Create a save object with metadata
      const saveData = {
        version: '250116200000', // Current game version
        timestamp: gameState.time?.currentTime || Date.now(),
        date: new Date().toISOString(),
        gameState: gameState
      };
      
      const jsonString = JSON.stringify(saveData, null, 2); // Pretty print for readability
      
      // Generate filename with timestamp
      const dateStr = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
      const filename = `FreeUseOffice-Save-${dateStr}.json`;
      
      // FIXED: Mobile-friendly export with fallback
      // Try modern download first (works on desktop)
      try {
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        URL.revokeObjectURL(url);
        showNotification(`ğŸ’¾ Save exported: ${filename}`, 'success');
      } catch (downloadError) {
        // Fallback for mobile: Copy to clipboard
        console.log('Download failed, trying clipboard fallback...', downloadError);
        
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(jsonString).then(() => {
            showNotification(`ğŸ“‹ Save data copied to clipboard! Paste it into a text file to save.`, 'success', 5000);
          }).catch(clipboardError => {
            // Final fallback: Show in modal
            console.log('Clipboard failed, showing modal...', clipboardError);
            showExportModal(jsonString, filename);
          });
        } else {
          // No clipboard support, show in modal
          showExportModal(jsonString, filename);
        }
      }
    } catch (error) {
      console.error('Error exporting save:', error);
      showNotification('âŒ Failed to export save!', 'error');
    }
  }
  
  /**
   * Show export data in modal (fallback for mobile)
   */
  function showExportModal(jsonString, filename) {
    const modal = document.createElement('div');
    modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:10000; display:flex; align-items:center; justify-content:center; padding:20px;';
    
    modal.innerHTML = `
      <div style="background:#16213e; border-radius:12px; padding:20px; max-width:600px; width:100%; max-height:90vh; overflow:auto;">
        <h3 style="margin:0 0 15px 0; color:#00d4ff;">ğŸ“‹ Export Save Data</h3>
        <p style="color:#aaa; font-size:0.9rem; margin:0 0 15px 0;">
          Copy this text and save it to a file named: <strong style="color:#fff;">${filename}</strong>
        </p>
        <textarea readonly style="width:100%; height:300px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:#fff; padding:10px; font-family:monospace; font-size:0.85rem; resize:vertical;">${jsonString}</textarea>
        <div style="display:flex; gap:10px; margin-top:15px;">
          <button onclick="navigator.clipboard.writeText(this.parentElement.parentElement.querySelector('textarea').value).then(() => showNotification('ğŸ“‹ Copied to clipboard!', 'success')).catch(() => showNotification('âŒ Copy failed', 'error'))" style="flex:1; padding:12px; background:#4ecca3; border:none; border-radius:8px; color:#0f1419; font-weight:600; cursor:pointer;">
            ğŸ“‹ Copy to Clipboard
          </button>
          <button onclick="this.closest('div[style*=\"position:fixed\"]').remove()" style="flex:1; padding:12px; background:#e94560; border:none; border-radius:8px; color:#fff; font-weight:600; cursor:pointer;">
            Close
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Select all text in textarea for easy copying
    const textarea = modal.querySelector('textarea');
    textarea.select();
    
    showNotification('ğŸ’¾ Save data ready! Copy and paste into a text file.', 'info', 5000);
  }
  
  /**
   * Import save from JSON file
   */
  function importSave() {
    const fileInput = document.getElementById('importFileInput');
    if (!fileInput) {
      showNotification('âŒ Import system not available!', 'error');
      return;
    }
    
    // Trigger file picker
    fileInput.click();
  }
  
  /**
   * Handle imported file
   */
  function handleImportedFile(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    
    reader.onload = async function(e) {
      try {
        const contents = e.target.result;
        const saveData = JSON.parse(contents);
        
        // Validate save data structure
        if (!saveData.gameState) {
          // Try legacy format (direct gameState)
          if (saveData.cash !== undefined && saveData.products !== undefined) {
            // This looks like a direct gameState export
            if (confirm('âš ï¸ This appears to be an old save format. Import anyway? (May cause issues)')) {
              await loadSaveData(saveData);
            }
          } else {
            showNotification('âŒ Invalid save file format!', 'error');
          }
          return;
        }
        
        // Show confirmation with save info
        const saveDate = saveData.date ? new Date(saveData.date).toLocaleString() : 'Unknown';
        const saveMoney = saveData.gameState.cash ? formatCash(saveData.gameState.cash) : 'Unknown';
        const saveEmployees = saveData.gameState.employees ? saveData.gameState.employees.length : 0;
        const savePrestige = saveData.gameState.prestigeLevel || 0;
        
        const confirmMsg = `ğŸ“¥ Import Save File?\n\n` +
          `ğŸ’° Money: ${saveMoney}\n` +
          `ğŸ‘¥ Employees: ${saveEmployees}\n` +
          `âœ¨ Prestige Level: ${savePrestige}\n` +
          `ğŸ“… Save Date: ${saveDate}\n\n` +
          `âš ï¸ This will overwrite your current progress!`;
        
        if (confirm(confirmMsg)) {
          await loadSaveData(saveData.gameState);
          showNotification('âœ… Save imported successfully!', 'success');
        }
      } catch (error) {
        console.error('Error importing save:', error);
        showNotification('âŒ Failed to import save! File may be corrupted.', 'error');
      }
      
      // Reset file input
      event.target.value = '';
    };
    
    reader.onerror = function() {
      showNotification('âŒ Failed to read file!', 'error');
    };
    
    reader.readAsText(file);
  }
  
  /**
   * Load save data into game
   */
  async function loadSaveData(data) {
    try {
      // Validate save data structure
      if (!data || typeof data !== 'object') {
        throw new Error('Invalid save data structure');
      }
      
      // Clear current game state
      Object.keys(gameState).forEach(key => delete gameState[key]);
      
      // Load new state
      Object.assign(gameState, data);
      
      // Ensure critical tracking objects exist (fixes save corruption issues)
      if (!gameState.autosaveTracking) {
        gameState.autosaveTracking = {
          lastSnapshotTime: Date.now(),
          currentSlotIndex: 0,
          snapshotIntervalMinutes: 5
        };
        console.log('[LoadSave] Restored missing autosaveTracking');
      }
      
      // Ensure flagDetection tracking exists
      if (!gameState.flagDetection) {
        gameState.flagDetection = { tracking: {} };
        console.log('[LoadSave] Restored missing flagDetection');
      } else if (!gameState.flagDetection.tracking) {
        gameState.flagDetection.tracking = {};
        console.log('[LoadSave] Restored missing flagDetection.tracking');
      }
      
      // Ensure settings exist
      if (!gameState.settings) {
        gameState.settings = {
          autosave: true,
          maxAiRequests: 15,
          // ... other default settings
        };
        console.log('[LoadSave] Restored missing settings');
      }
      
      // Save to storage with better error handling
      try {
        await kv.gameSave.set("gameState", gameState);
      } catch (storageError) {
        console.warn('[LoadSave] Storage save failed, but load continuing:', storageError);
        // Don't fail the load if storage save fails - game is still functional
      }
      
      // Refresh entire UI
      updateUI();
      updatePrestigeUI();
      renderInfluenceUpgrades();
      
      // Switch to dashboard and force refresh
      switchTab('dashboard');
      setTimeout(() => {
        updateDashboard();
        refreshDashboardSections();
        updateBusinessTab();
        updatePeopleTab();
        updateSocialTab();
      }, 100);
      
      // Restart autosave if enabled
      setupAutosave();
      
      // Reinitialize AI Request Queue with new settings
      if (typeof AIRequestQueue !== 'undefined' && gameState.settings) {
        AIRequestQueue.updateMaxConcurrent(gameState.settings.maxAiRequests || 15);
        console.log('[LoadSave] Reinitialized AI Request Queue');
      }
      
      return true;
    } catch (error) {
      console.error('Error loading save data:', error);
      
      // Enhanced error reporting
      if (error.message?.includes('QuotaExceededError')) {
        showNotification('ğŸ’¾ Storage full! Game loaded but autosave disabled.', 'warning', 8000);
      } else if (error.message?.includes('tracking is undefined')) {
        showNotification('ğŸ”§ Save data repaired automatically.', 'success', 4000);
      } else {
        showNotification('âŒ Failed to load save data!', 'error');
      }
      return false;
    }
  }
  
  // Reset game
  async function resetGame() {
    if (confirm('Are you sure you want to reset the game? This will start a fresh game, but your saved games will remain available in the Save Manager.')) {
      try {
        // Set reset flag to prevent any saves during reset
        isResetting = true;
        
        // Stop autosave immediately to prevent saving during reset
        if (autosaveIntervalId) {
          clearInterval(autosaveIntervalId);
          autosaveIntervalId = null;
        }
        
        // Wait a moment for any pending saves to complete
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Clear ONLY the autosave slot (not manual saves - those stay in Save Manager)
        await kv.gameSave.delete("fuoc_save_autosave");
        
        // Also clear legacy save key for compatibility
        await kv.gameSave.delete("gameState");
        
        // Clear old localStorage
        localStorage.removeItem('gameState');
        
        // Wait another moment to ensure delete operations complete
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Show notification before reload
        showNotification('Game reset! Starting fresh game. Your saves are still in Save Manager.');
        
        // Wait a bit for notification to show
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Now reload (isResetting flag will be cleared by reload)
        location.reload();
      } catch (error) {
        console.error('Error resetting game:', error);
        showNotification('Error resetting game. Please try again.');
        isResetting = false; // Reset flag on error
      }
    }
  }
  
  // Unlock location
  function unlockLocation(locationId) {
    const location = gameState.locations.find(l => l.id === locationId);
    if (!location) return showNotification('Location not found!');
    
    if (location.unlocked) return showNotification('Location already unlocked!');
    
    // Check prerequisites
    if (!checkLocationUnlockable(locationId)) {
      return showNotification('Complete all products in previous locations first!');
    }
    
    // Check cost
    if (gameState.cash < location.cost) {
      return showNotification(`Need $${formatNumber(location.cost)} to unlock ${location.name}!`);
    }
    
    // Unlock location
    gameState.cash -= location.cost;
    location.unlocked = true;
    location.owned = true; // backward compatibility
    
    // Initialize corporate pyramid positions for this location
    initializeHierarchicalPyramid();
    
    // Switch to the newly unlocked location
    gameState.activeLocationId = locationId;
    
    // Unlock the first product in this location
    const firstProduct = gameState.products.find(p => p.locationId === locationId);
    if (firstProduct && firstProduct.unlockCost === 0) {
      firstProduct.unlocked = true;
    }
    
    showNotification(`${location.name} unlocked!`);
    updateBusinessTab();
    updateUI();
  }
  
  // Purchase location (backward compatibility alias)
  function purchaseLocation(locationId) {
    unlockLocation(locationId);
  }
  
  // Generate initial employees
  function generateInitialEmployees() {
    // Use the massive name pools defined earlier
    const traits = ['Hardworking', 'Creative', 'Analytical', 'Charismatic', 'Detail-oriented', 'Adaptable'];
    const personalities = ['Friendly', 'Reserved', 'Outgoing', 'Thoughtful', 'Energetic', 'Calm'];
    const hobbies = ['Reading', 'Photography', 'Hiking', 'Gaming', 'Cooking', 'Traveling', 'Music', 'Art', 'Yoga', 'Dancing'];
    const kinks = ['Exhibitionism', 'Bondage', 'Roleplay', 'Dominance', 'Submission', 'Voyeurism', 'Teasing', 'Spanking'];
    
    // Generate 2 initial employees
    for (let i = 0; i < 2; i++) {
      // Use gender selection system
      const gender = selectGenderForEmployee();
      const fullName = generateUniqueName(gender); // Use unique name generator with gender
      
      // Generate random traits and personality
      const trait = traits[Math.floor(Math.random() * traits.length)];
      const personality = personalities[Math.floor(Math.random() * personalities.length)];
      
      // Generate 1-3 random hobbies
      const numHobbies = Math.floor(Math.random() * 3) + 1;
      const employeeHobbies = [];
      while (employeeHobbies.length < numHobbies) {
        const hobby = hobbies[Math.floor(Math.random() * hobbies.length)];
        if (!employeeHobbies.includes(hobby)) {
          employeeHobbies.push(hobby);
        }
      }
      
      // Generate 2-4 random kinks
      const numKinks = Math.floor(Math.random() * 3) + 2;
      const employeeKinks = [];
      while (employeeKinks.length < numKinks) {
        const kink = kinks[Math.floor(Math.random() * kinks.length)];
        if (!employeeKinks.includes(kink)) {
          employeeKinks.push(kink);
        }
      }
      
      // Generate initial stats (0-100 scale)
      const stats = {
        affection: 20 + Math.floor(Math.random() * 20),   // How much they like you personally
        comfort: 40 + Math.floor(Math.random() * 30),      // How comfortable they feel around you
        trust: 30 + Math.floor(Math.random() * 30),        // How much they trust you
        desire: 5 + Math.floor(Math.random() * 15),        // Romantic/sexual attraction
        obedience: 40 + Math.floor(Math.random() * 30),    // Willingness to follow instructions
        productivity: 50 + Math.floor(Math.random() * 30)  // Work performance (affects game mechanics)
      };
      
      // Generate detailed physical appearance (NEW SYSTEM!) - Gender-aware
      const detailedPhysical = generateDetailedPhysicalAppearance(gender);
      
      // Generate AI personality attributes (C.O.F.P.H.)
      const aiPersonality = {
        confidence: 30 + Math.floor(Math.random() * 50),    // 30-80 range
        outgoing: 20 + Math.floor(Math.random() * 60),      // 20-80 range
        flirty: 10 + Math.floor(Math.random() * 70),        // 10-80 range
        professional: 30 + Math.floor(Math.random() * 50),  // 30-80 range
        humor: 20 + Math.floor(Math.random() * 60)          // 20-80 range
      };
      
      gameState.employees.push({
        id: `emp_${Date.now()}_${i}`,
        name: fullName, // Use the unique name generated above
        position: 'Employee',
        gender: gender,
        trait: trait,
        personality: aiPersonality,  // AI-readable personality object
        personalityTraits: [personality], // Human-readable personality traits
        hobbies: employeeHobbies,
        kinks: employeeKinks,
        stats: stats,
        level: 1,
        hired: true,
        bio: `A ${personality.toLowerCase()} and ${trait.toLowerCase()} team member who enjoys ${employeeHobbies.join(', ')}.`,
        physical: detailedPhysical, // Use new detailed system
        profileImage: null,
        memory: [] // long-term memory: facts, events, relationship history
      });
    }
  }

  // Expose functions to global scope for external access
  window.selectManagerCandidate = selectManagerCandidate;
  window.closeHiringModal = closeHiringModal;
  window.showNotification = showNotification;
  window.updateUI = updateUI;
  window.updateDashboard = updateDashboard;
  window.updateBusinessTab = updateBusinessTab;
  window.updatePeopleTab = updatePeopleTab;
  window.updateGiftsTab = updateGiftsTab;
  window.updateHRTab = updateHRTab;
  window.updateNewsFeed = updateNewsFeed;
  window.gameTick = gameTick;
  window.updateNews = updateNews;
  window.saveGame = saveGame;
  window.loadGame = loadGame;
  window.migrateFromLocalStorage = migrateFromLocalStorage;
  window.resetGame = resetGame;
  window.exportSave = exportSave;
  window.resetGame = resetGame;
  window.unlockLocation = unlockLocation;
  window.purchaseLocation = purchaseLocation;
  window.checkLocationUnlockable = checkLocationUnlockable;
  window.handleEmployeeAction = handleEmployeeAction;
  window.openChat = openChat;
  window.loadChatHistory = loadChatHistory;
  window.addChatMessage = addChatMessage;
  window.sendChatMessage = sendChatMessage;
  window.updateEmployeeStatsFromChat = updateEmployeeStatsFromChat;
  window.setupEventListeners = setupEventListeners;
  window.switchTab = switchTab;
  window.updateTabContent = updateTabContent;
  window.updateProductsList = updateProductsList;
  window.updateProductProgressBars = updateProductProgressBars;
  window.startOrClickProduct = startOrClickProduct;
  window.upgradeProduct = upgradeProduct;
  window.hireOrUpgradeManager = hireOrUpgradeManager;
  window.createOrLinkManagerNPC = createOrLinkManagerNPC;
  window.buyClickPower = buyClickPower;
  window.buyIncomeBoost = buyIncomeBoost;
  window.buyCostReduction = buyCostReduction;
  window.updateUpgradesTab = updateUpgradesTab;
  
  // Boss fight functions
  window.startBossFight = startBossFight;
  window.bossFightAttack = bossFightAttack;
  window.bossFightRetreat = bossFightRetreat;
  window.closeBossFight = closeBossFight;
  window.checkBossFightRequirements = checkBossFightRequirements;
  window.generateInitialEmployees = generateInitialEmployees;
  window.setupAutosave = setupAutosave;
  window.calculateCashPerSecond = calculateCashPerSecond;
  window.getManagerSpeedMultiplier = getManagerSpeedMultiplier;
  window.currentCycleTimeMs = currentCycleTimeMs;
  window.currentValue = currentValue;
  window.clickReductionMs = clickReductionMs;
  
  // Social Network System Functions (for testing and debugging)
  window.initializeEmployeeSocialData = initializeEmployeeSocialData;
  window.updateRelationship = updateRelationship;
  window.generateRandomRelationships = generateRandomRelationships;
  window.updateCompanyAwareness = updateCompanyAwareness;
  window.logCompanyEvent = logCompanyEvent;
  window.getRelevantEvents = getRelevantEvents;
  window.getCoworkerContext = getCoworkerContext;
  window.getEmployeeAwarenessForPost = getEmployeeAwarenessForPost;
  window.getRandomCoworkerByRelation = getRandomCoworkerByRelation;
  window.getLocationCoworkers = getLocationCoworkers;
  window.getKnownLocations = getKnownLocations;
  window.knowsEmployee = knowsEmployee;
  window.createPost = createPost;
  window.createComment = createComment;
  window.createEvent = createEvent;
  window.createRelationship = createRelationship;
  
  // Social Feed UI Functions
  window.updateSocialTab = updateSocialTab;
  window.renderSocialFeed = renderSocialFeed;
  window.generateTestPost = generateTestPost;
  window.openPlayerPostComposer = openPlayerPostComposer;
  window.closePlayerPostModal = closePlayerPostModal;
  window.submitPlayerPostToFeed = submitPlayerPostToFeed;
  window.regeneratePlayerPostImage = regeneratePlayerPostImage;
  window.regeneratePostImage = regeneratePostImage;
  window.handleLikePost = handleLikePost;
  // toggleComments removed - now using modal system (openPostModal)
  window.openPostModal = openPostModal;
  window.closePostModal = closePostModal;
  window.submitModalComment = submitModalComment;
  window.addCommentToPost = addCommentToPost;
  window.openImageViewer = openImageViewer;
  window.showEmployeeProfile = showEmployeeProfile;
  window.loadProfileTab = loadProfileTab;
  window.openBioModal = openBioModal;
  window.openUnifiedProfile = openUnifiedProfile;
  window.setProfilePicture = setProfilePicture;
  window.linkifyMentions = linkifyMentions;
  
  // Autonomous Post Generation Functions
  window.autonomousPostGeneration = autonomousPostGeneration;
  window.generateEmployeePost = generateEmployeePost;
  window.generateFirstEmployeePost = generateFirstEmployeePost;
  window.generateAutonomousComments = generateAutonomousComments;
  window.generateAutonomousLikes = generateAutonomousLikes;
  
  // Initialize game when DOM is loaded
  document.addEventListener('DOMContentLoaded', initGame);
</script>

<style>
  /* General styles */
  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #0f1419;
    color: white;
    overflow-x: hidden;
    transition: background 1s ease-in-out;
  }
  
  /* Fullscreen button */
  #fullscreenBtn {
    transition: transform 0.2s, color 0.2s;
  }
  #fullscreenBtn:hover {
    transform: scale(1.1);
    color: #4ecca3;
  }
  #fullscreenBtn.is-fullscreen {
    color: #4ecca3;
  }
  
  /* Business tab - prevent text selection for better mobile UX */
  #businessTab,
  #businessTab * {
    -webkit-touch-callout: none;
  }
  #businessTab button,
  #businessTab .product-card {
    touch-action: manipulation;
  }
  
  /* Card styling */
  .card {
    transition: transform 0.2s;
  }
  
  .card:hover {
    transform: translateY(-5px);
  }
  
  .dashboard-card:hover {
    transform: translateY(-5px) scale(1.02);
    box-shadow: 0 6px 30px rgba(102,126,234,0.5) !important;
  }
  
  /* Custom scrollbar for dashboard sections */
  #dashRecentMessages::-webkit-scrollbar,
  #dashSocialMentions::-webkit-scrollbar,
  #dashTopPerformers::-webkit-scrollbar,
  #newsFeed::-webkit-scrollbar,
  #contextList::-webkit-scrollbar,
  #gossipList::-webkit-scrollbar {
    width: 6px;
  }
  
  #dashRecentMessages::-webkit-scrollbar-track,
  #dashSocialMentions::-webkit-scrollbar-track,
  #dashTopPerformers::-webkit-scrollbar-track,
  #newsFeed::-webkit-scrollbar-track,
  #contextList::-webkit-scrollbar-track,
  #gossipList::-webkit-scrollbar-track {
    background: #0f3460;
    border-radius: 3px;
  }
  
  #dashRecentMessages::-webkit-scrollbar-thumb,
  #dashSocialMentions::-webkit-scrollbar-thumb,
  #dashTopPerformers::-webkit-scrollbar-thumb,
  #newsFeed::-webkit-scrollbar-thumb,
  #contextList::-webkit-scrollbar-thumb,
  #gossipList::-webkit-scrollbar-thumb {
    background: #00d4ff;
    border-radius: 3px;
  }
  
  #dashRecentMessages::-webkit-scrollbar-thumb:hover,
  #dashSocialMentions::-webkit-scrollbar-thumb:hover,
  #dashTopPerformers::-webkit-scrollbar-thumb:hover,
  #newsFeed::-webkit-scrollbar-thumb:hover,
  #contextList::-webkit-scrollbar-thumb:hover,
  #gossipList::-webkit-scrollbar-thumb:hover {
    background: #00a8cc;
  }
  
  /* Button styling */
  button {
    transition: background-color 0.2s;
  }
  
  button:hover {
    opacity: 0.9;
  }
  
  /* Tab active styling */
  .tab-btn.active {
    border-bottom: 3px solid #e94560;
  }
  
  /* Modal styling */
  .modal {
    animation: fadeIn 0.3s;
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  @keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
  }
  
  /* Pulse animation for unlockable locations */
  @keyframes pulse {
    0%, 100% {
      opacity: 1;
      transform: scale(1);
    }
    50% {
      opacity: 0.8;
      transform: scale(1.05);
    }
  }

  /* Chat message styling */
  #chatMessages {
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><rect width="20" height="20" fill="%2316213e"/><circle cx="10" cy="10" r="1" fill="%230f3460"/></svg>');
    background-size: 20px 20px;
  }

  /* Notification animation */
  @keyframes slideIn {
    from { transform: translateX(100%); }
    to { transform: translateX(0); }
  }
  
  @keyframes slideDown {
    from { 
      transform: translateX(-50%) translateY(-20px);
      opacity: 0;
    }
    to { 
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
  }
  
  #newPostsNotification:hover {
    transform: translateX(-50%) scale(1.05) !important;
    box-shadow: 0 6px 30px rgba(0, 212, 255, 0.6) !important;
  }

  /* News ticker animation */
  @keyframes ticker {
    0% { transform: translateX(100%); }
    100% { transform: translateX(-100%); }
  }

  #newsContent {
    display: inline-block;
    animation: ticker 20s linear infinite;
  }

  /* Bulletproof hiring modal overlay */
  #hiringModal {
    position: fixed !important;
    inset: 0 !important;
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
    background: rgba(0,0,0,0.7) !important;
    z-index: 999999 !important; /* above chat/toasts/etc */
    pointer-events: auto !important;
  }
  #hiringModal * { pointer-events: auto !important; }
  #hiringModal[hidden] { display: none !important; }
  
  /* PHASE 7B: Enhanced candidate cards */
  .candidate-card {
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
  }
  .candidate-card:hover {
    transform: translateY(-4px) !important;
    box-shadow: 0 8px 20px rgba(255, 215, 0, 0.2) !important;
  }
  .select-candidate-btn:hover {
    transform: scale(1.02) !important;
    filter: brightness(1.1) !important;
  }
  .select-candidate-btn:active {
    transform: scale(0.98) !important;
  }

  /* Bulletproof chat modal overlay */
  #chatModal {
    position: fixed !important;
    inset: 0 !important;
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
    background: rgba(0,0,0,0.7) !important;
    z-index: 999999 !important;
    pointer-events: auto !important;
  }
  #chatModal * { pointer-events: auto !important; }
  #chatModal[hidden], #chatModal[style*="display:none"] { display: none !important; pointer-events: none !important; }
  
  /* Boss fight modal */
  #bossFightModal[hidden], #bossFightModal[style*="display:none"] { display: none !important; }

  /* Cash display glow animations */
  @keyframes cash-glow {
    0%, 100% { 
      text-shadow: 0 0 15px rgba(255, 165, 0, 0.7), 0 0 30px rgba(255, 165, 0, 0.4);
      transform: scale(1);
    }
    50% { 
      text-shadow: 0 0 25px rgba(255, 165, 0, 0.9), 0 0 50px rgba(255, 165, 0, 0.6);
      transform: scale(1.02);
    }
  }

  @keyframes cash-glow-intense {
    0%, 100% { 
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.5), 0 0 60px rgba(255, 215, 0, 0.3);
      transform: scale(1);
    }
    50% { 
      text-shadow: 0 0 35px rgba(255, 215, 0, 1), 0 0 70px rgba(255, 215, 0, 0.8), 0 0 100px rgba(255, 215, 0, 0.5);
      transform: scale(1.05);
    }
  }

  /* Constant stream animation for sub-1-second product cycles */
  @keyframes constantStream {
    0% { 
      background-position: 0% 50%;
    }
    100% { 
      background-position: 200% 50%;
    }
  }

  /* ========== MOBILE RESPONSIVE STYLES ========== */
  
  /* Mobile breakpoint */
  @media screen and (max-width: 768px) {
    
    /* ===== MODAL IMPROVEMENTS ===== */
    
    /* Make modals scrollable and properly sized on mobile */
    .modal {
      padding: 10px !important;
      align-items: flex-start !important; /* Align to top instead of center */
      overflow-y: auto !important;
      -webkit-overflow-scrolling: touch !important; /* Smooth scrolling on iOS */
    }
    
    /* Modal content containers */
    .modal > div {
      width: 95% !important;
      max-width: 95% !important;
      max-height: 95vh !important;
      margin: 10px auto !important;
      overflow-y: auto !important;
      -webkit-overflow-scrolling: touch !important;
    }
    
    /* Chat modal specific */
    #chatModal > div {
      height: 90vh !important;
      max-height: 90vh !important;
    }
    
    /* Player profile modal - make scrollable */
    #playerProfileModal > div {
      max-height: 90vh !important;
      overflow-y: auto !important;
    }
    
    /* Boss fight modal */
    #bossFightModal > div {
      max-height: 90vh !important;
      overflow-y: auto !important;
    }
    
    /* Prestige modal */
    #prestigeModal > div {
      max-height: 90vh !important;
      overflow-y: auto !important;
    }
    
    /* ===== SOCIAL FEED MOBILE LAYOUT ===== */
    
    /* Social tab container - make it stack vertically */
    #socialTab > div {
      flex-direction: column !important;
      height: auto !important;
      gap: 15px !important;
    }
    
    /* Left sidebar - expand to full width */
    #socialTab > div > div:first-child {
      flex: 1 !important;
      width: 100% !important;
    }
    
    /* Feed container - expand to full width */
    #socialTab > div > div:nth-child(2) {
      flex: 1 !important;
      width: 100% !important;
      max-height: none !important;
    }
    
    /* Social feed posts - better mobile layout */
    .social-post {
      padding: 12px !important;
      margin-bottom: 12px !important;
    }
    
    /* Social post content - ensure proper text wrapping */
    .social-post p,
    .social-post div {
      word-wrap: break-word !important;
      overflow-wrap: break-word !important;
      word-break: normal !important;
      white-space: normal !important;
      max-width: 100% !important;
    }
    
    /* Social post images */
    .social-post img {
      max-width: 100% !important;
      height: auto !important;
    }
    
    /* ===== MEETINGS TAB MOBILE LAYOUT ===== */
    
    /* Show the toggle tab button on mobile */
    #toggleMeetingsSidebarBtn {
      display: flex !important;
    }
    
    /* Arrow button styling - shows arrow pointing right to open */
    #toggleMeetingsSidebarBtn::before {
      content: 'â–¶' !important;
      display: block !important;
      line-height: 1 !important;
    }
    
    /* Arrow direction when sidebar is open - points left to close */
    #meetingsSidebar.show-mobile #toggleMeetingsSidebarBtn::before {
      content: 'â—€' !important;
    }
    
    /* Meetings tab main container */
    #meetingsTab > div:last-child {
      position: relative !important;
      overflow: visible !important; /* Allow button to stick out */
    }
    
    /* Meetings sidebar - hidden by default on mobile, slides in when shown */
    #meetingsSidebar {
      position: absolute !important;
      top: 0 !important;
      left: 0 !important;
      bottom: 0 !important;
      width: 85% !important;
      max-width: 320px !important;
      z-index: 100 !important;
      transform: translateX(-100%) !important;
      transition: transform 0.3s ease !important;
      box-shadow: 2px 0 10px rgba(0,0,0,0.5) !important;
      flex: none !important;
      overflow: visible !important; /* Allow button to be visible when sidebar is off-screen */
    }
    
    /* When sidebar is shown */
    #meetingsSidebar.show-mobile {
      transform: translateX(0) !important;
    }
    
    /* Meetings sidebar - hidden by default on mobile, slides in when shown */
    #meetingsSidebar {
      position: absolute !important;
      top: 0 !important;
      left: 0 !important;
      bottom: 0 !important;
      width: 85% !important;
      max-width: 320px !important;
      z-index: 100 !important;
      transform: translateX(-100%) !important;
      transition: transform 0.3s ease !important;
      box-shadow: 2px 0 10px rgba(0,0,0,0.5) !important;
      flex: none !important;
    }
    
    /* When sidebar is shown */
    #meetingsSidebar.show-mobile {
      transform: translateX(0) !important;
    }
    
    /* Meeting chat view - full width on mobile with proper flex */
    #meetingChatView {
      flex: 1 !important;
      width: 100% !important;
      display: flex !important;
      flex-direction: column !important;
      min-height: 0 !important;
      overflow: hidden !important;
    }
    
    /* Meetings tab container - ensure full height */
    #meetingsTab > div:last-child {
      height: calc(100vh - 140px) !important;
      min-height: 0 !important;
    }
    
    /* When header is collapsed on mobile - MASSIVE space gain */
    #mainContent.header-collapsed #meetingsTab > div:last-child {
      height: calc(100vh - 20px) !important;
    }
    
    #mainContent.header-collapsed #meetingChatView {
      height: 100% !important;
      max-height: calc(100vh - 20px) !important;
    }
    
    #mainContent.header-collapsed #meetingChatContainer {
      height: 100% !important;
      max-height: calc(100vh - 20px) !important;
    }
    
    /* Add overlay backdrop when sidebar is open */
    #meetingsSidebar.show-mobile::after {
      content: '' !important;
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      background: rgba(0,0,0,0.5) !important;
      z-index: -1 !important;
    }
    
    /* Meeting Header - Ultra compact on mobile */
    #meetingHeader {
      padding: 6px 8px !important;
      min-height: auto !important;
      flex-shrink: 0 !important;
    }
    
    #meetingTitle {
      font-size: 0.85rem !important;
      margin-bottom: 4px !important;
      line-height: 1.2 !important;
    }
    
    #meetingParticipants {
      gap: 3px !important;
      margin-top: 2px !important;
    }
    
    /* Make participant avatars smaller on mobile */
    #meetingParticipants > div {
      width: 28px !important;
      height: 28px !important;
      font-size: 0.65rem !important;
    }
    
    #meetingParticipants img {
      width: 28px !important;
      height: 28px !important;
    }
    
    /* Hide participant names on mobile to save space */
    .meeting-participant-btn span {
      display: none !important;
    }
    
    .meeting-participant-btn {
      padding: 2px !important;
      border-radius: 50% !important;
      min-width: auto !important;
    }
    
    /* Meeting settings and delete buttons more compact */
    #meetingSettingsBtn,
    #deleteMeetingBtn {
      padding: 5px 7px !important;
      font-size: 0.95rem !important;
    }
    
    /* CRITICAL: Give messages container flex priority */
    #meetingMessages {
      flex: 1 1 auto !important;
      min-height: 0 !important;
      max-height: none !important;
      overflow-y: auto !important;
    }
    
    /* Meeting chat container proper flex layout */
    #meetingChatContainer {
      display: flex !important;
      flex-direction: column !important;
      height: 100% !important;
      min-height: 0 !important;
    }
    
    /* Meeting input area - more compact and fixed at bottom */
    #meetingChatContainer > div:last-child {
      padding: 8px !important;
      flex-shrink: 0 !important;
    }
    
    #meetingInput {
      font-size: 0.9rem !important;
      padding: 10px 12px !important;
    }
    
    #sendMeetingMessageBtn,
    #stopMeetingRepliesBtn {
      padding: 10px 15px !important;
      font-size: 0.9rem !important;
    }
    
    #meetingPlayerAttachBtn {
      width: 40px !important;
      height: 40px !important;
      font-size: 20px !important;
    }
    
    /* ===== DASHBOARD IMPROVEMENTS ===== */
    
    /* Dashboard stats grid - single column on mobile */
    #dashboardTab > div[style*="grid-template-columns"] {
      grid-template-columns: 1fr !important;
    }
    
    /* Dashboard cards - adjust sizing */
    .dashboard-card {
      padding: 15px !important;
    }
    
    /* Main content grid - stack vertically */
    #dashboardTab > div[style*="grid-template-columns: 1fr 1fr"] {
      grid-template-columns: 1fr !important;
    }
    
    /* ===== TOP BAR IMPROVEMENTS ===== */
    
    /* Top bar - more compact on mobile */
    #topBar {
      padding: 8px 10px !important;
      font-size: 0.85rem !important;
      flex-wrap: wrap !important;
    }
    
    #topBar > div {
      gap: 10px !important;
      flex-wrap: wrap !important;
    }
    
    #topBar > div > div {
      font-size: 0.8rem !important;
    }
    
    /* ===== TAB NAVIGATION ===== */
    
    /* Tab buttons - better touch targets */
    .tab-btn {
      padding: 12px 15px !important;
      font-size: 0.9rem !important;
      min-width: fit-content !important;
    }
    
    #tabNav {
      overflow-x: auto !important;
      -webkit-overflow-scrolling: touch !important;
      white-space: nowrap !important;
    }
    
    /* ===== PEOPLE TAB IMPROVEMENTS ===== */
    
    /* Employee grid - single or double column on mobile */
    #peopleTab [style*="grid-template-columns"] {
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)) !important;
    }
    
    /* ===== BUSINESS TAB IMPROVEMENTS ===== */
    
    /* Products grid - single column on small screens */
    #productsList {
      grid-template-columns: 1fr !important;
      gap: 12px !important;
    }
    
    /* Product cards */
    .product-card {
      padding: 12px !important;
    }
    
    /* ===== TOUCH TARGET IMPROVEMENTS ===== */
    
    /* All buttons - minimum touch size */
    button {
      min-height: 44px !important;
      min-width: 44px !important;
      touch-action: manipulation !important;
    }
    
    /* Small icon buttons can be slightly smaller but still touch-friendly */
    button[style*="font-size:1.5rem"],
    button[style*="font-size:1.2rem"] {
      min-height: 40px !important;
      min-width: 40px !important;
    }
    
    /* Input fields - better touch targets */
    input, textarea, select {
      min-height: 44px !important;
      font-size: 16px !important; /* Prevent iOS zoom on focus */
      padding: 10px !important;
    }
    
    /* ===== HIRE MANAGER MODAL FIX ===== */
    
    /* Make hire manager modal scrollable and properly sized */
    #hiringModal {
      padding: 10px !important;
      overflow-y: auto !important;
      -webkit-overflow-scrolling: touch !important;
    }
    
    #hiringModal .hiring-modal-panel {
      width: 95% !important;
      max-width: 95% !important;
      max-height: 85vh !important;
      overflow-y: auto !important;
      padding: 15px !important;
      -webkit-overflow-scrolling: touch !important;
    }
    
    /* Candidate cards container - stack vertically on mobile */
    #hiringModal .hiring-modal-panel > div[style*="display:flex"] {
      flex-direction: column !important;
      align-items: center !important;
    }
    
    /* Individual candidate cards */
    #hiringModal .candidate-card {
      width: 100% !important;
      max-width: 350px !important;
      margin: 8px 0 !important;
    }
    
    /* Stats grid in candidate cards */
    #hiringModal .candidate-card > div[style*="grid-template-columns"] {
      grid-template-columns: repeat(2, 1fr) !important;
      gap: 6px !important;
    }
    
    /* ===== LOCATION SUBTABS FIX ===== */
    
    /* Location buttons - ensure horizontal scrolling */
    #locationSubtabs {
      display: flex !important;
      gap: 8px !important;
      overflow-x: auto !important;
      overflow-y: hidden !important;
      white-space: nowrap !important;
      -webkit-overflow-scrolling: touch !important;
      padding-bottom: 8px !important;
      scrollbar-width: thin !important;
    }
    
    /* Location buttons - prevent shrinking */
    #locationSubtabs button {
      flex-shrink: 0 !important;
      min-width: fit-content !important;
      padding: 10px 16px !important;
      white-space: nowrap !important;
      display: inline-flex !important;
      align-items: center !important;
      gap: 6px !important;
    }
    
    /* Ensure icons and text don't wrap */
    #locationSubtabs button span,
    #locationSubtabs button {
      white-space: nowrap !important;
    }
    
    /* ===== CHAT IMPROVEMENTS ===== */
    
    /* Chat modal container */
    #chatModal > div {
      width: 95% !important;
      max-width: 500px !important;
      height: 85vh !important;
      max-height: 85vh !important;
    }
    
    /* Chat messages area */
    #chatMessages {
      padding: 10px !important;
      gap: 8px !important;
    }
    
    /* Chat input container - proper flex layout */
    #chatModal > div > div:nth-last-child(2) {
      padding: 10px !important;
      display: flex !important;
      gap: 6px !important;
      flex-wrap: nowrap !important;
      align-items: center !important;
    }
    
    /* Chat attach and emoji buttons - fixed width */
    #chatAttachBtn,
    #chatEmojiBtn {
      flex-shrink: 0 !important;
      width: 40px !important;
      padding: 8px !important;
    }
    
    /* Chat input field - takes remaining space */
    #chatInput {
      flex: 1 1 auto !important;
      min-width: 0 !important;
      max-width: 100% !important;
      width: auto !important;
      margin: 0 !important;
    }
    
    /* Chat send button - fixed width */
    #chatSendBtn {
      flex-shrink: 0 !important;
      padding: 8px 12px !important;
      white-space: nowrap !important;
    }
    
    /* ===== MAIN CONTENT PADDING ===== */
    
    #mainContent {
      padding: 12px !important;
    }
    
    /* ===== CARDS AND CONTAINERS ===== */
    
    .card {
      padding: 12px !important;
      margin-bottom: 12px !important;
    }
    
    /* ===== TEXT SIZING ===== */
    
    h1 {
      font-size: 1.5rem !important;
    }
    
    h2 {
      font-size: 1.3rem !important;
    }
    
    h3 {
      font-size: 1.1rem !important;
    }
    
    /* ===== MODAL CLOSE BUTTONS ===== */
    
    /* Make close buttons larger and easier to tap */
    .modal button[style*="position:absolute"][style*="top:"] {
      width: 44px !important;
      height: 44px !important;
      font-size: 1.5rem !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
    }
    
    /* ===== IMAGE GALLERIES IN MODALS ===== */
    
    /* Request/send image modals - better layout */
    #requestImageModal > div,
    #sendImageModal > div,
    #requestPostModal > div {
      max-height: 85vh !important;
      overflow-y: auto !important;
    }
    
    /* Image preset buttons - grid layout */
    .request-preset,
    .send-preset,
    .request-post-preset {
      min-height: 44px !important;
      padding: 10px !important;
      font-size: 0.9rem !important;
    }
    
    /* ===== PLAYER POST COMPOSER ===== */
    
    #playerPostModal textarea {
      min-height: 120px !important;
      font-size: 16px !important;
    }
    
    /* ===== GIFTS TAB ===== */
    
    #giftsTab [style*="grid-template-columns"] {
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)) !important;
    }
    
    /* ===== HR TAB ===== */
    
    #hrTab [style*="grid-template-columns"] {
      grid-template-columns: 1fr !important;
    }
    
    /* ===== INVEST TAB ===== */
    
    #investTab [style*="grid-template-columns"] {
      grid-template-columns: 1fr !important;
    }
    
    /* ===== LANDSCAPE ORIENTATION IMPROVEMENTS ===== */
    
    @media (orientation: landscape) and (max-height: 500px) {
      /* Modals take full screen in landscape on short screens */
      .modal > div {
        width: 98% !important;
        max-height: 98vh !important;
        margin: 1vh auto !important;
      }
      
      /* Hire manager modal in landscape */
      #hiringModal .hiring-modal-panel {
        max-height: 96vh !important;
      }
      
      /* Reduce padding to maximize space */
      .modal > div > * {
        padding: 8px !important;
      }
      
      /* Top bar even more compact */
      #topBar {
        padding: 5px 8px !important;
        font-size: 0.75rem !important;
      }
      
      /* Tab navigation */
      .tab-btn {
        padding: 8px 12px !important;
        font-size: 0.85rem !important;
      }
      
      /* Location buttons even more compact in landscape */
      #locationSubtabs button {
        padding: 8px 12px !important;
        font-size: 0.85rem !important;
      }
    }
  }
  
  /* ===== TABLET BREAKPOINT (768px - 1024px) ===== */
  @media screen and (min-width: 769px) and (max-width: 1024px) {
    
    /* Slightly adjust layouts for tablets */
    #socialTab > div {
      flex-direction: row !important;
    }
    
    #socialTab > div > div:first-child {
      flex: 0 0 250px !important;
    }
    
    #socialTab > div > div:nth-child(2) {
      flex: 1 !important;
    }
    
    /* Dashboard - 2 columns */
    #dashboardTab > div[style*="grid-template-columns"] {
      grid-template-columns: repeat(2, 1fr) !important;
    }
    
    /* Products - 2 columns */
    #productsList {
      grid-template-columns: repeat(2, 1fr) !important;
    }
  }
  
  /* ===== SMALL MOBILE (< 400px) ===== */
  @media screen and (max-width: 400px) {
    
    /* Meeting header - ultra minimal on small screens */
    #meetingHeader {
      padding: 4px 6px !important;
      border-bottom: 1px solid #16213e !important;
    }
    
    #meetingTitle {
      font-size: 0.8rem !important;
      margin-bottom: 3px !important;
      line-height: 1.1 !important;
    }
    
    #meetingParticipants {
      gap: 2px !important;
      margin-top: 0 !important;
    }
    
    /* Hide participant names, show only avatars on very small screens */
    .meeting-participant-btn span {
      display: none !important;
    }
    
    .meeting-participant-btn {
      padding: 2px !important;
      border-radius: 50% !important;
      min-width: auto !important;
      width: 26px !important;
      height: 26px !important;
    }
    
    .meeting-participant-btn img {
      width: 26px !important;
      height: 26px !important;
    }
    
    /* Even smaller buttons */
    #meetingSettingsBtn,
    #deleteMeetingBtn {
      padding: 4px 6px !important;
      font-size: 0.85rem !important;
    }
    
    /* Meeting input more compact */
    #meetingInput {
      font-size: 0.85rem !important;
      padding: 8px 10px !important;
    }
    
    #sendMeetingMessageBtn,
    #stopMeetingRepliesBtn {
      padding: 8px 12px !important;
      font-size: 0.85rem !important;
    }
    
    #meetingPlayerAttachBtn {
      width: 36px !important;
      height: 36px !important;
      font-size: 18px !important;
    }
    
    /* Even more compact */
    #topBar {
      font-size: 0.75rem !important;
      padding: 6px 8px !important;
    }
    
    .tab-btn {
      padding: 10px 12px !important;
      font-size: 0.85rem !important;
    }
    
    /* Location buttons on very small screens */
    #locationSubtabs button {
      padding: 8px 12px !important;
      font-size: 0.8rem !important;
    }
    
    #mainContent {
      padding: 8px !important;
    }
    
    /* Modal content */
    .modal > div {
      width: 98% !important;
      padding: 15px !important;
    }
    
    /* Hire manager modal on small screens */
    #hiringModal .hiring-modal-panel {
      width: 98% !important;
      padding: 12px !important;
    }
    
    #hiringModal .candidate-card {
      max-width: 100% !important;
      padding: 12px !important;
    }
    
    /* Chat input on very small screens - even more compact */
    #chatAttachBtn,
    #chatEmojiBtn {
      width: 36px !important;
      padding: 6px !important;
      font-size: 1rem !important;
    }
    
    #chatSendBtn {
      padding: 6px 10px !important;
      font-size: 0.9rem !important;
    }
    
    /* Smaller text in tight spaces */
    .dashboard-card {
      font-size: 0.9rem !important;
    }
  }
  
  /* ===== ACCESSIBILITY IMPROVEMENTS ===== */
  
  /* Better focus indicators for keyboard/screen reader users */
  @media (hover: none) and (pointer: coarse) {
    /* Touch devices */
    button:active {
      transform: scale(0.98);
      opacity: 0.9;
    }
  }
  
  /* ========== CHAT MESSAGE EDITING STYLES ========== */
  
  /* Edit and resend buttons */
  .edit-btn, .resend-btn {
    opacity: 0;
    transition: opacity 0.2s ease;
  }
  
  .chat-message:hover .edit-btn,
  .chat-message:hover .resend-btn {
    opacity: 1;
  }
  
  /* Make buttons always visible on touch devices */
  @media (hover: none) and (pointer: coarse) {
    .edit-btn, .resend-btn {
      opacity: 0.7;
    }
    
    .chat-message:active .edit-btn,
    .chat-message:active .resend-btn {
      opacity: 1;
    }
  }
  
  /* Edit mode indicator for send button */
  #chatSendBtn {
    transition: all 0.3s ease;
  }
  
  #chatSendBtn.editing-mode {
    background-color: #ff9800 !important;
    animation: pulse-edit 2s infinite;
  }
  
  @keyframes pulse-edit {
    0%, 100% {
      box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.7);
    }
    50% {
      box-shadow: 0 0 0 10px rgba(255, 152, 0, 0);
    }
  }
  
  /* Regeneration count badge */
  .regenerate-count {
    display: inline-block;
    background: rgba(255, 152, 0, 0.2);
    color: #ff9800;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 10px;
    margin-left: 4px;
    font-weight: bold;
  }
  
  /* High contrast mode support */
  @media (prefers-contrast: high) {
    button {
      border: 2px solid currentColor !important;
    }
  }
  
  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
    
    #chatSendBtn.editing-mode {
      animation: none !important;
    }
  }
  
  /* ========== MEETING PLAYER ATTACHMENT STYLES ========== */
  .meeting-player-attach-item {
    transition: all 0.2s ease;
  }
  
  .meeting-player-attach-item:hover {
    background: rgba(78, 204, 163, 0.15) !important;
    transform: translateX(5px);
  }
  
  .meeting-player-attach-item:active {
    background: rgba(78, 204, 163, 0.25) !important;
    transform: scale(0.98);
  }
  
  #meetingPlayerAttachBtn:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
  }
  
  #meetingPlayerAttachBtn:active {
    transform: scale(0.95);
  }
  
  /* ========== COLLAPSIBLE HEADER STYLES ========== */
  #topBar.collapsed {
    transform: translateY(-100%);
    opacity: 0;
    pointer-events: none;
  }
  
  #newsTicker.collapsed {
    transform: translateY(-100%);
    opacity: 0;
    pointer-events: none;
  }
  
  #tabNav.collapsed {
    transform: translateY(-100%);
    opacity: 0;
    pointer-events: none;
  }
  
  #toggleHeaderBtn.header-collapsed {
    top: 0;
  }
  
  #toggleHeaderBtn:hover {
    background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
    transform: translateX(-50%) scale(1.05);
  }
  
  #toggleHeaderBtn:active {
    transform: translateX(-50%) scale(0.95);
  }
  
  /* Main content expansion when header collapsed */
  #mainContent.header-collapsed {
    min-height: calc(100vh - 20px) !important;
  }
  
  /* Meetings tab gets extra space when header collapsed */
  #mainContent.header-collapsed #meetingsTab > div:last-child {
    height: calc(100vh - 40px) !important;
  }
  
  /* Meeting chat view expands fully when header collapsed */
  #mainContent.header-collapsed #meetingChatView {
    height: 100% !important;
  }
  
  /* Meeting chat container expands when header collapsed */
  #mainContent.header-collapsed #meetingChatContainer {
    height: 100% !important;
    max-height: calc(100vh - 60px) !important;
  }
  
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  /* SAVE MANAGER STYLES */
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  
  .save-manager-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(8px);
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: fadeIn 0.2s ease;
  }
  
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  .save-manager-container {
    width: 100%;
    max-width: 1200px;
    max-height: 90vh;
    background: rgba(15, 20, 25, 0.98);
    border: 1px solid #1c2738;
    border-radius: 16px;
    display: flex;
    flex-direction: column;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    animation: slideUp 0.3s ease;
  }
  
  @keyframes slideUp {
    from { transform: translateY(50px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
  }
  
  .save-manager-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 24px 28px;
    border-bottom: 1px solid #1c2738;
    background: linear-gradient(180deg, #16213e 0%, #0e1522 100%);
    border-radius: 16px 16px 0 0;
  }
  
  .save-manager-title {
    display: flex;
    align-items: center;
    gap: 16px;
  }
  
  .save-manager-logo {
    font-size: 2rem;
  }
  
  .save-manager-title h2 {
    margin: 0;
    font-size: 1.8rem;
    color: #00d4ff;
  }
  
  .save-manager-subtitle {
    color: #8899a6;
    font-size: 0.9rem;
    margin-top: 4px;
  }
  
  .save-manager-close {
    background: transparent;
    border: none;
    color: #8899a6;
    font-size: 2rem;
    cursor: pointer;
    transition: all 0.2s;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
  }
  
  .save-manager-close:hover {
    background: rgba(255, 255, 255, 0.1);
    color: #e8f0f7;
  }
  
  .save-manager-actions {
    padding: 16px 28px;
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    border-bottom: 1px solid #1c2738;
    background: #0e1522;
  }
  
  .sm-btn {
    padding: 10px 16px;
    border: 1px solid #1c2738;
    background: linear-gradient(180deg, #142035, #0e1623);
    color: #e8f0f7;
    border-radius: 10px;
    cursor: pointer;
    font-size: 0.95rem;
    font-weight: 600;
    transition: all 0.15s ease;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  
  .sm-btn:hover {
    background: linear-gradient(180deg, #1a2d4a, #142035);
    border-color: #00d4ff;
    transform: translateY(-1px);
  }
  
  .sm-btn.accent {
    background: linear-gradient(180deg, #0bbbd1, #0aa1b5);
    color: #001318;
    font-weight: 700;
  }
  
  .sm-btn.accent:hover {
    background: linear-gradient(180deg, #0dd1e9, #0bbbd1);
  }
  
  .sm-btn.success {
    background: linear-gradient(180deg, #20d2a0, #10b37f);
    color: #05231b;
    font-weight: 700;
  }
  
  .sm-btn.success:hover {
    background: linear-gradient(180deg, #30e2b0, #20d2a0);
  }
  
  .sm-btn.primary {
    background: linear-gradient(180deg, #667eea, #5865d6);
    color: white;
    font-weight: 700;
  }
  
  .sm-btn.primary:hover {
    background: linear-gradient(180deg, #7889f4, #667eea);
  }
  
  .save-manager-toolbar {
    padding: 16px 28px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 16px;
    border-bottom: 1px solid #1c2738;
    background: #0e1522;
  }
  
  .save-tab-group {
    display: flex;
    gap: 8px;
  }
  
  .save-tab {
    padding: 10px 20px;
    background: #101a2a;
    border: 1px solid #1c2738;
    border-radius: 8px;
    color: #8899a6;
    cursor: pointer;
    transition: all 0.2s;
    font-size: 0.95rem;
    font-weight: 600;
  }
  
  .save-tab:hover {
    background: #142035;
    border-color: #00d4ff;
  }
  
  .save-tab.active {
    background: linear-gradient(135deg, #00d4ff, #0bbbd1);
    border-color: #00d4ff;
    color: #001318;
  }
  
  .save-search-box {
    display: flex;
    align-items: center;
    gap: 10px;
    background: #101a2a;
    border: 1px solid #1c2738;
    border-radius: 8px;
    padding: 8px 14px;
    flex: 1;
    max-width: 400px;
  }
  
  .save-search-icon {
    font-size: 1.2rem;
  }
  
  .save-search-box input {
    flex: 1;
    background: transparent;
    border: none;
    color: #e8f0f7;
    font-size: 0.95rem;
    outline: none;
  }
  
  .save-search-box input::placeholder {
    color: #8899a6;
  }
  
  .save-list-container {
    flex: 1;
    overflow-y: auto;
    padding: 0 28px 20px 28px;
    background: #0f1522;
  }
  
  .save-list-container::-webkit-scrollbar {
    width: 12px;
  }
  
  .save-list-container::-webkit-scrollbar-track {
    background: #0e1522;
  }
  
  .save-list-container::-webkit-scrollbar-thumb {
    background: #1c2738;
    border-radius: 6px;
  }
  
  .save-list-container::-webkit-scrollbar-thumb:hover {
    background: #2d3e5a;
  }
  
  .save-table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    margin-top: 20px;
  }
  
  .save-table thead {
    position: sticky;
    top: 0;
    z-index: 10;
    background: #0e1522;
  }
  
  .save-table th {
    padding: 14px 16px;
    text-align: left;
    color: #8899a6;
    font-size: 0.85rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    border-bottom: 2px solid #1c2738;
    background: #0e1522;
  }
  
  .save-table th.sortable {
    cursor: pointer;
    user-select: none;
    transition: color 0.2s;
  }
  
  .save-table th.sortable:hover {
    color: #00d4ff;
  }
  
  .sort-arrow {
    margin-left: 4px;
    opacity: 0.5;
  }
  
  .save-table tbody tr {
    border-bottom: 1px solid #1c2738;
    transition: background 0.2s;
  }
  
  .save-table tbody tr:hover {
    background: rgba(61, 214, 237, 0.05);
  }
  
  .save-table tbody tr.selected {
    outline: 2px solid #3dd6ed;
    background: rgba(61, 214, 237, 0.08);
  }
  
  .save-table td {
    padding: 16px;
    color: #e8f0f7;
    font-size: 0.95rem;
  }
  
  .save-table td.meta {
    color: #8899a6;
    font-size: 0.9rem;
  }
  
  .save-name-cell {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .save-name-input {
    background: transparent;
    border: 1px solid transparent;
    color: #e8f0f7;
    font-size: 0.95rem;
    padding: 4px 8px;
    border-radius: 4px;
    transition: all 0.2s;
    flex: 1;
    max-width: 250px;
  }
  
  .save-name-input:hover {
    background: rgba(255, 255, 255, 0.05);
    border-color: #1c2738;
  }
  
  .save-name-input:focus {
    outline: none;
    background: #101a2a;
    border-color: #00d4ff;
  }
  
  .save-tag {
    display: inline-block;
    padding: 3px 8px;
    border-radius: 999px;
    font-size: 11px;
    font-weight: 700;
    border: 1px solid #1c2738;
    background: #101a2a;
    color: #bcd2e6;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .save-tag.auto {
    background: #0e1c2e;
    border-color: #1f2b46;
    color: #b9c9ff;
  }
  
  .save-tag.quick {
    background: #0e2e1c;
    border-color: #1f462b;
    color: #b9ffc9;
  }
  
  .save-row-actions {
    display: flex;
    gap: 8px;
  }
  
  .save-action-btn {
    padding: 6px 12px;
    border: 1px solid #1c2738;
    background: #142035;
    color: #e8f0f7;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 600;
    transition: all 0.15s;
  }
  
  .save-action-btn:hover {
    background: #1a2d4a;
    border-color: #00d4ff;
  }
  
  .save-action-btn.load {
    background: linear-gradient(135deg, #667eea, #5865d6);
    border-color: #667eea;
    color: white;
  }
  
  .save-action-btn.load:hover {
    background: linear-gradient(135deg, #7889f4, #667eea);
  }
  
  .save-action-btn.export {
    background: #0e1c2e;
    border-color: #1f2b46;
    color: #b9c9ff;
  }
  
  .save-action-btn.export:hover {
    background: #142a46;
    border-color: #3d5a9e;
  }
  
  .save-action-btn.delete {
    background: #2e0e1c;
    border-color: #461f2b;
    color: #ffb9c9;
  }
  
  .save-action-btn.delete:hover {
    background: #46142a;
    border-color: #9e3d5a;
  }
  
  .create-row {
    background: rgba(0, 212, 255, 0.03);
  }
  
  .create-save-link {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px;
    cursor: pointer;
    color: #00d4ff;
    font-weight: 600;
    transition: all 0.2s;
  }
  
  .create-save-link:hover {
    color: #3dd6ed;
    background: rgba(0, 212, 255, 0.08);
  }
  
  .create-save-link span:first-child {
    font-size: 1.5rem;
  }
  
  .save-manager-footer {
    padding: 16px 28px;
    border-top: 1px solid #1c2738;
    background: #0e1522;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-radius: 0 0 16px 16px;
  }
  
  .save-footer-hint {
    display: flex;
    gap: 16px;
    align-items: center;
    color: #8899a6;
    font-size: 0.85rem;
  }
  
  .save-footer-hint span:first-child {
    color: #00d4ff;
    font-weight: 700;
  }
  
  .kbd {
    display: inline-block;
    padding: 2px 8px;
    background: #16213e;
    border: 1px solid #1c2738;
    border-radius: 4px;
    font-family: 'Courier New', monospace;
    font-size: 0.85rem;
    font-weight: 700;
    color: #00d4ff;
  }
  
  .save-count {
    color: #8899a6;
    font-size: 0.9rem;
  }
  
  .empty-state {
    text-align: center;
    padding: 60px 20px;
    color: #8899a6;
  }
  
  .empty-state-icon {
    font-size: 4rem;
    margin-bottom: 20px;
    opacity: 0.3;
  }
  
  .empty-state h3 {
    color: #e8f0f7;
    margin-bottom: 10px;
  }
  
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  /* MOBILE RESPONSIVE - SAVE MANAGER */
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  
  /* Card-based mobile layout for save rows */
  .save-card-container {
    display: none; /* Hidden by default, shown on mobile */
  }
  
  .save-card {
    background: rgba(22, 33, 62, 0.6);
    border: 2px solid #1c2738;
    border-radius: 8px;
    padding: 10px;
    margin-bottom: 8px;
  }
  
  .save-card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 8px;
  }
  
  .save-card-title {
    flex: 1;
  }
  
  .save-card-name {
    font-size: 0.95rem;
    font-weight: 700;
    color: #00d4ff;
    margin-bottom: 4px;
  }
  
  .save-card-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    font-size: 0.75rem;
    color: #8899a6;
    margin-top: 6px;
  }
  
  .save-card-meta-item {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  
  .save-card-actions {
    display: flex;
    gap: 6px;
    margin-top: 8px;
    flex-wrap: wrap;
  }
  
  .save-card-actions .save-action-btn {
    flex: 1;
    min-width: calc(50% - 3px);
  }
  
  /* Tablet & Small Desktop (Portrait) */
  @media (max-width: 1024px) {
    .save-manager-container {
      max-width: 95%;
      max-height: 95vh;
    }
    
    .save-list-container {
      padding: 0 16px 16px 16px;
    }
    
    .save-manager-header,
    .save-manager-actions,
    .save-manager-toolbar,
    .save-manager-footer {
      padding-left: 16px;
      padding-right: 16px;
    }
  }
  
  /* Mobile Landscape & Small Tablets */
  @media (max-width: 768px) {
    .save-manager-container {
      max-width: 98%;
      max-height: 98vh;
      border-radius: 12px;
    }
    
    .save-manager-header {
      padding: 14px;
      border-radius: 12px 12px 0 0;
    }
    
    .save-manager-title h2 {
      font-size: 1.4rem;
    }
    
    .save-manager-subtitle {
      font-size: 0.75rem;
    }
    
    .save-manager-logo {
      font-size: 1.5rem;
    }
    
    .save-manager-actions {
      padding: 10px 14px;
      gap: 6px;
      display: grid;
      grid-template-columns: 1fr 1fr;
    }
    
    .sm-btn {
      padding: 10px 12px;
      font-size: 0.85rem;
      white-space: nowrap;
    }
    
    .save-manager-toolbar {
      padding: 10px 14px;
      flex-wrap: wrap;
    }
    
    .save-tab {
      padding: 8px 12px;
      font-size: 0.85rem;
    }
    
    .save-search-box {
      max-width: 100%;
      flex: 1;
    }
    
    .save-list-container {
      padding: 0 10px 10px 10px;
    }
    
    .save-table th {
      padding: 10px 6px;
      font-size: 0.75rem;
    }
    
    .save-table td {
      padding: 10px 6px;
      font-size: 0.85rem;
    }
    
    .save-manager-footer {
      padding: 10px 14px;
      flex-wrap: wrap;
      gap: 8px;
    }
    
    .save-footer-hint {
      font-size: 0.75rem;
      gap: 8px;
      flex-wrap: wrap;
    }
  }
  
  /* Mobile Portrait - Switch to Card Layout */
  @media (max-width: 640px) {
    .save-manager-container {
      max-width: 100%;
      max-height: 95vh;
      height: 95vh;
      border-radius: 0;
      display: flex;
      flex-direction: column;
    }
    
    .save-manager-header {
      padding: 8px 12px;
      border-radius: 0;
      flex-shrink: 0;
    }
    
    .save-manager-title {
      gap: 8px;
    }
    
    .save-manager-title h2 {
      font-size: 1.1rem;
      margin: 0;
    }
    
    .save-manager-subtitle {
      display: none;
    }
    
    .save-manager-logo {
      font-size: 1.2rem;
    }
    
    .save-manager-close {
      width: 32px;
      height: 32px;
      font-size: 1.3rem;
    }
    
    /* Action buttons - 2 per row with better spacing */
    .save-manager-actions {
      padding: 6px 12px;
      gap: 6px;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      flex-shrink: 0;
    }
    
    .sm-btn {
      padding: 8px 6px;
      font-size: 0.75rem;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    /* Toolbar adjustments */
    .save-manager-toolbar {
      padding: 6px 12px;
      gap: 8px;
      flex-shrink: 0;
    }
    
    .save-tab-group {
      width: 100%;
      gap: 4px;
    }
    
    .save-tab {
      flex: 1;
      padding: 8px 6px;
      font-size: 0.75rem;
      text-align: center;
      white-space: nowrap;
    }
    
    .save-search-box {
      width: 100%;
      max-width: 100%;
      padding: 6px 10px;
    }
    
    .save-search-box input {
      font-size: 0.85rem;
    }
    
    .save-list-container {
      padding: 8px;
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      min-height: 0;
    }
    
    /* HIDE TABLE, SHOW CARDS */
    .save-table {
      display: none !important;
    }
    
    .save-card-container {
      display: block !important;
    }
    
    .save-card {
      overflow-x: auto;
      overflow-y: visible;
      -webkit-overflow-scrolling: touch;
    }
    
    .save-card.create-row {
      background: rgba(0, 212, 255, 0.08);
      border-color: #00d4ff;
    }
    
    .save-card-meta {
      display: flex;
      gap: 10px;
      overflow-x: auto;
      overflow-y: visible;
      white-space: nowrap;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 4px;
    }
    
    .save-card-meta-item {
      flex-shrink: 0;
    }
    
    /* Footer adjustments */
    .save-manager-footer {
      padding: 6px 12px;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }
    
    .save-footer-hint {
      display: none;
    }
    
    .save-count {
      font-size: 0.75rem;
      width: 100%;
      text-align: center;
    }
    
    .empty-state {
      padding: 30px 15px;
    }
    
    .empty-state-icon {
      font-size: 2.5rem;
    }
    
    .empty-state h3 {
      font-size: 1rem;
      margin: 8px 0 4px 0;
    }
    
    .empty-state p {
      font-size: 0.85rem;
      margin: 0;
    }
  }
  
  /* Extra Small Mobile (Portrait) - Ultra Compact */
  @media (max-width: 480px) {
    .save-manager-container {
      height: 95vh;
    }
    
    .save-manager-header {
      padding: 6px 10px;
    }
    
    .save-manager-title h2 {
      font-size: 1rem;
    }
    
    .save-manager-logo {
      font-size: 1.1rem;
    }
    
    .save-manager-close {
      width: 28px;
      height: 28px;
      font-size: 1.2rem;
    }
    
    .save-manager-actions {
      padding: 5px 8px;
      gap: 5px;
    }
    
    .sm-btn {
      padding: 7px 5px;
      font-size: 0.7rem;
    }
    
    .save-manager-toolbar {
      padding: 5px 8px;
    }
    
    .save-tab {
      padding: 7px 5px;
      font-size: 0.7rem;
    }
    
    .save-search-box {
      padding: 5px 8px;
    }
    
    .save-search-box input {
      font-size: 0.8rem;
    }
    
    .save-list-container {
      padding: 6px;
    }
    
    .save-card {
      padding: 8px;
      margin-bottom: 6px;
    }
    
    .save-card-name {
      font-size: 0.9rem;
    }
    
    .save-card-meta {
      font-size: 0.7rem;
      gap: 8px;
    }
    
    .save-card-actions .save-action-btn {
      padding: 7px 8px;
      font-size: 0.7rem;
    }
    
    .save-manager-footer {
      padding: 5px 8px;
    }
    
    .save-count {
      font-size: 0.7rem;
    }
  }
  
  /* Mobile Landscape - Optimize for wider, shorter screens */
  @media (max-width: 960px) and (orientation: landscape) {
    .save-manager-container {
      max-height: 98vh;
    }
    
    .save-manager-header {
      padding: 8px 16px;
    }
    
    .save-manager-title h2 {
      font-size: 1.2rem;
    }
    
    .save-manager-subtitle {
      font-size: 0.7rem;
    }
    
    .save-manager-actions {
      padding: 6px 16px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
    }
    
    .sm-btn {
      padding: 8px 10px;
      font-size: 0.8rem;
    }
    
    .save-manager-toolbar {
      padding: 6px 16px;
    }
    
    .save-tab {
      padding: 8px 10px;
      font-size: 0.8rem;
    }
    
    .save-manager-footer {
      padding: 6px 16px;
    }
    
    .save-footer-hint {
      font-size: 0.7rem;
      gap: 8px;
    }
    
    .kbd {
      padding: 1px 6px;
      font-size: 0.75rem;
    }
  }
  
  /* Touch-friendly adjustments - Better touch targets */
  @media (hover: none) and (pointer: coarse) {
    .sm-btn,
    .save-tab,
    .save-action-btn {
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 12px 10px;
    }
    
    .save-manager-close {
      min-width: 44px;
      min-height: 44px;
    }
  }
  
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  /* END MOBILE RESPONSIVE - SAVE MANAGER */
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  /* END SAVE MANAGER STYLES */
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
</style>
