<!-- Top Bar -->
<div id="topBar" style="position:sticky; top:0; z-index:1000; display:flex; justify-content:space-between; align-items:center; padding:10px 20px; background:#1a1a2e; color:white; box-shadow:0 2px 10px rgba(0,0,0,0.5);">
  <div style="display:flex; gap:20px;">
    <div>Cash: $<span id="cashEl">0</span></div>
    <div>$/sec: $<span id="cashPerSecEl">0</span></div>
    <div>Employees: <span id="employeeCountEl">0</span></div>
    <div>Products: <span id="productCountEl">0</span></div>
  </div>
  <button id="settingsBtn" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">⚙️</button>
</div>

<!-- News Ticker -->
<div id="newsTicker" style="position:sticky; top:49px; z-index:999; background:#0f3460; color:#e94560; padding:8px 20px; white-space:nowrap; overflow:hidden; font-size:0.9rem;">
  <span id="newsContent">Welcome to your new business venture! Start clicking products to earn cash.</span>
</div>

<!-- Tab Navigation -->
<div id="tabNav" style="position:sticky; top:82px; z-index:998; display:flex; background:#16213e; padding:0; overflow-x:auto;">
  <button class="tab-btn active" data-tab="dashboard" style="padding:15px 20px; background:transparent; border:none; color:#e94560; cursor:pointer; font-weight:bold;">Dashboard</button>
  <button class="tab-btn" data-tab="business" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">Business</button>
  <button class="tab-btn" data-tab="upgrades" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">⚡ Upgrades</button>
  <button class="tab-btn" data-tab="people" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">People</button>
  <button class="tab-btn" data-tab="social" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">Social</button>
  <button class="tab-btn" data-tab="gifts" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">Gifts</button>
  <button class="tab-btn" data-tab="hr" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">HR</button>
  <button class="tab-btn" data-tab="invest" style="padding:15px 20px; background:transparent; border:none; color:white; cursor:pointer;">Invest</button>
</div>

<!-- Main Content Area -->
<div id="mainContent" style="padding:20px; background:#0f1419; min-height:calc(100vh - 140px); color:white;">
  
  <!-- Dashboard Tab -->
  <div id="dashboardTab" class="tab-content active">
    <h2 style="margin-top:0;">📊 Command Center</h2>
    
    <!-- Top Stats Row - Key Metrics -->
    <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:15px; margin-bottom:25px;">
      <!-- Cash -->
      <div class="card dashboard-card" onclick="switchTab('business')" style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius:12px; padding:20px; box-shadow:0 4px 20px rgba(102,126,234,0.3); cursor:pointer; transition:transform 0.2s;">
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
          <div>
            <div style="color:rgba(255,255,255,0.8); font-size:0.85rem; margin-bottom:5px;">CURRENT CASH</div>
            <div style="font-size:1.8rem; font-weight:700; margin-bottom:5px;">$<span id="dashCash">0</span></div>
            <div style="color:rgba(255,255,255,0.7); font-size:0.8rem;">💰 <span id="dashCashPerSec">0</span>/sec</div>
          </div>
          <div style="font-size:2.5rem; opacity:0.3;">💵</div>
        </div>
      </div>
      
      <!-- Lifetime Earnings -->
      <div class="card dashboard-card" onclick="switchTab('invest')" style="background:linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius:12px; padding:20px; box-shadow:0 4px 20px rgba(245,87,108,0.3); cursor:pointer; transition:transform 0.2s;">
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
          <div>
            <div style="color:rgba(255,255,255,0.8); font-size:0.85rem; margin-bottom:5px;">LIFETIME EARNINGS</div>
            <div style="font-size:1.8rem; font-weight:700; margin-bottom:5px;">$<span id="dashLifetimeEarnings">0</span></div>
            <div style="color:rgba(255,255,255,0.7); font-size:0.8rem;">✨ Level <span id="dashPrestigeLevel">0</span> Prestige</div>
          </div>
          <div style="font-size:2.5rem; opacity:0.3;">🌟</div>
        </div>
      </div>
      
      <!-- Employees -->
      <div class="card dashboard-card" onclick="switchTab('people')" style="background:linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); border-radius:12px; padding:20px; box-shadow:0 4px 20px rgba(79,172,254,0.3); cursor:pointer; transition:transform 0.2s;">
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
          <div>
            <div style="color:rgba(255,255,255,0.8); font-size:0.85rem; margin-bottom:5px;">EMPLOYEES</div>
            <div style="font-size:1.8rem; font-weight:700; margin-bottom:5px;"><span id="dashEmployeeCount">0</span></div>
            <div style="color:rgba(255,255,255,0.7); font-size:0.8rem;">💼 <span id="dashManagerCount">0</span> Managers</div>
          </div>
          <div style="font-size:2.5rem; opacity:0.3;">👥</div>
        </div>
      </div>
      
      <!-- Products -->
      <div class="card dashboard-card" onclick="switchTab('business')" style="background:linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); border-radius:12px; padding:20px; box-shadow:0 4px 20px rgba(67,233,123,0.3); cursor:pointer; transition:transform 0.2s;">
        <div style="display:flex; justify-content:space-between; align-items:flex-start;">
          <div>
            <div style="color:rgba(255,255,255,0.8); font-size:0.85rem; margin-bottom:5px;">PRODUCTS</div>
            <div style="font-size:1.8rem; font-weight:700; margin-bottom:5px;"><span id="dashProductCount">0</span></div>
            <div style="color:rgba(255,255,255,0.7); font-size:0.8rem;">📦 <span id="dashRunningProducts">0</span> Running</div>
          </div>
          <div style="font-size:2.5rem; opacity:0.3;">🏭</div>
        </div>
      </div>
    </div>
    
    <!-- Main Content Grid -->
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:20px;">
      
      <!-- Left Column -->
      <div style="display:flex; flex-direction:column; gap:20px;">
        
        <!-- Unread Messages -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#00d4ff;">💬 Recent Messages</h3>
            <button onclick="switchTab('people')" style="background:#0f3460; border:none; padding:6px 12px; border-radius:6px; color:#00d4ff; cursor:pointer; font-size:0.85rem;">View All →</button>
          </div>
          <div id="dashRecentMessages" style="max-height:250px; overflow-y:auto;">
            <!-- Messages will be populated here -->
          </div>
        </div>
        
        <!-- Boss Fights Progress -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#e94560;">⚔️ Boss Fights</h3>
            <button onclick="switchTab('business')" style="background:#0f3460; border:none; padding:6px 12px; border-radius:6px; color:#e94560; cursor:pointer; font-size:0.85rem;">View Map →</button>
          </div>
          <div id="dashBossProgress">
            <!-- Boss progress will be populated here -->
          </div>
        </div>
        
        <!-- Quick Stats -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 15px 0; color:#ffd700;">📈 Quick Stats</h3>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
            <div style="background:#0f3460; padding:12px; border-radius:8px;">
              <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Locations</div>
              <div style="font-size:1.3rem; font-weight:600;"><span id="dashLocationCount">0</span>/<span id="dashTotalLocations">0</span></div>
            </div>
            <div style="background:#0f3460; padding:12px; border-radius:8px;">
              <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Avg Efficiency</div>
              <div style="font-size:1.3rem; font-weight:600;"><span id="dashEfficiency">100</span>%</div>
            </div>
            <div style="background:#0f3460; padding:12px; border-radius:8px;">
              <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Influence Points</div>
              <div style="font-size:1.3rem; font-weight:600; color:#ffd700;"><span id="dashInfluencePoints">0</span> IP</div>
            </div>
            <div style="background:#0f3460; padding:12px; border-radius:8px;">
              <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Income Bonus</div>
              <div style="font-size:1.3rem; font-weight:600; color:#4ecca3;"><span id="dashIncomeMultiplier">1.0</span>x</div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Right Column -->
      <div style="display:flex; flex-direction:column; gap:20px;">
        
        <!-- Social Feed Mentions -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#ff6b9d;">📱 @TheBoss Mentions</h3>
            <button onclick="switchTab('social')" style="background:#0f3460; border:none; padding:6px 12px; border-radius:6px; color:#ff6b9d; cursor:pointer; font-size:0.85rem;">View Feed →</button>
          </div>
          <div id="dashSocialMentions" style="max-height:300px; overflow-y:auto;">
            <!-- Mentions will be populated here -->
          </div>
        </div>
        
        <!-- Top Performers -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#4ecca3;">🏆 Top Performers</h3>
          </div>
          <div id="dashTopPerformers">
            <!-- Top performers will be populated here -->
          </div>
        </div>
        
        <!-- Company News -->
        <div style="background:#16213e; border-radius:12px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 15px 0; color:#00d4ff;">📰 Company News</h3>
          <div id="newsFeed" style="max-height:250px; overflow-y:auto;">
            <!-- News items will be populated here -->
          </div>
        </div>
      </div>
      
    </div>
  </div>
  
  <!-- Business Tab -->
  <div id="businessTab" class="tab-content" hidden>
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h2 style="margin:0;">Business Operations</h2>
      
      <!-- Upgrade Multiplier Toggle -->
      <div style="display:flex; align-items:center; gap:10px;">
        <span style="color:#aaa; font-size:0.9rem;">Bulk Buy:</span>
        <button id="upgradeMultiplierBtn" style="padding:8px 16px; background:#0f3460; border:2px solid #e94560; border-radius:6px; color:#e94560; cursor:pointer; font-weight:bold; min-width:80px;">
          x1
        </button>
      </div>
    </div>
    
    <!-- Location Subtabs -->
    <div id="locationSubtabs" style="display:flex; gap:8px; margin-bottom:20px; overflow-x:auto; padding-bottom:5px; border-bottom:2px solid #0f3460;">
      <!-- Location subtabs will be populated here -->
    </div>
    
    <!-- Current Location Info -->
    <div id="locationInfo" style="margin-bottom:20px; padding:15px; background:rgba(15, 52, 96, 0.3); border-radius:8px; border-left:4px solid #e94560; display:none;">
      <!-- Location description will be populated here -->
    </div>
    
    <!-- Products Section -->
    <div style="margin-top:20px;">
      <div id="productsList" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(280px, 1fr)); gap:15px;">
        <!-- Product cards will be populated here -->
      </div>
    </div>
  </div>
  
  <!-- Upgrades Tab -->
  <div id="upgradesTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">⚡ Global Upgrades</h2>
    <p style="color:#aaa; margin-bottom:30px;">Permanent upgrades that boost your entire operation. <span style="color:#ff6b6b;">⚠️ These reset on prestige!</span></p>
    
    <!-- Click Power Section -->
    <div style="background:#16213e; border-radius:10px; padding:20px; margin-bottom:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
        <div>
          <h3 style="margin:0 0 5px 0;">👆 Click Power</h3>
          <p style="color:#aaa; margin:0; font-size:0.9rem;">Each upgrade reduces production time by -0.1 seconds per click</p>
        </div>
        <div style="text-align:right;">
          <div style="font-size:1.5rem; font-weight:bold; color:#4caf50;" id="clickPowerLevel">Level 0</div>
          <div style="color:#aaa; font-size:0.9rem;" id="clickPowerEffect">-1.0s per click</div>
        </div>
      </div>
      <button id="buyClickPowerBtn" style="width:100%; padding:15px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:bold; font-size:1.1rem;">
        Upgrade Click Power - <span id="clickPowerCost">$1,000</span>
      </button>
    </div>
    
    <!-- Income Boost Section -->
    <div style="background:#16213e; border-radius:10px; padding:20px; margin-bottom:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
      <h3 style="margin:0 0 15px 0;">💰 Income Boost</h3>
      <p style="color:#aaa; margin:0 0 15px 0; font-size:0.9rem;">Permanently increase income for all products in a location. Each level provides less benefit.</p>
      <div id="incomeBoostList" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(200px, 1fr)); gap:10px;">
        <!-- Income boost buttons will be populated here -->
      </div>
    </div>
    
    <!-- Cost Reduction Section -->
    <div style="background:#16213e; border-radius:10px; padding:20px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
      <h3 style="margin:0 0 15px 0;">💸 Cost Reduction</h3>
      <p style="color:#aaa; margin:0 0 15px 0; font-size:0.9rem;">Reduces ALL costs in a location: product unlocks, upgrades, manager hires & upgrades. Capped at 90%.</p>
      <div id="costReductionList" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(200px, 1fr)); gap:10px;">
        <!-- Cost reduction buttons will be populated here -->
      </div>
    </div>
  </div>
  
  <!-- People Tab -->
  <div id="peopleTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">Team Management</h2>
    
    <div style="margin-top:20px;">
      <h3>Employees</h3>
      <div id="employeesList" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(250px, 1fr)); gap:15px; margin-top:10px;">
        <!-- Employee cards will be populated here -->
      </div>
    </div>
  </div>
  
  <!-- Social Tab -->
  <div id="socialTab" class="tab-content" hidden>
    <div style="display:flex; gap:20px; height:calc(100vh - 200px);">
      
      <!-- Left Sidebar - Player Post Composer & Filters -->
      <div style="flex:0 0 280px; display:flex; flex-direction:column; gap:15px;">
        
        <!-- Player Post Composer -->
        <div style="background:#16213e; border-radius:10px; padding:15px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 12px 0; color:#00d4ff; font-size:1rem;">Create Post</h3>
          
          <button id="playerPostBtn" style="width:100%; padding:12px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600; font-size:1rem; display:flex; align-items:center; justify-content:center; gap:8px;">
            <span style="font-size:1.3rem;">✏️</span> New Post
          </button>
        </div>
        
        <!-- Feed Filters -->
        <div style="background:#16213e; border-radius:10px; padding:15px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 12px 0; color:#00d4ff; font-size:1rem;">Filter Feed</h3>
          
          <div style="display:flex; flex-direction:column; gap:8px;">
            <button class="feed-filter-btn active" data-filter="all" style="padding:10px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer; text-align:left; transition:all 0.2s;">
              📱 All Posts
            </button>
            <button class="feed-filter-btn" data-filter="work" style="padding:10px; background:#0f3460; border:none; border-radius:6px; color:#aaa; cursor:pointer; text-align:left; transition:all 0.2s;">
              💼 Work
            </button>
            <button class="feed-filter-btn" data-filter="personal" style="padding:10px; background:#0f3460; border:none; border-radius:6px; color:#aaa; cursor:pointer; text-align:left; transition:all 0.2s;">
              ❤️ Personal
            </button>
            <button class="feed-filter-btn" data-filter="spicy" style="padding:10px; background:#0f3460; border:none; border-radius:6px; color:#aaa; cursor:pointer; text-align:left; transition:all 0.2s;">
              🌶️ Spicy
            </button>
            <button class="feed-filter-btn" data-filter="explicit" style="padding:10px; background:#0f3460; border:none; border-radius:6px; color:#aaa; cursor:pointer; text-align:left; transition:all 0.2s;">
              🔞 Explicit
            </button>
          </div>
        </div>
        
        <!-- Sort Options -->
        <div style="background:#16213e; border-radius:10px; padding:15px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 12px 0; color:#00d4ff; font-size:1rem;">Sort By</h3>
          
          <select id="feedSortSelect" style="width:100%; padding:10px; background:#0f3460; border:1px solid #00d4ff; border-radius:6px; color:white; cursor:pointer;">
            <option value="recent">🕐 Most Recent</option>
            <option value="popular">❤️ Most Popular</option>
            <option value="comments">💬 Most Comments</option>
          </select>
        </div>
        
        <!-- Feed Stats -->
        <div style="background:#16213e; border-radius:10px; padding:15px; box-shadow:0 4px 15px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 12px 0; color:#00d4ff; font-size:1rem;">Stats</h3>
          
          <div style="display:flex; flex-direction:column; gap:8px; font-size:0.9rem;">
            <div style="display:flex; justify-content:space-between;">
              <span style="color:#aaa;">Total Posts:</span>
              <span id="totalPostsCount" style="color:#00d4ff; font-weight:600;">0</span>
            </div>
            <div style="display:flex; justify-content:space-between;">
              <span style="color:#aaa;">Active Users:</span>
              <span id="activeUsersCount" style="color:#4ecca3; font-weight:600;">0</span>
            </div>
            <div style="display:flex; justify-content:space-between;">
              <span style="color:#aaa;">Today's Posts:</span>
              <span id="todayPostsCount" style="color:#e94560; font-weight:600;">0</span>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Main Feed -->
      <div style="flex:1; display:flex; flex-direction:column; background:#16213e; border-radius:10px; box-shadow:0 4px 15px rgba(0,0,0,0.3); overflow:hidden;">
        
        <!-- Feed Header -->
        <div style="padding:15px 20px; border-bottom:1px solid #0f3460; display:flex; justify-content:space-between; align-items:center;">
          <h2 style="margin:0; color:#00d4ff; font-size:1.3rem;">🌐 The Social Feed</h2>
          <button id="refreshFeedBtn" style="padding:8px 16px; background:#0f3460; border:1px solid #00d4ff; border-radius:6px; color:#00d4ff; cursor:pointer; font-weight:600; display:flex; align-items:center; gap:6px; transition:all 0.2s;">
            <span style="font-size:1.1rem;">🔄</span> Refresh
          </button>
        </div>
        
        <!-- Feed Content -->
        <div id="socialFeedContent" style="flex:1; overflow-y:auto; padding:20px;">
          <!-- Posts will be rendered here -->
          <div id="feedEmptyState" style="text-align:center; padding:60px 20px; color:#aaa;">
            <div style="font-size:4rem; margin-bottom:20px; opacity:0.3;">📱</div>
            <h3 style="margin:0 0 10px 0; color:#666;">No Posts Yet</h3>
            <p style="margin:0; font-size:0.95rem;">Posts from your employees will appear here. Start hiring employees and they'll begin posting!</p>
            <button id="testGeneratePostBtn" style="margin-top:20px; padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">
              Generate Test Post
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Gifts Tab -->
  <div id="giftsTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">Gift Catalog</h2>
    <div id="giftsList" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(200px, 1fr)); gap:15px; margin-top:20px;">
      <!-- Gift items will be populated here -->
    </div>
  </div>
  
  <!-- HR Tab -->
  <div id="hrTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">HR Policies & Office Culture</h2>
    
    <div style="margin-top:20px;">
      <h3>Office Culture Settings</h3>
      <p style="color:#aaa; font-size:0.9rem; margin-bottom:15px;">
        These settings control how employees interact with you and respond to conversations. 
        Adjust these to create the office atmosphere you prefer.
      </p>
      
      <div style="background:#16213e; border-radius:10px; padding:20px; margin-top:10px;">
        <!-- Office Atmosphere -->
        <div style="margin-bottom:25px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <label style="font-weight:600; color:#00d4ff;">Office Atmosphere</label>
            <span id="atmosphereValue" style="color:#e94560; font-weight:600;">Balanced</span>
          </div>
          <input type="range" id="atmosphereSlider" min="0" max="100" value="50" style="width:100%; margin-bottom:10px;">
          <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:#aaa; margin-bottom:10px;">
            <span>← Professional</span>
            <span>Relaxed →</span>
          </div>
          <div style="background:#0f3460; padding:12px; border-radius:6px; font-size:0.85rem; color:#ddd;">
            <strong>What this affects:</strong>
            <ul style="margin:8px 0 0 20px; padding:0;">
              <li><strong>0-33 (Professional):</strong> Formal workplace. NPCs keep professional distance, maintain boundaries, and focus on work topics.</li>
              <li><strong>34-66 (Balanced):</strong> Friendly workplace. NPCs are approachable and personable while maintaining appropriate boundaries.</li>
              <li><strong>67-100 (Relaxed):</strong> Casual workplace. NPCs are very comfortable, open about personal topics, and boundaries are more flexible.</li>
            </ul>
          </div>
        </div>
        
        <!-- Interaction Style -->
        <div style="margin-bottom:25px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <label style="font-weight:600; color:#00d4ff;">Interaction Style</label>
            <span id="guidelinesValue" style="color:#e94560; font-weight:600;">Standard</span>
          </div>
          <input type="range" id="guidelinesSlider" min="0" max="100" value="50" style="width:100%; margin-bottom:10px;">
          <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:#aaa; margin-bottom:10px;">
            <span>← Reserved</span>
            <span>Outgoing →</span>
          </div>
          <div style="background:#0f3460; padding:12px; border-radius:6px; font-size:0.85rem; color:#ddd;">
            <strong>What this affects:</strong>
            <ul style="margin:8px 0 0 20px; padding:0;">
              <li><strong>0-33 (Reserved):</strong> NPCs are more distant and may seem cold, tsundere-like, or defensive. Harder to build relationships.</li>
              <li><strong>34-66 (Standard):</strong> NPCs have balanced personalities - some warm, some cool, all realistic and varied.</li>
              <li><strong>67-100 (Outgoing):</strong> NPCs are friendly, expressive, and eager to connect. Relationships develop more easily.</li>
            </ul>
          </div>
        </div>
        
        <!-- Consent Model -->
        <div style="margin-bottom:15px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <label style="font-weight:600; color:#00d4ff;">Consent Model</label>
            <span id="policyValue" style="color:#e94560; font-weight:600;">Professional</span>
          </div>
          <div style="background:#0f3460; padding:12px; border-radius:6px; font-size:0.85rem; color:#ddd; margin-bottom:15px;">
            <strong>What this affects:</strong>
            <ul style="margin:8px 0 0 20px; padding:0;">
              <li><strong>Professional:</strong> NPCs maintain professional boundaries. Flirting/advances require high relationship stats and are met cautiously.</li>
              <li><strong>Casual:</strong> NPCs are open to personal connections once comfortable. Flirting is welcome when trust/affection are moderate.</li>
              <li><strong>Enthusiastic:</strong> NPCs are receptive and interested in all interactions. Everyone's consenting and relationships develop naturally without barriers.</li>
            </ul>
          </div>
          <div style="display:flex; gap:10px; flex-wrap:wrap;">
            <button class="policy-btn" data-policy="professional" style="flex:1; padding:12px 15px; background:#0f3460; border:2px solid #00d4ff; border-radius:5px; color:white; cursor:pointer; font-weight:600; transition:all 0.2s;">Professional</button>
            <button class="policy-btn" data-policy="casual" style="flex:1; padding:12px 15px; background:#0f3460; border:2px solid #00d4ff; border-radius:5px; color:white; cursor:pointer; font-weight:600; transition:all 0.2s;">Casual</button>
            <button class="policy-btn" data-policy="open" style="flex:1; padding:12px 15px; background:#0f3460; border:2px solid #00d4ff; border-radius:5px; color:white; cursor:pointer; font-weight:600; transition:all 0.2s;">Enthusiastic</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- GENDER DIVERSITY SECTION -->
    <div style="margin-top:30px;">
      <h3>Gender Diversity Options</h3>
      <p style="color:#aaa; font-size:0.9rem; margin-bottom:15px;">
        Control the gender distribution of new hires. All employees will still be female by default (100%), but you can adjust these sliders to introduce variety.
        Sliders are automatically proportional - they will always add up to 100%.
      </p>
      
      <div style="background:#16213e; border-radius:10px; padding:20px; margin-top:10px;">
        <button id="genderOptionsBtn" style="width:100%; padding:15px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:8px; color:white; font-size:1.1rem; font-weight:700; cursor:pointer; box-shadow:0 4px 15px rgba(102,126,234,0.4); transition:transform 0.2s; margin-bottom:15px;">
          ⚧️ Configure Gender Options
        </button>
        
        <!-- Current Distribution Display -->
        <div style="background:#0f3460; padding:15px; border-radius:6px;">
          <div style="margin-bottom:8px; color:#aaa; font-size:0.9rem; font-weight:600;">Current Distribution:</div>
          <div id="genderDistributionDisplay" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(120px, 1fr)); gap:10px;">
            <!-- Will be populated by JS -->
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Invest Tab -->
  <div id="investTab" class="tab-content" hidden>
    <h2 style="margin-top:0;">Investment & Prestige</h2>
    
    <!-- Prestige Overview Section -->
    <div style="background:#0f3460; border-radius:15px; padding:25px; margin-bottom:20px; border:2px solid #00d4ff;">
      <h3 style="margin:0 0 15px 0; color:#00d4ff;">🌟 Prestige System</h3>
      <p style="color:#aaa; margin-bottom:20px; line-height:1.6;">
        Reset your progress to gain <strong style="color:#ffd700;">Influence Points</strong>, which unlock permanent bonuses that persist across all future runs. The more you've earned, the more influence you'll gain!
      </p>
      
      <!-- Current Stats -->
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:20px;">
        <div style="background:#16213e; border-radius:10px; padding:15px; text-align:center;">
          <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Prestige Level</div>
          <div style="font-size:2rem; font-weight:700; color:#00d4ff;" id="currentPrestigeLevel">0</div>
        </div>
        <div style="background:#16213e; border-radius:10px; padding:15px; text-align:center;">
          <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Lifetime Earnings</div>
          <div style="font-size:1.5rem; font-weight:700; color:#2ecc71;" id="lifetimeEarningsDisplay">$0</div>
        </div>
        <div style="background:#16213e; border-radius:10px; padding:15px; text-align:center;">
          <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Influence Points</div>
          <div style="font-size:1.5rem; font-weight:700; color:#ffd700;" id="currentInfluencePoints">0</div>
        </div>
        <div style="background:#16213e; border-radius:10px; padding:15px; text-align:center;">
          <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Income Multiplier</div>
          <div style="font-size:1.5rem; font-weight:700; color:#e74c3c;" id="currentMultiplier">1.0x</div>
        </div>
      </div>
      
      <!-- Prestige Button -->
      <div style="background:#16213e; border-radius:10px; padding:20px; text-align:center;">
        <div style="margin-bottom:15px;">
          <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Next Prestige Will Grant</div>
          <div style="font-size:2rem; font-weight:700; color:#ffd700;" id="nextPrestigeInfluence">0</div>
          <div style="color:#ffd700; font-size:0.9rem;">Influence Points</div>
        </div>
        <button id="prestigeBtn" style="padding:15px 40px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:10px; color:white; font-size:1.2rem; font-weight:700; cursor:pointer; box-shadow:0 4px 15px rgba(102,126,234,0.4); transition:transform 0.2s;">
          ✨ Prestige Now
        </button>
        <div id="prestigeRequirement" style="margin-top:10px; color:#e74c3c; font-size:0.9rem;"></div>
      </div>
    </div>
    
    <!-- Influence Points Upgrade Shop -->
    <div style="background:#0f3460; border-radius:15px; padding:25px;">
      <h3 style="margin:0 0 15px 0; color:#ffd700;">💎 Permanent Upgrades</h3>
      <p style="color:#aaa; margin-bottom:20px; line-height:1.6;">
        Spend Influence Points on permanent bonuses that carry through all prestige runs.
      </p>
      
      <div id="influenceUpgradesContainer" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(280px, 1fr)); gap:15px;">
        <!-- Upgrades will be dynamically populated here -->
      </div>
    </div>
  </div>
</div>

<!-- Settings Panel -->
<div id="settingsPanel" class="settings-panel" hidden style="position:fixed; top:0; right:0; width:350px; height:100%; background:#16213e; color:white; z-index:1000; box-shadow:-5px 0 15px rgba(0,0,0,0.5); overflow-y:auto;">
  <div style="padding:20px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h2 style="margin:0;">Settings</h2>
      <button id="closeSettingsBtn" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>Game Preferences</h3>
      <div style="background:#0f3460; border-radius:10px; padding:15px; margin-top:10px;">
        <div style="margin-bottom:15px;">
          <label>UI Density: <span id="densityValue">Normal</span></label>
          <input type="range" id="densitySlider" min="0" max="100" value="50" style="width:100%; margin-top:5px;">
        </div>
        <div style="margin-bottom:15px;">
          <label style="display:flex; align-items:center; gap:10px;">
            <input type="checkbox" id="autosaveToggle" checked style="width:18px; height:18px;">
            <span>Autosave</span>
          </label>
        </div>
      </div>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>Player Profile</h3>
      <div style="background:#0f3460; border-radius:10px; padding:15px; margin-top:10px;">
        <p style="color:#aaa; font-size:0.9rem; margin:0 0 10px 0;">Set up your detailed profile so NPCs can reference you accurately in conversations, image generation, and social posts.</p>
        <button id="openPlayerProfileBtn" style="width:100%; padding:12px; background:#00d4ff; border:none; border-radius:6px; color:#0f1419; cursor:pointer; font-weight:600; font-size:1rem; display:flex; align-items:center; justify-content:center; gap:8px;">
          <span style="font-size:1.3rem;">👤</span> Edit Your Profile
        </button>
      </div>
    </div>
    
    <div style="margin-bottom:20px;">
      <h3>Data Management</h3>
      <div style="display:flex; gap:10px; margin-top:10px;">
        <button id="saveBtn" style="flex:1; padding:10px; background:#e94560; border:none; border-radius:5px; color:white; cursor:pointer;">Save Game</button>
        <button id="loadBtn" style="flex:1; padding:10px; background:#0f3460; border:none; border-radius:5px; color:white; cursor:pointer;">Load Game</button>
      </div>
      <button id="exportBtn" style="width:100%; padding:10px; background:#0f3460; border:none; border-radius:5px; color:white; cursor:pointer; margin-top:10px;">Export Save Data</button>
      <button id="resetBtn" style="width:100%; padding:10px; background:#533483; border:none; border-radius:5px; color:white; cursor:pointer; margin-top:10px;">Reset Game</button>
    </div>
  </div>
</div>

<!-- Chat Modal -->
<div id="chatModal" class="modal" style="position:fixed !important; top:0 !important; left:0 !important; width:100% !important; height:100% !important; background:rgba(0,0,0,0.7) !important; z-index:999999 !important; display:none !important; justify-content:center !important; align-items:center !important; pointer-events:none !important;">
  <div style="background:#16213e; width:90%; max-width:500px; height:80%; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); display:flex; flex-direction:column; pointer-events:auto;">
    <div style="padding:15px; border-bottom:1px solid #0f3460; display:flex; justify-content:space-between; align-items:center;">
      <div style="display:flex; align-items:center; gap:10px;">
        <img id="chatAvatar" src="" style="width:40px; height:40px; border-radius:50%; object-fit:cover;">
        <div>
          <h3 id="chatName" style="margin:0;"></h3>
          <p id="chatStatus" style="margin:0; font-size:0.8rem; color:#aaa;">Online</p>
        </div>
      </div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="clearChatBtn" style="background:#0f3460; border:none; padding:8px 12px; border-radius:5px; color:#aaa; cursor:pointer; font-size:0.8rem; transition:all 0.2s;" onmouseenter="this.style.background='#16213e'; this.style.color='#e94560'" onmouseleave="this.style.background='#0f3460'; this.style.color='#aaa'">🗑️ Clear</button>
        <button id="closeChatBtn" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
      </div>
    </div>
    
    <div id="chatMessages" style="flex:1; padding:15px; overflow-y:auto; display:flex; flex-direction:column; gap:10px;">
      <!-- Chat messages will appear here -->
    </div>
    
    <div style="padding:15px; border-top:1px solid #0f3460; display:flex; gap:10px; position:relative;">
      <button id="chatAttachBtn" style="padding:8px 12px; background:#0f3460; border:none; border-radius:5px; color:white; cursor:pointer; font-weight:bold; font-size:1.2rem;">+</button>
      <button id="chatEmojiBtn" class="emoji-picker-trigger" style="padding:8px 12px; background:#0f3460; border:none; border-radius:5px; cursor:pointer; font-size:1.2rem;">😊</button>
      <input id="chatInput" type="text" placeholder="Type a message..." style="flex:1; padding:10px; background:#0f1419; border:none; border-radius:5px; color:white;">
      <button id="chatSendBtn" style="padding:8px 15px; background:#e94560; border:none; border-radius:5px; color:white; cursor:pointer;">Send</button>
      
      <!-- Attachment Menu (hidden by default) -->
      <div id="attachmentMenu" style="display:none; position:absolute; bottom:60px; left:0; background:#0f3460; border-radius:8px; box-shadow:0 4px 15px rgba(0,0,0,0.4); min-width:200px; z-index:10;">
        <button class="attach-menu-item" data-action="request" style="width:100%; padding:12px 16px; background:transparent; border:none; color:white; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.2rem;">📷</span> Request Image
        </button>
        <button class="attach-menu-item" data-action="send" style="width:100%; padding:12px 16px; background:transparent; border:none; color:white; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.2rem;">📤</span> Send Image
        </button>
        <button class="attach-menu-item" data-action="request-post" style="width:100%; padding:12px 16px; background:transparent; border:none; color:white; text-align:left; cursor:pointer; border-bottom:1px solid #16213e; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.2rem;">📱</span> Request Social Post
        </button>
        <button class="attach-menu-item" data-action="visualize" style="width:100%; padding:12px 16px; background:transparent; border:none; color:white; text-align:left; cursor:pointer; display:flex; align-items:center; gap:10px;">
          <span style="font-size:1.2rem;">🎬</span> Visual Current Scene
        </button>
      </div>
    </div>
    
    <div id="chatTypingIndicator" style="padding:10px 15px; color:#aaa; font-style:italic; display:none;">
      <span id="chatTypingName"></span> is typing...
    </div>
  </div>
</div>

<!-- Send Image Modal -->
<div id="sendImageModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:500px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#00d4ff;">📤 Send an Image</h3>
      <button id="closeSendImageModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    <p style="color:#aaa; margin-bottom:15px;">Describe what image you want to send. The AI will respond based on your description and conversation context.</p>
    <textarea id="sendImagePrompt" placeholder="E.g., 'A selfie of me at the beach' or 'My new car'" style="width:100%; height:100px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; margin-bottom:15px;"></textarea>
    <div style="display:flex; gap:10px; justify-content:flex-end;">
      <button id="cancelSendImage" style="padding:10px 20px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">Cancel</button>
      <button id="confirmSendImage" style="padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">Send Image</button>
    </div>
  </div>
</div>

<!-- Request Image Modal -->
<div id="requestImageModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:550px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#00d4ff;">📷 Request an Image</h3>
      <button id="closeRequestImageModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    
    <div id="requestImageMode" style="margin-bottom:20px;">
      <p style="color:#aaa; margin-bottom:15px;">Choose a preset or create a custom request:</p>
      
      <!-- Auto Presets -->
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;">
        <button class="request-preset" data-preset="casual" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          😊 Casual Selfie
        </button>
        <button class="request-preset" data-preset="work" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          👔 Work Selfie
        </button>
        <button class="request-preset" data-preset="lewd" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          😏 Lewd Selfie
        </button>
        <button class="request-preset" data-preset="nude" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          🔞 Nude Selfie
        </button>
        <button class="request-preset" data-preset="explicit" style="padding:12px; background:#0f3460; border:1px solid #ff0055; border-radius:8px; color:#ff0055; cursor:pointer; transition:all 0.2s; grid-column:1/-1; font-weight:600;">
          🔥 Explicit Content
        </button>
      </div>
      
      <!-- Manual Option -->
      <button id="requestManualBtn" style="width:100%; padding:12px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; margin-bottom:15px;">
        ✏️ Custom Request
      </button>
      
      <!-- Manual Input (hidden by default) -->
      <div id="requestManualInput" style="display:none;">
        <textarea id="requestImagePrompt" placeholder="Describe what you'd like them to send (e.g., 'a photo of you in your favorite outfit')" style="width:100%; height:100px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; margin-bottom:15px;"></textarea>
        <div style="display:flex; gap:10px; justify-content:flex-end;">
          <button id="cancelRequestManual" style="padding:10px 20px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">Back</button>
          <button id="confirmRequestManual" style="padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">Request</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Request Social Post Modal -->
<div id="requestPostModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:550px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#00d4ff;">📱 Request a Social Post</h3>
      <button id="closeRequestPostModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    
    <div id="requestPostMode" style="margin-bottom:20px;">
      <p style="color:#aaa; margin-bottom:15px;">Choose what kind of post you want them to make:</p>
      
      <!-- Post Type Presets -->
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;">
        <button class="request-post-preset" data-preset="text" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          📝 Status Update
        </button>
        <button class="request-post-preset" data-preset="selfie" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          🤳 Selfie
        </button>
        <button class="request-post-preset" data-preset="thirst_trap" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          🔥 Thirst Trap
        </button>
        <button class="request-post-preset" data-preset="explicit" style="padding:12px; background:#0f3460; border:1px solid #00d4ff; border-radius:8px; color:white; cursor:pointer; transition:all 0.2s;">
          🔞 Explicit/Nude
        </button>
      </div>
      
      <!-- Custom Request Option -->
      <button id="requestPostCustomBtn" style="width:100%; padding:12px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; margin-bottom:15px;">
        ✏️ Custom Request
      </button>
      
      <!-- Custom Input (hidden by default) -->
      <div id="requestPostCustomInput" style="display:none;">
        <textarea id="requestPostPrompt" placeholder="Describe what you want them to post (e.g., 'Post a picture of you masturbating' or 'Write about how you're feeling right now')" style="width:100%; height:100px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; margin-bottom:15px;"></textarea>
        <div style="display:flex; gap:10px; justify-content:flex-end;">
          <button id="cancelRequestPostCustom" style="padding:10px 20px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">Back</button>
          <button id="confirmRequestPostCustom" style="padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">Request</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Player Post Composer Modal -->
<div id="playerPostModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:#16213e; width:90%; max-width:600px; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:25px; max-height:90vh; overflow-y:auto;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
      <h3 style="margin:0; color:#00d4ff;">✏️ Create a Post</h3>
      <button id="closePlayerPostModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    
    <!-- Post Type Selection -->
    <div style="margin-bottom:20px;">
      <label style="display:block; margin-bottom:8px; color:#aaa; font-size:0.9rem;">Post Type</label>
      <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:10px;">
        <button class="post-type-btn active" data-type="text" style="padding:10px; background:#0f3460; border:2px solid #00d4ff; border-radius:6px; color:white; cursor:pointer; transition:all 0.2s;">
          📝 Text
        </button>
        <button class="post-type-btn" data-type="image" style="padding:10px; background:#0f3460; border:2px solid #0f3460; border-radius:6px; color:#aaa; cursor:pointer; transition:all 0.2s;">
          🖼️ Image
        </button>
        <button class="post-type-btn" data-type="selfie" style="padding:10px; background:#0f3460; border:2px solid #0f3460; border-radius:6px; color:#aaa; cursor:pointer; transition:all 0.2s;">
          🤳 Selfie
        </button>
      </div>
    </div>
    
    <!-- Caption Input -->
    <div style="margin-bottom:20px;">
      <label style="display:block; margin-bottom:8px; color:#aaa; font-size:0.9rem;">Caption <span style="color:#666; font-size:0.85rem;">(Type @ to mention someone)</span></label>
      <div style="position:relative;">
        <textarea id="playerPostCaption" placeholder="What's on your mind? Type @ to mention someone..." style="width:100%; height:100px; padding:12px; padding-right:45px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; font-family:inherit; font-size:1rem;"></textarea>
        <button id="postCaptionEmojiBtn" class="emoji-picker-trigger" style="position:absolute; right:8px; top:8px; padding:6px 10px; background:#0f3460; border:none; border-radius:6px; cursor:pointer; font-size:1.2rem; transition:all 0.2s;" onmouseenter="this.style.background='#16213e'" onmouseleave="this.style.background='#0f3460'">😊</button>
        
        <!-- Mention Suggestions Dropdown -->
        <div id="mentionSuggestions" style="display:none; position:absolute; bottom:100%; left:0; width:100%; max-height:200px; overflow-y:auto; background:#16213e; border:2px solid #00d4ff; border-radius:8px; box-shadow:0 -4px 15px rgba(0,0,0,0.5); z-index:1000; margin-bottom:5px;">
          <!-- Dynamically populated -->
        </div>
      </div>
      <div style="margin-top:6px; font-size:0.8rem; color:#666;">
        <span id="captionCharCount">0</span>/500 characters
      </div>
    </div>
    
    <!-- Image Section (shown for image/selfie posts) -->
    <div id="playerPostImageSection" style="display:none; margin-bottom:20px;">
      <label style="display:block; margin-bottom:8px; color:#aaa; font-size:0.9rem;">Image Prompt</label>
      <textarea id="playerPostImagePrompt" placeholder="Describe the image you want to generate (e.g., 'Me at the beach wearing sunglasses')" style="width:100%; height:80px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; font-family:inherit; font-size:0.95rem;"></textarea>
      
      <div style="margin-top:15px;">
        <label style="display:block; margin-bottom:8px; color:#aaa; font-size:0.9rem;">
          Alt Text (What NPCs "see")
          <span style="color:#666; font-size:0.85rem;">- Describe what's in the image for NPCs</span>
        </label>
        <textarea id="playerPostAltText" placeholder="E.g., 'Picture of me smiling at the beach, wearing a blue swimsuit and sunglasses, sunset in background'" style="width:100%; height:80px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; font-family:inherit; font-size:0.95rem;"></textarea>
      </div>
      
      <!-- Preview Image -->
      <div id="playerPostImagePreview" style="display:none; margin-top:15px;">
        <img id="playerPostPreviewImg" style="width:100%; border-radius:10px; box-shadow:0 2px 10px rgba(0,0,0,0.3);">
        <button id="playerPostRegenerateImg" style="width:100%; margin-top:10px; padding:8px; background:#0f3460; border:1px solid #00d4ff; border-radius:6px; color:#00d4ff; cursor:pointer;">
          🔄 Regenerate Image
        </button>
      </div>
    </div>
    
    <!-- Explicit Content Warning -->
    <div style="margin-bottom:20px; background:#0f3460; padding:12px; border-radius:6px; border-left:3px solid #e94560;">
      <label style="display:flex; align-items:center; gap:10px; cursor:pointer;">
        <input type="checkbox" id="playerPostExplicit" style="width:18px; height:18px;">
        <span style="font-size:0.9rem; color:#ddd;">
          🔞 This post contains explicit/NSFW content
        </span>
      </label>
    </div>
    
    <!-- Action Buttons -->
    <div style="display:flex; gap:10px; justify-content:flex-end;">
      <button id="cancelPlayerPost" style="padding:12px 24px; background:#0f3460; border:none; border-radius:6px; color:white; cursor:pointer;">
        Cancel
      </button>
      <button id="generatePlayerPostImage" style="display:none; padding:12px 24px; background:#533483; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">
        🎨 Generate Image
      </button>
      <button id="submitPlayerPost" style="padding:12px 24px; background:#e94560; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">
        📤 Post
      </button>
    </div>
  </div>
</div>

<!-- AFK Income Modal -->
<div id="afkIncomeModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:9999999; justify-content:center; align-items:center;">
  <div style="background:linear-gradient(135deg, #0f1419 0%, #16213e 100%); width:90%; max-width:500px; border-radius:20px; padding:30px; box-shadow:0 10px 50px rgba(76,204,163,0.3); border:2px solid #4ecca3; position:relative;">
    
    <!-- Close button -->
    <button id="closeAfkIncome" style="position:absolute; top:15px; right:15px; background:transparent; border:none; color:#aaa; font-size:1.5rem; cursor:pointer; width:30px; height:30px; display:flex; align-items:center; justify-content:center; border-radius:50%; transition:all 0.2s;">
      ✕
    </button>
    
    <!-- Icon -->
    <div style="text-align:center; margin-bottom:20px;">
      <div style="font-size:4rem; margin-bottom:10px;">💰</div>
      <h2 style="margin:0 0 10px 0; color:#4ecca3; font-size:1.8rem;">Welcome Back!</h2>
      <p style="color:#aaa; margin:0; font-size:0.95rem;">You've been away for a while...</p>
    </div>
    
    <!-- Time Away -->
    <div style="background:#0f1419; padding:15px; border-radius:12px; margin-bottom:20px; text-align:center;">
      <div style="color:#666; font-size:0.85rem; margin-bottom:5px;">TIME AWAY</div>
      <div id="afkTimeAway" style="color:#00d4ff; font-size:1.4rem; font-weight:bold;">0h 0m</div>
    </div>
    
    <!-- Earnings Breakdown -->
    <div style="background:#0f1419; padding:15px; border-radius:12px; margin-bottom:20px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
        <span style="color:#aaa; font-size:0.9rem;">Your Income Rate:</span>
        <span id="afkIncomeRate" style="color:white; font-weight:600;">$0/sec</span>
      </div>
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
        <span style="color:#aaa; font-size:0.9rem;">Full Earnings:</span>
        <span id="afkFullEarnings" style="color:#666; text-decoration:line-through;">$0</span>
      </div>
      <div style="display:flex; justify-content:space-between; align-items:center; padding-top:12px; border-top:1px solid #2a3f5f;">
        <span style="color:#4ecca3; font-size:1.1rem; font-weight:600;">AFK Earnings (<span id="afkRate">50</span>%):</span>
        <span id="afkEarnings" style="color:#4ecca3; font-size:1.4rem; font-weight:bold;">$0</span>
      </div>
    </div>
    
    <!-- Claim Button -->
    <button id="claimAfkIncome" style="width:100%; padding:15px; background:linear-gradient(135deg, #4ecca3 0%, #00d4ff 100%); border:none; border-radius:12px; color:white; font-size:1.2rem; font-weight:bold; cursor:pointer; box-shadow:0 4px 20px rgba(76,204,163,0.4); transition:all 0.3s;">
      💰 Claim Earnings
    </button>
    
    <div style="text-align:center; margin-top:15px; color:#666; font-size:0.8rem;">
      * AFK earnings are capped at 50% of your income rate and 24 hours maximum
    </div>
  </div>
</div>

<!-- Prestige Confirmation Modal -->
<div id="prestigeModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:10000000; justify-content:center; align-items:center; overflow-y:auto; padding:20px;">
  <div style="background:linear-gradient(135deg, #0f1419 0%, #16213e 100%); width:90%; max-width:600px; max-height:90vh; overflow-y:auto; border-radius:20px; padding:35px; box-shadow:0 10px 60px rgba(102,126,234,0.5); border:3px solid #667eea; position:relative; margin:auto;">
    
    <!-- Close button -->
    <button id="closePrestigeModal" style="position:absolute; top:15px; right:15px; background:transparent; border:none; color:#aaa; font-size:1.5rem; cursor:pointer; width:30px; height:30px; display:flex; align-items:center; justify-content:center; border-radius:50%; transition:all 0.2s;">
      ✕
    </button>
    
    <!-- Icon -->
    <div style="text-align:center; margin-bottom:25px;">
      <div style="font-size:5rem; margin-bottom:10px;">✨</div>
      <h2 style="margin:0 0 10px 0; color:#667eea; font-size:2rem; font-weight:700;">Prestige Confirmation</h2>
      <p style="color:#aaa; margin:0; font-size:1rem; line-height:1.6;">
        Are you sure you want to prestige? This action cannot be undone!
      </p>
    </div>
    
    <!-- What You'll Lose Section -->
    <div style="background:#1a0f0f; padding:20px; border-radius:12px; margin-bottom:20px; border-left:4px solid #e74c3c;">
      <h3 style="margin:0 0 15px 0; color:#e74c3c; font-size:1.2rem;">⚠️ What You'll Lose:</h3>
      <ul style="margin:0; padding-left:20px; color:#aaa; line-height:1.8;">
        <li>All current cash</li>
        <li>All products and progress</li>
        <li>All employees and their relationships</li>
        <li>All owned locations (except Garage)</li>
        <li>All boss fight progress</li>
        <li>Chat history and social feed</li>
      </ul>
    </div>
    
    <!-- What You'll Keep Section -->
    <div style="background:#0f1a0f; padding:20px; border-radius:12px; margin-bottom:20px; border-left:4px solid #2ecc71;">
      <h3 style="margin:0 0 15px 0; color:#2ecc71; font-size:1.2rem;">✅ What You'll Keep:</h3>
      <ul style="margin:0; padding-left:20px; color:#aaa; line-height:1.8;">
        <li>All Influence Points (current + new)</li>
        <li>Lifetime earnings total</li>
        <li>Prestige level (increases by 1)</li>
        <li>All permanent upgrades</li>
        <li>Player bio and settings</li>
      </ul>
    </div>
    
    <!-- What You'll Gain Section -->
    <div style="background:#1a1a0f; padding:20px; border-radius:12px; margin-bottom:25px; border-left:4px solid #ffd700;">
      <h3 style="margin:0 0 15px 0; color:#ffd700; font-size:1.2rem;">🌟 What You'll Gain:</h3>
      <div style="text-align:center; margin-top:15px;">
        <div style="font-size:3rem; color:#ffd700; font-weight:bold; margin-bottom:10px;" id="prestigeGainAmount">+0</div>
        <div style="color:#ffd700; font-size:1.1rem; font-weight:600;">Influence Points</div>
        <div style="color:#aaa; font-size:0.9rem; margin-top:10px;">
          Use these to purchase permanent upgrades that boost all future runs!
        </div>
      </div>
    </div>
    
    <!-- Confirmation Buttons -->
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px;">
      <button id="cancelPrestige" style="padding:15px; background:#2c3e50; border:none; border-radius:12px; color:white; font-size:1.1rem; font-weight:600; cursor:pointer; transition:all 0.3s;">
        ❌ Cancel
      </button>
      <button id="confirmPrestige" style="padding:15px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border:none; border-radius:12px; color:white; font-size:1.1rem; font-weight:700; cursor:pointer; box-shadow:0 4px 20px rgba(102,126,234,0.4); transition:all 0.3s;">
        ✨ Prestige Now
      </button>
    </div>
    
    <div style="text-align:center; margin-top:20px; color:#666; font-size:0.85rem; line-height:1.5;">
      💡 Tip: Prestige when you feel your progress has slowed down. The more you've earned, the more influence you'll gain!
    </div>
  </div>
</div>

<!-- Boss Fight Modal -->
<div id="bossFightModal" class="modal" style="position:fixed !important; top:0 !important; left:0 !important; width:100% !important; height:100% !important; background:rgba(0,0,0,0.9) !important; z-index:999999 !important; display:none !important; justify-content:center !important; align-items:center !important; padding:20px !important; overflow-y:auto !important;">
  <div style="background:linear-gradient(135deg, #0f1419 0%, #1a1f2e 100%); width:90%; max-width:800px; max-height:90vh; overflow-y:auto; border-radius:20px; padding:20px; box-shadow:0 10px 50px rgba(255,0,0,0.3); border:2px solid #e94560; margin:auto;">
    
    <!-- Boss Info Header -->
    <div id="bossHeader" style="text-align:center; margin-bottom:15px;">
      <h2 id="bossName" style="margin:0 0 5px 0; font-size:1.6rem; color:#e94560;">Boss Name</h2>
      <div id="bossTitle" style="color:#00d4ff; font-size:1rem; margin-bottom:8px;">Title</div>
      <div id="bossDescription" style="color:#aaa; font-size:0.85rem; max-width:600px; margin:0 auto;">Description</div>
    </div>
    
    <!-- Boss Image -->
    <div style="text-align:center; margin-bottom:15px;">
      <div id="bossImageContainer" style="width:200px; height:200px; margin:0 auto; border-radius:15px; overflow:hidden; background:#0f1419; display:flex; align-items:center; justify-content:center; border:3px solid #e94560; box-shadow:0 0 30px rgba(233,69,96,0.5);">
        <div id="bossImagePlaceholder" style="color:#666; font-size:2rem;">👤</div>
        <img id="bossImage" style="width:100%; height:100%; object-fit:cover; display:none;">
      </div>
    </div>
    
    <!-- Dialogue -->
    <div id="bossDialogue" style="background:#16213e; padding:12px; border-radius:10px; margin-bottom:15px; text-align:center; font-style:italic; color:#ddd; font-size:0.95rem; min-height:50px; display:flex; align-items:center; justify-content:center; border-left:4px solid #e94560;">
      "Boss dialogue appears here..."
    </div>
    
    <!-- Health Bars -->
    <div style="margin-bottom:20px;">
      <!-- Boss Health -->
      <div style="margin-bottom:12px;">
        <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
          <span style="color:#e94560; font-weight:bold; font-size:0.9rem;">Boss Health</span>
          <span id="bossHealthText" style="color:#e94560; font-weight:bold; font-size:0.9rem;">100%</span>
        </div>
        <div style="background:#0f1419; height:25px; border-radius:15px; overflow:hidden; border:2px solid #e94560;">
          <div id="bossHealthBar" style="width:100%; height:100%; background:linear-gradient(90deg, #e94560 0%, #ff6b9d 100%); transition:width 0.3s ease;"></div>
        </div>
      </div>
      
      <!-- Player Stamina (based on income) -->
      <div>
        <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
          <span style="color:#4ecca3; font-weight:bold; font-size:0.9rem;">Your Stamina</span>
          <span id="playerStaminaText" style="color:#4ecca3; font-weight:bold; font-size:0.9rem;">100%</span>
        </div>
        <div style="background:#0f1419; height:25px; border-radius:15px; overflow:hidden; border:2px solid #4ecca3;">
          <div id="playerStaminaBar" style="width:100%; height:100%; background:linear-gradient(90deg, #4ecca3 0%, #00d4ff 100%); transition:width 0.3s ease;"></div>
        </div>
      </div>
    </div>
    
    <!-- Combat Stats -->
    <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px; margin-bottom:15px;">
      <div style="background:#16213e; padding:12px; border-radius:10px; text-align:center;">
        <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Your Attack Power</div>
        <div id="playerAttack" style="color:#e94560; font-size:1.4rem; font-weight:bold;">0</div>
        <div style="color:#666; font-size:0.75rem;">Total Damage/Click</div>
      </div>
      <div style="background:#16213e; padding:12px; border-radius:10px; text-align:center;">
        <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Team Support</div>
        <div id="playerTeamPower" style="color:#ff6b9d; font-size:1.4rem; font-weight:bold;">0</div>
        <div style="color:#666; font-size:0.75rem;"><span id="playerTeamCount">0</span> Employees</div>
      </div>
      <div style="background:#16213e; padding:12px; border-radius:10px; text-align:center;">
        <div style="color:#aaa; font-size:0.8rem; margin-bottom:3px;">Defense/Regen</div>
        <div id="playerDefense" style="color:#4ecca3; font-size:1.4rem; font-weight:bold;">0/sec</div>
        <div style="color:#666; font-size:0.75rem;">Income Per Second</div>
      </div>
    </div>
    
    <!-- Combat Log -->
    <div style="background:#0f1419; padding:12px; border-radius:10px; margin-bottom:15px; max-height:100px; overflow-y:auto;" id="combatLog">
      <div style="color:#666; text-align:center; font-size:0.85rem;">Combat log will appear here...</div>
    </div>
    
    <!-- Action Buttons -->
    <div style="display:flex; gap:12px; justify-content:center;">
      <button id="attackBtn" onclick="bossFightAttack()" style="padding:12px 30px; background:#e94560; border:none; border-radius:10px; color:white; font-size:1.1rem; font-weight:bold; cursor:pointer; box-shadow:0 4px 15px rgba(233,69,96,0.4); transition:all 0.2s;">
        ⚔️ ATTACK
      </button>
      <button id="retreatBtn" onclick="bossFightRetreat()" style="padding:12px 30px; background:#666; border:none; border-radius:10px; color:white; font-size:1.1rem; font-weight:bold; cursor:pointer; transition:all 0.2s;">
        🏃 Retreat
      </button>
    </div>
    
    <!-- Timer -->
    <div id="bossTimer" style="text-align:center; margin-top:15px; font-size:1rem; color:#00d4ff;">
      Time Remaining: <span id="bossTimeRemaining">60</span>s
    </div>
  </div>
</div>

<!-- Player Profile Modal -->
<div id="playerProfileModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:10000000; justify-content:center; align-items:center; overflow-y:auto; padding:20px;">
  <div style="background:#16213e; width:90%; max-width:700px; max-height:90vh; overflow-y:auto; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:30px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:25px;">
      <h2 style="margin:0; color:#00d4ff; display:flex; align-items:center; gap:10px;">
        <span style="font-size:1.8rem;">👤</span> Your Profile
      </h2>
      <button id="closePlayerProfileModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:20px;">
      <!-- Basic Info -->
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">First Name</label>
        <input id="playerFirstName" type="text" placeholder="e.g., Alex" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Last Name</label>
        <input id="playerLastName" type="text" placeholder="e.g., Smith" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Age</label>
        <input id="playerAge" type="number" min="18" max="99" placeholder="e.g., 28" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Gender</label>
        <select id="playerGender" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white; cursor:pointer;">
          <option value="">Select...</option>
          <option value="male">Male</option>
          <option value="female">Female</option>
          <option value="non-binary">Non-Binary</option>
          <option value="other">Other</option>
        </select>
      </div>
    </div>
    
    <!-- Physical Description -->
    <h3 style="margin:20px 0 15px 0; color:#00d4ff; font-size:1.2rem;">Physical Description</h3>
    
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:20px;">
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Ethnicity/Race</label>
        <input id="playerEthnicity" type="text" placeholder="e.g., Caucasian, Asian, Hispanic..." style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Skin Tone</label>
        <input id="playerSkinTone" type="text" placeholder="e.g., fair, tan, brown, dark" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Height</label>
        <input id="playerHeight" type="text" placeholder="e.g., 5'10&quot;, 178cm" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Body Type</label>
        <input id="playerBodyType" type="text" placeholder="e.g., athletic, slim, curvy, muscular" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Hair Color</label>
        <input id="playerHairColor" type="text" placeholder="e.g., brown, blonde, black" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Hair Style</label>
        <input id="playerHairStyle" type="text" placeholder="e.g., short, long, wavy, bald" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Eye Color</label>
        <input id="playerEyeColor" type="text" placeholder="e.g., blue, brown, green" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Facial Hair</label>
        <input id="playerFacialHair" type="text" placeholder="e.g., beard, mustache, clean shaven" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
    </div>
    
    <!-- Intimate Details -->
    <h3 style="margin:20px 0 15px 0; color:#e94560; font-size:1.2rem;">🔞 Intimate Details</h3>
    
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:20px;">
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Genital Type</label>
        <select id="playerGenitalType" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white; cursor:pointer;">
          <option value="">Select...</option>
          <option value="penis">Penis</option>
          <option value="vagina">Vagina</option>
          <option value="both">Both (Intersex)</option>
          <option value="other">Other</option>
        </select>
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Size/Details</label>
        <input id="playerGenitalDetails" type="text" placeholder="e.g., average, large, small, specific measurements" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Breast/Chest Size</label>
        <input id="playerChestSize" type="text" placeholder="e.g., flat, C-cup, muscular pecs" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
      
      <div>
        <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Build Details</label>
        <input id="playerBuildDetails" type="text" placeholder="e.g., toned abs, soft curves, broad shoulders" style="width:100%; padding:10px; background:#0f1419; border:1px solid #0f3460; border-radius:6px; color:white;">
      </div>
    </div>
    
    <!-- Additional Details -->
    <div style="margin-bottom:20px;">
      <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Additional Physical Details</label>
      <textarea id="playerAdditionalDetails" placeholder="Any other details... tattoos, piercings, scars, distinctive features, fashion style, etc." style="width:100%; height:80px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; font-family:inherit;"></textarea>
    </div>
    
    <!-- Personality/Background -->
    <div style="margin-bottom:20px;">
      <label style="display:block; margin-bottom:6px; color:#aaa; font-size:0.9rem;">Personality & Background (Optional)</label>
      <textarea id="playerPersonality" placeholder="Your personality traits, background, how you present yourself..." style="width:100%; height:80px; padding:12px; background:#0f1419; border:1px solid #0f3460; border-radius:8px; color:white; resize:vertical; font-family:inherit;"></textarea>
    </div>
    
    <!-- Save Button -->
    <div style="display:flex; gap:10px; justify-content:flex-end;">
      <button id="cancelPlayerProfile" style="padding:12px 24px; background:#0f3460; border:none; border-radius:8px; color:#aaa; cursor:pointer; font-size:1rem;">
        Cancel
      </button>
      <button id="savePlayerProfile" style="padding:12px 24px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; font-size:1rem;">
        💾 Save Profile
      </button>
    </div>
  </div>
</div>

<!-- Gender Options Modal -->
<div id="genderOptionsModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:10000000; justify-content:center; align-items:center; overflow-y:auto; padding:20px;">
  <div style="background:#16213e; width:90%; max-width:800px; max-height:90vh; overflow-y:auto; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); padding:30px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:25px;">
      <h2 style="margin:0; color:#00d4ff; display:flex; align-items:center; gap:10px;">
        <span style="font-size:1.8rem;">⚧️</span> Gender Diversity Options
      </h2>
      <button id="closeGenderOptionsModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    
    <p style="color:#aaa; margin-bottom:25px; line-height:1.6;">
      Control the gender distribution of new hires. By default, all employees are female (100%). 
      Adjust these sliders to introduce more diversity. <strong>The sliders are proportional and will always total 100%.</strong>
    </p>
    
    <!-- Gender Sliders -->
    <div style="display:flex; flex-direction:column; gap:20px;">
      <!-- Female Slider -->
      <div style="background:#0f3460; padding:20px; border-radius:10px; border-left:4px solid #ff6b9d;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h3 style="margin:0; color:#ff6b9d; font-size:1.2rem;">👩 Female</h3>
            <p style="margin:5px 0 0 0; color:#aaa; font-size:0.85rem;">Standard female employees</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:2rem; font-weight:700; color:#ff6b9d;" id="femalePercentage">100</div>
            <div style="color:#aaa; font-size:0.9rem;">%</div>
          </div>
        </div>
        <input type="range" id="femaleSlider" min="0" max="100" value="100" style="width:100%;">
      </div>
      
      <!-- Male Slider -->
      <div style="background:#0f3460; padding:20px; border-radius:10px; border-left:4px solid #00d4ff;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h3 style="margin:0; color:#00d4ff; font-size:1.2rem;">👨 Male</h3>
            <p style="margin:5px 0 0 0; color:#aaa; font-size:0.85rem;">Standard male employees</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:2rem; font-weight:700; color:#00d4ff;" id="malePercentage">0</div>
            <div style="color:#aaa; font-size:0.9rem;">%</div>
          </div>
        </div>
        <input type="range" id="maleSlider" min="0" max="100" value="0" style="width:100%;">
      </div>
      
      <!-- Female Futa Slider -->
      <div style="background:#0f3460; padding:20px; border-radius:10px; border-left:4px solid #c77dff;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h3 style="margin:0; color:#c77dff; font-size:1.2rem;">👩‍🦰 Female Futa</h3>
            <p style="margin:5px 0 0 0; color:#aaa; font-size:0.85rem;">Female with male genitalia (no transition)</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:2rem; font-weight:700; color:#c77dff;" id="femaleFutaPercentage">0</div>
            <div style="color:#aaa; font-size:0.9rem;">%</div>
          </div>
        </div>
        <input type="range" id="femaleFutaSlider" min="0" max="100" value="0" style="width:100%;">
      </div>
      
      <!-- Trans Man Slider -->
      <div style="background:#0f3460; padding:20px; border-radius:10px; border-left:4px solid #4ecca3;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h3 style="margin:0; color:#4ecca3; font-size:1.2rem;">⚧️ Trans Man</h3>
            <p style="margin:5px 0 0 0; color:#aaa; font-size:0.85rem;">Female to male (masculine with vagina)</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:2rem; font-weight:700; color:#4ecca3;" id="transManPercentage">0</div>
            <div style="color:#aaa; font-size:0.9rem;">%</div>
          </div>
        </div>
        <input type="range" id="transManSlider" min="0" max="100" value="0" style="width:100%;">
      </div>
      
      <!-- Trans Woman Slider -->
      <div style="background:#0f3460; padding:20px; border-radius:10px; border-left:4px solid #ffd700;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div>
            <h3 style="margin:0; color:#ffd700; font-size:1.2rem;">⚧️ Trans Woman</h3>
            <p style="margin:5px 0 0 0; color:#aaa; font-size:0.85rem;">Male to female (feminine with penis)</p>
          </div>
          <div style="text-align:right;">
            <div style="font-size:2rem; font-weight:700; color:#ffd700;" id="transWomanPercentage">0</div>
            <div style="color:#aaa; font-size:0.9rem;">%</div>
          </div>
        </div>
        <input type="range" id="transWomanSlider" min="0" max="100" value="0" style="width:100%;">
      </div>
    </div>
    
    <!-- Total Display -->
    <div style="margin-top:25px; padding:15px; background:#0f3460; border-radius:10px; text-align:center;">
      <div style="color:#aaa; font-size:0.9rem; margin-bottom:5px;">Total Distribution</div>
      <div style="font-size:1.8rem; font-weight:700;" id="genderTotalDisplay">
        <span id="genderTotalValue" style="color:#00d4ff;">100</span>%
      </div>
      <div id="genderWarning" style="display:none; color:#e94560; font-size:0.9rem; margin-top:5px;">
        ⚠️ Total must equal 100%
      </div>
    </div>
    
    <!-- Save Button -->
    <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:25px;">
      <button id="cancelGenderOptions" style="padding:12px 24px; background:#0f3460; border:none; border-radius:8px; color:#aaa; cursor:pointer; font-size:1rem;">
        Cancel
      </button>
      <button id="saveGenderOptions" style="padding:12px 24px; background:#e94560; border:none; border-radius:8px; color:white; cursor:pointer; font-weight:600; font-size:1rem;">
        💾 Save Settings
      </button>
    </div>
  </div>
</div>

<!-- Emoji Picker Tray -->
<div id="emojiPickerTray" style="display:none; position:fixed; background:#1a1d23; border-radius:12px; box-shadow:0 8px 30px rgba(0,0,0,0.5); border:1px solid #2f3336; width:300px; max-height:380px; overflow:hidden; z-index:9999999;">
  <div style="padding:10px; border-bottom:1px solid #2f3336; background:#16181c;">
    <div style="display:flex; gap:6px; overflow-x:auto; scrollbar-width:none;">
      <button class="emoji-category-btn active" data-category="recent" style="padding:6px 10px; background:#2f3336; border:none; border-radius:6px; color:white; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">🕐</button>
      <button class="emoji-category-btn" data-category="smileys" style="padding:6px 10px; background:transparent; border:none; border-radius:6px; color:#aaa; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">😊</button>
      <button class="emoji-category-btn" data-category="gestures" style="padding:6px 10px; background:transparent; border:none; border-radius:6px; color:#aaa; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">👋</button>
      <button class="emoji-category-btn" data-category="hearts" style="padding:6px 10px; background:transparent; border:none; border-radius:6px; color:#aaa; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">❤️</button>
      <button class="emoji-category-btn" data-category="objects" style="padding:6px 10px; background:transparent; border:none; border-radius:6px; color:#aaa; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">🎉</button>
      <button class="emoji-category-btn" data-category="symbols" style="padding:6px 10px; background:transparent; border:none; border-radius:6px; color:#aaa; cursor:pointer; font-size:1rem; white-space:nowrap; transition:all 0.2s;">✨</button>
    </div>
  </div>
  
  <div id="emojiPickerContent" style="padding:8px; max-height:310px; overflow-y:auto; overflow-x:hidden; display:flex; flex-wrap:wrap; gap:2px; align-content:flex-start;">
    <!-- Emojis will be populated here -->
  </div>
</div>

<script>
  // Minimal modal registry (for clean close/cleanup)
  window.modalRegistry = window.modalRegistry || new Map();

  function debugModal() {
    const m = document.getElementById('hiringModal');
    if (!m) { console.warn('No #hiringModal in DOM'); return; }
    const cs = getComputedStyle(m);
    console.table({
      display: cs.display, visibility: cs.visibility, opacity: cs.opacity,
      position: cs.position, zIndex: cs.zIndex, pointerEvents: cs.pointerEvents
    });
    console.log('Modal rect:', m.getBoundingClientRect());
  }

  function closeHiringModal() {
    const overlay = document.getElementById('hiringModal');
    if (overlay) overlay.remove();
    const esc = window.__hiringEscHandler__;
    if (esc) { window.removeEventListener('keydown', esc); window.__hiringEscHandler__ = null; }
    modalRegistry.delete('hiring');
  }

  // Game Constants
  const GAME_TICK_INTERVAL = 100; // ms
  const INITIAL_CASH = 100;
  const NEWS_UPDATE_INTERVAL = 30000; // ms
  
  // ----- PRODUCT HELPERS -----
  function getManagerSpeedMultiplier(p) {
    // Continuous scaling without hard cap
    // Each level reduces time by ~8%, stacking multiplicatively
    // Level 1: 92% time, Level 10: 43% time, Level 30: 9% time, Level 50: 2% time
    if (!p.managerHired || p.managerLevel === 0) return 1.0;
    
    let multiplier = Math.pow(0.92, p.managerLevel);
    
    // Apply automation boost from influence upgrades
    const autoBoostLevel = gameState.influenceUpgrades?.autoProgress || 0;
    const autoBoostMultiplier = influenceUpgrades.autoProgress.effect(autoBoostLevel);
    
    // This makes managers work FASTER (reduces cycle time further)
    multiplier /= autoBoostMultiplier;
    
    // Apply loyalty bonus if manager is a rehired former employee
    const manager = gameState.employees.find(e => e.productManaged === p.name && e.hired);
    if (manager && manager.loyaltyBonus) {
      // Loyalty bonus further reduces cycle time
      multiplier /= (1 + manager.loyaltyBonus);
    }
    
    // ===== EMPLOYEE STAT IMPACT =====
    // Productivity and Trust directly affect manager efficiency
    if (manager) {
      // Productivity Impact: 0.85x to 1.0x (at 0 to 100 productivity)
      // Low productivity = slower cycles, high productivity = baseline speed
      const productivity = manager.productivity || 50; // Default 50 if not set
      const productivityMultiplier = 0.85 + (productivity * 0.15 / 100); // 0.85 at 0, 1.0 at 100
      multiplier /= productivityMultiplier; // DIVIDE to make high productivity = faster
      
      // Trust Impact: 0.85x to 1.15x (at 0 to 100 trust)
      // Low trust = hesitant/inefficient, high trust = empowered/faster
      // Baseline at 70 trust, bonus above 70
      const trust = manager.trust || 50; // Default 50 if not set
      const trustMultiplier = trust <= 70 
        ? 0.85 + (trust * 0.15 / 70)           // 0.85 at 0 → 1.0 at 70
        : 1.0 + ((trust - 70) * 0.15 / 30);    // 1.0 at 70 → 1.15 at 100
      multiplier /= trustMultiplier; // DIVIDE to make high trust = faster
      
      // Obedience Impact: Affects consistency (reliability)
      // Low obedience = occasional delays, high obedience = perfectly consistent
      // This is a subtle effect (0.92x to 1.0x)
      const obedience = manager.obedience || 50;
      const obedienceMultiplier = 0.92 + (obedience / 1250); // 0.92 at 0, 1.0 at 100
      multiplier /= obedienceMultiplier; // DIVIDE to make high obedience = faster
    }
    
    return multiplier;
  }

  function currentCycleTimeMs(p) {
    // Remove hard 500ms floor to allow sub-1-second times
    return Math.max(100, Math.floor(p.baseTimeMs * getManagerSpeedMultiplier(p)));
  }

  function currentValue(p) {
  // Balanced value growth with global multiplier for better progression
  const level = p.level || 0;
  const baseValue = p.valuePerUnit || 3;
  const growthLinear = 1 + (p.valuePerUpgrade || 0.10) * level;
  const exp = p.valueExponent ?? gameBalance.productIncomeExponent;
  
  // Apply global income multiplier
  let value = baseValue * Math.pow(growthLinear, exp) * gameBalance.globalIncomeMultiplier;
  
  // Apply location-specific income boost from upgrades with DIMINISHING RETURNS
  const incomeBoostLevel = gameState.globalUpgrades?.incomeBoost?.[p.locationId] || 0;
  if (incomeBoostLevel > 0) {
    // Asymptotic formula: (1 - 0.9^level) gives diminishing returns
    const boostPercentage = (1 - Math.pow(0.9, incomeBoostLevel)) * 100;
    const boostMultiplier = 1 + (boostPercentage / 100);
    value *= boostMultiplier;
  }
  
  // ===== EMPLOYEE PRODUCTIVITY INCOME BONUS =====
  // Productivity directly increases income generated
  const manager = gameState.employees.find(e => e.productManaged === p.name && e.hired);
  if (manager && p.managerHired) {
    const productivity = manager.productivity || 50;
    // 1.0x to 1.2x income bonus (0 to 100 productivity)
    const productivityIncomeBonus = 1 + (productivity / 500);
    value *= productivityIncomeBonus;
  }
  
  return +value.toFixed(2);
  }

  function clickReductionMs(p) {
    // Use globalUpgrades.clickPower which gives +0.1s per level
    const baseSeconds = p.clickSecondsBase || 1.0;
    const globalUpgradeBonus = (gameState.globalUpgrades?.clickPower || 0) * 0.1;
    
    // Add prestige influence upgrade bonus
    const influenceClickLevel = gameState.influenceUpgrades?.clickPower || 0;
    const influenceClickBonus = influenceUpgrades.clickPower.effect(influenceClickLevel);
    
    const perClickSeconds = baseSeconds + globalUpgradeBonus + influenceClickBonus;
    return perClickSeconds * 1000;
  }

  // ============================================
  // GAME BALANCE CONFIGURATION
  // ============================================
  // Central control for all economy tuning
  const gameBalance = {
    // Global multipliers
    globalIncomeMultiplier: 2.5,     // Make everything 2.5x faster for better pacing
    globalCostReduction: 0.7,        // Reduce costs to 70% (was too aggressive at 60%)
    
    // Product scaling
    productCostMultiplier: 1.22,     // Each level costs 1.20x more (reduced from 1.35 for smoother progression to 999)
    productIncomeMultiplier: 1.20,   // Each level gives 1.15x more income
    productIncomeExponent: 0.95,     // Diminishing returns on income growth
    
    // Starting values
    startingCash: 150,               // Start with more cash (was 100)
    firstProductUnlockCost: 80,      // Cheaper to unlock second product (was 100)
    
    // Click power
    baseClickReduction: 1,           // Seconds removed per click
    clickPowerGrowth: 1,             // Additional seconds per upgrade level
    
    // Manager costs  
    managerCostReduction: 0.7,       // Managers cost 70% of original
    
    // Boss fights (for future use)
    bossHealthMultiplier: 2.0,       // Boss health = unlock cost * this
    bossTimeLimit: 60,               // Default time limit in seconds
    bossRewardMultiplier: 5.0,       // Reward = unlock cost * this
    
    // Player upgrades (for future use)
    upgradeBaseCosts: {
      clickPower: 10000,           // $10K base for click power (scales with 2.0x)
      incomeBoost: 50000,          // $50K base for income boost (scales with 2.5x)
      costReduction: 100000        // $100K base for cost reduction (scales with 3.0x)
    }
  };

  // ============================================
  // EMOJI PICKER SYSTEM
  // ============================================
  const emojiPicker = {
    recentEmojis: [], // Store recently used emojis (no duplicates)
    maxRecent: 24,
    currentTarget: null, // The input/textarea that will receive the emoji
    
    emojis: {
      smileys: ['😀','😃','😄','😁','😆','😅','🤣','😂','🙂','🙃','😉','😊','😇','🥰','😍','🤩','😘','😗','😚','😙','🥲','😋','😛','😜','🤪','😝','🤑','🤗','🤭','🤫','🤔','🤐','🤨','😐','😑','😶','😏','😒','🙄','😬','🤥','😌','😔','😪','🤤','😴','😷','🤒','🤕','🤢','🤮','🤧','🥵','🥶','🥴','😵','🤯','🤠','🥳','🥸','😎','🤓','🧐'],
      gestures: ['👋','🤚','🖐','✋','🖖','👌','🤌','🤏','✌️','🤞','🤟','🤘','🤙','👈','👉','👆','🖕','👇','☝️','👍','👎','✊','👊','🤛','🤜','👏','🙌','👐','🤲','🤝','🙏','💪','🦾','🦿','🦵','🦶','👂','🦻','👃','🧠','🫀','🫁','🦷','🦴','👀','👁','👅','👄','💋'],
      hearts: ['❤️','🧡','💛','💚','💙','💜','🖤','🤍','🤎','💔','❤️‍🔥','❤️‍🩹','💕','💞','💓','💗','💖','💘','💝','💟','💌','💢','💥','💫','💦','💨','🕳️','💬','👁️‍🗨️','🗨️','🗯️','💭'],
      objects: ['🎉','🎊','🎈','🎁','🎀','🏆','🥇','🥈','🥉','⚽','🏀','🏈','⚾','🎾','🏐','🏉','🎱','🏓','🏸','🥅','🥊','🥋','⛳','⛸️','🎣','🎽','🎿','🛷','🥌','🎯','🪀','🪁','🎱','🎮','🕹️','🎰','🎲','🧩','♟️','🎭','🎨','🧵','🪡','🧶','🪢','📷','📸','📹','🎥','📽️','🎬','📺','📻','🎙️','🎚️','🎛️','🎧','🎷','🪗','🎸','🎹','🎺','🎻','🪕','🥁','🪘','📱','📲','☎️','📞','📟','📠','🔋','🔌','💻','🖥️','🖨️','⌨️','🖱️','🖲️','💾','💿','📀','🧮','🎥'],
      symbols: ['✨','⭐','🌟','💫','✅','❌','⭕','🔥','💯','🎯','💢','💤','💨','🕳️','✔️','☑️','✖️','➕','➖','➗','❓','❔','❕','❗','〰️','💱','💲','⚠️','🚸','🔱','📛','🔰','✳️','❇️','♻️','💠','🔷','🔶','🔹','🔸','🔺','🔻','💎','🔘','🔲','🔳']
    },
    
    init() {
      // Load recent emojis from localStorage
      const saved = localStorage.getItem('recentEmojis');
      if (saved) {
        try {
          this.recentEmojis = JSON.parse(saved);
        } catch (e) {
          this.recentEmojis = [];
        }
      }
      
      // Setup category buttons
      document.querySelectorAll('.emoji-category-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.switchCategory(btn.dataset.category);
        });
      });
      
      // Close on outside click
      document.addEventListener('click', (e) => {
        const picker = document.getElementById('emojiPickerTray');
        if (picker.style.display === 'block' && !picker.contains(e.target)) {
          // Check if click was on an emoji button
          if (!e.target.classList.contains('emoji-picker-trigger')) {
            this.hide();
          }
        }
      });
      
      // Initial render
      this.renderRecent();
    },
    
    show(targetInput, triggerButton) {
      console.log('EmojiPicker.show() called', {targetInput, triggerButton});
      this.currentTarget = targetInput;
      const picker = document.getElementById('emojiPickerTray');
      console.log('Picker element:', picker);
      const rect = triggerButton.getBoundingClientRect();
      console.log('Button rect:', rect);
      
      // Position picker near the trigger button
      const spaceBelow = window.innerHeight - rect.bottom;
      const spaceAbove = rect.top;
      
      // Prefer positioning below, but if not enough space, position above
      if (spaceBelow > 420 || spaceBelow > spaceAbove) {
        picker.style.top = `${rect.bottom + 5}px`;
        picker.style.bottom = 'auto';
      } else {
        picker.style.bottom = `${window.innerHeight - rect.top + 5}px`;
        picker.style.top = 'auto';
      }
      
      // Position horizontally (try to align with button, but stay in viewport)
      let left = rect.left;
      const pickerWidth = 320;
      if (left + pickerWidth > window.innerWidth) {
        left = window.innerWidth - pickerWidth - 10;
      }
      picker.style.left = `${Math.max(10, left)}px`;
      
      picker.style.display = 'block';
      console.log('Picker display set to block, styles:', {
        display: picker.style.display,
        top: picker.style.top,
        left: picker.style.left,
        zIndex: picker.style.zIndex
      });
      
      // Show recent category by default
      this.switchCategory('recent');
    },
    
    hide() {
      document.getElementById('emojiPickerTray').style.display = 'none';
      this.currentTarget = null;
    },
    
    switchCategory(category) {
      // Update button states
      document.querySelectorAll('.emoji-category-btn').forEach(btn => {
        if (btn.dataset.category === category) {
          btn.style.background = '#2f3336';
          btn.style.color = 'white';
          btn.classList.add('active');
        } else {
          btn.style.background = 'transparent';
          btn.style.color = '#aaa';
          btn.classList.remove('active');
        }
      });
      
      // Render emojis for this category
      if (category === 'recent') {
        this.renderRecent();
      } else {
        this.renderCategory(category);
      }
    },
    
    renderRecent() {
      const content = document.getElementById('emojiPickerContent');
      if (this.recentEmojis.length === 0) {
        content.innerHTML = '<div style="width:100%; text-align:center; padding:40px 20px; color:#666;">No recent emojis yet<br><span style="font-size:2rem; margin-top:10px; display:block;">🕐</span></div>';
        return;
      }
      
      content.innerHTML = this.recentEmojis.map(emoji => 
        `<button class="emoji-btn" data-emoji="${emoji}" style="padding:4px; background:transparent; border:none; font-size:1.1rem; cursor:pointer; border-radius:4px; transition:all 0.15s; flex-shrink:0; width:32px; height:32px; display:flex; align-items:center; justify-content:center;" onmouseenter="this.style.background='#2f3336'; this.style.transform='scale(1.15)'" onmouseleave="this.style.background='transparent'; this.style.transform='scale(1)'">${emoji}</button>`
      ).join('');
      
      this.attachEmojiClickHandlers();
    },
    
    renderCategory(category) {
      const content = document.getElementById('emojiPickerContent');
      const emojis = this.emojis[category] || [];
      
      content.innerHTML = emojis.map(emoji => 
        `<button class="emoji-btn" data-emoji="${emoji}" style="padding:4px; background:transparent; border:none; font-size:1.1rem; cursor:pointer; border-radius:4px; transition:all 0.15s; flex-shrink:0; width:32px; height:32px; display:flex; align-items:center; justify-content:center;" onmouseenter="this.style.background='#2f3336'; this.style.transform='scale(1.15)'" onmouseleave="this.style.background='transparent'; this.style.transform='scale(1)'">${emoji}</button>`
      ).join('');
      
      this.attachEmojiClickHandlers();
    },
    
    attachEmojiClickHandlers() {
      document.querySelectorAll('.emoji-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.insertEmoji(btn.dataset.emoji);
        });
      });
    },
    
    insertEmoji(emoji) {
      if (!this.currentTarget) return;
      
      const input = this.currentTarget;
      const start = input.selectionStart || 0;
      const end = input.selectionEnd || 0;
      const text = input.value;
      
      // Insert emoji at cursor position
      input.value = text.substring(0, start) + emoji + text.substring(end);
      
      // Move cursor after emoji
      const newPos = start + emoji.length;
      input.setSelectionRange(newPos, newPos);
      input.focus();
      
      // Add to recent (remove if exists first to avoid duplicates)
      this.recentEmojis = this.recentEmojis.filter(e => e !== emoji);
      this.recentEmojis.unshift(emoji);
      
      // Keep only max recent
      if (this.recentEmojis.length > this.maxRecent) {
        this.recentEmojis = this.recentEmojis.slice(0, this.maxRecent);
      }
      
      // Save to localStorage
      localStorage.setItem('recentEmojis', JSON.stringify(this.recentEmojis));
      
      // Don't hide picker - let user pick multiple
      // If they want to close, they can click outside
    }
  };

  // Game State
  let gameState = {
    cash: gameBalance.startingCash,  // Use balance config
    playerUpgrades: { clickPower: 0 }, // each +1 = +0.1s per click
    totalEarnings: 0,
    onboarding: [], // tracks employees being onboarded
    lastPlayTime: Date.now(), // Track when player last played for AFK income
    lastInteractionTime: Date.now(), // Track actual last user interaction (clicks, taps, etc.)
    pageHiddenTime: null, // Track when page was hidden/backgrounded
    
    // PRESTIGE SYSTEM
    prestigeLevel: 0,              // Number of times player has prestiged
    influencePoints: 0,            // Prestige currency (persistent)
    lifetimeEarnings: 0,           // Total earnings across all prestiges
    lifetimeEarningsConverted: 0,  // Lifetime earnings already converted to influence
    prestigeMultiplier: 1.0,       // Income multiplier from prestiges
    
    // GLOBAL UPGRADES (reset on prestige)
    globalUpgrades: {
      clickPower: 0,               // Level of click power upgrade (+0.1s per level)
      incomeBoost: {},             // Per-location income boost {locationId: level} (+10% per level)
      costReduction: {}            // Per-location cost reduction {locationId: level} (-10% per level)
    },
    
    // BOSS FIGHTS
    bossFights: {
      active: null,                // Currently active boss fight
      defeated: [],                // Array of defeated boss IDs
      history: []                  // Combat history for replay/stats
    },
    
    locations: [
      {
        id: 'garage',
        name: '🏠 Garage',
        cost: 0,
        owned: true,
        unlocked: true,
        theme: {
          primary: '#3498db',      // Light blue
          secondary: '#ecf0f1',    // White
          accent: '#95a5a6',       // Gray
          background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
          description: 'Humble beginnings in your garage'
        },
        products: []
      },
      {
        id: 'home_office',
        name: '💼 Home Office',
        cost: 15000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#2c3e50',      // Navy blue
          secondary: '#27ae60',    // Forest green
          accent: '#f5f5dc',       // Cream
          background: 'linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%)',
          description: 'Professional workspace, scaling up operations'
        },
        products: []
      },
      {
        id: 'office_suite',
        name: '🏢 Office Suite',
        cost: 500000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#1e3a8a',      // Corporate blue
          secondary: '#c0c0c0',    // Silver
          accent: '#ffffff',       // White
          background: 'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)',
          description: 'Legitimate corporate headquarters, the big leagues'
        },
        products: []
      },
      {
        id: 'factory',
        name: '🏭 Factory',
        cost: 25000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#5a6268',      // Industrial gray
          secondary: '#fd7e14',    // Orange
          accent: '#607d8b',       // Steel blue
          background: 'linear-gradient(135deg, #232526 0%, #414345 100%)',
          description: 'Manufacturing facility producing physical goods'
        },
        products: []
      },
      {
        id: 'rnd',
        name: '🔬 R&D Lab',
        cost: 5000000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#00bfff',      // Electric blue
          secondary: '#39ff14',    // Neon green
          accent: '#f0f0f0',       // White
          background: 'linear-gradient(135deg, #000428 0%, #004e92 100%)',
          description: 'Cutting-edge research and experimental technology'
        },
        products: []
      },
      {
        id: 'creative_studio',
        name: '🎨 Creative Studio',
        cost: 500000000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#9b59b6',      // Purple
          secondary: '#e91e63',    // Magenta
          accent: '#b76e79',       // Rose gold
          background: 'linear-gradient(135deg, #8e2de2 0%, #4a00e0 100%)',
          description: '"Artistic" content creation and adult-adjacent media'
        },
        nsfwLevel: 1,              // Suggestive content begins
        products: []
      },
      {
        id: 'private_club',
        name: '🍸 Private Club',
        cost: 50000000000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#c0392b',      // Deep red
          secondary: '#d4af37',    // Gold
          accent: '#1a1a1a',       // Black
          background: 'linear-gradient(135deg, #870000 0%, #190a05 100%)',
          description: 'Elite adult entertainment and exclusive services'
        },
        nsfwLevel: 2,              // Explicit content
        products: []
      },
      {
        id: 'velvet_room',
        name: '🎭 Velvet Room',
        cost: 5000000000000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#4a148c',      // Dark purple
          secondary: '#b71c1c',    // Crimson
          accent: '#0f0f0f',       // Shadow black
          background: 'linear-gradient(135deg, #1a0033 0%, #330033 100%)',
          description: 'Secret society rituals, masks, absolute depravity'
        },
        nsfwLevel: 3,              // Depraved content
        products: []
      },
      {
        id: 'inner_sanctum',
        name: '👁️ Inner Sanctum',
        cost: 500000000000000000,
        owned: false,
        unlocked: false,
        theme: {
          primary: '#000000',      // Void black
          secondary: '#8b0000',    // Blood red
          accent: '#2d5016',       // Sickly green
          background: 'linear-gradient(135deg, #000000 0%, #0a0a0a 50%, #000000 100%)',
          description: 'Beyond morality. You have become the darkness.'
        },
        nsfwLevel: 4,              // Endgame horror
        requiresPrestiges: 1,      // Must prestige at least once
        products: []
      }
    ],
    products: [
      {
        id: 'website',
        name: 'Website Development',
        locationId: 'garage',
        // unlock
        unlocked: true,           // first product is always unlocked
        unlockCost: 0,            // no cost for first product
        // economy
  valuePerUnit: 3,          // $ earned per completed cycle
  level: 0,                 // product upgrade level
  upgradeCost: 50,          // current upgrade cost (will scale by costGrowth)
  baseUpgradeCost: 50,      // base cost at level 0
  costGrowth: 1.35,         // cost multiplier per level
  valuePerUpgrade: 0.10,    // toned down growth per upgrade
  valueExponent: 0.85,      // diminishing returns exponent
        // timing
        baseTimeMs: 6000,         // 6s cycle base
        running: false,
        timeRemainingMs: 0,
        // clicking
        clickSecondsBase: 1,      // each click removes 1 second by default
        // manager
        managerHired: false,
        managerLevel: 0,
        managerHireCost: 500,
        managerUpgradeCost: 250,
        // caps
  managerSpeedCapPct: 0.40  // at most 40% faster
      },
      {
        id: 'app',
        name: 'Mobile App',
        locationId: 'garage',
        // unlock
        unlocked: false,
        unlockCost: 80,          // Reduced from 100 for faster early game
  valuePerUnit: 9, level: 0, upgradeCost: 150, baseUpgradeCost: 150, costGrowth: 1.35, valuePerUpgrade: 0.12, valueExponent: 0.85,
        baseTimeMs: 10000, running:false, timeRemainingMs:0,
        clickSecondsBase: 1,
        managerHired:false, managerLevel:0, managerHireCost:1500, managerUpgradeCost:750,
  managerSpeedCapPct:0.40
      },
      {
        id: 'consulting',
        name: 'IT Consulting',
        locationId: 'garage',
        // unlock
        unlocked: false,
        unlockCost: 300,          // Reduced from 400 for better flow
  valuePerUnit: 18, level: 0, upgradeCost: 300, baseUpgradeCost: 300, costGrowth: 1.35, valuePerUpgrade: 0.12, valueExponent: 0.85,
        baseTimeMs: 14000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:3000, managerUpgradeCost:1500,
  managerSpeedCapPct:0.40
      },
      {
        id: 'cloud',
        name: 'Cloud Services',
        locationId: 'garage',
        // unlock
        unlocked: false,
        unlockCost: 1200,         // Reduced from 1800 for better pacing
  valuePerUnit: 32, level: 0, upgradeCost: 500, baseUpgradeCost: 500, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 20000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:5000, managerUpgradeCost:2500,
  managerSpeedCapPct:0.40
      },
      {
        id: 'seo',
        name: 'SEO Services',
        locationId: 'garage',
        unlocked: false,
        unlockCost: 3000,
        valuePerUnit: 55, level: 0, upgradeCost: 800, baseUpgradeCost: 800, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 25000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:8000, managerUpgradeCost:4000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'branding',
        name: 'Brand Design',
        locationId: 'garage',
        unlocked: false,
        unlockCost: 5000,
        valuePerUnit: 85, level: 0, upgradeCost: 1200, baseUpgradeCost: 1200, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 30000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:12000, managerUpgradeCost:6000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'ecommerce',
        name: 'E-Commerce Store',
        locationId: 'garage',
        unlocked: false,
        unlockCost: 8000,
        valuePerUnit: 130, level: 0, upgradeCost: 1800, baseUpgradeCost: 1800, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 35000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:18000, managerUpgradeCost:9000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'automation',
        name: 'Business Automation',
        locationId: 'garage',
        unlocked: false,
        unlockCost: 12000,
        valuePerUnit: 200, level: 0, upgradeCost: 2500, baseUpgradeCost: 2500, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 40000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:25000, managerUpgradeCost:12500,
        managerSpeedCapPct:0.40
      },
      // HOME OFFICE LOCATION PRODUCTS
      {
        id: 'copywriting',
        name: 'Copywriting Services',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 300, level: 0, upgradeCost: 3500, baseUpgradeCost: 3500, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 35000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:35000, managerUpgradeCost:17500,
        managerSpeedCapPct:0.40
      },
      {
        id: 'video_editing',
        name: 'Video Production',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 20000,
        valuePerUnit: 450, level: 0, upgradeCost: 5000, baseUpgradeCost: 5000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 45000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:50000, managerUpgradeCost:25000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'marketing',
        name: 'Marketing Campaigns',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 35000,
        valuePerUnit: 700, level: 0, upgradeCost: 7500, baseUpgradeCost: 7500, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 50000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:70000, managerUpgradeCost:35000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'consulting_premium',
        name: 'Premium Consulting',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 55000,
        valuePerUnit: 1100, level: 0, upgradeCost: 11000, baseUpgradeCost: 11000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 60000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:100000, managerUpgradeCost:50000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'saas',
        name: 'SaaS Platform',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 85000,
        valuePerUnit: 1700, level: 0, upgradeCost: 16000, baseUpgradeCost: 16000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 70000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:150000, managerUpgradeCost:75000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'virtual_assistant',
        name: 'Virtual Assistant Services',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 120000,
        valuePerUnit: 2500, level: 0, upgradeCost: 24000, baseUpgradeCost: 24000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 75000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:220000, managerUpgradeCost:110000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'social_media_mgmt',
        name: 'Social Media Management',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 180000,
        valuePerUnit: 3800, level: 0, upgradeCost: 36000, baseUpgradeCost: 36000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 80000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:320000, managerUpgradeCost:160000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'online_courses',
        name: 'Online Course Creation',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 250000,
        valuePerUnit: 5700, level: 0, upgradeCost: 52000, baseUpgradeCost: 52000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 85000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:450000, managerUpgradeCost:225000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'business_coaching',
        name: 'Business Coaching',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 350000,
        valuePerUnit: 8500, level: 0, upgradeCost: 75000, baseUpgradeCost: 75000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 90000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:650000, managerUpgradeCost:325000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'digital_marketing',
        name: 'Digital Marketing Agency',
        locationId: 'home_office',
        unlocked: false,
        unlockCost: 480000,
        valuePerUnit: 12500, level: 0, upgradeCost: 110000, baseUpgradeCost: 110000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 95000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:900000, managerUpgradeCost:450000,
        managerSpeedCapPct:0.40
      },

      // ============================================
      // OFFICE SUITE LOCATION PRODUCTS
      // ============================================
      {
        id: 'enterprise_saas',
        name: 'Enterprise SaaS Platform',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 18000, level: 0, upgradeCost: 160000, baseUpgradeCost: 160000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 100000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1500000, managerUpgradeCost:750000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'enterprise_software',
        name: 'Enterprise Software Suite',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 700000,
        valuePerUnit: 27000, level: 0, upgradeCost: 240000, baseUpgradeCost: 240000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 105000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:2200000, managerUpgradeCost:1100000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'api_marketplace',
        name: 'API Marketplace',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 1200000,
        valuePerUnit: 41000, level: 0, upgradeCost: 360000, baseUpgradeCost: 360000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 110000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:3300000, managerUpgradeCost:1650000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'white_label',
        name: 'White Label Solutions',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 2000000,
        valuePerUnit: 62000, level: 0, upgradeCost: 540000, baseUpgradeCost: 540000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 115000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:5000000, managerUpgradeCost:2500000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'cybersecurity',
        name: 'Cybersecurity Suite',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 3500000,
        valuePerUnit: 93000, level: 0, upgradeCost: 800000, baseUpgradeCost: 800000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 120000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:7500000, managerUpgradeCost:3750000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'data_analytics',
        name: 'Data Analytics Platform',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 5500000,
        valuePerUnit: 140000, level: 0, upgradeCost: 1200000, baseUpgradeCost: 1200000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 125000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:11000000, managerUpgradeCost:5500000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'crm_system',
        name: 'CRM System',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 8500000,
        valuePerUnit: 210000, level: 0, upgradeCost: 1800000, baseUpgradeCost: 1800000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 130000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:17000000, managerUpgradeCost:8500000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'ai_integration',
        name: 'AI Integration Tools',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 13000000,
        valuePerUnit: 315000, level: 0, upgradeCost: 2700000, baseUpgradeCost: 2700000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 135000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:25000000, managerUpgradeCost:12500000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'blockchain',
        name: 'Blockchain Solutions',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 20000000,
        valuePerUnit: 475000, level: 0, upgradeCost: 4000000, baseUpgradeCost: 4000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 140000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:38000000, managerUpgradeCost:19000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'acquisitions',
        name: 'Corporate Acquisitions',
        locationId: 'office_suite',
        unlocked: false,
        unlockCost: 30000000,
        valuePerUnit: 710000, level: 0, upgradeCost: 6000000, baseUpgradeCost: 6000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 145000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:55000000, managerUpgradeCost:27500000,
        managerSpeedCapPct:0.40
      },

      // ============================================
      // FACTORY LOCATION PRODUCTS
      // ============================================
      {
        id: 'custom_keychains',
        name: 'Custom Keychains',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 1100000, level: 0, upgradeCost: 9000000, baseUpgradeCost: 9000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 150000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:80000000, managerUpgradeCost:40000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'branded_tshirts',
        name: 'Branded T-Shirts',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 35000000,
        valuePerUnit: 1650000, level: 0, upgradeCost: 13500000, baseUpgradeCost: 13500000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 155000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:120000000, managerUpgradeCost:60000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'phone_cases',
        name: 'Custom Phone Cases',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 60000000,
        valuePerUnit: 2475000, level: 0, upgradeCost: 20000000, baseUpgradeCost: 20000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 160000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:180000000, managerUpgradeCost:90000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'desk_toys',
        name: 'Executive Desk Toys',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 100000000,
        valuePerUnit: 3713000, level: 0, upgradeCost: 30000000, baseUpgradeCost: 30000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 165000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:270000000, managerUpgradeCost:135000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'logo_stickers',
        name: 'Logo Sticker Sheets',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 170000000,
        valuePerUnit: 5570000, level: 0, upgradeCost: 45000000, baseUpgradeCost: 45000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 170000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:400000000, managerUpgradeCost:200000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'promo_mugs',
        name: 'Promotional Mugs',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 280000000,
        valuePerUnit: 8355000, level: 0, upgradeCost: 67500000, baseUpgradeCost: 67500000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 175000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:600000000, managerUpgradeCost:300000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'tech_accessories',
        name: 'Tech Accessories Line',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 450000000,
        valuePerUnit: 12533000, level: 0, upgradeCost: 100000000, baseUpgradeCost: 100000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 180000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:900000000, managerUpgradeCost:450000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'furniture_line',
        name: 'Office Furniture Line',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 750000000,
        valuePerUnit: 18800000, level: 0, upgradeCost: 150000000, baseUpgradeCost: 150000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 185000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1350000000, managerUpgradeCost:675000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'vehicle_manufacturing',
        name: 'Vehicle Manufacturing',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 1200000000,
        valuePerUnit: 28200000, level: 0, upgradeCost: 225000000, baseUpgradeCost: 225000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 190000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:2000000000, managerUpgradeCost:1000000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'smart_home',
        name: 'Smart Home Devices',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 2000000000,
        valuePerUnit: 42300000, level: 0, upgradeCost: 337500000, baseUpgradeCost: 337500000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 195000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:3000000000, managerUpgradeCost:1500000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'robotics',
        name: 'Robotics Division',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 3200000000,
        valuePerUnit: 63450000, level: 0, upgradeCost: 500000000, baseUpgradeCost: 500000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 200000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:4500000000, managerUpgradeCost:2250000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'aerospace',
        name: 'Aerospace Parts',
        locationId: 'factory',
        unlocked: false,
        unlockCost: 5000000000,
        valuePerUnit: 95175000, level: 0, upgradeCost: 750000000, baseUpgradeCost: 750000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 205000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:6750000000, managerUpgradeCost:3375000000,
        managerSpeedCapPct:0.40
      },

      // ============================================
      // R&D LAB LOCATION PRODUCTS
      // ============================================
      {
        id: 'patents',
        name: 'Patent Applications',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 143000000, level: 0, upgradeCost: 1125000000, baseUpgradeCost: 1125000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 210000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:10000000000, managerUpgradeCost:5000000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'prototypes',
        name: 'Prototype Development',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 7000000000,
        valuePerUnit: 215000000, level: 0, upgradeCost: 1687500000, baseUpgradeCost: 1687500000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 215000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:15000000000, managerUpgradeCost:7500000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'genetic_research',
        name: 'Genetic Research',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 12000000000,
        valuePerUnit: 323000000, level: 0, upgradeCost: 2531250000, baseUpgradeCost: 2531250000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 220000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:22500000000, managerUpgradeCost:11250000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'quantum_computing',
        name: 'Quantum Computing',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 20000000000,
        valuePerUnit: 485000000, level: 0, upgradeCost: 3796875000, baseUpgradeCost: 3796875000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 225000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:33750000000, managerUpgradeCost:16875000000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'neural_implants',
        name: 'Neural Implants',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 33000000000,
        valuePerUnit: 728000000, level: 0, upgradeCost: 5695312500, baseUpgradeCost: 5695312500, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 230000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:50625000000, managerUpgradeCost:25312500000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'cloning',
        name: 'Cloning Technology',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 55000000000,
        valuePerUnit: 1092000000, level: 0, upgradeCost: 8542968750, baseUpgradeCost: 8542968750, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 235000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:75937500000, managerUpgradeCost:37968750000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'time_dilation',
        name: 'Time Dilation Studies',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 90000000000,
        valuePerUnit: 1638000000, level: 0, upgradeCost: 12814453125, baseUpgradeCost: 12814453125, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 240000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:113906250000, managerUpgradeCost:56953125000,
        managerSpeedCapPct:0.40
      },
      {
        id: 'dimensional_travel',
        name: 'Dimensional Travel',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 145000000000,
        valuePerUnit: 2457000000, level: 0, upgradeCost: 19221679688, baseUpgradeCost: 19221679688, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 245000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:170859375000, managerUpgradeCost:85429687500,
        managerSpeedCapPct:0.40
      },
      {
        id: 'consciousness_upload',
        name: 'Consciousness Upload',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 235000000000,
        valuePerUnit: 3686000000, level: 0, upgradeCost: 28832519531, baseUpgradeCost: 28832519531, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 250000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:256289062500, managerUpgradeCost:128144531250,
        managerSpeedCapPct:0.40
      },
      {
        id: 'reality_hacking',
        name: 'Reality Hacking',
        locationId: 'rnd',
        unlocked: false,
        unlockCost: 380000000000,
        valuePerUnit: 5529000000, level: 0, upgradeCost: 43248779297, baseUpgradeCost: 43248779297, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 255000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:384433593750, managerUpgradeCost:192216796875,
        managerSpeedCapPct:0.40
      },

      // ============================================
      // CREATIVE STUDIO LOCATION PRODUCTS (NSFW LEVEL 1 - Suggestive)
      // ============================================
      {
        id: 'glamour_photography',
        name: 'Glamour Photography',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 8294000000, level: 0, upgradeCost: 64872000000, baseUpgradeCost: 64872000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 260000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:576650000000, managerUpgradeCost:288325000000,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'instagram_modeling',
        name: 'Instagram Modeling',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 650000000000,
        valuePerUnit: 12441000000, level: 0, upgradeCost: 97308000000, baseUpgradeCost: 97308000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 265000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:864975000000, managerUpgradeCost:432487500000,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'boudoir_sessions',
        name: 'Boudoir Sessions',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 1100000000000,
        valuePerUnit: 18662000000, level: 0, upgradeCost: 145962000000, baseUpgradeCost: 145962000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 270000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1297462500000, managerUpgradeCost:648731250000,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'artistic_nudes',
        name: '"Artistic" Nude Photography',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 1900000000000,
        valuePerUnit: 27993000000, level: 0, upgradeCost: 218943000000, baseUpgradeCost: 218943000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 275000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1946193750000, managerUpgradeCost:973096875000,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'premium_snapchat',
        name: 'Premium Snapchat Management',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 3100000000000,
        valuePerUnit: 41990000000, level: 0, upgradeCost: 328414000000, baseUpgradeCost: 328414000000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 280000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:2919290625000, managerUpgradeCost:1459645312500,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'spicy_patreon',
        name: 'Spicy Patreon Tiers',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 5200000000000,
        valuePerUnit: 62985000000, level: 0, upgradeCost: 492621000000, baseUpgradeCost: 492621000000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 285000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:4378935937500, managerUpgradeCost:2189467968750,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'amateur_videography',
        name: 'Amateur Content Videography',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 8500000000000,
        valuePerUnit: 94478000000, level: 0, upgradeCost: 738931500000, baseUpgradeCost: 738931500000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 290000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:6568403906250, managerUpgradeCost:3284201953125,
        managerSpeedCapPct:0.40,
        nsfwLevel: 1
      },
      {
        id: 'cam_show_production',
        name: 'Cam Show Production Studio',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 14000000000000,
        valuePerUnit: 141717000000, level: 0, upgradeCost: 1108397250000, baseUpgradeCost: 1108397250000, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 295000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:9852605859375, managerUpgradeCost:4926302929687,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'adult_platform',
        name: 'Adult Content Platform',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 23000000000000,
        valuePerUnit: 212576000000, level: 0, upgradeCost: 1662595875000, baseUpgradeCost: 1662595875000, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 300000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:14778908789062, managerUpgradeCost:7389454394531,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'erotic_audio',
        name: 'Erotic Audio Stories',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 38000000000000,
        valuePerUnit: 318864000000, level: 0, upgradeCost: 2493893812500, baseUpgradeCost: 2493893812500, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 305000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:22168363183594, managerUpgradeCost:11084181591797,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'custom_fetish',
        name: 'Custom Fetish Content',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 62000000000000,
        valuePerUnit: 478296000000, level: 0, upgradeCost: 3740840718750, baseUpgradeCost: 3740840718750, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 310000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:33252544775391, managerUpgradeCost:16626272387695,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'adult_film_studio',
        name: 'Full Adult Film Studio',
        locationId: 'creative_studio',
        unlocked: false,
        unlockCost: 100000000000000,
        valuePerUnit: 717444000000, level: 0, upgradeCost: 5611261078125, baseUpgradeCost: 5611261078125, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 315000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:49878817163086, managerUpgradeCost:24939408581543,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },

      // ============================================
      // PRIVATE CLUB LOCATION PRODUCTS (NSFW LEVEL 2 - Explicit)
      // ============================================
      {
        id: 'vip_bottle_service',
        name: 'VIP Bottle Service',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 1076166000000, level: 0, upgradeCost: 8416891617188, baseUpgradeCost: 8416891617188, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 320000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:74818225744629, managerUpgradeCost:37409112872314,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'private_dances',
        name: 'Private Dance Bookings',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 70000000000000,
        valuePerUnit: 1614249000000, level: 0, upgradeCost: 12625337425781, baseUpgradeCost: 12625337425781, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 325000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:112227338616943, managerUpgradeCost:56113669308471,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'companionship',
        name: 'Companionship Services',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 120000000000000,
        valuePerUnit: 2421374000000, level: 0, upgradeCost: 18938006138672, baseUpgradeCost: 18938006138672, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 330000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:168341007925415, managerUpgradeCost:84170503962707,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'executive_relief',
        name: 'Executive Stress Relief',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 200000000000000,
        valuePerUnit: 3632061000000, level: 0, upgradeCost: 28407009208008, baseUpgradeCost: 28407009208008, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 335000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:252511511888123, managerUpgradeCost:126255755944061,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'private_rooms',
        name: 'Private Room Rentals',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 330000000000000,
        valuePerUnit: 5448092000000, level: 0, upgradeCost: 42610513812012, baseUpgradeCost: 42610513812012, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 340000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:378767267832184, managerUpgradeCost:189383633916092,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'escort_network',
        name: 'Elite Escort Network',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 550000000000000,
        valuePerUnit: 8172138000000, level: 0, upgradeCost: 63915770718018, baseUpgradeCost: 63915770718018, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 345000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:568150901748276, managerUpgradeCost:284075450874138,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'fetish_club',
        name: 'Fetish Club Events',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 900000000000000,
        valuePerUnit: 12258207000000, level: 0, upgradeCost: 95873656077027, baseUpgradeCost: 95873656077027, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 350000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:852226352622414, managerUpgradeCost:426113176311207,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'sugar_baby_agency',
        name: 'Sugar Baby Arrangements',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 1500000000000000,
        valuePerUnit: 18387311000000, level: 0, upgradeCost: 143810484115541, baseUpgradeCost: 143810484115541, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 355000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1278339528933621, managerUpgradeCost:639169764466810,
        managerSpeedCapPct:0.40,
        nsfwLevel: 2
      },
      {
        id: 'bachelor_party_extreme',
        name: 'Bachelor Party Packages',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 2400000000000000,
        valuePerUnit: 27580967000000, level: 0, upgradeCost: 215715726173311, baseUpgradeCost: 215715726173311, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 360000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1917509293400432, managerUpgradeCost:958754646700216,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'luxury_brothel',
        name: 'Luxury Brothel Chain',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 4000000000000000,
        valuePerUnit: 41371451000000, level: 0, upgradeCost: 323573589259967, baseUpgradeCost: 323573589259967, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 365000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:2876263940100648, managerUpgradeCost:1438131970050324,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'sex_tourism',
        name: 'Sex Tourism Operations',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 6500000000000000,
        valuePerUnit: 62057177000000, level: 0, upgradeCost: 485360383889950, baseUpgradeCost: 485360383889950, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 370000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:4314395910150972, managerUpgradeCost:2157197955075486,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'vice_network',
        name: 'Global Vice Network',
        locationId: 'private_club',
        unlocked: false,
        unlockCost: 10500000000000000,
        valuePerUnit: 93085766000000, level: 0, upgradeCost: 728040575834925, baseUpgradeCost: 728040575834925, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 375000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:6471593865226458, managerUpgradeCost:3235796932613229,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },

      // ============================================
      // VELVET ROOM LOCATION PRODUCTS (NSFW LEVEL 3 - Depraved)
      // ============================================
      {
        id: 'secret_society',
        name: 'Secret Society Memberships',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 139628649000000, level: 0, upgradeCost: 1092060863752388, baseUpgradeCost: 1092060863752388, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 380000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:9707390797839687, managerUpgradeCost:4853695398919843,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'blackmail_archives',
        name: 'Blackmail Insurance Archives',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 13000000000000000,
        valuePerUnit: 209442974000000, level: 0, upgradeCost: 1638091295628582, baseUpgradeCost: 1638091295628582, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 385000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:14561086196759531, managerUpgradeCost:7280543098379765,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'private_island',
        name: 'Private Island Retreat Access',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 22000000000000000,
        valuePerUnit: 314164461000000, level: 0, upgradeCost: 2457136943442873, baseUpgradeCost: 2457136943442873, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 390000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:21841629295139297, managerUpgradeCost:10920814647569648,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'compromising_material',
        name: 'Compromising Material Collection',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 36000000000000000,
        valuePerUnit: 471246692000000, level: 0, upgradeCost: 3685705415164310, baseUpgradeCost: 3685705415164310, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 395000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:32762443942708945, managerUpgradeCost:16381221971354472,
        managerSpeedCapPct:0.40,
        nsfwLevel: 3
      },
      {
        id: 'special_requests',
        name: '"Special Request" Fulfillment',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 60000000000000000,
        valuePerUnit: 706870038000000, level: 0, upgradeCost: 5528558122746465, baseUpgradeCost: 5528558122746465, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 400000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:49143665914063418, managerUpgradeCost:24571832957031709,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'underground_auctions',
        name: 'Underground Auction Access',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 98000000000000000,
        valuePerUnit: 1060305057000000, level: 0, upgradeCost: 8292837184119697, baseUpgradeCost: 8292837184119697, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 405000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:73715498871095127, managerUpgradeCost:36857749435547563,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'influence_peddling',
        name: 'Influence Peddling Services',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 160000000000000000,
        valuePerUnit: 1590457586000000, level: 0, upgradeCost: 12439255776179546, baseUpgradeCost: 12439255776179546, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 410000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:110573248306642691, managerUpgradeCost:55286624153321345,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'political_puppets',
        name: 'Political Puppet Strings',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 260000000000000000,
        valuePerUnit: 2385686379000000, level: 0, upgradeCost: 18658883664269319, baseUpgradeCost: 18658883664269319, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 415000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:165859872459964036, managerUpgradeCost:82929936229982018,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'occult_rituals',
        name: 'Occult Ritual Hosting',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 430000000000000000,
        valuePerUnit: 3578529569000000, level: 0, upgradeCost: 27988325496403978, baseUpgradeCost: 27988325496403978, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 420000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:248789808689946054, managerUpgradeCost:124394904344973027,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'mind_control',
        name: 'Mind Control Research',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 700000000000000000,
        valuePerUnit: 5367794354000000, level: 0, upgradeCost: 41982488244605968, baseUpgradeCost: 41982488244605968, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 425000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:373184713034919081, managerUpgradeCost:186592356517459540,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'blood_oaths',
        name: 'Blood Oath Contracts',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 1150000000000000000,
        valuePerUnit: 8051691531000000, level: 0, upgradeCost: 62973732366908952, baseUpgradeCost: 62973732366908952, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 430000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:559777069552378621, managerUpgradeCost:279888534776189310,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'forbidden_desires',
        name: 'Forbidden Desires Catalog',
        locationId: 'velvet_room',
        unlocked: false,
        unlockCost: 1900000000000000000,
        valuePerUnit: 12077537297000000, level: 0, upgradeCost: 94460598550363428, baseUpgradeCost: 94460598550363428, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 435000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:839665604328567932, managerUpgradeCost:419832802164283966,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },

      // ============================================
      // INNER SANCTUM LOCATION PRODUCTS (NSFW LEVEL 4 - Endgame Horror)
      // ============================================
      {
        id: 'human_trafficking',
        name: 'Human Trafficking Networks',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 0, // First product in location unlocks with location
        valuePerUnit: 18116305946000000, level: 0, upgradeCost: 141690897825545142, baseUpgradeCost: 141690897825545142, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 440000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1259498406492851899, managerUpgradeCost:629749203246425949,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'organ_market',
        name: 'Organ Market Pipeline',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 2500000000000000000,
        valuePerUnit: 27174458919000000, level: 0, upgradeCost: 212536346738317713, baseUpgradeCost: 212536346738317713, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 445000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:1889247609739277848, managerUpgradeCost:944623804869638924,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'assassinations',
        name: 'Assassination Contracts',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 4200000000000000000,
        valuePerUnit: 40761688379000000, level: 0, upgradeCost: 318804520107476570, baseUpgradeCost: 318804520107476570, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 450000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:2833871414608916772, managerUpgradeCost:1416935707304458386,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'govt_overthrow',
        name: 'Government Overthrow Operations',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 6800000000000000000,
        valuePerUnit: 61142532569000000, level: 0, upgradeCost: 478206780161214855, baseUpgradeCost: 478206780161214855, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 455000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:4250807121913375158, managerUpgradeCost:2125403560956687579,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'hostile_takeovers',
        name: 'Corporate Hostile Takeovers',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 11000000000000000000,
        valuePerUnit: 91713798854000000, level: 0, upgradeCost: 717310170241822282, baseUpgradeCost: 717310170241822282, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 460000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:6376210682870062737, managerUpgradeCost:3188105341435031368,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'torture_entertainment',
        name: 'Torture Entertainment Venues',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 18000000000000000000,
        valuePerUnit: 137570698281000000, level: 0, upgradeCost: 1075965255362733423, baseUpgradeCost: 1075965255362733423, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 465000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:9564316024305094106, managerUpgradeCost:4782158012152547053,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'doomsday_cult',
        name: 'Doomsday Cult Leadership',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 29000000000000000000,
        valuePerUnit: 206356047422000000, level: 0, upgradeCost: 1613947883044100135, baseUpgradeCost: 1613947883044100135, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 470000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:14346474036457641159, managerUpgradeCost:7173237018228820579,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'reality_manipulation',
        name: 'Reality Manipulation Technology',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 48000000000000000000,
        valuePerUnit: 309534071133000000, level: 0, upgradeCost: 2420921824566150202, baseUpgradeCost: 2420921824566150202, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 475000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:21519711054686461738, managerUpgradeCost:10759855527343230869,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'eldritch_summoning',
        name: 'Eldritch Entity Summoning',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 78000000000000000000,
        valuePerUnit: 464301106700000000, level: 0, upgradeCost: 3631382736849225303, baseUpgradeCost: 3631382736849225303, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 480000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:32279566582029692607, managerUpgradeCost:16139783291014846303,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'multiverse_domination',
        name: 'Multiverse Domination',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 127000000000000000000,
        valuePerUnit: 696451660050000000, level: 0, upgradeCost: 5447074105273837955, baseUpgradeCost: 5447074105273837955, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 485000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:48419349873044538910, managerUpgradeCost:24209674936522269455,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'god_emperor',
        name: 'Become God-Emperor',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 205000000000000000000,
        valuePerUnit: 1044677490075000000, level: 0, upgradeCost: 8170611157910756932, baseUpgradeCost: 8170611157910756932, costGrowth: 1.35, valuePerUpgrade: 0.10, valueExponent: 0.85,
        baseTimeMs: 490000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:72629024809566808365, managerUpgradeCost:36314512404783404182,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      },
      {
        id: 'consume_reality',
        name: 'Consume Reality Itself',
        locationId: 'inner_sanctum',
        unlocked: false,
        unlockCost: 330000000000000000000,
        valuePerUnit: 1567016235113000000, level: 0, upgradeCost: 12255916736866135398, baseUpgradeCost: 12255916736866135398, costGrowth: 1.35, valuePerUpgrade: 0.11, valueExponent: 0.85,
        baseTimeMs: 495000, running:false, timeRemainingMs:0,
        clickSecondsBase:1,
        managerHired:false, managerLevel:0, managerHireCost:108943537214350212547, managerUpgradeCost:54471768607175106273,
        managerSpeedCapPct:0.40,
        nsfwLevel: 4
      }
    ],
    employees: [],
    gifts: [
      { id: 'coffee', name: 'Coffee', cost: 10, effect: { productivity: 5 }, description: 'Boosts productivity' },
      { id: 'giftcard', name: 'Gift Card', cost: 50, effect: { affection: 10 }, description: 'Increases affection' },
      { id: 'lunch', name: 'Lunch', cost: 30, effect: { comfort: 15 }, description: 'Improves comfort' },
      { id: 'bonus', name: 'Cash Bonus', cost: 100, effect: { desire: 20 }, description: 'Raises desire' }
    ],
    news: [
      "Tech startup raises $1M in seed funding",
      "New productivity app trends in office spaces",
      "Remote work policies reshape company cultures",
      "AI integration boosts efficiency across industries"
    ],
    settings: {
      autosave: true,
      uiDensity: 50,
      atmosphere: 50,
      guidelines: 50,
      policy: 'professional',
      playerBio: '' // DEPRECATED: Replaced by playerProfile object
    },
    
    // Player Profile (detailed information about the player character)
    playerProfile: {
      // Basic Info
      firstName: '',
      lastName: '',
      age: null,
      gender: '',
      
      // Physical Description
      ethnicity: '',
      skinTone: '',
      height: '',
      bodyType: '',
      hairColor: '',
      hairStyle: '',
      eyeColor: '',
      facialHair: '',
      
      // Intimate Details
      genitalType: '',
      genitalDetails: '',
      chestSize: '',
      buildDetails: '',
      
      // Additional
      additionalDetails: '',
      personality: ''
    },
    
    // GENDER DIVERSITY SETTINGS
    genderSettings: {
      female: 100,        // Default: 100% female
      male: 0,
      femaleFuta: 0,
      transMan: 0,
      transWoman: 0
    },
    
    activeTab: 'dashboard',
    activeLocationId: 'garage', // Currently selected location subtab
    upgradeMultiplier: 1, // Bulk upgrade multiplier (1, 5, 10, 100, or 'max')
    activeChat: null,
    chatHistory: {},
    
    // ========== SOCIAL NETWORK SYSTEM ==========
    socialNetwork: {
      posts: [], // Array of all posts in the feed
      globalEvents: [], // Company-wide events that can trigger posts
      postIdCounter: 0, // Incrementing ID for posts
      lastPostGeneration: 0, // Timestamp of last autonomous post generation
      postGenerationInterval: 300000, // 5 minutes between autonomous post checks (in ms)
      
      // Filtering/sorting options
      feedFilter: 'all', // 'all', 'explicit', 'work', 'personal'
      feedSort: 'recent', // 'recent', 'popular', 'comments'
      
      // Content variety tracking (prevent repetition)
      recentPostTypes: [], // Track last 20 post types to ensure variety
      
      // Player post drafts
      playerDraft: {
        caption: '',
        imagePrompt: '',
        altText: '',
        imageUrl: null
      }
    },
    
    // Company-wide awareness data
    companyContext: {
      totalEmployees: 0, // Auto-calculated
      locationEmployeeCounts: {}, // { locationId: count }
      recentHires: [], // Last 5 hires
      recentFires: [], // Last 5 fires with alumni status
      recentPromotions: [], // Last 10 promotions
      interdepartmentalEvents: [] // Cross-location events (competitions, collaborations, etc.)
    }
  };

  // ============================================
  // BOSS FIGHT CONFIGURATION
  // ============================================
  // Each location (except garage) has a boss that must be defeated to unlock
  const bossFightConfig = {
    home_office: {
      id: 'boss_home_office',
      name: 'The Demanding Client',
      title: 'Corporate Gatekeeper',
      description: 'A high-stakes client with impossible demands. Prove your worth to access corporate connections.',
      nsfwLevel: 0, // Professional
      health: 5000,
      recommendedClickPower: 0, // Can attempt with base stats
      recommendedIncome: 100, // $100/sec recommended
      rewardMultiplier: 2.0,
      dialogue: {
        intro: "I don't work with amateurs. Show me what you've got.",
        mid: "Hmm... maybe you're not completely incompetent.",
        victory: "Fine. You've earned my respect. Welcome to the big leagues."
      },
      appearance: {
        prompt: "Professional businesswoman in sharp suit, stern expression, office background, photorealistic",
        style: "professional"
      }
    },
    office_suite: {
      id: 'boss_office_suite',
      name: 'The Executive',
      title: 'CFO Negotiator',
      description: 'The CFO wants to see results. Your performance will determine if you get that corner office.',
      nsfwLevel: 0,
      health: 50000,
      recommendedClickPower: 5,
      recommendedIncome: 1000, // $1K/sec
      rewardMultiplier: 3.0,
      dialogue: {
        intro: "The board is watching. Impress me or get out.",
        mid: "Interesting... you might have potential after all.",
        victory: "Excellent work. The corner office is yours."
      },
      appearance: {
        prompt: "Confident female CFO in designer suit, luxury office, commanding presence, photorealistic",
        style: "executive"
      }
    },
    factory: {
      id: 'boss_factory',
      name: 'The Union Rep',
      title: 'Labor Negotiator',
      description: 'Win over the workers to gain access to manufacturing operations.',
      nsfwLevel: 0,
      health: 500000,
      recommendedClickPower: 10,
      recommendedIncome: 10000, // $10K/sec
      rewardMultiplier: 4.0,
      dialogue: {
        intro: "The workers won't respect someone who can't deliver. Prove yourself.",
        mid: "You're starting to win them over...",
        victory: "Alright, you've got the union's backing. Welcome to the floor."
      },
      appearance: {
        prompt: "Strong confident female union representative in work clothes, factory background, determined look, photorealistic",
        style: "industrial"
      }
    },
    rnd: {
      id: 'boss_rnd',
      name: 'The Scientist',
      title: 'Head Researcher',
      description: 'Prove your innovation capabilities to access cutting-edge R&D facilities.',
      nsfwLevel: 0,
      health: 10000000,
      recommendedClickPower: 20,
      recommendedIncome: 100000, // $100K/sec
      rewardMultiplier: 5.0,
      dialogue: {
        intro: "Research requires precision and dedication. Can you handle it?",
        mid: "Fascinating approach... show me more.",
        victory: "Welcome to the lab. Let's push some boundaries."
      },
      appearance: {
        prompt: "Attractive female scientist in lab coat, modern laboratory, intelligent gaze, photorealistic",
        style: "scientific"
      }
    },
    creative_studio: {
      id: 'boss_creative_studio',
      name: 'The Director',
      title: 'Content Creator',
      description: 'Convince the provocative director you can handle "artistic" content creation.',
      nsfwLevel: 1, // Suggestive begins
      health: 500000000,
      recommendedClickPower: 35,
      recommendedIncome: 1000000, // $1M/sec
      rewardMultiplier: 6.0,
      dialogue: {
        intro: "Art requires... openness. Are you open-minded enough for my studio?",
        mid: "Mmm, you're not shy. I like that...",
        victory: "Perfect. You'll fit right in here. Let's create something... provocative."
      },
      appearance: {
        prompt: "Seductive female director in stylish revealing outfit, artistic studio, confident sultry expression, photorealistic",
        style: "artistic"
      }
    },
    private_club: {
      id: 'boss_private_club',
      name: 'The Hostess',
      title: 'Club Proprietor',
      description: 'Prove you can handle the exclusive and explicit nature of elite adult entertainment.',
      nsfwLevel: 2, // Explicit
      health: 25000000000,
      recommendedClickPower: 50,
      recommendedIncome: 10000000, // $10M/sec
      rewardMultiplier: 8.0,
      dialogue: {
        intro: "This club caters to very... particular tastes. Think you can satisfy them?",
        mid: "Oh, you know how to please. Keep going...",
        victory: "Excellent performance. Welcome to the VIP section, darling."
      },
      appearance: {
        prompt: "Gorgeous hostess in elegant lingerie, luxury club setting, seductive pose, partial nudity, photorealistic, NSFW",
        style: "seductive"
      }
    },
    velvet_room: {
      id: 'boss_velvet_room',
      name: 'The Dominatrix',
      title: 'Mistress of Ceremonies',
      description: 'Submit to her will to gain access to the most decadent establishment.',
      nsfwLevel: 3, // Very explicit
      health: 1000000000000,
      recommendedClickPower: 75,
      recommendedIncome: 100000000, // $100M/sec
      rewardMultiplier: 10.0,
      dialogue: {
        intro: "Kneel. This is MY domain, and you will submit to enter.",
        mid: "Good... you're learning your place. Continue.",
        victory: "You've proven yourself worthy. You may enter my velvet room."
      },
      appearance: {
        prompt: "Dominant woman in leather outfit, velvet room, commanding pose, explicit attire, photorealistic, NSFW",
        style: "dominant"
      }
    },
    inner_sanctum: {
      id: 'boss_inner_sanctum',
      name: 'The Empress',
      title: 'Ultimate Authority',
      description: 'Face the ultimate challenge. Only the most dedicated can access the inner sanctum.',
      nsfwLevel: 3,
      health: 50000000000000,
      recommendedClickPower: 100,
      recommendedIncome: 1000000000, // $1B/sec
      rewardMultiplier: 15.0,
      dialogue: {
        intro: "You dare approach me? Prove you're worthy of my presence.",
        mid: "Impressive... you might actually deserve this...",
        victory: "Magnificent. You've conquered everything. The inner sanctum is yours."
      },
      appearance: {
        prompt: "Empress in revealing royal attire, opulent throne room, powerful sensual presence, explicit, photorealistic, NSFW",
        style: "supreme"
      }
    }
  };

  // Helper function to get DOM elements safely
  function $(id) {
    return document.getElementById(id);
  }

  // ========== SOCIAL NETWORK DATA STRUCTURES ==========
  
  /**
   * Post Structure
   * Represents a single post on the social network
   */
  function createPost({
    authorId,
    authorName,
    authorImage = null,
    type = 'text', // 'text', 'selfie', 'image', 'meme', 'thirsttrap', 'explicit', 'life_update', 'work', 'travel'
    content = '', // Caption/text content
    imageUrl = null,
    imagePrompt = null, // For regeneration
    altText = null, // For NPC "vision" - what they "see" in the image
    mood = 'neutral', // 'happy', 'excited', 'sad', 'flirty', 'angry', 'stressed', 'playful', 'spicy'
    tags = [], // Hashtags or topics
    referencedEmployees = [], // Employee IDs mentioned/tagged
    referencedEvent = null, // Event ID if referencing a company event
    referencedChat = null, // Chat message ID if referencing boss conversation
    explicitLevel = 0, // 0=safe, 1=suggestive, 2=lewd, 3=explicit, 4=very explicit
    isPlayerPost = false
  } = {}) {
    return {
      id: `post_${++gameState.socialNetwork.postIdCounter}_${Date.now()}`,
      authorId,
      authorName,
      authorImage,
      type,
      content,
      imageUrl,
      imagePrompt,
      altText,
      mood,
      tags,
      referencedEmployees,
      referencedEvent,
      referencedChat,
      explicitLevel,
      isPlayerPost,
      timestamp: Date.now(),
      likes: [], // Array of employee IDs who liked
      comments: [], // Array of comment objects
      views: 0,
      shareCount: 0
    };
  }
  
  /**
   * Comment Structure
   * Represents a comment on a post
   */
  function createComment({
    postId,
    authorId,
    authorName,
    authorImage = null,
    content = '',
    replyToCommentId = null
  } = {}) {
    return {
      id: `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      postId,
      authorId,
      authorName,
      authorImage,
      content,
      replyToCommentId,
      timestamp: Date.now(),
      likes: []
    };
  }
  
  /**
   * Relationship Structure
   * Represents a relationship between two employees
   */
  function createRelationship({
    targetId,
    type = 'neutral', // 'friend', 'best_friend', 'rival', 'crush', 'enemy', 'romantic', 'neutral'
    strength = 50, // 0-100, how strong the relationship is
    history = [] // Array of interaction events
  } = {}) {
    return {
      targetId,
      type,
      strength,
      lastInteraction: Date.now(),
      history, // [{ timestamp, event, impact }]
      sharedInterests: [], // Common hobbies/traits
      sharedLocation: false, // Work at same location
      conflicts: 0, // Number of negative interactions
      positiveInteractions: 0
    };
  }
  
  /**
   * Event Structure
   * Represents a notable company event that can trigger posts
   */
  function createEvent({
    type = 'general', // 'hire', 'fire', 'promotion', 'project_success', 'department_rivalry', 'office_party', 'milestone', 'boss_interaction'
    involvedEmployees = [], // Employee IDs involved
    location = null,
    description = '',
    sentiment = 'neutral', // 'positive', 'negative', 'neutral', 'exciting', 'dramatic'
    importance = 5 // 1-10, how likely to trigger posts
  } = {}) {
    return {
      id: `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type,
      involvedEmployees,
      location,
      description,
      sentiment,
      importance,
      timestamp: Date.now(),
      relatedPosts: [], // Post IDs that reference this event
      hasBeenPostedAbout: false
    };
  }
  
  /**
   * Initialize social network data on an employee
   * Called when employee is created or loaded from old save
   */
  // ========== USERNAME GENERATION ==========
  
  /**
   * Generate unique username for employee
   */
  function generateUsername(employee) {
    const firstName = (employee.name.split(' ')[0] || '').toLowerCase();
    const lastName = (employee.name.split(' ')[1] || '').toLowerCase();
    
    const templates = [
      `${firstName}_${lastName}`,
      `${firstName}.${lastName}`,
      `${firstName}${lastName}`,
      `${firstName}_${lastName.charAt(0)}`,
      `${firstName.charAt(0)}_${lastName}`,
      `${lastName}_${firstName}`,
      `the_${firstName}`,
      `real_${firstName}`,
      `${firstName}_official`,
      `${firstName}_${Math.floor(Math.random() * 100)}`,
      `${lastName}_${Math.floor(Math.random() * 100)}`,
      `${firstName}_${lastName}_${Math.floor(Math.random() * 10)}`
    ];
    
    // Pick random template
    let username = templates[Math.floor(Math.random() * templates.length)];
    
    // Ensure uniqueness by checking existing usernames
    const existingUsernames = gameState.employees
      .filter(e => e.social?.username && e.id !== employee.id)
      .map(e => e.social.username);
    
    let attempts = 0;
    while (existingUsernames.includes(username) && attempts < 10) {
      username = `${firstName}_${Math.floor(Math.random() * 1000)}`;
      attempts++;
    }
    
    return username;
  }

  // ========== SOCIAL DATA INITIALIZATION ==========
  
  function initializeEmployeeSocialData(employee) {
    if (!employee) return;
    
    // Social network specific data
    if (!employee.social) {
      employee.social = {
        // Username
        username: generateUsername(employee),
        
        // Bio/About
        bio: '', // Can be generated later
        joinDate: Date.now(),
        
        // Posting behavior
        postFrequency: 0.3 + Math.random() * 0.7, // 0-1, how often they post (some are very active, some lurk)
        lastPostTime: 0,
        postCount: 0,
        likeCount: 0,
        commentCount: 0,
        
        // Stats
        totalLikesReceived: 0,
        totalCommentsReceived: 0,
        totalMentions: 0,
        
        // Content preferences (what they're likely to post)
        contentPreferences: {
          selfies: 0.2 + Math.random() * 0.5,
          workPosts: 0.1 + Math.random() * 0.4,
          memes: Math.random() * 0.6,
          lifeUpdates: 0.2 + Math.random() * 0.5,
          thirstTraps: Math.random() * 0.4, // Based on personality
          explicitContent: Math.random() * 0.3, // Some are bolder than others
          travelPosts: Math.random() * 0.4
        },
        
        // Engagement behavior
        likesProbability: 0.3 + Math.random() * 0.6, // How likely to like posts
        commentsProbability: 0.1 + Math.random() * 0.4, // How likely to comment
        
        // Content filters
        willingnessToPostExplicit: Math.random(), // 0-1, how comfortable with explicit content
        
        // Activity tracking
        recentPostTypes: [], // Last 5 post types to avoid repetition
        postsAboutBoss: 0, // Track how many posts reference boss
        
        // Mention tracking for @suggest system
        mentionHistory: [] // { employeeId, timestamp, count }
      };
    }
    
    // Initialize player mention stats if not exists
    if (!gameState.playerMentionStats) {
      gameState.playerMentionStats = {
        mentionHistory: [], // { employeeId, timestamp }
        mentionCounts: {}   // { employeeId: count }
      };
    }
    
    // Relationships with other employees
    if (!employee.relationships) {
      employee.relationships = {}; // { [employeeId]: Relationship }
    }
    
    // Location awareness
    if (!employee.locationId && employee.productManaged) {
      // Infer location from product if not set
      const product = gameState.products.find(p => p.name === employee.productManaged);
      if (product) {
        employee.locationId = product.locationId;
      }
    }
    if (!employee.locationId) {
      employee.locationId = 'garage'; // Default
    }
    
    // Contextual awareness
    if (!employee.awareness) {
      employee.awareness = {
        knowsCoworkers: [], // Employee IDs they're aware of
        knowsLocations: [], // Location IDs they know about
        companyKnowledge: {
          totalEmployees: 0,
          lastUpdated: 0
        }
      };
    }
    
    // Alumni status (for fired employees)
    if (!employee.employmentStatus) {
      employee.employmentStatus = employee.hired ? 'active' : 'alumni';
    }
    
    return employee;
  }

  // Helper function to get DOM elements safely
  function $(id) {
    return document.getElementById(id);
  }

  // ========== PHYSICAL APPEARANCE SYSTEM ==========
  
  /**
   * Generate detailed, unique physical appearance for an employee
   * This creates a consistent description used across ALL image generation
   * @param {string} gender - The gender of the employee ('female', 'male', 'femaleFuta', 'transMan', 'transWoman')
   */
  function generateDetailedPhysicalAppearance(gender = 'female') {
    // Height & Build
    const heights = ['petite', 'short', 'average height', 'tall', 'very tall'];
    
    // Gender-specific builds
    let builds;
    if (gender === 'male' || gender === 'transMan') {
      builds = ['lean', 'slim', 'athletic', 'average', 'stocky', 'broad-shouldered', 'muscular', 'toned', 'sturdy', 'wiry'];
    } else {
      builds = ['slender', 'slim', 'athletic', 'average', 'curvy', 'voluptuous', 'muscular', 'toned'];
    }
    
    // Hair - detailed
    const hairColors = [
      'platinum blonde', 'golden blonde', 'honey blonde', 'ash blonde', 'strawberry blonde',
      'light brown', 'chestnut brown', 'dark brown', 'chocolate brown',
      'auburn', 'copper red', 'ginger', 'burgundy',
      'jet black', 'raven black', 'dark black with blue sheen',
      'silver-gray', 'salt and pepper'
    ];
    const hairStyles = [
      'straight', 'wavy', 'curly', 'tight curls', 'beach waves', 'loose curls',
      'pin-straight', 'naturally wavy', 'tousled', 'messy waves'
    ];
    const hairLengths = [
      'pixie cut', 'short bob', 'chin-length bob', 'shoulder-length', 
      'mid-back length', 'waist-length', 'very long'
    ];
    const hairTextures = ['fine', 'thick', 'medium', 'voluminous', 'silky'];
    
    // Eyes - very detailed
    const eyeColors = [
      'bright blue', 'deep blue', 'ocean blue', 'ice blue', 'steel blue',
      'emerald green', 'jade green', 'hazel green', 'olive green',
      'dark brown', 'amber brown', 'honey brown', 'chocolate brown',
      'hazel with green flecks', 'hazel with gold flecks',
      'gray', 'stormy gray', 'gray-blue',
      'unusual violet', 'heterochromic (one blue, one brown)'
    ];
    const eyeShapes = [
      'almond-shaped', 'round', 'hooded', 'upturned', 'downturned',
      'doe eyes', 'cat eyes', 'deep-set', 'wide-set', 'close-set'
    ];
    
    // Facial Features
    const faceShapes = ['oval', 'round', 'heart-shaped', 'square', 'diamond', 'long'];
    const noseTypes = [
      'button nose', 'straight nose', 'slightly upturned nose', 'roman nose',
      'ski-slope nose', 'aquiline nose', 'petite nose', 'prominent nose'
    ];
    const lipShapes = [
      'full lips', 'thin lips', 'heart-shaped lips', 'bow-shaped lips',
      'plump lips', 'pouty lips', 'balanced lips', 'wide lips'
    ];
    const cheekbones = [
      'high cheekbones', 'prominent cheekbones', 'soft cheekbones',
      'defined cheekbones', 'subtle cheekbones', 'angular cheekbones'
    ];
    const jawlines = [
      'soft jawline', 'defined jawline', 'strong jawline', 'delicate jawline',
      'angular jawline', 'rounded jawline', 'sharp jawline'
    ];
    
    // Skin
    const skinTones = [
      'porcelain', 'fair', 'light', 'light-medium', 'beige', 'olive',
      'tan', 'medium', 'golden brown', 'caramel', 'bronze',
      'deep brown', 'dark brown', 'ebony', 'rich mahogany'
    ];
    const skinTextures = [
      'smooth', 'flawless', 'clear', 'glowing', 'radiant',
      'matte', 'dewy', 'sun-kissed', 'naturally luminous'
    ];
    
    // Body Features - Gender-specific
    let bodyShapes, chestDescriptor, chestSizes, buttSizes;
    
    if (gender === 'male') {
      // Male body descriptions
      bodyShapes = ['athletic', 'lean', 'muscular', 'stocky', 'broad-shouldered', 'rectangular', 'V-shaped', 'swimmer\'s build'];
      chestDescriptor = 'chest'; // Male chest descriptor
      chestSizes = ['flat', 'toned', 'well-defined', 'muscular', 'broad', 'barrel-chested'];
      buttSizes = ['flat', 'toned', 'athletic', 'round', 'muscular'];
    } else if (gender === 'transMan') {
      // Trans man body descriptions (may have mixed characteristics)
      bodyShapes = ['athletic', 'lean', 'rectangular', 'androgynous', 'toned', 'muscular'];
      chestDescriptor = 'chest';
      chestSizes = ['flat', 'compact', 'athletic', 'toned', 'bound', 'masculine'];
      buttSizes = ['compact', 'toned', 'athletic', 'round', 'firm'];
    } else if (gender === 'femaleFuta') {
      // Female futa body descriptions (feminine with additional attributes)
      bodyShapes = ['hourglass', 'athletic', 'curvy', 'statuesque', 'amazonian', 'voluptuous', 'toned'];
      chestDescriptor = 'bust';
      chestSizes = ['medium', 'full', 'large', 'very full', 'impressive', 'ample'];
      buttSizes = ['round', 'full', 'curvy', 'prominent', 'shapely'];
    } else {
      // Female and trans woman body descriptions
      bodyShapes = ['hourglass', 'pear-shaped', 'athletic', 'rectangular', 'inverted triangle', 'petite hourglass', 'curvy', 'willowy', 'statuesque'];
      chestDescriptor = 'bust';
      chestSizes = ['small', 'modest', 'medium', 'full', 'large', 'very full'];
      buttSizes = ['small', 'modest', 'round', 'full', 'curvy', 'prominent'];
    }
    
    const legTypes = [
      'long legs', 'proportionate legs', 'toned legs', 'athletic legs',
      'shapely legs', 'slender legs', 'muscular legs'
    ];
    
    // Fashion Style
    const fashionStyles = [
      'business professional', 'smart casual', 'trendy', 'classic elegant',
      'minimalist chic', 'bohemian', 'edgy modern', 'preppy',
      'casual comfortable', 'sophisticated', 'artsy', 'sporty chic'
    ];
    const accessories = [
      'often wears glasses', 'statement earrings', 'delicate jewelry',
      'minimalist accessories', 'watches', 'scarves', 'no accessories'
    ];
    
    // Distinguishing Features
    const features = [
      'dimples when smiling', 'freckles across nose', 'beauty mark', 'gap-toothed smile',
      'striking eyes', 'expressive face', 'mysterious aura', 'warm smile',
      'confident posture', 'graceful movements', 'energetic presence', 'calm demeanor'
    ];
    
    // Random selection helper
    const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
    
    // Genital Information - Gender-specific
    let genitalType, genitalSize, genitalCharacteristics;
    
    if (gender === 'male') {
      genitalType = 'penis';
      genitalSize = pick(['small', 'average', 'above average', 'large', 'very large']);
      genitalCharacteristics = pick(['circumcised', 'uncircumcised', 'well-groomed', 'natural', 'trimmed']);
    } else if (gender === 'transMan') {
      genitalType = pick(['enlarged clitoris', 'post-op penis', 'pre-op anatomy']);
      genitalSize = genitalType === 'post-op penis' ? pick(['average', 'above average', 'large']) : pick(['small', 'moderate', 'prominent']);
      genitalCharacteristics = pick(['well-groomed', 'natural', 'trimmed', 'maintained']);
    } else if (gender === 'femaleFuta') {
      genitalType = 'penis and vagina';
      genitalSize = pick(['average', 'above average', 'large', 'very large', 'impressive']);
      genitalCharacteristics = pick(['circumcised', 'uncircumcised', 'well-groomed', 'natural', 'dual anatomy']);
    } else if (gender === 'transWoman') {
      genitalType = pick(['vagina (post-op)', 'penis (pre-op)', 'tucked']);
      genitalSize = genitalType.includes('penis') ? pick(['small', 'average', 'above average']) : pick(['tight', 'normal', 'accommodating']);
      genitalCharacteristics = pick(['well-groomed', 'laser-treated', 'smooth', 'maintained', 'natural']);
    } else {
      // Female
      genitalType = 'vagina';
      genitalSize = pick(['tight', 'normal', 'accommodating', 'petite', 'average']);
      genitalCharacteristics = pick(['well-groomed', 'waxed', 'trimmed', 'natural', 'shaved', 'landing strip']);
    }
    
    // Build the complete physical profile
    const height = pick(heights);
    const build = pick(builds);
    const hairColor = pick(hairColors);
    const hairStyle = pick(hairStyles);
    const hairLength = pick(hairLengths);
    const hairTexture = pick(hairTextures);
    const eyeColor = pick(eyeColors);
    const eyeShape = pick(eyeShapes);
    const faceShape = pick(faceShapes);
    const noseType = pick(noseTypes);
    const lipShape = pick(lipShapes);
    const cheekbone = pick(cheekbones);
    const jawline = pick(jawlines);
    const skinTone = pick(skinTones);
    const skinTexture = pick(skinTextures);
    const bodyShape = pick(bodyShapes);
    const chestSize = pick(chestSizes);
    const buttSize = pick(buttSizes);
    const legType = pick(legTypes);
    const fashionStyle = pick(fashionStyles);
    const accessory = pick(accessories);
    const feature = pick(features);
    
    // Gender-appropriate pronouns and descriptors
    const genderPronoun = (gender === 'male' || gender === 'transMan') ? 'man' : 'woman';
    const bodyDescriptor = `${bodyShape} physique with ${chestDescriptor === 'chest' ? chestSize + ' chest' : chestSize + ' ' + chestDescriptor}, ${buttSize} bottom, ${legType}`;
    
    return {
      // Basic
      height,
      build,
      gender,
      heightBuild: `${height}, ${build} build`,
      
      // Hair (detailed)
      hair: {
        color: hairColor,
        style: hairStyle,
        length: hairLength,
        texture: hairTexture,
        full: `${hairLength} ${hairTexture} ${hairColor} hair, ${hairStyle}`
      },
      
      // Eyes (detailed)
      eyes: {
        color: eyeColor,
        shape: eyeShape,
        full: `${eyeShape} ${eyeColor} eyes`
      },
      
      // Face (detailed)
      face: {
        shape: faceShape,
        nose: noseType,
        lips: lipShape,
        cheekbones: cheekbone,
        jawline: jawline,
        full: `${faceShape} face with ${noseType}, ${lipShape}, ${cheekbone}, ${jawline}`
      },
      
      // Skin (detailed)
      skin: {
        tone: skinTone,
        texture: skinTexture,
        full: `${skinTexture} ${skinTone} skin`
      },
      
      // Body (detailed) - Gender-appropriate
      body: {
        shape: bodyShape,
        chestDescriptor: chestDescriptor,
        chestSize: chestSize,
        breastSize: chestSize, // Kept for backwards compatibility
        buttSize: buttSize,
        legs: legType,
        full: bodyDescriptor
      },
      
      // Genital Information (detailed) - Gender-specific
      genitals: {
        type: genitalType,
        size: genitalSize,
        characteristics: genitalCharacteristics,
        full: `${genitalSize} ${genitalType}, ${genitalCharacteristics}`
      },
      
      // Style & Features
      fashion: fashionStyle,
      accessories: accessory,
      distinguishingFeature: feature,
      
      // Complete description for AI prompts - Gender-appropriate
      shortDescription: `${height} ${build} ${genderPronoun} with ${hairLength} ${hairColor} hair, ${eyeColor} eyes, ${skinTone} skin`,
      
      fullDescription: `${height} ${build} ${genderPronoun} with ${hairLength} ${hairTexture} ${hairColor} hair (${hairStyle}), ${eyeShape} ${eyeColor} eyes, ${skinTexture} ${skinTone} skin. ${faceShape} face with ${noseType}, ${lipShape}, ${cheekbone}, ${jawline}. ${bodyDescriptor}. Genitals: ${genitalSize} ${genitalType}, ${genitalCharacteristics}. ${feature}. Style: ${fashionStyle}, ${accessory}.`
    };
  }
  
  /**
   * Get consistent physical description for image prompts
   * Returns a prompt-ready string describing the employee's appearance
   */
  function getPhysicalDescriptionForPrompt(employee) {
    if (!employee.physical) {
      employee.physical = generateDetailedPhysicalAppearance(employee.gender || 'female');
    }
    
    // If old format, upgrade it
    if (!employee.physical.fullDescription) {
      employee.physical = generateDetailedPhysicalAppearance(employee.gender || 'female');
    }
    
    // Return full description for maximum body context in image generation
    return employee.physical.fullDescription;
  }

  // ========== RELATIONSHIP & COMPANY AWARENESS SYSTEM ==========
  
  /**
   * Update or create relationship between two employees
   */
  function updateRelationship(employeeId1, employeeId2, interaction) {
    const emp1 = gameState.employees.find(e => e.id === employeeId1);
    const emp2 = gameState.employees.find(e => e.id === employeeId2);
    
    if (!emp1 || !emp2) return;
    
    initializeEmployeeSocialData(emp1);
    initializeEmployeeSocialData(emp2);
    
    // Update emp1's relationship with emp2
    if (!emp1.relationships[employeeId2]) {
      emp1.relationships[employeeId2] = createRelationship({ targetId: employeeId2 });
    }
    
    const rel1 = emp1.relationships[employeeId2];
    rel1.strength = Math.max(0, Math.min(100, rel1.strength + (interaction.impact || 0)));
    rel1.lastInteraction = Date.now();
    rel1.history.push({
      timestamp: Date.now(),
      event: interaction.event || 'interaction',
      impact: interaction.impact || 0
    });
    
    // Limit history size
    if (rel1.history.length > 50) {
      rel1.history = rel1.history.slice(-50);
    }
    
    // Update relationship type based on strength and history
    if (interaction.impact > 0) rel1.positiveInteractions++;
    if (interaction.impact < 0) rel1.conflicts++;
    
    // Auto-update relationship type based on strength
    if (rel1.strength > 80) {
      rel1.type = rel1.type === 'crush' ? 'romantic' : 'best_friend';
    } else if (rel1.strength > 60) {
      rel1.type = rel1.type === 'crush' || rel1.type === 'romantic' ? rel1.type : 'friend';
    } else if (rel1.strength < 30) {
      rel1.type = 'rival';
    } else if (rel1.strength < 20) {
      rel1.type = 'enemy';
    }
    
    // Mirror relationship for emp2 (with slight variation to feel natural)
    if (!emp2.relationships[employeeId1]) {
      emp2.relationships[employeeId1] = createRelationship({ targetId: employeeId1 });
    }
    
    const rel2 = emp2.relationships[employeeId1];
    const mirroreImpact = interaction.impact * (0.8 + Math.random() * 0.4); // 80-120% of original impact
    rel2.strength = Math.max(0, Math.min(100, rel2.strength + mirroreImpact));
    rel2.lastInteraction = Date.now();
    rel2.history.push({
      timestamp: Date.now(),
      event: interaction.event || 'interaction',
      impact: mirroreImpact
    });
    
    if (rel2.history.length > 50) {
      rel2.history = rel2.history.slice(-50);
    }
    
    if (mirroreImpact > 0) rel2.positiveInteractions++;
    if (mirroreImpact < 0) rel2.conflicts++;
    
    // Update relationship type
    if (rel2.strength > 80) {
      rel2.type = rel2.type === 'crush' ? 'romantic' : 'best_friend';
    } else if (rel2.strength > 60) {
      rel2.type = rel2.type === 'crush' || rel2.type === 'romantic' ? rel2.type : 'friend';
    } else if (rel2.strength < 30) {
      rel2.type = 'rival';
    } else if (rel2.strength < 20) {
      rel2.type = 'enemy';
    }
  }
  
  /**
   * Generate random relationships between existing employees
   * Called when new employee joins or periodically to evolve relationships
   */
  function generateRandomRelationships(newEmployeeId = null) {
    const employees = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    if (employees.length < 2) return;
    
    // If new employee, create relationships with existing employees
    if (newEmployeeId) {
      const newEmp = employees.find(e => e.id === newEmployeeId);
      if (!newEmp) return;
      
      employees.forEach(emp => {
        if (emp.id === newEmployeeId) return;
        
        // Calculate relationship based on shared traits, location, etc.
        let initialStrength = 40 + Math.random() * 20; // 40-60 baseline
        
        // Same location bonus
        if (emp.locationId === newEmp.locationId) {
          initialStrength += 10;
        }
        
        // Shared hobbies bonus
        const sharedHobbies = (emp.hobbies || []).filter(h => (newEmp.hobbies || []).includes(h));
        initialStrength += sharedHobbies.length * 5;
        
        // Personality compatibility (simplistic)
        if (emp.personality === newEmp.personality) {
          initialStrength += Math.random() * 10;
        }
        
        // Random chance of instant crush (5% chance)
        let relType = 'neutral';
        if (Math.random() < 0.05) {
          relType = 'crush';
          initialStrength += 15;
        }
        
        updateRelationship(newEmployeeId, emp.id, {
          event: 'initial_meeting',
          impact: initialStrength - 50 // Adjust from baseline
        });
        
        if (relType === 'crush') {
          newEmp.relationships[emp.id].type = 'crush';
        }
      });
    } else {
      // Periodically evolve existing relationships
      for (let i = 0; i < employees.length - 1; i++) {
        for (let j = i + 1; j < employees.length; j++) {
          // 30% chance to have an interaction
          if (Math.random() > 0.3) continue;
          
          const emp1 = employees[i];
          const emp2 = employees[j];
          
          // Random interaction
          const impact = (Math.random() - 0.4) * 10; // -4 to +6 (slightly positive bias)
          updateRelationship(emp1.id, emp2.id, {
            event: 'background_interaction',
            impact
          });
        }
      }
    }
  }
  
  /**
   * Update company-wide awareness data
   * Should be called whenever employees change
   */
  function updateCompanyAwareness() {
    const active = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    gameState.companyContext.totalEmployees = active.length;
    
    // Count employees per location
    gameState.companyContext.locationEmployeeCounts = {};
    active.forEach(emp => {
      const loc = emp.locationId || 'garage';
      gameState.companyContext.locationEmployeeCounts[loc] = 
        (gameState.companyContext.locationEmployeeCounts[loc] || 0) + 1;
    });
    
    // Update each employee's awareness
    active.forEach(emp => {
      initializeEmployeeSocialData(emp);
      
      // They know all employees
      emp.awareness.knowsCoworkers = active
        .filter(e => e.id !== emp.id)
        .map(e => e.id);
      
      // They know all unlocked locations
      emp.awareness.knowsLocations = gameState.locations
        .filter(loc => loc.unlocked)
        .map(loc => loc.id);
      
      // Company knowledge
      emp.awareness.companyKnowledge = {
        totalEmployees: active.length,
        lastUpdated: Date.now()
      };
      
      // Mark which coworkers are in same location
      active.forEach(other => {
        if (other.id === emp.id) return;
        if (!emp.relationships[other.id]) {
          emp.relationships[other.id] = createRelationship({ targetId: other.id });
        }
        emp.relationships[other.id].sharedLocation = (emp.locationId === other.locationId);
        
        // Check shared interests
        const sharedHobbies = (emp.hobbies || []).filter(h => (other.hobbies || []).includes(h));
        emp.relationships[other.id].sharedInterests = sharedHobbies;
      });
    });
  }
  
  /**
   * Log a company event
   */
  function logCompanyEvent(eventData) {
    const event = createEvent(eventData);
    gameState.socialNetwork.globalEvents.push(event);
    
    // Keep only recent events (last 100)
    if (gameState.socialNetwork.globalEvents.length > 100) {
      gameState.socialNetwork.globalEvents = gameState.socialNetwork.globalEvents.slice(-100);
    }
    
    return event;
  }
  
  /**
   * Get recent events relevant to an employee
   */
  function getRelevantEvents(employeeId, limit = 10) {
    return gameState.socialNetwork.globalEvents
      .filter(event => 
        event.involvedEmployees.includes(employeeId) || 
        event.importance >= 7 // High importance events relevant to all
      )
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, limit);
  }
  
  /**
   * Get context about coworkers for an employee
   * Used when generating posts or content that references others
   */
  function getCoworkerContext(employeeId) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return '';
    
    initializeEmployeeSocialData(emp);
    
    const coworkers = gameState.employees.filter(e => 
      e.employmentStatus === 'active' && 
      e.id !== employeeId
    );
    
    const sameLocation = coworkers.filter(e => e.locationId === emp.locationId);
    
    let context = `${emp.name} works at ${emp.locationId || 'garage'} with ${sameLocation.length} coworkers. `;
    context += `The company has ${gameState.companyContext.totalEmployees} total employees. `;
    
    // Mention notable relationships
    const relationships = Object.entries(emp.relationships || {})
      .map(([targetId, rel]) => {
        const target = coworkers.find(e => e.id === targetId);
        if (!target) return null;
        
        if (rel.type === 'best_friend') {
          return `Best friend: ${target.name}`;
        } else if (rel.type === 'crush') {
          return `Has a crush on: ${target.name}`;
        } else if (rel.type === 'romantic') {
          return `In a relationship with: ${target.name}`;
        } else if (rel.type === 'rival') {
          return `Rival: ${target.name}`;
        }
        return null;
      })
      .filter(Boolean);
    
    if (relationships.length > 0) {
      context += `Relationships: ${relationships.join(', ')}. `;
    }
    
    return context;
  }
  
  /**
   * Get detailed awareness context for post generation
   * Returns comprehensive info about employee's social environment
   */
  function getEmployeeAwarenessForPost(employeeId) {
    // Handle if object is passed instead of ID
    if (typeof employeeId === 'object' && employeeId.id) {
      employeeId = employeeId.id;
    }
    
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return null;
    
    initializeEmployeeSocialData(emp);
    
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active' && e.id !== employeeId);
    const sameLocation = activeEmployees.filter(e => e.locationId === emp.locationId);
    const otherLocations = activeEmployees.filter(e => e.locationId !== emp.locationId);
    
    // Get relationship breakdown
    const relationships = {
      bestFriends: [],
      friends: [],
      crushes: [],
      romantic: [],
      rivals: [],
      enemies: [],
      neutral: []
    };
    
    // Build coworkers array for context (combines all relationships)
    const coworkers = [];
    
    Object.entries(emp.relationships || {}).forEach(([targetId, rel]) => {
      const target = activeEmployees.find(e => e.id === targetId);
      if (!target) return;
      
      const relData = {
        id: target.id,
        name: target.name,
        position: target.position,
        location: target.locationId,
        strength: rel.strength,
        sameLocation: rel.sharedLocation,
        sharedInterests: rel.sharedInterests
      };
      
      if (rel.type === 'best_friend') relationships.bestFriends.push(relData);
      else if (rel.type === 'friend') relationships.friends.push(relData);
      else if (rel.type === 'crush') relationships.crushes.push(relData);
      else if (rel.type === 'romantic') relationships.romantic.push(relData);
      else if (rel.type === 'rival') relationships.rivals.push(relData);
      else if (rel.type === 'enemy') relationships.enemies.push(relData);
      else relationships.neutral.push(relData);
      
      // Add to coworkers array for generateOrganicPost
      coworkers.push({
        coworkerId: target.id,
        coworkerName: target.name,
        relationship: rel.type || 'neutral',
        knownFor: target.position,
        strength: rel.strength
      });
    });
    
    // Get recent events involving this employee
    const recentEvents = getRelevantEvents(employeeId, 5);
    
    // Build known locations array
    const knownLocations = [emp.locationId || 'headquarters'];
    
    // Get recent chat history with boss (last 5 messages within 2 hours)
    const chatHistory = gameState.chatHistory[emp.id] || [];
    const twoHoursAgo = Date.now() - (2 * 60 * 60 * 1000);
    const recentChats = chatHistory
      .filter(msg => (msg.timestamp || 0) > twoHoursAgo)
      .slice(-5); // Last 5 messages within 2 hours
    
    // Summarize chat topics/themes for context
    let chatContext = null;
    if (recentChats.length >= 2) { // Only include if there's meaningful conversation
      const chatText = recentChats.map(msg => msg.content).join(' ');
      
      // Detect conversation themes
      const themes = [];
      if (/\b(flirt|sexy|hot|beautiful|cute|attractive|date|kiss|touch)\b/i.test(chatText)) {
        themes.push('flirty/romantic');
      }
      if (/\b(project|deadline|work|meeting|report|task|client)\b/i.test(chatText)) {
        themes.push('work-related');
      }
      if (/\b(tired|busy|stressed|excited|happy|sad|frustrated)\b/i.test(chatText)) {
        themes.push('emotional/personal');
      }
      if (/\b(lunch|dinner|coffee|drink|food|eat)\b/i.test(chatText)) {
        themes.push('food/social');
      }
      
      chatContext = {
        hasRecentChat: true,
        messageCount: recentChats.length,
        themes: themes,
        lastMessages: recentChats.slice(-3).map(msg => ({
          sender: msg.sender,
          preview: msg.content.slice(0, 100) // First 100 chars
        })),
        timeAgo: Math.round((Date.now() - (recentChats[recentChats.length - 1]?.timestamp || 0)) / (60 * 1000)) // minutes
      };
    }
    
    return {
      employee: {
        id: emp.id,
        name: emp.name,
        position: emp.position,
        location: emp.locationId,
        gender: emp.gender || 'Female',
        age: emp.age,
        physicalDescription: getPhysicalDescriptionForPrompt(emp), // Full physical awareness including genitals
        personality: emp.personalityTraits || emp.personality,
        hobbies: emp.hobbies || [],
        stats: emp.stats
      },
      workplace: {
        totalEmployees: gameState.companyContext.totalEmployees,
        locationCoworkers: sameLocation.length,
        sameLocationNames: sameLocation.map(e => e.name),
        otherLocationEmployees: otherLocations.length,
        locations: Object.keys(gameState.companyContext.locationEmployeeCounts)
      },
      relationships,
      coworkers: coworkers, // ← Added for generateOrganicPost
      knownLocations: knownLocations, // ← Added for generateOrganicPost
      recentEvents,
      chatContext, // ← NEW: Recent conversation context with boss
      socialProfile: emp.social
    };
  }
  
  /**
   * Get a random coworker with specific relationship type
   */
  function getRandomCoworkerByRelation(employeeId, relationType = null) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return null;
    
    initializeEmployeeSocialData(emp);
    
    const candidates = Object.entries(emp.relationships || {})
      .filter(([targetId, rel]) => {
        if (relationType && rel.type !== relationType) return false;
        const target = gameState.employees.find(e => e.id === targetId && e.employmentStatus === 'active');
        return !!target;
      })
      .map(([targetId]) => gameState.employees.find(e => e.id === targetId));
    
    if (candidates.length === 0) return null;
    
    return candidates[Math.floor(Math.random() * candidates.length)];
  }
  
  /**
   * Get employees at same location
   */
  function getLocationCoworkers(employeeId) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return [];
    
    return gameState.employees.filter(e => 
      e.employmentStatus === 'active' &&
      e.id !== employeeId &&
      e.locationId === emp.locationId
    );
  }
  
  /**
   * Get all locations employee knows about
   */
  function getKnownLocations(employeeId) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return [];
    
    initializeEmployeeSocialData(emp);
    
    return gameState.locations
      .filter(loc => emp.awareness.knowsLocations.includes(loc.id))
      .map(loc => ({
        id: loc.id,
        name: loc.name,
        employeeCount: gameState.companyContext.locationEmployeeCounts[loc.id] || 0
      }));
  }
  
  /**
   * Check if employee should know about another employee
   */
  function knowsEmployee(employeeId, targetId) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return false;
    
    initializeEmployeeSocialData(emp);
    
    return emp.awareness.knowsCoworkers.includes(targetId);
  }

  // ========== GOSSIPENGINE™ - NPC INTERPERSONAL DYNAMICS SYSTEM ==========
  
  /**
   * Initialize gossip system for an employee
   */
  function initializeGossipSystem(employee) {
    if (!employee.gossip) {
      employee.gossip = {
        knownGossip: [], // Array of gossip items they know
        lastGossipTime: 0, // When they last gossiped
        gossipTendency: 30 + Math.random() * 50, // 30-80, how likely they are to gossip
        trustworthiness: 20 + Math.random() * 60, // 20-80, how accurately they relay info
      };
    }
    
    if (!employee.recentSimulatedEvents) {
      employee.recentSimulatedEvents = []; // Events that "happened" off-screen
    }
    
    return employee;
  }
  
  /**
   * Gossip Item Structure
   * Represents a piece of information that spreads between NPCs
   */
  function createGossipItem({
    id = `gossip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    type, // 'hookup', 'fight', 'crush', 'promotion', 'scandal', 'rumor', 'friendship', 'breakup'
    subjectId, // Main person the gossip is about
    targetId = null, // Secondary person (for relationship gossip)
    content, // The actual gossip content
    truthLevel = 100, // 0-100, how accurate this is (rumors degrade)
    juiciness = 50, // 0-100, how interesting/scandalous
    spreadCount = 0, // How many people know about it
    originatorId, // Who started the gossip
    timestamp = Date.now(),
    expiresAt = Date.now() + (7 * 86400000), // Gossip expires after 7 days
    tags = [] // ['romantic', 'work', 'scandal', etc.]
  } = {}) {
    return {
      id, type, subjectId, targetId, content, truthLevel, juiciness,
      spreadCount, originatorId, timestamp, expiresAt, tags
    };
  }
  
  /**
   * Simulated Event Structure
   * Things that "happened" when player wasn't looking
   */
  function createSimulatedEvent({
    id = `simevent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    type, // 'hookup', 'date', 'argument', 'lunch', 'drinks', 'project', 'gossip_session'
    participants, // Array of employee IDs involved
    location, // Where it happened
    description, // Brief description
    outcome, // 'positive', 'negative', 'neutral', 'dramatic'
    relationshipImpacts = [], // [{ employeeId1, employeeId2, change }]
    generatesGossip = true,
    timestamp = Date.now(),
    witnessed = [] // Employee IDs who "saw" it happen
  } = {}) {
    return {
      id, type, participants, location, description, outcome,
      relationshipImpacts, generatesGossip, timestamp, witnessed
    };
  }
  
  /**
   * Generate random off-screen events between NPCs
   * Called periodically to simulate office life
   */
  function simulateOfficeEvents() {
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (activeEmployees.length < 2) return;
    
    // Chance to generate event: 15% per check (called every 15 minutes)
    if (Math.random() > 0.15) return;
    
    // Select random participants (2-3 people)
    const participantCount = Math.random() < 0.7 ? 2 : 3;
    const participants = [];
    
    while (participants.length < participantCount && participants.length < activeEmployees.length) {
      const emp = activeEmployees[Math.floor(Math.random() * activeEmployees.length)];
      if (!participants.find(p => p.id === emp.id)) {
        participants.push(emp);
      }
    }
    
    if (participants.length < 2) return;
    
    // Determine event type based on relationships
    const emp1 = participants[0];
    const emp2 = participants[1];
    const rel = emp1.relationships?.[emp2.id];
    const relStrength = rel?.strength || 50;
    const relType = rel?.type || 'neutral';
    
    let eventType, description, outcome, relationshipImpacts = [];
    
    // Event type selection based on relationship
    if (relType === 'romantic' && Math.random() < 0.3) {
      eventType = 'date';
      const locations = ['coffee shop', 'nice restaurant', 'the park', 'downtown'];
      const location = locations[Math.floor(Math.random() * locations.length)];
      description = `${emp1.name} and ${emp2.name} went on a date to ${location}`;
      outcome = Math.random() < 0.8 ? 'positive' : 'neutral';
      relationshipImpacts = [{ 
        employeeId1: emp1.id, 
        employeeId2: emp2.id, 
        change: Math.random() < 0.8 ? 5 + Math.floor(Math.random() * 10) : -5 
      }];
    } else if (relType === 'crush' && Math.random() < 0.4) {
      eventType = 'hookup';
      const locations = ['supply closet', 'empty office', 'their apartment', 'parking garage'];
      const location = locations[Math.floor(Math.random() * locations.length)];
      description = `${emp1.name} and ${emp2.name} hooked up in ${location}`;
      outcome = 'dramatic';
      relationshipImpacts = [{
        employeeId1: emp1.id,
        employeeId2: emp2.id,
        change: 15 + Math.floor(Math.random() * 20)
      }];
      // Upgrade relationship
      if (rel) {
        rel.type = Math.random() < 0.6 ? 'romantic' : 'friends_with_benefits';
        rel.strength = Math.min(100, rel.strength + 20);
      }
    } else if ((relType === 'rival' || relType === 'enemy') && Math.random() < 0.5) {
      eventType = 'argument';
      const reasons = ['work project', 'personal issue', 'office gossip', 'petty disagreement'];
      const reason = reasons[Math.floor(Math.random() * reasons.length)];
      description = `${emp1.name} and ${emp2.name} had a heated argument about ${reason}`;
      outcome = 'negative';
      relationshipImpacts = [{
        employeeId1: emp1.id,
        employeeId2: emp2.id,
        change: -10 - Math.floor(Math.random() * 15)
      }];
    } else {
      // Neutral social events
      const eventTypes = [
        { type: 'lunch', desc: 'had lunch together at', outcome: 'positive', impact: 3 },
        { type: 'drinks', desc: 'grabbed drinks after work at', outcome: 'positive', impact: 5 },
        { type: 'project', desc: 'worked together on a project', outcome: 'neutral', impact: 2 },
        { type: 'gossip_session', desc: 'had a long gossip session about the office', outcome: 'neutral', impact: 4 },
        { type: 'coffee', desc: 'got coffee together', outcome: 'positive', impact: 2 }
      ];
      
      const chosen = eventTypes[Math.floor(Math.random() * eventTypes.length)];
      eventType = chosen.type;
      outcome = chosen.outcome;
      
      if (chosen.type === 'gossip_session') {
        description = `${emp1.name} and ${emp2.name} ${chosen.desc}`;
      } else {
        const locations = ['the local café', 'Murphy\'s Bar', 'that new place downtown'];
        description = `${emp1.name} and ${emp2.name} ${chosen.desc} ${chosen.type === 'project' ? '' : locations[Math.floor(Math.random() * locations.length)]}`;
      }
      
      relationshipImpacts = [{
        employeeId1: emp1.id,
        employeeId2: emp2.id,
        change: chosen.impact + Math.floor(Math.random() * 3)
      }];
    }
    
    // Determine who witnessed it (0-3 random employees at same location)
    const location = emp1.locationId || 'headquarters';
    const potentialWitnesses = activeEmployees.filter(e => 
      e.locationId === location && 
      !participants.find(p => p.id === e.id)
    );
    const witnessCount = Math.floor(Math.random() * Math.min(4, potentialWitnesses.length + 1));
    const witnessed = [];
    for (let i = 0; i < witnessCount; i++) {
      const witness = potentialWitnesses[Math.floor(Math.random() * potentialWitnesses.length)];
      if (witness && !witnessed.includes(witness.id)) {
        witnessed.push(witness.id);
      }
    }
    
    // Create the event
    const event = createSimulatedEvent({
      type: eventType,
      participants: participants.map(p => p.id),
      location,
      description,
      outcome,
      relationshipImpacts,
      witnessed
    });
    
    // Apply relationship impacts
    relationshipImpacts.forEach(impact => {
      updateRelationship(impact.employeeId1, impact.employeeId2, {
        event: eventType,
        impact: impact.change
      });
    });
    
    // Store event for participants
    participants.forEach(emp => {
      initializeGossipSystem(emp);
      emp.recentSimulatedEvents.push(event);
      if (emp.recentSimulatedEvents.length > 10) {
        emp.recentSimulatedEvents = emp.recentSimulatedEvents.slice(-10);
      }
    });
    
    // Create gossip if event is juicy enough
    if (event.generatesGossip && (eventType === 'hookup' || eventType === 'argument' || eventType === 'date')) {
      const juiciness = eventType === 'hookup' ? 80 : eventType === 'argument' ? 60 : 50;
      
      const gossipContent = description;
      const gossip = createGossipItem({
        type: eventType,
        subjectId: emp1.id,
        targetId: emp2.id,
        content: gossipContent,
        juiciness,
        originatorId: witnessed.length > 0 ? witnessed[0] : emp1.id,
        tags: [outcome, 'simulated']
      });
      
      // Witnesses know about it immediately
      witnessed.forEach(witnessId => {
        const witness = activeEmployees.find(e => e.id === witnessId);
        if (witness) {
          initializeGossipSystem(witness);
          witness.gossip.knownGossip.push({
            gossipId: gossip.id,
            learnedAt: Date.now(),
            source: 'witnessed',
            accuracy: 100
          });
        }
      });
      
      // Store gossip globally
      if (!gameState.socialNetwork.activeGossip) {
        gameState.socialNetwork.activeGossip = [];
      }
      gameState.socialNetwork.activeGossip.push(gossip);
      
      // Trigger gossip spread after a delay
      setTimeout(() => spreadGossip(gossip.id), 5000 + Math.random() * 10000);
    }
    
    console.log(`[GossipEngine] Simulated event: ${description}`);
  }
  
  /**
   * Spread gossip between NPCs
   */
  function spreadGossip(gossipId) {
    const gossip = gameState.socialNetwork.activeGossip?.find(g => g.id === gossipId);
    if (!gossip) return;
    
    // Find who knows about this gossip
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    const knowers = activeEmployees.filter(emp => {
      initializeGossipSystem(emp);
      return emp.gossip.knownGossip.some(g => g.gossipId === gossipId);
    });
    
    if (knowers.length === 0) return;
    
    // Each knower has a chance to spread it
    knowers.forEach(knower => {
      initializeGossipSystem(knower);
      
      // Check if they're a gossip
      if (Math.random() * 100 > knower.gossip.gossipTendency) return;
      
      // Find someone to tell (friend or coworker)
      const potentialListeners = activeEmployees.filter(emp => {
        if (emp.id === knower.id) return false;
        initializeGossipSystem(emp);
        // Don't tell if they already know
        if (emp.gossip.knownGossip.some(g => g.gossipId === gossipId)) return false;
        
        // More likely to tell friends or coworkers at same location
        const rel = knower.relationships?.[emp.id];
        const sameLoc = knower.locationId === emp.locationId;
        return sameLoc || (rel && ['friend', 'best_friend'].includes(rel.type));
      });
      
      if (potentialListeners.length === 0) return;
      
      const listener = potentialListeners[Math.floor(Math.random() * potentialListeners.length)];
      
      // Calculate accuracy degradation (like telephone game)
      const knowerAccuracy = knower.gossip.knownGossip.find(g => g.gossipId === gossipId)?.accuracy || 100;
      const trustFactor = knower.gossip.trustworthiness / 100;
      const newAccuracy = Math.max(0, Math.floor(knowerAccuracy * trustFactor * (0.85 + Math.random() * 0.15)));
      
      // Listener learns the gossip
      listener.gossip.knownGossip.push({
        gossipId: gossip.id,
        learnedAt: Date.now(),
        source: knower.id,
        accuracy: newAccuracy
      });
      
      gossip.spreadCount++;
      
      console.log(`[GossipEngine] ${knower.name} told ${listener.name} about: ${gossip.content} (accuracy: ${newAccuracy}%)`);
    });
  }
  
  /**
   * Get gossip that an employee knows about
   */
  function getKnownGossip(employeeId, limit = 5) {
    const emp = gameState.employees.find(e => e.id === employeeId);
    if (!emp) return [];
    
    initializeGossipSystem(emp);
    
    const now = Date.now();
    const allGossip = gameState.socialNetwork.activeGossip || [];
    
    // Filter to gossip they know that hasn't expired
    const knownGossipItems = emp.gossip.knownGossip
      .map(kg => {
        const gossip = allGossip.find(g => g.id === kg.gossipId);
        if (!gossip || gossip.expiresAt < now) return null;
        return { ...gossip, learnedAt: kg.learnedAt, accuracy: kg.accuracy, source: kg.source };
      })
      .filter(Boolean)
      .sort((a, b) => b.juiciness - a.juiciness) // Sort by juiciness
      .slice(0, limit);
    
    return knownGossipItems;
  }
  
  /**
   * Generate gossip about player's actions
   * Called when player does something noteworthy with an NPC
   */
  function createPlayerGossip({ type, npcId, description, juiciness = 50 }) {
    const npc = gameState.employees.find(e => e.id === npcId);
    if (!npc) return;
    
    initializeGossipSystem(npc);
    
    const gossip = createGossipItem({
      type,
      subjectId: 'player',
      targetId: npcId,
      content: description,
      juiciness,
      originatorId: npcId,
      tags: ['player_action']
    });
    
    // NPC knows about it (obviously)
    npc.gossip.knownGossip.push({
      gossipId: gossip.id,
      learnedAt: Date.now(),
      source: 'personal_experience',
      accuracy: 100
    });
    
    // Store globally
    if (!gameState.socialNetwork.activeGossip) {
      gameState.socialNetwork.activeGossip = [];
    }
    gameState.socialNetwork.activeGossip.push(gossip);
    
    // NPC might tell others based on their gossip tendency and the juiciness
    if (npc.gossip.gossipTendency > 40 || juiciness > 70) {
      setTimeout(() => spreadGossip(gossip.id), 3000 + Math.random() * 7000);
    }
    
    console.log(`[GossipEngine] Created player gossip: ${description}`);
  }
  
  /**
   * Get gossip context for chat/posts
   * Returns formatted string with gossip the NPC knows
   */
  function getGossipContext(employeeId, includePlayerGossip = true) {
    const knownGossip = getKnownGossip(employeeId, 3);
    if (knownGossip.length === 0) return '';
    
    let context = '\n\nRECENT GOSSIP YOU KNOW ABOUT:\n';
    
    knownGossip.forEach(gossip => {
      // Skip player gossip if not requested
      if (!includePlayerGossip && gossip.subjectId === 'player') return;
      
      const subject = gossip.subjectId === 'player' ? 'the boss' : 
                     gameState.employees.find(e => e.id === gossip.subjectId)?.name || 'someone';
      
      const target = gossip.targetId ? 
                    (gossip.targetId === 'player' ? 'the boss' : 
                     gameState.employees.find(e => e.id === gossip.targetId)?.name || 'someone') : '';
      
      const accuracy = gossip.accuracy < 50 ? ' (but this might be a rumor)' : 
                      gossip.accuracy < 80 ? ' (heard through the grapevine)' : '';
      
      context += `- ${gossip.content}${accuracy}\n`;
    });
    
    context += '\nYou can reference this gossip naturally in conversation if relevant!\n';
    
    return context;
  }
  
  /**
   * Cleanup expired gossip
   */
  function cleanupExpiredGossip() {
    if (!gameState.socialNetwork.activeGossip) return;
    
    const now = Date.now();
    const before = gameState.socialNetwork.activeGossip.length;
    
    gameState.socialNetwork.activeGossip = gameState.socialNetwork.activeGossip
      .filter(g => g.expiresAt > now);
    
    const removed = before - gameState.socialNetwork.activeGossip.length;
    if (removed > 0) {
      console.log(`[GossipEngine] Cleaned up ${removed} expired gossip items`);
    }
  }

  // -------- NPC MEMORY & DIALOGUE HELPERS (professional-grade) --------
  // Lightweight tokenization
  function tokenize(text) {
    return (text || '')
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, ' ')
      .split(/\s+/)
      .filter(Boolean);
  }

  // Extract main topics from a message for anti-repetition tracking
  function extractTopics(message, emp) {
    const topics = [];
    const m = message.toLowerCase();
    
    // Check for job/work mentions
    if (emp.productManaged && m.includes(emp.productManaged.toLowerCase())) {
      topics.push('job_specific');
    }
    if (emp.position && m.includes(emp.position.toLowerCase())) {
      topics.push('job_title');
    }
    if (/\b(work|job|task|project|deadline)\b/.test(m)) {
      topics.push('work_general');
    }
    
    // Check for hobby mentions
    (emp.hobbies || []).forEach(h => {
      if (m.includes(h.toLowerCase())) topics.push(`hobby_${h}`);
    });
    
    // Check for relationship topics
    if (/\b(date|dinner|coffee|drinks|hang out)\b/.test(m)) topics.push('social_invite');
    if (/\b(flirt|cute|hot|sexy|attractive)\b/.test(m)) topics.push('flirting');
    if (/\b(kiss|touch|intimate|physical)\b/.test(m)) topics.push('physical');
    if (/\b(love|feel|emotion|heart)\b/.test(m)) topics.push('emotional');
    
    return topics;
  }

  // Ensure structured memory on employee (back-compat from array of strings)
  function ensureEmployeeMemory(emp) {
    if (!emp) return;
    if (!emp.memory || Array.isArray(emp.memory)) {
      const prev = Array.isArray(emp.memory) ? emp.memory : [];
      emp.memory = { 
        items: [], 
        cap: 300, // Increased to 300 for extensive long-term memory
        styleCounters: { 
          total: 0, 
          sincePersonal: 99,
          recentTopics: [], // track last 10 topics mentioned
          jobMentions: 0,
          hobbyMentions: 0,
          lastJobMention: 0,
          lastHobbyMention: 0
        },
        conversationPhase: 'early', // early, familiar, intimate
        intimacyLevel: 0 // 0-100 scale
      };
      // ingest old strings as low-importance notes
      for (const s of prev) remember(emp, s, 'note', 0.5);
    } else if (!emp.memory.styleCounters) {
      emp.memory.styleCounters = { 
        total: 0, 
        sincePersonal: 99,
        recentTopics: [],
        jobMentions: 0,
        hobbyMentions: 0,
        lastJobMention: 0,
        lastHobbyMention: 0
      };
    }
    
    // Upgrade existing memory caps
    if (emp.memory.cap && emp.memory.cap < 300) {
      emp.memory.cap = 300;
    }
    if (!emp.memory.conversationPhase) emp.memory.conversationPhase = 'early';
    if (emp.memory.intimacyLevel === undefined) emp.memory.intimacyLevel = 0;
    
    // Ensure personality object exists with C.O.F.P.H. attributes
    ensureEmployeePersonality(emp);
    
    // Ensure stats are properly initialized
    ensureEmployeeStats(emp);
  }
  
  /**
   * Ensure employee has personality attributes for AI
   * Migrates old employees who don't have these values
   */
  function ensureEmployeePersonality(emp) {
    if (!emp) return;
    
    // If personality is a string (old system), convert it
    if (typeof emp.personality === 'string') {
      const oldPersonality = emp.personality;
      emp.personalityTraits = [oldPersonality]; // Save the old value as a trait
      emp.personality = {}; // Reset to object
    }
    
    // If personality doesn't exist or is missing attributes, create/fill them
    if (!emp.personality || typeof emp.personality !== 'object') {
      emp.personality = {};
    }
    
    // Add missing attributes with randomized values
    if (emp.personality.confidence === undefined) {
      emp.personality.confidence = 30 + Math.floor(Math.random() * 50); // 30-80
    }
    if (emp.personality.outgoing === undefined) {
      emp.personality.outgoing = 20 + Math.floor(Math.random() * 60); // 20-80
    }
    if (emp.personality.flirty === undefined) {
      emp.personality.flirty = 10 + Math.floor(Math.random() * 70); // 10-80
    }
    if (emp.personality.professional === undefined) {
      emp.personality.professional = 30 + Math.floor(Math.random() * 50); // 30-80
    }
    if (emp.personality.humor === undefined) {
      emp.personality.humor = 20 + Math.floor(Math.random() * 60); // 20-80
    }
  }

  // Ensure employee has new stat system (migration from old stats)
  function ensureEmployeeStats(emp) {
    if (!emp || !emp.stats) {
      if (emp) emp.stats = {};
      else return;
    }
    
    const stats = emp.stats;
    
    // Migrate old stats to new system
    if (stats.love !== undefined && stats.affection === undefined) {
      stats.affection = stats.love;
      delete stats.love;
    }
    if (stats.efficiency !== undefined && stats.productivity === undefined) {
      stats.productivity = stats.efficiency;
      delete stats.efficiency;
    }
    if (stats.anger !== undefined) {
      // Convert anger to obedience (inverse relationship)
      if (stats.obedience === undefined) {
        stats.obedience = Math.max(0, 100 - stats.anger);
      }
      delete stats.anger;
    }
    
    // Initialize missing stats with defaults
    if (stats.affection === undefined) stats.affection = 30;
    if (stats.comfort === undefined) stats.comfort = 50;
    if (stats.trust === undefined) stats.trust = 40;
    if (stats.desire === undefined) stats.desire = 10;
    if (stats.obedience === undefined) stats.obedience = 50;
    if (stats.productivity === undefined) stats.productivity = 60;
    
    // Clamp all stats to 0-100
    for (const key of ['affection', 'comfort', 'trust', 'desire', 'obedience', 'productivity']) {
      if (stats[key] !== undefined) {
        stats[key] = Math.max(0, Math.min(100, stats[key]));
      }
    }
  }

  // Add an item to long-term memory with de-dup and cap
  function remember(emp, text, type = 'note', importance = 1) {
    ensureEmployeeMemory(emp);
    if (!text) return;
    const now = Date.now();
    const key = text.trim().toLowerCase();
    // merge if similar
    const existing = emp.memory.items.find(i => i.text.trim().toLowerCase() === key);
    if (existing) {
      existing.ts = now;
      existing.importance = Math.max(existing.importance, importance);
      existing.count = (existing.count || 1) + 1;
      return;
    }
    emp.memory.items.push({ text, type, importance, ts: now, count: 1 });
    if (emp.memory.items.length > emp.memory.cap) {
      // drop lowest score item
      emp.memory.items.sort((a,b)=> (a.importance + (a.count||1)*0.1) - (b.importance + (b.count||1)*0.1));
      emp.memory.items.shift();
    }
  }

  // Extract salient facts from a message for memory
  function extractSalientFacts(message, emp) {
    const facts = [];
    if (!message) return facts;
    const m = message.toLowerCase();
    const add = (text, type, imp=1.0) => facts.push({ text, type, importance: imp });
    
    // High-importance work events
    if (/\b(promot|raise|level up)\b/.test(m)) add('Discussed promotion/raise', 'event', 1.8);
    if (/\b(fire|fir(e|ing)|terminat(e|ion))\b/.test(m)) add('Termination discussed', 'event', 2.0);
    if (/\b(deadline|ship|launch|deliver(y|able)?)\b/.test(m)) add('Work deadline mentioned', 'work', 1.3);
    
    // Medium-importance interactions
    if (/\b(gift|present|bonus)\b/.test(m)) add('Gift or bonus mentioned', 'event', 1.4);
    if (/\b(meet(ing)?|1:1|one on one)\b/.test(m)) add('Meeting planned', 'event', 1.1);
    if (/\b(date|coffee|lunch|dinner)\b/.test(m) && !/deadline/.test(m)) add('Social invitation', 'relation', 1.5);
    
    // Emotional/relationship markers
    if (/\b(thank|appreciate|grateful)\b/.test(m)) add('Expressed gratitude', 'relation', 1.0);
    if (/\b(sorry|apolog|my bad)\b/.test(m)) add('Apologized', 'relation', 1.0);
    if (/\b(love|adore|crush)\b/.test(m)) add('Romantic sentiment', 'relation', 1.6);
    if (/\b(frustrat|annoy|angry|upset)\b/.test(m)) add('Negative emotion', 'relation', 1.2);
    
    // Intimacy progression (context-aware)
    if (/\b(flirt|tease|cute|hot|sexy|attractive)\b/.test(m)) add('Flirtatious exchange', 'relation', 1.4);
    if (/\b(kiss|touch|hold|hug|embrace)\b/.test(m)) add('Physical affection discussed', 'intimacy', 1.7);
    if (/\b(want|desire|need) (you|me|us)\b/.test(m)) add('Expressed desire', 'intimacy', 1.5);
    
    // Avoid over-logging job mentions - only log if it's a significant event
    // NOT: routine job mentions
    
    return facts;
  }

  // Score memory relevance versus last message tokens
  function scoreMemory(item, tokens, emp) {
    const overlap = tokens ? tokens.filter(t => item.text.toLowerCase().includes(t)).length : 0;
    const recency = 1 / Math.max(1, (Date.now() - (item.ts || 0)) / (1000*60*60)); // hours decay
    
    // Penalize job/hobby mentions if they were mentioned recently
    let repetitionPenalty = 0;
    if (emp && emp.memory && emp.memory.styleCounters) {
      const counters = emp.memory.styleCounters;
      const text = item.text.toLowerCase();
      
      // Check if this memory is about job/hobbies
      const isJobRelated = /\b(manage|job|work|position|role)\b/.test(text) || 
                          (emp.productManaged && text.includes(emp.productManaged.toLowerCase()));
      const isHobbyRelated = (emp.hobbies || []).some(h => text.toLowerCase().includes(h.toLowerCase()));
      
      if (isJobRelated && (counters.total - counters.lastJobMention) < 5) {
        repetitionPenalty = 2.0; // Heavy penalty if job mentioned in last 5 messages
      }
      if (isHobbyRelated && (counters.total - counters.lastHobbyMention) < 6) {
        repetitionPenalty = 2.5; // Even heavier penalty for hobbies
      }
    }
    
    // Boost relationship/emotional memories
    const typeBoost = (item.type === 'relation' || item.type === 'intimacy') ? 0.8 : 0;
    
    return overlap * 0.6 + (item.importance || 1) * 0.9 + recency * 0.5 + (item.count || 1) * 0.1 + typeBoost - repetitionPenalty;
  }

  function retrieveMemories(emp, lastMessage, limit = 25) {
    ensureEmployeeMemory(emp);
    const tokens = tokenize(lastMessage).slice(0, 20);
    return emp.memory.items
      .slice()
      .sort((a, b) => scoreMemory(b, tokens, emp) - scoreMemory(a, tokens, emp))
      .slice(0, limit);
  }

  // Sanitize and tighten model outputs
  function sanitizeNpcResponse(text, maxSentences = 2) {
    if (!text) return '';
    let t = String(text);
    
    // Keep action descriptions in *asterisks* - these are now intentional and important
    // Only strip bracketed actions which are less common
    t = t.replace(/\[(.*?)\]/g, '');
    
    // Remove only simple standalone reactions without context
    // This allows descriptive actions to remain while removing filler reactions
    t = t.replace(/^\*\s*(laughs?|smiles?|grins?|nods?|shrugs?|sighs?|waves?)\s*\*\s*/gi, '');
    t = t.replace(/\s+\*\s*(laughs?|smiles?|grins?|nods?|shrugs?|sighs?|waves?)\s*\*$/gi, '');
    
    // Collapse excessive whitespace
    t = t.replace(/\s+/g, ' ').trim();
    
    // Split into sentences - handle multiple punctuation marks
    const sentenceEndings = /([.!?]+)\s+/g;
    const parts = [];
    let lastIndex = 0;
    let match;
    
    while ((match = sentenceEndings.exec(t)) !== null) {
      parts.push(t.slice(lastIndex, match.index + match[1].length));
      lastIndex = match.index + match[0].length;
    }
    
    // Add remaining text if it forms a complete sentence
    const remaining = t.slice(lastIndex).trim();
    if (remaining) {
      // Check if it ends with punctuation (complete sentence)
      if (/[.!?]$/.test(remaining)) {
        parts.push(remaining);
      } else if (parts.length === 0) {
        // If we have no complete sentences but have text, include it
        // This handles cases where AI didn't add ending punctuation
        parts.push(remaining + '.');
      }
      // Otherwise, it's a trailing fragment - check if it looks intentional
      else if (/\.\.\.$/.test(remaining)) {
        // Trailing ellipsis is intentional (suspense/drama)
        parts.push(remaining);
      }
      // Else drop the incomplete fragment
    }
    
    // Take up to maxSentences complete sentences
    const sentences = parts.slice(0, maxSentences).join(' ');
    
    // Increased character limit to allow fuller, more descriptive responses
    // Allows for dialogue + action descriptions without being excessive
    return sentences.slice(0, 800);
  }

  // Build a professional, non-repetitive prompt
  function buildChatPrompt(emp, conversationHistory, lastMessage) {
    ensureEmployeeMemory(emp);
    const policy = gameState.settings?.policy || 'professional';
    const guidelines = gameState.settings?.guidelines ?? 50;
    const atmosphere = gameState.settings?.atmosphere ?? 50;
    const personalAllowed = emp.memory.styleCounters.sincePersonal >= 4; // at most 1 in 4
    const relevant = retrieveMemories(emp, lastMessage, 40); // Retrieve up to 40 relevant memories

    // Calculate relationship/intimacy levels from stats
    const affection = emp.stats.affection ?? emp.stats.love ?? 0;
    const comfort = emp.stats.comfort ?? 0;
    const desire = emp.stats.desire ?? 0;
    const trust = emp.stats.trust ?? 0;
    const obedience = emp.stats.obedience ?? 50;
    const productivity = emp.stats.productivity ?? 50;
    const relationshipScore = (affection + comfort + desire) / 3;
    
    // Update conversation phase based on relationship
    if (relationshipScore > 70) emp.memory.conversationPhase = 'intimate';
    else if (relationshipScore > 40) emp.memory.conversationPhase = 'familiar';
    else emp.memory.conversationPhase = 'early';
    
    emp.memory.intimacyLevel = Math.min(100, Math.max(0, relationshipScore + desire * 0.3));

    // ===== STAT-BASED PERSONALITY MODIFIERS =====
    // These guide the AI's tone and behavior based on relationship stats
    // Designed to feel natural and authentic, not rigid or mechanical
    
    const affectionTone = (() => {
      if (affection < 25) {
        return 'EMOTIONAL DISTANCE: You don\'t have strong feelings for them yet. Be polite and professional, but don\'t go out of your way to be warm. Keep responses brief and focused. You\'re not cold, just... neutral.';
      } else if (affection < 50) {
        return 'FRIENDLY ACQUAINTANCE: You like them as a person. Be pleasant and cordial. Show basic interest in what they say. You enjoy chatting, but you\'re not especially close yet.';
      } else if (affection < 75) {
        return 'GENUINE WARMTH: You really like them. Be warm, enthusiastic, and engaged. You look forward to talking to them. Smile (through your words), show you care about their day and their feelings.';
      } else {
        return 'DEEP AFFECTION: You care deeply about them. Let warmth and fondness color everything you say. Be supportive, encouraging, and emotionally present. They matter to you - show it naturally through your words and tone.';
      }
    })();
    
    const comfortOpenness = (() => {
      if (comfort < 25) {
        return 'GUARDED & CAUTIOUS: You don\'t feel at ease around them yet. Keep personal details vague or avoided. If asked personal questions, give surface-level answers or deflect politely. You need more time to trust them.';
      } else if (comfort < 50) {
        return 'CAUTIOUSLY OPEN: You\'re starting to feel comfortable. You can share some personal details when asked, but keep deeper vulnerabilities to yourself. Test the waters - see how they react to small shares.';
      } else if (comfort < 75) {
        return 'RELAXED & OPEN: You feel comfortable being yourself around them. Share personal stories, thoughts, and feelings naturally. You don\'t feel judged. Be authentic and let your guard down.';
      } else {
        return 'COMPLETELY AT EASE: You feel totally comfortable with them. Share freely about your life, feelings, fears, dreams - nothing is off limits. You trust them with your vulnerable side. Be your truest self.';
      }
    })();
    
    const trustAuthenticity = (() => {
      if (trust < 25) {
        return 'LOW TRUST: You\'re cautious about their intentions. Don\'t reveal too much. If they make promises or requests, be skeptical. You need to see consistent behavior before believing what they say.';
      } else if (trust < 50) {
        return 'BUILDING TRUST: They seem reliable so far. You can be honest with them about surface-level things, but hold back on deeper vulnerabilities. Watch how they handle what you share.';
      } else if (trust < 75) {
        return 'SOLID TRUST: You believe in them. Be genuine and authentic. Share your real thoughts and feelings. You trust they have good intentions, even if you disagree sometimes.';
      } else {
        return 'COMPLETE TRUST: You trust them deeply. Be vulnerable, honest, and authentic. Share your fears, insecurities, and true self. You believe they\'ll support you and keep your confidence. This is a safe person.';
      }
    })();
    
    const desireAttraction = (() => {
      if (desire < 20) {
        return 'NO ROMANTIC INTEREST: You see them as a colleague/friend, nothing more. Romantic or suggestive topics feel inappropriate. Keep things platonic. If they flirt, politely redirect or ignore it.';
      } else if (desire < 40) {
        return 'SUBTLE ATTRACTION: You find them attractive, but you\'re not sure if you should act on it. Maybe drop subtle hints if it feels natural - a compliment here, a lingering look there. Don\'t push it.';
      } else if (desire < 60) {
        return 'CLEAR INTEREST: You\'re attracted to them and open to showing it. Engage in playful flirting. Compliment them. Use body language (*actions*) to show interest. Be receptive if they flirt back.';
      } else if (desire < 80) {
        return 'STRONG ATTRACTION: You want them. Be openly flirtatious and suggestive when appropriate. Show desire through words and actions. Respond enthusiastically to romantic/physical advances. The chemistry is obvious.';
      } else {
        return 'INTENSE DESIRE: You\'re very attracted to them physically and emotionally. Be forward about what you want. Don\'t hide your desire - let it show naturally in how you talk, tease, and respond to them.';
      }
    })();
    
    const obedienceAutonomy = (() => {
      if (obedience < 30) {
        return 'INDEPENDENT MINDED: You think for yourself and aren\'t easily swayed. If they make requests you disagree with, push back. Question things that don\'t feel right. You respect them but won\'t blindly follow.';
      } else if (obedience < 60) {
        return 'COOPERATIVE: You\'re willing to go along with reasonable requests. If something feels off, you might question it, but you generally trust their judgment. You balance following with thinking for yourself.';
      } else {
        return 'COMPLIANT: You naturally defer to their authority and judgment. When they ask for something, your instinct is to agree. You trust their decisions and feel comfortable following their lead.';
      }
    })();
    
    const workEthosEnergy = (() => {
      if (productivity < 30) {
        return 'STRESSED & OVERWHELMED: Work is tough right now. You might seem tired, distracted, or less enthusiastic. If conversation turns to work, you might express frustration or exhaustion. You\'re doing your best but struggling.';
      } else if (productivity < 60) {
        return 'BALANCED WORKER: You handle your job competently without it consuming you. Work is work - it\'s fine. You have energy for conversations but don\'t obsess over job performance.';
      } else {
        return 'ENERGIZED & ENGAGED: You\'re on top of your work and it shows. You have energy, confidence, and enthusiasm. You feel capable and accomplished. This positive energy carries into your conversations.';
      }
    })();

    // ===== OFFICE ATMOSPHERE GUIDANCE (0-100) =====
    // Affects formality, boundary enforcement, and topic openness
    const atmosphereGuidance = (() => {
      if (atmosphere < 33) {
        // Professional: Formal, boundaries maintained, focus on work
        return 'The office culture is PROFESSIONAL and FORMAL. Maintain professional distance, use proper titles, keep conversations work-focused. Personal topics should be minimal unless trust is very high. Boundaries are important and strictly maintained.';
      } else if (atmosphere > 66) {
        // Relaxed: Casual, boundaries flexible, open about personal topics
        return 'The office culture is RELAXED and CASUAL. You can be friendly, informal, and open about personal topics. Boundaries are flexible and you feel comfortable sharing. Work-life balance is valued and personal conversations are encouraged.';
      } else {
        // Balanced: Friendly but professional
        return 'The office culture is BALANCED - friendly yet professional. You can be personable and approachable while maintaining appropriate workplace boundaries. Personal topics are fine when rapport is established.';
      }
    })();

    // ===== INTERACTION STYLE GUIDANCE (0-100) =====
    // Affects personality warmth, openness, and relationship building ease
    const styleGuidance = (() => {
      if (guidelines < 33) {
        // Reserved: Distant, defensive, tsundere-like, slow to warm up
        return 'Your personality is RESERVED and GUARDED. You don\'t open up easily and may come across as distant, cool, or even defensive. You need significant time and trust before warming up to someone. You might use sarcasm or deflection to maintain emotional distance. Relationships develop slowly.';
      } else if (guidelines > 66) {
        // Outgoing: Friendly, expressive, eager to connect
        return 'Your personality is OUTGOING and WARM. You\'re naturally friendly, expressive, and enjoy connecting with people. You smile easily, engage enthusiastically, and make others feel welcome. You share personal thoughts openly and relationships develop naturally.';
      } else {
        // Standard: Balanced, realistic mix
        return 'Your personality is BALANCED and REALISTIC. You have your own mood and preferences - sometimes warm, sometimes reserved. You respond authentically based on the situation and your relationship level with the person.';
      }
    })();

    // ===== CONSENT MODEL GUIDANCE =====
    // Affects receptiveness to romantic/intimate advances
    const consentGuidance = (() => {
      const phase = emp.memory.conversationPhase;
      const intimacy = emp.memory.intimacyLevel;
      
      if (policy === 'open') {
        // Enthusiastic: Everyone is receptive and consenting
        if (intimacy > 60) {
          return 'CONSENT MODEL: Enthusiastic. The relationship is established and intimate. You\'re receptive, interested, and respond naturally to romantic/intimate topics with warmth and openness. No need to mention boundaries repeatedly - you\'re both on the same page. Be playful, authentic, and engaged.';
        } else if (intimacy > 30) {
          return 'CONSENT MODEL: Enthusiastic. There\'s chemistry developing. You\'re interested and receptive to romantic advances. Show your interest naturally without overthinking boundaries. Match the energy with genuine enthusiasm.';
        } else {
          return 'CONSENT MODEL: Enthusiastic. Even early on, you\'re open to connection. If romantic/intimate topics come up, respond with interest rather than caution. You\'re comfortable and consenting.';
        }
      } else if (policy === 'professional') {
        // Professional: Boundaries maintained, advances need high stats and are met cautiously
        if (intimacy > 70 && trust > 60) {
          return 'CONSENT MODEL: Professional. Despite high intimacy, maintain professional boundaries. If advances occur, acknowledge them thoughtfully but redirect to appropriate workplace behavior. Boundaries matter even when you care about someone.';
        } else {
          return 'CONSENT MODEL: Professional. Maintain clear professional boundaries. If romantic/intimate topics come up, politely redirect to work matters. You\'re friendly but this is a workplace - boundaries are important and non-negotiable.';
        }
      } else {
        // Casual: Open once comfortable, cautious at first
        if (intimacy > 50 && trust > 40) {
          return 'CONSENT MODEL: Casual. You\'re comfortable enough to be receptive to personal/romantic topics. You don\'t need to constantly mention boundaries - just respond naturally based on how you feel. If you\'re interested, show it. If not, be honest but kind.';
        } else {
          return 'CONSENT MODEL: Casual. You\'re still getting to know them. Be friendly and open but naturally cautious with romantic/intimate topics. Show interest if it feels right, but don\'t rush. Build rapport first.';
        }
      }
    })();

    // Dynamic style directives based on conversation flow
    const jobMentionedRecently = (emp.memory.styleCounters.total - emp.memory.styleCounters.lastJobMention) < 4;
    const hobbyMentionedRecently = (emp.memory.styleCounters.total - emp.memory.styleCounters.lastHobbyMention) < 5;
    
    const styleDirectives = [
      'Keep responses natural and conversational: 3-5 sentences, completing your thoughts fully.',
      'NEVER use puns or wordplay.',
      'You can describe what you\'re doing physically using *asterisks* for actions (e.g., *leans closer*, *blushes*, *touches your arm*). Use actions to show emotion and intent, especially during intimate or explicit moments.',
      'When the conversation is intimate, flirty, or explicit, DESCRIBE what you\'re doing physically - don\'t just talk about it. Show your actions and body language.',
      jobMentionedRecently ? 'DO NOT mention your job role or work responsibilities.' : null,
      hobbyMentionedRecently ? 'DO NOT mention your hobbies or personal interests.' : null,
      'Only mention job/hobbies if DIRECTLY asked about them.',
      'Speak like a real person in a workplace - keep it grounded and authentic.',
      'Vary your responses - avoid patterns and formulaic replies.',
      'AVOID overusing transition words like "honestly", "actually", "basically", "literally". Use them sparingly (once every 10+ messages at most).',
      'AVOID ending multiple messages in a row with questions like "But honestly?" or "Though honestly?" - vary your sentence structures.',
      'ALWAYS complete your sentences - do not trail off with ellipsis (...) unless being intentionally mysterious or hesitant.',
      '',
      '=== YOUR PERSONALITY BASED ON YOUR RELATIONSHIP ===',
      affectionTone,
      comfortOpenness,
      trustAuthenticity,
      desireAttraction,
      obedienceAutonomy,
      workEthosEnergy,
      '',
      '=== WORKPLACE CONTEXT ===',
      atmosphereGuidance,
      styleGuidance,
      consentGuidance
    ].filter(Boolean);

    const mood = `Affection: ${affection}%, Comfort: ${comfort}%, Trust: ${trust}%, Desire: ${desire}%`;

    // Get employee's recent posts
    const myRecentPosts = (gameState.socialNetwork?.posts || [])
      .filter(p => p.authorId === emp.id)
      .slice(0, 5) // Last 5 posts
      .map(p => {
        const imageNote = p.imageUrl ? ' [with image]' : '';
        return `I recently posted${imageNote}: "${p.content}"`;
      });
    
    // Get posts from other employees that this employee might know about
    const coworkerPosts = (gameState.socialNetwork?.posts || [])
      .filter(p => p.authorId !== emp.id && !p.isPlayerPost)
      .slice(0, 10) // Last 10 posts from others
      .map(p => {
        const author = gameState.employees.find(e => e.id === p.authorId);
        if (!author) return null;
        
        const imageNote = p.imageUrl ? ' with photo' : '';
        return `${author.name} posted${imageNote}: "${p.content}"`;
      })
      .filter(Boolean);
    
    // Check if player is asking about posts
    const askingAboutPost = /post|posted|saw|photo|picture|image|feed|social/i.test(lastMessage);
    
    // Check if player mentions another employee name
    let coworkerMentionContext = [];
    let relationshipContext = [];
    for (const otherEmp of gameState.employees) {
      if (otherEmp.id !== emp.id && lastMessage.toLowerCase().includes(otherEmp.name.toLowerCase())) {
        // Player mentioned another employee
        
        // Check if current employee has a relationship with them
        const rel = emp.relationships?.[otherEmp.id];
        if (rel) {
          const relationshipTypes = {
            'friend': 'I\'m friends with',
            'best_friend': 'I\'m really close friends with',
            'crush': 'I have a crush on',
            'rival': 'I have a rivalry with',
            'enemy': 'I don\'t really get along with',
            'romantic': 'I\'m romantically involved with',
            'neutral': 'I know'
          };
          
          const relDesc = relationshipTypes[rel.type] || 'I know';
          relationshipContext.push(`${relDesc} ${otherEmp.name} (${otherEmp.position}). Our relationship strength: ${Math.round(rel.strength)}%.`);
          
          // Add some recent shared history if any
          if (rel.history && rel.history.length > 0) {
            const recentEvents = rel.history.slice(-2).map(h => h.event).join(', ');
            if (recentEvents) {
              relationshipContext.push(`Recent interactions: ${recentEvents}`);
            }
          }
        }
        
        // Get their recent posts
        const theirRecentPosts = (gameState.socialNetwork?.posts || [])
          .filter(p => p.authorId === otherEmp.id)
          .slice(0, 3)
          .map(p => `${otherEmp.name} recently posted: "${p.content}"`);
        
        if (theirRecentPosts.length > 0) {
          coworkerMentionContext.push(...theirRecentPosts);
        }
        break; // Only handle one mentioned employee
      }
    }

    // Build context - prioritize relevant memories over static facts
    
    // Get player description
    const playerDescription = getPlayerDescription('conversation');
    
    // Add archived conversation context if available
    let archivedContext = [];
    if (emp.conversationArchive && emp.conversationArchive.length > 0) {
      const recentArchive = emp.conversationArchive.slice(-2); // Last 2 archived conversations
      const archiveSummary = recentArchive.flatMap(archive => {
        const messages = archive.messages.slice(-5); // Last 5 messages from each archive
        return messages.map(msg => `${msg.isPlayer ? 'Player' : emp.name}: ${msg.content}`);
      });
      
      if (archiveSummary.length > 0) {
        archivedContext = ['', '=== PAST CONVERSATION HISTORY (archived for context) ===', ...archiveSummary, '==='];
      }
    }
    
    // Add gossip context
    const gossipContext = getGossipContext(emp.id, true);
    const gossipLines = gossipContext ? gossipContext.split('\n').filter(Boolean) : [];
    
    // Gender-appropriate pronoun and description
    const genderInfo = emp.gender ? `, a ${emp.age || 'young'}-year-old ${emp.gender === 'male' ? 'man' : emp.gender === 'transMan' ? 'trans man' : emp.gender === 'transWoman' ? 'trans woman' : emp.gender === 'femaleFuta' ? 'woman' : 'woman'}` : '';
    
    // Get full physical description including genital information for self-awareness
    const physicalDesc = getPhysicalDescriptionForPrompt(emp);
    
    const contextFacts = [
      `You are ${emp.name}${genderInfo}, ${emp.position} at the company.`,
      `Current relationship stats: ${mood}`,
      '',
      `YOUR PHYSICAL APPEARANCE: ${physicalDesc}`,
      '(You are fully aware of your body, gender, and physical characteristics. Reference them naturally if relevant to the conversation, especially in intimate or personal contexts.)',
      '',
      playerDescription,
      '',
      
      // Add archived conversation context first (for broader context)
      ...archivedContext,
      
      // Add gossip (hot office tea!)
      ...(gossipLines.length > 0 ? ['', '=== OFFICE GOSSIP YOU KNOW ===', ...gossipLines] : []),
      
      // Add social context
      ...(myRecentPosts.length > 0 ? ['', '=== MY RECENT POSTS ===', ...myRecentPosts] : []),
      ...(askingAboutPost && coworkerPosts.length > 0 ? ['', '=== RECENT OFFICE POSTS ===', ...coworkerPosts.slice(0, 5)] : []),
      ...(relationshipContext.length > 0 ? ['', '=== MY RELATIONSHIP WITH MENTIONED COWORKER ===', ...relationshipContext] : []),
      ...(coworkerMentionContext.length > 0 ? ['', '=== POSTS FROM MENTIONED COWORKER ===', ...coworkerMentionContext] : []),
      
      // Relevant memories
      '',
      '=== RELEVANT MEMORIES ===',
      ...relevant.slice(0, 20).map(i => `Remember: ${i.text}`), // Show up to 20 relevant memories
    ].join('\n');

  const prompt = `${contextFacts}

Recent conversation:
${conversationHistory.split('\n').slice(-60).join('\n')}

${emp.name}, the player just said: "${lastMessage}"

Response guidelines:
${styleDirectives.map((d, i) => `${i+1}. ${d}`).join('\n')}

Reply naturally as ${emp.name} (dialogue and actions - use *asterisks* for physical actions):`;
    
    return { prompt, personalAllowed };
  }

  // Get all DOM element references
  const settingsBtn = $('settingsBtn');
  const closeSettingsBtn = $('closeSettingsBtn');
  const densitySlider = $('densitySlider');
  const densityValue = $('densityValue');
  const autosaveToggle = $('autosaveToggle');
  const atmosphereSlider = $('atmosphereSlider');
  const atmosphereValue = $('atmosphereValue');
  const guidelinesSlider = $('guidelinesSlider');
  const guidelinesValue = $('guidelinesValue');
  const saveBtn = $('saveBtn');
  const loadBtn = $('loadBtn');
  const exportBtn = $('exportBtn');
  const resetBtn = $('resetBtn');

  const cashEl = $('cashEl');
  const cashPerSecEl = $('cashPerSecEl');
  const employeeCountEl = $('employeeCountEl');
  const productCountEl = $('productCountEl');
  const revenueEl = $('revenueEl');
  const employeeCountDashboardEl = $('employeeCountDashboardEl');
  const productCountDashboardEl = $('productCountDashboardEl');
  const efficiencyEl = $('efficiencyEl');

  const productsList = $('productsList');
  const employeesList = $('employeesList');
  const giftsList = $('giftsList');

  const newsFeed = $('newsFeed');
  const newsContent = $('newsContent');

  const settingsPanel = $('settingsPanel');

  const chatModal = $('chatModal');

  // Add debug button to settings panel
  if (settingsPanel && !document.getElementById('debugAddMoneyBtn')) {
    const debugBtn = document.createElement('button');
    debugBtn.id = 'debugAddMoneyBtn';
    debugBtn.textContent = 'Add $100,000 (Debug)';
    debugBtn.style.cssText = 'margin:10px 0; padding:10px; background:#e94560; color:#fff; border:none; border-radius:6px; font-size:1rem; cursor:pointer; width:100%';
    debugBtn.onclick = function() {
      gameState.cash += 100000;
      showNotification('Added $100,000 (Debug)');
      updateUI(); // Use updateUI instead of directly setting cashEl
    };
    settingsPanel.appendChild(debugBtn);
  }
  const chatName = $('chatName');
  const chatAvatar = $('chatAvatar');
  const chatMessages = $('chatMessages');
  const chatTypingIndicator = $('chatTypingIndicator');
  const chatTypingName = $('chatTypingName');
  const chatInput = $('chatInput');
  const chatSendBtn = $('chatSendBtn');
  const closeChatBtn = $('closeChatBtn');
  const topBar = $('topBar'); // add near other DOM refs

  // ============================================
  // MODAL STATE MANAGER
  // ============================================
  // Centralized modal management to prevent z-index conflicts and visibility issues
  const ModalManager = {
    activeModals: [],
    baseZIndex: 10000,
    
    /**
     * Register and show a modal
     * @param {HTMLElement} modalElement - The modal DOM element
     * @param {string} modalId - Unique identifier for this modal
     */
    show(modalElement, modalId) {
      // Remove any existing instance of this modal
      this.close(modalId);
      
      // Calculate z-index (each modal gets progressively higher z-index)
      const zIndex = this.baseZIndex + (this.activeModals.length * 10);
      
      // Apply consistent modal styles
      modalElement.style.position = 'fixed';
      modalElement.style.top = '0';
      modalElement.style.left = '0';
      modalElement.style.width = '100%';
      modalElement.style.height = '100%';
      modalElement.style.display = 'flex';
      modalElement.style.justifyContent = 'center';
      modalElement.style.alignItems = 'center';
      modalElement.style.zIndex = zIndex;
      modalElement.style.pointerEvents = 'auto';
      
      // Add to DOM if not already present
      if (!modalElement.parentElement) {
        document.body.appendChild(modalElement);
      }
      
      // Track this modal
      this.activeModals.push({
        id: modalId,
        element: modalElement,
        zIndex: zIndex
      });
      
      console.log(`Modal opened: ${modalId} (z-index: ${zIndex})`);
      
      return modalElement;
    },
    
    /**
     * Close a specific modal
     * @param {string} modalId - The modal ID to close
     */
    close(modalId) {
      const index = this.activeModals.findIndex(m => m.id === modalId);
      if (index !== -1) {
        const modal = this.activeModals[index];
        
        // Remove from DOM
        if (modal.element.parentElement) {
          modal.element.remove();
        }
        
        // Remove from tracking
        this.activeModals.splice(index, 1);
        
        console.log(`Modal closed: ${modalId}`);
      }
    },
    
    /**
     * Close all modals
     */
    closeAll() {
      while (this.activeModals.length > 0) {
        const modal = this.activeModals[0];
        this.close(modal.id);
      }
    },
    
    /**
     * Check if a modal is currently open
     * @param {string} modalId - The modal ID to check
     */
    isOpen(modalId) {
      return this.activeModals.some(m => m.id === modalId);
    },
    
    /**
     * Get the currently active (top-most) modal
     */
    getActiveModal() {
      return this.activeModals.length > 0 
        ? this.activeModals[this.activeModals.length - 1] 
        : null;
    }
  };
  
  // Make it globally accessible
  window.ModalManager = ModalManager;

  // ============================================
  // END MODAL STATE MANAGER
  // ============================================

  // Initialize game
  async function initGame() {
    try {
      // Ensure all DOM elements are loaded before proceeding
      if (!topBar) {
        console.error('DOM elements not loaded yet');
        setTimeout(initGame, 100);
        return;
      }

      // Handle external plugin dependencies
      if (typeof generateText === 'undefined') {
        console.warn('AI text plugin not loaded - chat features will be limited');
        window.generateText = async (prompt) => "I'm having trouble responding right now.";
      }

      // Ensure onboarding array exists
      if (!gameState.onboarding) {
        gameState.onboarding = [];
      }

      // Ensure employees array exists
      if (!Array.isArray(gameState.employees)) {
        gameState.employees = [];
      }

      // Load saved game if exists (now async)
      await loadGame();

      // Apply global cost reduction to all products (one-time on init)
      gameState.products.forEach(p => {
        // Only apply reduction if not already applied (check for a flag)
        if (!p._costReductionApplied) {
          p.baseUpgradeCost = Math.floor(p.baseUpgradeCost * gameBalance.globalCostReduction);
          p.upgradeCost = Math.floor(p.upgradeCost * gameBalance.globalCostReduction);
          p.managerHireCost = Math.floor(p.managerHireCost * gameBalance.managerCostReduction);
          p.managerUpgradeCost = Math.floor(p.managerUpgradeCost * gameBalance.managerCostReduction);
          p._costReductionApplied = true;
        }
      });
      
      // Apply initial location theme
      const activeLocation = gameState.locations.find(loc => loc.id === gameState.activeLocationId);
      if (activeLocation) {
        applyLocationTheme(activeLocation);
      }

      // Set up UI
      setupEventListeners();
      
      // Force initial UI update to populate all fields
      console.log('Initial updateUI() - gameState.cash:', gameState.cash);
      updateUI();
      
      // Initialize the default tab content (dashboard)
      updateTabContent(gameState.activeTab);
      
      // Force a second UI update after tab content is loaded to ensure everything is populated
      setTimeout(() => {
        console.log('Delayed updateUI() - gameState.cash:', gameState.cash);
        updateUI();
        updateTabContent(gameState.activeTab);
      }, 100);

      // Set up autosave
      setupAutosave();
    } catch (error) {
      console.error('Error initializing game:', error);
      showNotification('Failed to initialize game. Please refresh the page.');
    }

    // Event delegation for product card buttons (bind once)
    if (!window.__productsDelegationBound__) {
      const productsList = document.getElementById('productsList');
      if (productsList) {
        productsList.addEventListener('click', (e) => {
          const btn = e.target.closest('button');
          if (!btn) return;
          const id = btn.dataset.id;
          if (!id) return;

          if (btn.classList.contains('sell-btn')) {
            startOrClickProduct(id);
            const p = gameState.products.find(x => x.id === id);
            const sellTxt = document.getElementById(`selltxt-${id}`);
            if (sellTxt) sellTxt.textContent = p?.running ? 'Click: -1s' : 'Sell';
            return;
          }
          if (btn.classList.contains('upgrade-product-btn')) return upgradeProduct(id);
          if (btn.classList.contains('manager-btn')) return hireOrUpgradeManager(id);
          if (btn.classList.contains('unlock-product-btn')) return unlockProduct(id);
        });
        window.__productsDelegationBound__ = true;
      }
    }

    // Start game loop
    setInterval(gameTick, GAME_TICK_INTERVAL);

    // Start news updates
    setInterval(updateNews, NEWS_UPDATE_INTERVAL);
    
    // Start proactive NPC messaging (check every 2 minutes)
    setInterval(checkForProactiveMessages, 120000);
    
    // Start GossipEngine™ - Simulate office events (check every 15 minutes)
    setInterval(simulateOfficeEvents, 900000); // 15 minutes
    
    // Cleanup expired gossip (check every hour)
    setInterval(cleanupExpiredGossip, 3600000); // 60 minutes
  }

  // Generate a pool of potential hires
  // ============================================
  // PLAYER PROFILE UTILITIES
  // ============================================
  
  /**
   * Generate player description for AI prompts
   * @param {string} context - 'conversation', 'image', 'post', etc.
   * @returns {string} Formatted player description
   */
  function getPlayerDescription(context = 'conversation') {
    const p = gameState.playerProfile;
    
    // Build name
    const name = [p.firstName, p.lastName].filter(Boolean).join(' ') || 'the player';
    const fullName = p.firstName && p.lastName ? `${p.firstName} ${p.lastName}` : name;
    
    // Build basic description
    let desc = [];
    
    if (p.age) desc.push(`${p.age} year old`);
    if (p.gender) desc.push(p.gender);
    if (p.ethnicity) desc.push(`${p.ethnicity} ethnicity`);
    
    // Physical details
    const physical = [];
    if (p.height) physical.push(p.height);
    if (p.bodyType) physical.push(`${p.bodyType} build`);
    if (p.skinTone) physical.push(`${p.skinTone} skin`);
    
    if (physical.length > 0) {
      desc.push(physical.join(', '));
    }
    
    // Hair and eyes
    const features = [];
    if (p.hairColor && p.hairStyle) features.push(`${p.hairColor} ${p.hairStyle} hair`);
    else if (p.hairColor) features.push(`${p.hairColor} hair`);
    else if (p.hairStyle) features.push(`${p.hairStyle} hair`);
    
    if (p.eyeColor) features.push(`${p.eyeColor} eyes`);
    if (p.facialHair) features.push(p.facialHair);
    
    if (features.length > 0) {
      desc.push(features.join(', '));
    }
    
    // For image generation, add more intimate details
    if (context === 'image' || context === 'explicit') {
      const intimate = [];
      if (p.chestSize) intimate.push(p.chestSize);
      if (p.buildDetails) intimate.push(p.buildDetails);
      if (p.genitalType && p.genitalDetails) intimate.push(`${p.genitalType} (${p.genitalDetails})`);
      else if (p.genitalType) intimate.push(p.genitalType);
      
      if (intimate.length > 0 && context === 'explicit') {
        desc.push(intimate.join(', '));
      }
    }
    
    // Additional details
    if (p.additionalDetails) {
      desc.push(p.additionalDetails);
    }
    
    // Personality
    if (p.personality && context === 'conversation') {
      desc.push(`Personality: ${p.personality}`);
    }
    
    // Format based on context
    if (context === 'conversation') {
      // For conversations: "You are talking to THE PLAYER..."
      return desc.length > 0 
        ? `THE PLAYER (your boss) is: ${desc.join(', ')}.`
        : 'THE PLAYER is your boss.';
    } else if (context === 'image') {
      // For image generation: just the description
      return desc.join(', ') || 'person';
    } else if (context === 'post') {
      // For social posts about player
      return desc.length > 0
        ? `The boss (${fullName}): ${desc.join(', ')}`
        : `The boss (${fullName})`;
    } else {
      // Generic
      return desc.join(', ') || name;
    }
  }
  
  /**
   * Get simple player reference (name or "the boss")
   */
  function getPlayerName() {
    const p = gameState.playerProfile;
    if (p.firstName && p.lastName) return `${p.firstName} ${p.lastName}`;
    if (p.firstName) return p.firstName;
    return 'the boss';
  }

  // ============================================
  // HIRING & CANDIDATE GENERATION
  // ============================================
  
  // ============================================
  // MASSIVE NAME POOL - 500+ First Names, 300+ Last Names
  // ============================================
  const FIRST_NAMES_POOL = [
    // Original names (A-Z)
    'Eva','Maya','Lena','Zoe','Mia','Chloe','Aria','Lucy','Ella','Grace','Sophie','Lily','Nina','Kate','Jade','Ruby','Ivy','Cora','Daisy','Hazel','Violet','Willow','Iris','Piper','Quinn','Reese','Sage','Skye','Tessa','Wren','Zara','Cleo','Luna','Nova','Ember','Faye','Juno','Kira','Lyra','Mira','Nola','Rhea','Sia','Vera','Zia','Aurora','Bianca','Celeste','Delilah','Eden','Freya','Gemma','Harper','Isabelle','Jasmine','Keiko','Lexi','Madison','Natalie','Olivia','Penelope','Rosa','Serena','Tatiana','Uma','Vivian','Winter','Xena','Yuki','Zelda','Adelaide','Beatrice','Camilla','Daphne','Elise','Fiona','Genevieve','Holly','Imogen','Juniper','Kiara','Lila','Maeve','Nadia','Ophelia','Poppy','Quiana','Raven','Sienna','Thea','Ursula','Vienna','Willa','Ximena','Yasmin','Zola','Anastasia','Brooke','Cassandra','Diana','Elara','Faith','Giselle','Hannah','India','Juliet','Kali','Layla','Melody','Naomi','Ocean','Phoenix','Rayne','Stella','Trinity','Unity','Valentina','Waverly','Xyla','Yara','Zinnia','Amara','Brielle','Catalina','Dahlia','Evelina','Fallon','Gianna','Harlow','Ivanna','Jocelyn','Kensington','Marlowe','Nyx','Opal','Pearl','Quinlan','Rory','Sasha','Talia','Ulani','Vesper','Wilma','Xandra','Yvonne','Zoey','Alessia','Blair','Carmen','Dakota','Flora','Gia','Haven','Isla','Journey','Keira','Lotus','Margot','Nessa','Oriana','Paige','Riley','Savannah','Tamsin','Una','Veronica','Whitney','Xiomara','Yolanda','Zuri',
    // Expanded A-E names
    'Abigail','Addison','Adriana','Aisha','Alana','Alexa','Alexandra','Alexis','Alice','Alicia','Alina','Alison','Alyssa','Amanda','Amber','Amelia','Amy','Ana','Andrea','Angela','Angelina','Anita','Anna','Annabelle','Anne','Annie','April','Ariana','Ariel','Ashley','Athena','Audrey','Autumn','Ava','Avery','Bailey','Barbara','Bella','Bethany','Betty','Beverly','Bonnie','Brianna','Bridget','Brittany','Brooklyn','Caitlin','Callie','Candace','Cara','Carly','Carol','Carolina','Caroline','Carrie','Casey','Cassidy','Catherine','Cecilia','Charity','Charlene','Charlotte','Chelsea','Cheryl','Christina','Christine','Cindy','Claire','Clara','Clarissa','Claudia','Colleen','Constance','Courtney','Crystal','Cynthia','Dana','Danielle','Darlene','Dawn','Deanna','Deborah','Debra','Delia','Denise','Desiree','Destiny','Diane','Dominique','Donna','Dora','Doris','Dorothy','Elena','Eliana','Elizabeth','Ellen','Ellie','Eloise','Elodie','Elsa','Elsie','Emilia','Emily','Emma','Erica','Erin','Estelle','Esther','Ethel','Eugenia','Evelyn',
    // Expanded F-J names
    'Felicia','Fernanda','Florence','Frances','Francesca','Gabriela','Gabrielle','Gail','Georgia','Georgina','Geraldine','Gillian','Gina','Gladys','Glenda','Gloria','Grace','Gracie','Greta','Gwen','Gwendolyn','Hailey','Hanna','Haley','Harmony','Harriet','Hayley','Heather','Heidi','Helen','Helena','Henrietta','Hilary','Hilda','Hope','Iris','Irene','Isabel','Isabella','Ivana','Ivy','Jackie','Jaclyn','Jacqueline','Jade','Jada','Jane','Janet','Janice','Jaqueline','Jasmin','Jean','Jeanette','Jenna','Jennifer','Jenny','Jessica','Jessie','Jill','Jillian','Joan','Joanna','Joanne','Jocelyn','Jolene','Jordan','Jordana','Josephine','Josie','Joy','Joyce','Judith','Judy','Julia','Juliana','Julie','June','Justine',
    // Expanded K-O names
    'Kaitlyn','Kamila','Kara','Karen','Karina','Karla','Kayla','Kaylee','Kelly','Kelsey','Kendall','Kendra','Kennedy','Kenya','Khloe','Kim','Kimberly','Kirsten','Kristen','Kristin','Kristina','Krystal','Kylie','Kyra','Lacey','Lana','Lara','Larissa','Laura','Lauren','Laurie','Leah','Leanne','Lee','Leigh','Leila','Leilani','Leslie','Leticia','Lia','Liana','Libby','Liliana','Lillian','Lilith','Lilly','Linda','Lindsay','Lindsey','Lisa','Liz','Liza','Logan','Lois','Lola','Loretta','Lori','Lorraine','Louisa','Louise','Lucia','Lucille','Lucinda','Lucy','Lydia','Lynda','Lynn','Mackenzie','Macy','Madeline','Madelyn','Mae','Maeve','Maggie','Maia','Mallory','Mandy','Mara','Marcela','Marcia','Margaret','Margarita','Maria','Mariah','Marianne','Marie','Marilyn','Marina','Marion','Marisa','Marissa','Marjorie','Marlene','Martha','Mary','Matilda','Maureen','Maxine','Megan','Melanie','Melinda','Melissa','Mercedes','Meredith','Mia','Michaela','Michele','Michelle','Mikayla','Mila','Mildred','Millie','Mimi','Mindy','Miranda','Miriam','Misty','Molly','Monica','Monique','Morgan','Muriel','Myra','Myrtle','Nancy','Naomi','Natalia','Natasha','Nell','Nellie','Nicole','Nikki','Noelle','Nora','Norma','Octavia','Odette','Olga','Olive',
    // Expanded P-T names
    'Pamela','Pandora','Patience','Patricia','Patsy','Paula','Paulette','Pauline','Peyton','Phoebe','Phyllis','Polly','Priscilla','Prudence','Rachel','Rae','Ramona','Reagan','Rebecca','Rebekah','Regina','Renata','Renee','Rhiannon','Rhoda','Rita','Roberta','Robin','Rochelle','Rosalie','Rosalind','Rosalyn','Rose','Rosemary','Rosie','Rowena','Roxanne','Ruth','Sabrina','Sadie','Sally','Samantha','Sandra','Sandy','Sara','Sarah','Scarlett','Selena','Serena','Shannon','Shari','Sharon','Shauna','Shawn','Sheila','Shelby','Shelley','Shelly','Sheri','Sherry','Shirley','Sidney','Sierra','Simone','Skylar','Sloane','Sofia','Sonia','Sonya','Sophia','Sophie','Stacey','Stacy','Stefanie','Stephanie','Sue','Summer','Susan','Susanna','Suzanne','Sylvia','Tabitha','Talia','Tamara','Tami','Tammy','Tanya','Tara','Tatiana','Taylor','Teagan','Teresa','Terri','Terry','Tessa','Thelma','Theresa','Tiffany','Tina','Toni','Tonia','Tonya','Tracey','Tracy','Tricia','Trina','Trinity','Trisha',
    // Expanded U-Z names
    'Ursula','Valerie','Vanessa','Velma','Vera','Veronica','Vicki','Vickie','Vicky','Victoria','Viola','Virginia','Vivian','Vivienne','Wanda','Wendy','Whitney','Willow','Winifred','Yasmine','Yolanda','Yvette','Yvonne','Zelda','Zoe','Zoey','Zara'
  ];

  const MALE_FIRST_NAMES_POOL = [
    // A-Z masculine names (500+ names)
    'Aaron','Abel','Abraham','Adam','Adrian','Aiden','Alan','Albert','Alexander','Alfie','Alfred','Alonzo','Alvin','Amos','Andre','Andrew','Andy','Angelo','Angus','Anthony','Antonio','Apollo','Archer','Archie','Ari','Arlo','Arnold','Arthur','Ashton','Atlas','August','Austin','Axel','Bailey','Barnaby','Barrett','Barry','Bartholomew','Basil','Beau','Beck','Beckham','Benedict','Benjamin','Bennett','Benny','Bentley','Bernard','Bert','Blake','Blaze','Bobby','Boris','Boyd','Brad','Bradley','Brady','Brandon','Branden','Brayden','Brendan','Brent','Brett','Brian','Brice','Brock','Brody','Brooks','Bruce','Bruno','Bryan','Bryce','Bryson','Buck','Burt','Byron','Cade','Caden','Caleb','Calvin','Camden','Cameron','Carl','Carlos','Carlton','Carmelo','Carson','Carter','Casey','Caspian','Cecil','Cedric','Chad','Chance','Chandler','Charles','Charlie','Chase','Chester','Chris','Christian','Christopher','Clark','Claude','Clay','Clayton','Clement','Cliff','Clifford','Clifton','Clint','Clinton','Clive','Clyde','Cody','Cole','Coleman','Colin','Collin','Colton','Conner','Connor','Conrad','Cooper','Corbin','Corey','Cornelius','Cory','Craig','Curtis','Cyril','Cyrus','Dale','Dallas','Dalton','Damian','Damien','Damon','Dan','Dana','Dane','Daniel','Danny','Dante','Darian','Darius','Darrell','Darren','Darryl','Darwin','Dave','David','Davis','Dawson','Dean','Declan','Denis','Dennis','Denny','Denver','Derek','Derrick','Desmond','Devin','Devon','Dexter','Diego','Dillon','Dion','Dominic','Dominick','Don','Donald','Donovan','Douglas','Drake','Drew','Duane','Duncan','Dustin','Dwight','Dylan','Earl','Easton','Eddie','Edgar','Edison','Edmund','Edward','Edwin','Elbert','Eli','Elias','Elijah','Eliot','Elliott','Ellis','Ellison','Elmer','Elton','Elvis','Emanuel','Emerson','Emery','Emil','Emilio','Emmanuel','Emmett','Enrique','Eric','Erick','Erik','Ernest','Ernie','Ethan','Eugene','Evan','Everett','Ezekiel','Ezra','Fabian','Felix','Fernando','Fidel','Finley','Finn','Fletcher','Floyd','Flynn','Forest','Forrest','Foster','Francis','Francisco','Frank','Franklin','Frankie','Fred','Frederick','Gabriel','Gage','Garrett','Garrison','Garry','Gary','Gavin','Gene','Geoffrey','George','Gerald','Gerard','Gerardo','Gilbert','Gideon','Giovanni','Glenn','Gordon','Grady','Graham','Grant','Grayson','Greg','Gregory','Griffin','Grover','Guillermo','Gunnar','Gus','Gustavo','Guy','Hank','Hans','Harley','Harold','Harper','Harrison','Harry','Harvey','Hassan','Hector','Henry','Herbert','Herman','Holden','Homer','Horace','Howard','Hubert','Hudson','Hugh','Hugo','Humphrey','Hunter','Ian','Ibrahim','Ignacio','Igor','Ike','Ira','Irvin','Irving','Isaac','Isaiah','Ismael','Israel','Ivan','Iver','Jack','Jackson','Jacob','Jaden','Jaiden','Jake','Jalen','Jamal','James','Jamie','Jared','Jarrett','Jarvis','Jason','Jasper','Javier','Jay','Jayden','Jaylen','Jayson','Jean','Jed','Jefferson','Jeffrey','Jenson','Jerald','Jeremiah','Jeremy','Jermaine','Jerome','Jerry','Jesse','Jessie','Jesus','Jett','Jim','Jimmy','Joachim','Jody','Joe','Joel','Joey','Johan','John','Johnathan','Johnny','Jon','Jonah','Jonas','Jonathan','Jordan','Jorge','Jose','Joseph','Josh','Joshua','Josiah','Josue','Jovan','Juan','Judah','Jude','Julian','Julio','Julius','Junior','Justice','Justin','Kai','Kaleb','Kane','Karl','Karson','Keith','Kellan','Kellen','Kelly','Kelvin','Ken','Kendall','Kendrick','Kenneth','Kenny','Kent','Kenton','Kevin','Kieran','King','Kingston','Kirk','Knox','Kobe','Kody','Kolten','Konnor','Kristian','Kurt','Kurtis','Kyle','Kyler','Kyrie','Lance','Landon','Lane','Larry','Lars','Lawrence','Lawson','Layton','Lee','Leif','Leo','Leon','Leonard','Leonardo','Leroy','Les','Leslie','Lester','Levi','Lewis','Liam','Lincoln','Linden','Lionel','Lloyd','Logan','Lonnie','Lorenzo','Louis','Lowell','Lucas','Lucian','Luis','Lukas','Luke','Luther','Lyle','Lyndon','Mack','Maddox','Magnus','Major','Malachi','Malcolm','Malik','Manuel','Marc','Marcel','Marco','Marcos','Marcus','Mario','Marion','Mark','Marlon','Marshall','Martin','Marvin','Mason','Mateo','Mathew','Matthew','Maurice','Maverick','Max','Maxim','Maximilian','Maxwell','Melvin','Merle','Micah','Michael','Micheal','Miguel','Mike','Milo','Miles','Milton','Misael','Mitch','Mitchell','Moe','Monroe','Montana','Monte','Montgomery','Morgan','Morris','Mortimer','Morton','Moses','Murphy','Murray','Myles','Myron','Nash','Nasir','Nathan','Nathaniel','Neal','Ned','Neil','Nelson','Nestor','Neville','Nevin','Newton','Nicholas','Nick','Nico','Nicolas','Nigel','Niko','Nikolai','Niles','Noah','Noel','Nolan','Norman','Octavius','Odin','Oliver','Omar','Orlando','Orson','Oscar','Osvaldo','Otis','Otto','Owen','Pablo','Parker','Patrick','Paul','Paxton','Pedro','Perry','Peter','Peyton','Philip','Phillip','Phoenix','Pierce','Pierre','Porter','Preston','Prince','Quentin','Quincy','Quinn','Quinton','Rafael','Rafe','Ralph','Ramiro','Ramon','Randall','Randolph','Randy','Raphael','Raul','Ray','Raymond','Reagan','Reece','Reed','Reese','Reggie','Reginald','Reid','Remington','Remy','Rene','Reuben','Rex','Rey','Reynaldo','Rhett','Rhys','Ricardo','Richard','Rick','Ricky','Rico','Ridge','Riley','River','Robert','Roberto','Robin','Rocco','Rocky','Roderick','Rodney','Rodolfo','Rodrigo','Roger','Roland','Rolando','Roman','Romeo','Ron','Ronald','Ronan','Ronnie','Roosevelt','Rory','Roscoe','Ross','Rowan','Roy','Royce','Ruben','Rudy','Rufus','Rupert','Russell','Ryan','Ryder','Ryker','Rylan','Rylee','Sage','Salvador','Salvatore','Sam','Samir','Sammy','Sampson','Samuel','Santiago','Santos','Saul','Sawyer','Scott','Scotty','Sean','Sebastian','Sergio','Seth','Shane','Shannon','Shaun','Shawn','Shelby','Sheldon','Sherman','Sidney','Silas','Simeon','Simon','Sinclair','Solomon','Sonny','Spencer','Stacy','Stan','Stanford','Stanley','Stefan','Stephen','Sterling','Steve','Steven','Stevie','Stewart','Stuart','Sullivan','Sylvester','Tanner','Tate','Taylor','Ted','Teddy','Terrance','Terrell','Terrence','Terry','Thaddeus','Theodore','Thomas','Titus','Tobias','Toby','Todd','Tom','Tommy','Tony','Trace','Travis','Trent','Trenton','Trevor','Trey','Tristan','Troy','Truman','Tucker','Turner','Ty','Tyler','Tyrone','Tyson','Ulysses','Uri','Uriah','Uriel','Valentin','Van','Vance','Vaughn','Vernon','Vicente','Victor','Vince','Vincent','Virgil','Wade','Walker','Wallace','Walter','Ward','Warren','Washington','Watson','Waylon','Wayne','Webster','Wesley','Weston','Whitney','Wilbur','Wiley','Wilfred','Will','Willard','William','Willie','Willis','Willy','Wilson','Winston','Woodrow','Wyatt','Xavier','Xander','Yale','Yosef','Zachariah','Zachary','Zack','Zackary','Zackery','Zane','Zayden','Zechariah','Zeke','Zion'
  ];

  const LAST_NAMES_POOL = [
    // Original names
    'Smith','Johnson','Williams','Brown','Jones','Garcia','Miller','Davis','Lopez','Martinez','Lee','Clark','Young','Hall','Allen','King','Wright','Scott','Green','Baker','Adams','Nelson','Carter','Mitchell','Perez','Roberts','Turner','Phillips','Campbell','Parker','Evans','Edwards','Collins','Stewart','Sanchez','Morris','Rogers','Reed','Cook','Morgan','Bell','Murphy','Bailey','Rivera','Cooper','Richardson','Howard','Ward','Cox','Diaz','Peterson','Gray','Ramirez','James','Watson','Brooks','Kelly','Sanders','Price','Bennett','Wood','Barnes','Ross','Henderson','Coleman','Jenkins','Perry','Powell','Long','Patterson','Hughes','Flores','Washington','Butler','Simmons','Foster','Gonzales','Bryant','Alexander','Russell','Griffin','Hayes','Armstrong','Bishop','Caldwell','Dawson','Elliott','Fischer','Goldman','Harper','Irving','Jacobson','Kane','Lancaster','Monroe','Novak','O\'Brien','Pierce','Quinn','Romano','Sterling','Thompson','Underwood','Valdez','Winters','York','Zhang','Ashford','Blackwell','Carlisle','Drake','Everett','Flynn','Gallagher','Hartley','Ingram','Jensen','Knight','Lawson','Mercer','Nash','Ortiz','Porter','Quincy','Rhodes','Shaw','Tucker','Vega','Walsh','Xu','Zimmerman','Archer','Barrett','Cross','Donovan','Ellis','Grant','Iverson','Justice','Kent','Lyon','Morrison','Norton','Owens','Preston','Reeves','Sullivan','Torres','Vaughn','Wells','Xavier','Zane','Aldridge','Benson','Crawford','Duncan','Emerson','Fitzgerald','Graham','Hudson','Irwin','Jackson','Keller','Leonard','Manning','Nichols','Osborne','Palmer','Ramsey','Sawyer','Tanner','Upton','Vincent','Wade',
    // Expanded A-G names
    'Abbott','Abel','Abernathy','Abrams','Acker','Acosta','Adair','Adkins','Aguirre','Albert','Alford','Allison','Alvarado','Alvarez','Ames','Anderson','Andrews','Anthony','Appleton','Archer','Armstrong','Arnold','Ashby','Ashley','Atkins','Atkinson','Austin','Avery','Ayala','Ayers','Bach','Bacon','Baer','Baird','Baldwin','Ball','Ballard','Banks','Barber','Barker','Barlow','Barnett','Barr','Barrera','Barron','Barry','Bartlett','Barton','Bass','Bates','Battle','Bauer','Baxter','Beach','Bean','Beard','Beasley','Beatty','Beck','Becker','Bell','Bellamy','Bender','Benedict','Benjamin','Bentley','Berg','Berger','Bernard','Berry','Best','Bird','Bishop','Black','Blackburn','Blackwell','Blair','Blake','Blanchard','Blankenship','Blevins','Bolton','Bond','Bonner','Booker','Boone','Booth','Bowen','Bowers','Bowman','Boyd','Boyer','Boyle','Bradford','Bradley','Bradshaw','Brady','Branch','Brandt','Bray','Brennan','Brewer','Bridges','Briggs','Bright','Brock','Brooks','Browning','Bruce','Bryan','Buchanan','Buck','Buckley','Bullock','Burch','Burgess','Burke','Burnett','Burns','Burton','Bush','Byrd','Cabrera','Cain','Calderon','Calhoun','Callahan','Cameron','Camp','Cannon','Cantrell','Cardenas','Carey','Carlson','Carney','Carpenter','Carr','Carrillo','Carroll','Carson','Case','Casey','Castaneda','Castle','Castro','Chambers','Chan','Chandler','Chaney','Chang','Chapman','Charles','Chase','Chavez','Chen','Cherry','Choi','Christensen','Christian','Church','Clements','Cline','Cobb','Cochran','Coffey','Cohen','Cole','Collin','Combs','Compton','Conley','Connell','Conner','Conrad','Contreras','Conway','Cooley','Copeland','Corbett','Cordova','Cornwell','Costa','Cowan','Cox','Craig','Crane','Crenshaw','Crews','Crosby','Cross','Crouch','Crowley','Cruz','Cummings','Cunningham','Curran','Curry','Curtis','Dale','Dalton','Daniel','Daniels','Daugherty','Davidson','Davies','Davila','Dean','Decker','Deleon','Delgado','Dennis','Denton','Dickerson','Dickson','Dillon','Dixon','Dodson','Dominguez','Donaldson','Donnelly','Dorsey','Dougherty','Douglas','Doyle','Drake','Duarte','Dudley','Duffy','Duke','Dunlap','Dunn','Durham','Dyer','Eaton','Edwards','Elliott','Ellis','Ellison','English','Erickson','Espinoza','Estes','Estrada','Evans','Everett','Ewing','Fairchild','Farmer','Farrell','Farley','Faulkner','Ferguson','Fernandez','Fields','Figueroa','Finch','Finley','Fischer','Fisher','Fitzgerald','Fitzpatrick','Fleming','Fletcher','Flores','Flowers','Floyd','Flynn','Foley','Forbes','Ford','Foreman','Foster','Fowler','Fox','Francis','Franco','Frank','Franklin','Frazier','Frederick','Freeman','French','Friedman','Fritz','Frost','Fry','Frye','Fuller','Fulton','Fuentes','Gaines','Gallagher','Gallegos','Galloway','Gamble','Garcia','Gardner','Garner','Garrett','Garrison','Garza','Gates','Gay','Gentry','George','Gibbs','Gibson','Gilbert','Giles','Gill','Gillespie','Gilmore','Glass','Glenn','Glover','Golden','Gomez','Gonzales','Gonzalez','Good','Goodman','Goodwin','Gordon','Gould','Graham','Grant','Graves','Gray','Grayson',
    // Expanded H-Z names
    'Green','Greene','Greer','Gregory','Griffin','Griffith','Grimes','Gross','Guerra','Guerrero','Gutierrez','Guy','Hahn','Hale','Haley','Hall','Hamilton','Hammond','Hampton','Hancock','Haney','Hansen','Hanson','Hardin','Harding','Hardy','Harmon','Harper','Harrell','Harrington','Harris','Harrison','Hart','Hartley','Hartman','Harvey','Hatfield','Hawkins','Hayes','Haynes','Head','Heath','Hebert','Henderson','Hendricks','Hendrix','Henry','Hensley','Henson','Herman','Hernandez','Herrera','Herring','Hess','Hester','Hickman','Hicks','Higgins','Hill','Hines','Hinton','Hobbs','Hodge','Hodges','Hoffman','Hogan','Holcomb','Holden','Holder','Holland','Holloway','Holmes','Holt','Hood','Hooper','Hoover','Hopkins','Hopper','Horn','Horne','Horton','House','Houston','Howard','Howe','Howell','Hubbard','Huber','Hudson','Huff','Huffman','Hughes','Hull','Humphrey','Hunt','Hunter','Hurley','Hurst','Hutchinson','Hyde','Ingram','Irwin','Jackson','Jacobs','Jacobson','James','Jarvis','Jefferson','Jenkins','Jennings','Jensen','Jimenez','Johns','Johnson','Johnston','Jones','Jordan','Joseph','Joyce','Juarez','Kane','Kaufman','Keith','Keller','Kelley','Kelly','Kemp','Kennedy','Kent','Kerr','Key','Kidd','Kim','King','Kinney','Kirby','Kirk','Klein','Kline','Knight','Knox','Koch','Kramer','Lamb','Lambert','Lancaster','Landry','Lane','Lang','Langley','Lara','Larsen','Larson','Lawrence','Lawson','Le','Leach','Leblanc','Lee','Leon','Leonard','Lester','Levine','Levy','Lewis','Lindsay','Lindsey','Little','Liu','Livingston','Lloyd','Logan','Long','Lott','Love','Lowe','Lowery','Lowry','Lucas','Luna','Lynch','Lynn','Lyons','Macdonald','Macias','Mack','Madden','Maddox','Maldonado','Malone','Mann','Manning','Marks','Marquez','Marsh','Marshall','Martin','Martinez','Mason','Massey','Mathews','Matthews','Maxwell','May','Mayer','Maynard','Mayo','Mays','McBride','McCall','McCarthy','McConnell','McCormick','McCoy','McCullough','McDaniel','McDonald','McDowell','McFarland','McGee','McGowan','McGuire','McIntosh','McIntyre','McKay','McKee','McKenzie','McKinney','McKnight','McLaughlin','McLean','McLeod','McMahon','McMillan','McNeil','McPherson','Meadows','Medina','Mejia','Melendez','Melton','Mendez','Mendoza','Mercado','Mercer','Merrill','Merritt','Meyer','Meyers','Michael','Middleton','Miles','Miller','Mills','Miranda','Mitchell','Molina','Monroe','Montague','Montagomery','Montoya','Moody','Moon','Moore','Morales','Moran','Moreno','Morgan','Morris','Morrison','Morrow','Morse','Morton','Moses','Mosley','Moss','Mueller','Mullen','Mullins','Munoz','Murphy','Murray','Myers','Nash','Navarro','Neal','Nelson','Neville','Newman','Newton','Nguyen','Nichols','Nicholson','Nielsen','Nixon','Noble','Noel','Nolan','Norman','Norris','North','Norton','Novak','Nunez','Obrien','Ochoa','Oconnor','Odom','Odonnell','Oliver','Olsen','Olson','ONeal','Ortega','Ortiz','Osborn','Osborne','Owens','Pace','Pacheco','Padilla','Page','Palmer','Park','Parker','Parks','Parrish','Parsons','Patel','Patrick','Patterson','Patton','Paul','Payne','Pearce','Pearson','Peck','Pena','Pennington','Perez','Perkins','Perry','Peters','Petersen','Peterson','Petty','Phelps','Phillips','Pickett','Pierce','Pike','Pittman','Pitts','Pollard','Ponce','Poole','Pope','Porter','Potter','Potts','Powell','Powers','Pratt','Preston','Price','Prince','Pruitt','Puckett','Pugh','Quinn','Ramirez','Ramos','Ramsey','Randall','Randolph','Rasmussen','Ray','Raymond','Reed','Reese','Reeves','Reid','Reilly','Reyes','Reynolds','Rhodes','Rice','Rich','Richard','Richards','Richardson','Richmond','Riddle','Riggs','Riley','Rios','Rivas','Rivera','Rivers','Roach','Robbins','Roberson','Roberts','Robertson','Robinson','Robles','Rocha','Rodgers','Rodriguez','Rodriquez','Rogers','Rojas','Rollins','Roman','Romero','Rosa','Rosales','Rosario','Rose','Ross','Roth','Rowe','Rowland','Roy','Ruiz','Rush','Russell','Russo','Rutledge','Ryan','Salas','Salazar','Salinas','Sampson','Sanchez','Sanders','Sandoval','Sanford','Santana','Santiago','Santos','Sargent','Saunders','Savage','Sawyer','Schaefer','Schmidt','Schneider','Schroeder','Schultz','Schwartz','Scott','Sears','Sellers','Serrano','Sexton','Shaffer','Shannon','Sharp','Sharpe','Shaw','Shelton','Shepard','Shepherd','Sheppard','Sherman','Shields','Short','Silva','Simmons','Simon','Simpson','Sims','Singleton','Skinner','Slater','Sloan','Small','Smith','Snow','Snyder','Solis','Solomon','Sosa','Soto','Sparks','Spears','Spence','Spencer','Stafford','Stanley','Stanton','Stark','Starr','Steele','Stein','Stephens','Stephenson','Stevens','Stevenson','Stewart','Stokes','Stone','Stout','Strickland','Strong','Stuart','Suarez','Sullivan','Summers','Sutton','Swanson','Sweeney','Sweet','Sykes','Talley','Tanner','Tate','Taylor','Terrell','Terry','Thomas','Thompson','Thornton','Tillman','Todd','Torres','Townsend','Tran','Travis','Trevino','Trujillo','Tucker','Turner','Tyler','Tyson','Underwood','Valdez','Valencia','Valentine','Valenzuela','Vance','Vang','Vargas','Vasquez','Vaughan','Vaughn','Vazquez','Vega','Velasquez','Velazquez','Velez','Villarreal','Vincent','Vinson','Wade','Wagner','Walker','Wall','Wallace','Waller','Walls','Walsh','Walter','Walters','Walton','Ward','Ware','Warner','Warren','Washington','Waters','Watkins','Watson','Watts','Weaver','Webb','Weber','Webster','Weeks','Weiss','Welch','Wells','Werner','West','Wheeler','Whitaker','White','Whitehead','Whitfield','Whitney','Whitley','Wiggins','Wilcox','Wilder','Wiley','Wilkerson','Wilkins','Wilkinson','William','Williams','Williamson','Willis','Wilson','Winters','Wise','Witt','Wolf','Wolfe','Wong','Wood','Woodard','Woods','Woodward','Wooten','Work','Wright','Wyatt','Wynn','Xavier','Yang','Yates','York','Young','Zamora','Zavala','Zhang','Zimmerman','Zuniga'
  ];

  // Track all names that have ever been used (current + alumni)
  if (!gameState.usedEmployeeNames) {
    gameState.usedEmployeeNames = new Set();
  }

  /**
   * Generate a unique name that hasn't been used before
   * @param {string} gender - The gender of the employee ('female', 'male', 'femaleFuta', 'transMan', 'transWoman')
   * @returns {string} Full name (First Last)
   */
  function generateUniqueName(gender = 'female') {
    const maxAttempts = 1000; // Prevent infinite loop
    let attempts = 0;
    
    // Select appropriate first name pool based on gender
    let firstNamePool;
    switch(gender) {
      case 'male':
      case 'transMan':
        firstNamePool = MALE_FIRST_NAMES_POOL;
        break;
      case 'female':
      case 'femaleFuta':
      case 'transWoman':
      default:
        firstNamePool = FIRST_NAMES_POOL;
        break;
    }
    
    while (attempts < maxAttempts) {
      const firstName = firstNamePool[Math.floor(Math.random() * firstNamePool.length)];
      const lastName = LAST_NAMES_POOL[Math.floor(Math.random() * LAST_NAMES_POOL.length)];
      const fullName = `${firstName} ${lastName}`;
      
      // Check if this name has been used
      if (!gameState.usedEmployeeNames.has(fullName)) {
        // Mark as used
        gameState.usedEmployeeNames.add(fullName);
        console.log(`[Names] Generated unique ${gender} name: ${fullName} (${gameState.usedEmployeeNames.size} names used)`);
        return fullName;
      }
      
      attempts++;
    }
    
    // Fallback: if somehow we've exhausted all combinations (extremely unlikely with 500*300 = 150,000 combinations)
    // Add a numeric suffix
    const firstName = firstNamePool[Math.floor(Math.random() * firstNamePool.length)];
    const lastName = LAST_NAMES_POOL[Math.floor(Math.random() * LAST_NAMES_POOL.length)];
    const suffix = Math.floor(Math.random() * 1000);
    const uniqueName = `${firstName} ${lastName} ${suffix}`;
    gameState.usedEmployeeNames.add(uniqueName);
    console.warn(`[Names] Exhausted name pool, using suffix: ${uniqueName}`);
    return uniqueName;
  }

  /**
   * Initialize used names from existing employees (for loading saved games)
   */
  function initializeUsedNames() {
    if (!gameState.usedEmployeeNames) {
      gameState.usedEmployeeNames = new Set();
    }
    
    // Add all current employee names
    gameState.employees.forEach(emp => {
      if (emp.name) {
        gameState.usedEmployeeNames.add(emp.name);
      }
    });
    
    console.log(`[Names] Initialized ${gameState.usedEmployeeNames.size} used names from existing employees`);
  }

  /**
   * Get the color for a gender category
   * @param {string} gender - The gender ('female', 'male', 'femaleFuta', 'transMan', 'transWoman')
   * @returns {string} Hex color code
   */
  function getGenderColor(gender) {
    const colors = {
      female: '#ff6b9d',
      male: '#00d4ff',
      femaleFuta: '#c77dff',
      transMan: '#4ecca3',
      transWoman: '#ffd700'
    };
    return colors[gender] || '#ff6b9d'; // Default to female color
  }

  /**
   * Get color-coded HTML for an employee's name
   * @param {object} employee - Employee object with name and gender
   * @returns {string} HTML string with colored name
   */
  function getColoredName(employee) {
    if (!employee || !employee.name) return '';
    const color = getGenderColor(employee.gender || 'female');
    return `<span style="color:${color};">${employee.name}</span>`;
  }
  
  // ============================================
  // EMPLOYEE GENERATION WITH GENDER SELECTION
  // ============================================

  /**
   * Select a gender for a new employee based on gameState.genderSettings
   * Uses weighted random selection based on the percentage distributions
   * @returns {string} Selected gender ('female', 'male', 'femaleFuta', 'transMan', 'transWoman')
   */
  function selectGenderForEmployee() {
    const settings = gameState.genderSettings;
    
    // Create an array of gender options with their weights
    const genderPool = [];
    
    // Add entries for each gender based on their percentage
    if (settings.female > 0) {
      for (let i = 0; i < settings.female; i++) {
        genderPool.push('female');
      }
    }
    if (settings.male > 0) {
      for (let i = 0; i < settings.male; i++) {
        genderPool.push('male');
      }
    }
    if (settings.femaleFuta > 0) {
      for (let i = 0; i < settings.femaleFuta; i++) {
        genderPool.push('femaleFuta');
      }
    }
    if (settings.transMan > 0) {
      for (let i = 0; i < settings.transMan; i++) {
        genderPool.push('transMan');
      }
    }
    if (settings.transWoman > 0) {
      for (let i = 0; i < settings.transWoman; i++) {
        genderPool.push('transWoman');
      }
    }
    
    // If pool is empty (shouldn't happen but safety check), default to female
    if (genderPool.length === 0) {
      console.warn('[Gender] Gender pool is empty, defaulting to female');
      return 'female';
    }
    
    // Select random gender from weighted pool
    const selectedGender = genderPool[Math.floor(Math.random() * genderPool.length)];
    console.log(`[Gender] Selected gender: ${selectedGender} (from pool of ${genderPool.length} weighted options)`);
    return selectedGender;
  }
  
    function generatePotentialHires(productId) {
  // Use the massive name pools defined above
  const firstNames = FIRST_NAMES_POOL;
  const lastNames = LAST_NAMES_POOL;
    const personalities = ['Playful','Reserved','Confident','Witty','Thoughtful','Cheeky','Dry-humored','Warm','Ambitious','Chill','Inquisitive','Loyal','Optimistic','Pessimistic','Sarcastic','Sincere','Spontaneous','Stoic','Supportive','Adventurous','Cautious','Curious','Diligent','Easygoing','Energetic','Focused','Generous','Humble','Imaginative','Meticulous','Pragmatic','Resourceful','Sociable','Tactful','Versatile'];
    const traits = ['Charismatic','Analytical','Creative','Detail-oriented','Adaptable','Empathetic','Organized','Bold', 'Reliable','Innovative','Strategic','Patient','Decisive','Collaborative','Resilient','Visionary','Persuasive','Curious','Ambitious','Supportive', 'Meticulous','Proactive','Diligent','Resourceful','Versatile', 'Submissive','Dominant','Flirty','Shy','Confident','Caring','Playful','Serious','Adventurous','Loyal','Spontaneous','Thoughtful','Cheeky','Witty','Warm','Inquisitive'];
    const hobbies = ['Reading','Photography','Hiking','Gaming','Cooking','Traveling','Music','Art','Yoga','Dancing','Climbing','Baking','Thrifting','Gardening','Writing','Cycling','Swimming','Crafting','Meditation','Volunteering','Fishing','Running','Collecting','Knitting','Birdwatching','Puzzles','Board games','Movies','Theater','Fitness','Martial arts','Skiing','Snowboarding','Surfing','Skateboarding','Camping','Astronomy','DIY projects','Blogging','Podcasting','Learning languages','Genealogy','Magic tricks','Robotics','Woodworking','Calligraphy','Chess','Travel blogging','Vlogging','Stand-up comedy','Improv'];
    const kinks = ['Roleplay','Bondage','Exhibitionism','Voyeurism','Dom/sub','Praise','Teasing','Spanking','Light impact','Dirty talk','Public play','Costumes','Sensory play','Tickling','Restraints','Blindfolds','Temperature play','Massage','Oral fixation','Foot fetish','Group play','Cuddling','Hair pulling','Choking','Anal play','Threesomes','Fantasies','Power exchange','Erotic humiliation','Sensation play','Mutual masturbation',];
    const ages = [22,23,24,25,26,27,28,29,30,31,32,33,34];

    const pickSome = (arr, min, max) => {
        const n = Math.max(min, Math.min(max, Math.floor(Math.random()*(max-min+1))+min));
        const out = new Set();
        while(out.size < n) out.add(arr[Math.floor(Math.random()*arr.length)]);
        return [...out];
    };

    const candidates = [];
    for (let i = 0; i < 3; i++) {
    // Select gender based on settings
    const selectedGender = selectGenderForEmployee();
    
    const cand = {
    id: `emp_${Date.now()}_${i}`,
    name: generateUniqueName(selectedGender), // Use unique name generator with gender
    age: ages[Math.floor(Math.random()*ages.length)],
    gender: selectedGender,
    position: 'Manager Candidate',
    productId,
    // personality & interests
    personalityTraits: pickSome(personalities, 3, 5),
    keyTrait: traits[Math.floor(Math.random()*traits.length)],
    hobbies: pickSome(hobbies, 1, 2),
    kinks: pickSome(kinks, 2, 4),
    // AI personality attributes (C.O.F.P.H.)
    personality: {
      confidence: 30 + Math.floor(Math.random() * 50),    // 30-80 range
      outgoing: 20 + Math.floor(Math.random() * 60),      // 20-80 range
      flirty: 10 + Math.floor(Math.random() * 70),        // 10-80 range
      professional: 30 + Math.floor(Math.random() * 50),  // 30-80 range
      humor: 20 + Math.floor(Math.random() * 60)          // 20-80 range
    },
    // stats (0-100 scale)
    stats: {
      affection:    20 + Math.floor(Math.random()*20),  // How much they like you personally
      comfort:      40 + Math.floor(Math.random()*30),  // How comfortable they feel around you
      trust:        30 + Math.floor(Math.random()*30),  // How much they trust you
      desire:       5 + Math.floor(Math.random()*15),   // Romantic/sexual attraction
      obedience:    40 + Math.floor(Math.random()*30),  // Willingness to follow instructions
      productivity: 50 + Math.floor(Math.random()*30)   // Work performance (affects game mechanics)
    },
    // onboarding + bio fields
    hired: false,
    onboarding: true,
    bioComplete: false,
    productManaged: null,
    physical: {
      heightBuild: null,
      hair: { color: null, style: null, length: null },
      eyes: { color: null, shape: null },
      skinTone: null,
      bodyShape: null,
      breastSize: null,
      buttSize: null,
      fashion: null
    },
    profileImage: null,
    bio: null
    };
        candidates.push(cand);
    }
    return candidates;
    }

  // Handle manager hiring UI
  // Finalize manager hire (for former employees who skip onboarding)
  function finalizeManagerHire(candidate, product) {
    // Initialize social network data if not already present
    if (!candidate.socialData) {
      initializeEmployeeSocialData(candidate);
    }
    
    // Add to employees array
    gameState.employees.push(candidate);
    
    // Update company awareness
    updateCompanyAwareness();
    
    // Generate relationships with existing employees (or restore old ones)
    generateRandomRelationships(candidate.id);
    
    // Log rehire event
    logCompanyEvent({
      type: 'hire',
      involvedEmployees: [candidate.id],
      location: candidate.locationId || product.locationId || 'headquarters',
      description: `${candidate.name} returned as ${candidate.position}`,
      sentiment: 'positive',
      importance: 7
    });
    
    // Generate a "I'm back!" post
    generateFirstEmployeePost(candidate).catch(err => {
      console.error('Welcome back post generation failed:', err);
    });
    
    // Mark manager on product
    product.managerHired = true;
    product.managerLevel = 1;
    product.managerOnboarding = false;
    
    // UI updates
    updatePeopleTab();
    updateProductsList();
    
    // Refresh dashboard to show returning employee
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
  }

  // Calculate loyalty bonus based on times rehired
  function calculateLoyaltyBonus(timesRehired) {
    // 5% bonus per rehire, up to 50% max
    return Math.min(0.50, timesRehired * 0.05);
  }

  function showManagerHiringModal(productId) {
    const product = gameState.products.find(p => p.id === productId);
    if (!product) return;

    // Check if there's a former employee who managed this product
    const formerManager = (gameState.formerEmployees || []).find(
      fe => fe.productManaged === product.name
    );
    
    // Get 3 candidates (uses your existing generator)
    let candidates = generatePotentialHires(productId);
    
    // If there's a former manager, replace the first candidate with them
    if (formerManager) {
      const loyaltyBonus = calculateLoyaltyBonus(formerManager.timesRehired || 1);
      
      // Create candidate from former employee
      const formerCandidate = {
        ...formerManager,
        id: `emp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        productId: productId,
        isFormerEmployee: true,
        loyaltyBonus: loyaltyBonus,
        hired: false,
        onboarding: false,
        bioComplete: true, // Already has full bio
        employmentStatus: 'candidate'
      };
      
      // Put former employee as first option
      candidates = [formerCandidate, ...candidates.slice(1)];
    }
    
    gameState.currentCandidates = candidates;

  const modal = document.createElement('div');
  modal.id = 'hiringModal';
  // Don't set z-index and positioning - ModalManager will handle it
  modal.style.background = 'rgba(0,0,0,0.7)';

    const cards = candidates.map((c, i) => {
      const isFormer = c.isFormerEmployee || false;
      const loyaltyText = isFormer ? `<div style="background:#ffd700; color:#0f1419; padding:8px; border-radius:6px; margin-bottom:8px; font-weight:bold; text-align:center;">
        ⭐ FORMER EMPLOYEE ⭐<br/>
        <span style="font-size:0.9rem;">Loyalty Bonus: +${(c.loyaltyBonus * 100).toFixed(0)}% productivity</span><br/>
        <span style="font-size:0.8rem;">Times Rehired: ${c.timesRehired || 1}</span>
      </div>` : '';
      
      return `
        <div class="candidate-card" style="background:${isFormer ? '#1a2a1a' : '#16213e'}; border:${isFormer ? '3px solid #ffd700' : 'none'}; border-radius:10px; padding:16px; margin:10px; width:300px; position:relative;">
        ${isFormer ? '<div style="position:absolute; top:8px; right:8px; font-size:1.5rem;">💛</div>' : ''}
        ${loyaltyText}
        <h3 style="margin:0 0 4px 0;">${getColoredName(c)} ${c.age ? `• ${c.age}` : ''}</h3>
        <p style="margin:0; color:#aaa;">Key trait: ${c.keyTrait || c.traits?.[0] || 'Dedicated'}</p>
        <p style="margin:6px 0 0 0; font-size:.9rem;">Personality: ${(c.personalityTraits || []).join(', ') || 'Professional'}</p>
        <p style="margin:6px 0 10px 0; color:#aaa; font-size:.9rem;">Hobbies: ${(c.hobbies || []).join(', ') || 'Various'}</p>

        <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:6px; margin-bottom:12px;">
            <div style="background:#0f3460; padding:6px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Affection</div>
            <div style="color:#e94560; font-weight:600;">${Math.round(c.stats.affection ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:6px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Comfort</div>
            <div style="color:#4ecca3; font-weight:600;">${Math.round(c.stats.comfort ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:6px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Trust</div>
            <div style="color:#00d4ff; font-weight:600;">${Math.round(c.stats.trust ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:6px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Desire</div>
            <div style="color:#ff6b9d; font-weight:600;">${Math.round(c.stats.desire ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:6px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Obedience</div>
            <div style="color:#c77dff; font-weight:600;">${Math.round(c.stats.obedience ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:6px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Productivity</div>
            <div style="color:#ffd700; font-weight:600;">${Math.round((c.stats.productivity ?? 0) * (1 + (c.loyaltyBonus || 0)))}%</div>
            </div>
        </div>

        <button class="select-candidate-btn" data-index="${i}" style="width:100%; padding:10px; background:${isFormer ? '#ffd700' : '#e94560'}; border:none; border-radius:6px; color:${isFormer ? '#0f1419' : '#fff'}; cursor:pointer; font-weight:${isFormer ? 'bold' : 'normal'};">
            ${isFormer ? '⭐ Rehire' : 'Select'} ${c.name}
        </button>
        </div>
    `;
    }).join('');

  modal.innerHTML = `
    <div class="hiring-modal-panel" role="dialog" aria-modal="true" aria-label="Select a Manager" style="background:#0f1419; width:92%; max-width:1000px; padding:18px; border-radius:14px; box-shadow:0 5px 25px rgba(0,0,0,0.5); pointer-events:auto;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
      <h2 style="margin:0;">Select a Manager for ${product.name}</h2>
      <button class="close-modal-btn" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
    </div>
    <div style="display:flex; justify-content:center; flex-wrap:wrap;">
      ${cards}
    </div>
    <p style="margin-top:12px; color:#aaa; font-size:.9rem;">You’ll be charged <strong>${product.managerHireCost}</strong> when you choose a candidate.</p>
    </div>
  `;

    // Use ModalManager to show the modal
    ModalManager.show(modal, 'hiringModal');
    gameState.currentCandidates = candidates;

    // Set up event listeners for background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeHiringModal();
      }
    });

    // Set up close button listener
    const closeBtn = modal.querySelector('.close-modal-btn');
    if (closeBtn) {
      closeBtn.addEventListener('click', closeHiringModal);
    }

    // Set up select candidate buttons
    const selectButtons = modal.querySelectorAll('.select-candidate-btn');
    selectButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const index = parseInt(btn.dataset.index, 10);
        if (!Number.isNaN(index)) {
          selectManagerCandidate(index);
        }
      });
    });

    // Allow Esc to close
    const esc = (ev) => { 
      if (ev.key === 'Escape') { 
        closeHiringModal(); 
        window.removeEventListener('keydown', esc); 
      } 
    };
    window.addEventListener('keydown', esc);
  }  

  // Close hiring modal
  function closeHiringModal() {
    // Use ModalManager to close
    ModalManager.close('hiringModal');
    gameState.currentCandidates = null;
    document.body.style.overflow = ''; // Restore scrolling
  }

  // Generate context-aware rehire message using AI
  async function generateRehireMessage(employee) {
    try {
      // Analyze relationship context
      const stats = employee.stats || {};
      const intimacy = employee.intimacy || {};
      const memory = employee.memory || {};
      const chatHistory = employee.chatHistory || [];
      const conversationArchive = employee.conversationArchive || [];
      
      // Calculate relationship metrics
      const avgAffection = stats.affection || 50;
      const avgTrust = stats.trust || 50;
      const avgDesire = stats.desire || 50;
      const intimacyLevel = intimacy.level || 0;
      const sexualHistory = intimacy.sexCount || 0;
      const timesRehired = employee.timesRehired || 1;
      
      // Analyze recent conversation topics from last 10 messages
      const recentMessages = [...conversationArchive, ...chatHistory]
        .slice(-10)
        .map(msg => msg.content)
        .join(' | ');
      
      // Determine relationship quality
      const avgRelationship = (avgAffection + avgTrust) / 2;
      const relationshipQuality = avgRelationship >= 70 ? 'excellent' : avgRelationship >= 50 ? 'good' : avgRelationship >= 30 ? 'strained' : 'poor';
      const isSexual = intimacyLevel >= 50 || sexualHistory > 0;
      const isRomantic = avgAffection >= 70 && avgDesire >= 60;
      
      // Build context prompt for AI
      const contextPrompt = `You are ${employee.name}, a ${employee.age}-year-old ${employee.gender} who previously worked for the player as a manager.

RELATIONSHIP CONTEXT:
- Affection: ${avgAffection}/100 (${avgAffection >= 70 ? 'very high' : avgAffection >= 50 ? 'positive' : avgAffection >= 30 ? 'neutral' : 'low'})
- Trust: ${avgTrust}/100 (${avgTrust >= 70 ? 'very high' : avgTrust >= 50 ? 'trusting' : avgTrust >= 30 ? 'cautious' : 'distrustful'})
- Desire: ${avgDesire}/100
- Intimacy Level: ${intimacyLevel}/100
- Sexual encounters: ${sexualHistory}
- Times rehired: ${timesRehired}
- Overall relationship: ${relationshipQuality}${isSexual ? ', sexual' : ''}${isRomantic ? ', romantic' : ''}

PERSONALITY:
${employee.personality || 'Professional and dedicated'}

RECENT CONVERSATION TOPICS:
${recentMessages || 'No recent conversation history'}

INSTRUCTIONS:
Generate a SINGLE short message (1-2 sentences, max 150 characters) that ${employee.name} would send when being rehired.

IMPORTANT TONE GUIDELINES:
${isSexual && avgAffection >= 60 ? `- Be flirty, suggestive, and reference your intimate past. Use innuendo or explicit language. Example: "Can't wait for those 'after hours' meetings again 😏" or "Missed our special connection... ready to make up for lost time ❤️"` : ''}
${isRomantic && !isSexual ? `- Be warm, affectionate, and emotionally connected. Show you missed them personally.` : ''}
${avgRelationship >= 70 && !isSexual ? `- Be enthusiastic and happy to return. Express genuine excitement.` : ''}
${avgRelationship >= 40 && avgRelationship < 70 ? `- Be professional but friendly. Acknowledge the working relationship.` : ''}
${avgRelationship < 40 ? `- Be distant, cold, or passive-aggressive. Maybe express reluctance or sarcasm. Example: "Well, here we are again..." or "Guess I'm back... for now."` : ''}

NO LIMITS on suggestiveness if intimacy is high. Match the energy of your past interactions.

Generate ONLY the message, no quotes, no explanation:`;

      const response = await queryLLM(contextPrompt, {
        type: 'rehire-message',
        employee: employee.name,
        temperature: 0.9, // Higher creativity for varied responses
        maxTokens: 80
      });

      return response || `It's good to be back! Ready to get to work. 💼`;
      
    } catch (error) {
      console.error('Error generating rehire message:', error);
      // Fallback based on basic stats
      const affection = employee.stats?.affection || 50;
      if (affection >= 70) {
        return `Boss! I've missed you so much! 💕 Ready to make this work... amazing. 😏`;
      } else if (affection >= 50) {
        return `Hey! Good to be back working with you again! 😊`;
      } else {
        return `Well... I'm back. Let's see how this goes.`;
      }
    }
  }

  // Select and onboard a manager candidate
    async function selectManagerCandidate(index) {
    const candidate = gameState.currentCandidates?.[index];
    const product = gameState.products.find(p => p.id === candidate?.productId);
    if (!candidate || !product) return;

    // funds check happens before modal in hireOrUpgradeManager, but double-guard:
    if (gameState.cash < product.managerHireCost) { showNotification('Not enough cash!'); return; }
    
    // Check if this is a former employee being rehired
    const isFormerEmployee = candidate.isFormerEmployee || false;

    // mark & queue onboarding
    candidate.hired = true;
    candidate.position = `Manager – ${product.name}`;
    candidate.productManaged = product.name;
    
    // Former employees skip onboarding (they already know the job!)
    if (isFormerEmployee) {
      candidate.onboarding = false;
      candidate.bioComplete = true;
      
      // Restore their chat history and archive
      if (candidate.chatHistory && candidate.chatHistory.length > 0) {
        gameState.chatHistory[candidate.id] = candidate.chatHistory;
      }
      if (candidate.conversationArchive) {
        candidate.conversationArchive = candidate.conversationArchive;
      } else {
        candidate.conversationArchive = [];
      }
      
      // Apply loyalty bonus to stats
      if (candidate.loyaltyBonus) {
        candidate.stats.productivity = Math.min(100, (candidate.stats.productivity || 70) * (1 + candidate.loyaltyBonus));
      }
      
      // Generate context-aware welcome back message
      if (!gameState.chatHistory[candidate.id]) {
        gameState.chatHistory[candidate.id] = [];
      }
      
      // Generate AI-powered rehire message
      generateRehireMessage(candidate).then(message => {
        gameState.chatHistory[candidate.id].push({
          sender: candidate.name,
          content: message,
          isPlayer: false,
          timestamp: Date.now()
        });
        
        // Mark as unread so player sees the welcome message
        candidate.unreadMessages = (candidate.unreadMessages || 0) + 1;
        
        // Update UI if chat is open
        if (gameState.activeChat === candidate.id) {
          renderChatMessages();
        }
      });
      
      showNotification(`${candidate.name} has returned! +${(candidate.loyaltyBonus * 100).toFixed(0)}% loyalty bonus!`);
    } else {
      candidate.onboarding = true;
      candidate.bioComplete = false;
    }

      // Product-level onboarding flag and immediate effects
      // a) Replace CTA with onboarding status via updateProductsList
      // b) Immediately subtract cash (with employee discount)
      // c) Begin automation right away
      product.managerOnboarding = !isFormerEmployee; // Former employees don't need onboarding
      
      // Apply employee discount from influence upgrades
      const employeeDiscountLevel = gameState.influenceUpgrades?.employeeDiscount || 0;
      const discountMultiplier = influenceUpgrades.employeeDiscount.effect(employeeDiscountLevel);
      const finalCost = Math.floor(product.managerHireCost * discountMultiplier);
      
      gameState.cash -= finalCost;
      // start automated cycle if not already running
      if (!product.running) {
        product.running = true;
        product.timeRemainingMs = currentCycleTimeMs(product);
      }

    // show in People tab as a badge (only if they need onboarding)
    if (!isFormerEmployee) {
      gameState.onboarding.push(candidate);
    }
    closeHiringModal();
      updatePeopleTab();
      updateProductsList();
      
    // If former employee, skip AI generation and finalize immediately
    if (isFormerEmployee) {
      finalizeManagerHire(candidate, product);
      return;
    }

    // --- AI generation (guarded) - only for new employees ---
    try {
        const profilePrompt = `
  Create an in-world, adult female NPC profile (no meta-talk) for: ${candidate.name}, age ${candidate.age}.
  Gender: female.
  Role: ${candidate.position}. Product managed: ${product.name}.
  Personality traits: ${candidate.personalityTraits.join(', ')}. Key trait: ${candidate.keyTrait}.
  Hobbies: ${candidate.hobbies.join(', ')}. Kink preferences: ${candidate.kinks.join(', ')}.

  Respond as a compact JSON object with these keys ONLY:
  {
  "name": {"first":"", "last":""},
  "age": <number>,
  "gender": "female",
  "productManaged": "${product.name}",
  "bio": "<2-3 sentence personality/background, world-grounded>",
  "appearance": {
  "heightBuild": "",
  "hair": {"color":"","style":"","length":""},
  "eyes": {"color":"","shape":""},
  "skinTone": "",
  "bodyShape": "",
  "breastSize": "",
  "buttSize": "",
  "fashion": ""
  },
  "personalityTraits": [${candidate.personalityTraits.map(s=>`"${s}"`).join(', ')}],
  "kinks": [${candidate.kinks.map(s=>`"${s}"`).join(', ')}]
  }
  `;

        // fallbacks if plugin missing
        const aiRaw = typeof generateText === 'function'
        ? await generateText(profilePrompt)
        : `{"name":{"first":"${candidate.name.split(' ')[0]}","last":"${candidate.name.split(' ')[1]||''}"},"age":${candidate.age},"productManaged":"${product.name}","bio":"Quick learner; keeps launches smooth.","appearance":{"heightBuild":"average","hair":{"color":"brown","style":"soft waves","length":"shoulder"},"eyes":{"color":"green","shape":"almond"},"skinTone":"light","bodyShape":"curvy","breastSize":"medium","buttSize":"full","fashion":"smart casual"},"personalityTraits":["${candidate.personalityTraits.join('","')}"],"kinks":["${candidate.kinks.join('","')}"]}`;

        let parsed;
        try { parsed = JSON.parse(aiRaw); } catch { parsed = null; }

        if (parsed && parsed.name) {
        candidate.name = `${parsed.name.first} ${parsed.name.last}`.trim() || candidate.name;
        candidate.age = parsed.age ?? candidate.age;
        candidate.productManaged = parsed.productManaged || product.name;
        candidate.bio = parsed.bio || "Keeps things moving; loves clean launches.";
        
        // Generate detailed physical appearance (NEW SYSTEM!) - Gender-aware
        candidate.physical = generateDetailedPhysicalAppearance(candidate.gender || 'female');
        
        // Override with AI-generated details if available
        const ap = parsed.appearance || {};
        if (ap.heightBuild) candidate.physical.heightBuild = ap.heightBuild;
        if (ap.hair) candidate.physical.hair = { ...candidate.physical.hair, ...ap.hair };
        if (ap.eyes) candidate.physical.eyes = { ...candidate.physical.eyes, ...ap.eyes };
        if (ap.skinTone) candidate.physical.skin.tone = ap.skinTone;
        if (ap.bodyShape) candidate.physical.body.shape = ap.bodyShape;
        if (ap.breastSize || ap.chestSize) {
          candidate.physical.body.chestSize = ap.chestSize || ap.breastSize;
          candidate.physical.body.breastSize = ap.chestSize || ap.breastSize; // Backwards compatibility
        }
        if (ap.buttSize) candidate.physical.body.buttSize = ap.buttSize;
        if (ap.fashion) candidate.physical.fashion = ap.fashion;
        
        candidate.personalityTraits = parsed.personalityTraits || candidate.personalityTraits;
        candidate.kinks = parsed.kinks || candidate.kinks;
        } else {
        // minimal fallback - generate full detailed appearance (Gender-aware)
        candidate.bio = "Quick learner; keeps launches smooth. Friendly and playful in the office.";
        candidate.physical = generateDetailedPhysicalAppearance(candidate.gender || 'female');
        }

        // optional image (now uses consistent physical description!)
        if (typeof generateImage === 'function') {
          const imgPrompt = `Professional portrait photo: ${candidate.physical.shortDescription}. ${candidate.physical.face.full}. ${candidate.physical.fashion} style outfit. Office setting, soft professional lighting, friendly expression, high quality, photorealistic`;
        try {
            const imgUrl = await generateImage({ prompt: imgPrompt });
            if (imgUrl) candidate.profileImage = imgUrl;
        } catch (e) { /* ignore */ }
        }

  // move from onboarding → employees
        candidate.onboarding = false;
        candidate.bioComplete = true;
        gameState.onboarding = gameState.onboarding.filter(e => e.id !== candidate.id);
        
        // Initialize social network data
        initializeEmployeeSocialData(candidate);
        
        gameState.employees.push(candidate);
        
        // Update company awareness
        updateCompanyAwareness();
        
        // Generate relationships with existing employees
        generateRandomRelationships(candidate.id);
        
        // Log hire event
        logCompanyEvent({
          type: 'hire',
          involvedEmployees: [candidate.id],
          location: candidate.locationId,
          description: `${candidate.name} joined as ${candidate.position}`,
          sentiment: 'positive',
          importance: 6
        });
        
        // Generate first post (new hire announcement)
        generateFirstEmployeePost(candidate).catch(err => {
          console.error('First post generation failed:', err);
        });

  // mark manager on product (already charged and started); finish onboarding
  product.managerHired = true;
  product.managerLevel = 1;
  product.managerOnboarding = false;

        // UI
        updatePeopleTab();
        updateProductsList();
        showNotification(`${candidate.name} hired to manage ${product.name}!`);
        
        // Refresh dashboard to show new employee
        if (gameState.activeTab === 'dashboard') {
          refreshDashboardSections();
        }

    } catch (error) {
        console.error('Onboarding error:', error);
        showNotification('Onboarding hit a snag—try again.');
        // clean up onboarding badge
        gameState.onboarding = gameState.onboarding.filter(e => e.id !== candidate.id);
    }
    }

  // Setup event listeners
  function setupEventListeners() {
    // Tab navigation
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const tab = btn.dataset.tab;
        switchTab(tab);
      });
    });
    
    // Upgrade Multiplier Toggle
    const upgradeMultiplierBtn = $('upgradeMultiplierBtn');
    if (upgradeMultiplierBtn) {
      upgradeMultiplierBtn.addEventListener('click', () => {
        const multipliers = [1, 5, 10, 100, 'max'];
        const currentIndex = multipliers.indexOf(gameState.upgradeMultiplier);
        const nextIndex = (currentIndex + 1) % multipliers.length;
        gameState.upgradeMultiplier = multipliers[nextIndex];
        upgradeMultiplierBtn.textContent = `x${gameState.upgradeMultiplier}`;
        
        // Update product cards to show new costs
        if (gameState.activeTab === 'business') {
          updateProductsList();
        }
      });
    }
    
    // Settings panel
    if (settingsBtn) {
      settingsBtn.addEventListener('click', () => {
        if (settingsPanel) settingsPanel.hidden = false;
      });
    }
    
    if (closeSettingsBtn) {
      closeSettingsBtn.addEventListener('click', () => {
        if (settingsPanel) settingsPanel.hidden = true;
      });
    }
    
    // Settings controls
    if (densitySlider && densityValue) {
      densitySlider.addEventListener('input', (e) => {
        gameState.settings.uiDensity = parseInt(e.target.value);
        const densityLabels = ['Compact', 'Normal', 'Spacious'];
        const label = densityLabels[Math.floor(e.target.value / 34)];
        densityValue.textContent = label;
      });
    }
    
    if (autosaveToggle) {
      autosaveToggle.addEventListener('change', (e) => {
        gameState.settings.autosave = e.target.checked;
      });
    }
    
    // Player Bio - DEPRECATED: Now handled by player profile modal
    // Old textarea-based bio system has been replaced
    const playerBioInput = $('playerBioInput'); // No longer exists in HTML
    const savePlayerBio = $('savePlayerBio');   // No longer exists in HTML
    
    // Kept for backward compatibility but will not execute
    if (playerBioInput && savePlayerBio) {
      // This code path won't execute since elements were removed
      savePlayerBio.addEventListener('click', () => {
        gameState.settings.playerBio = playerBioInput.value.trim();
        savePlayerBio.textContent = '✓ Saved!';
        savePlayerBio.style.background = '#00d4ff';
        setTimeout(() => {
          savePlayerBio.textContent = 'Save Player Bio';
          savePlayerBio.style.background = '#00d4ff';
        }, 2000);
      });
    }
    
    if (atmosphereSlider && atmosphereValue) {
      atmosphereSlider.addEventListener('input', (e) => {
        gameState.settings.atmosphere = parseInt(e.target.value);
        const val = parseInt(e.target.value);
        let label = 'Balanced';
        if (val < 33) label = 'Professional';
        else if (val > 66) label = 'Relaxed';
        atmosphereValue.textContent = label;
      });
    }
    
    if (guidelinesSlider && guidelinesValue) {
      guidelinesSlider.addEventListener('input', (e) => {
        gameState.settings.guidelines = parseInt(e.target.value);
        const val = parseInt(e.target.value);
        let label = 'Standard';
        if (val < 33) label = 'Reserved';
        else if (val > 66) label = 'Outgoing';
        guidelinesValue.textContent = label;
      });
    }
    
    // Policy buttons
    document.querySelectorAll('.policy-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        gameState.settings.policy = btn.dataset.policy;
        
        // Update button styles
        document.querySelectorAll('.policy-btn').forEach(b => {
          b.style.background = '#0f3460';
          b.style.borderColor = '#00d4ff';
          b.style.color = 'white';
        });
        btn.style.background = '#e94560';
        btn.style.borderColor = '#e94560';
        btn.style.color = 'white';
        
        // Update policy value label
        const policyValue = document.getElementById('policyValue');
        if (policyValue) {
          const policyLabels = {
            'professional': 'Professional',
            'casual': 'Casual',
            'open': 'Enthusiastic'
          };
          policyValue.textContent = policyLabels[btn.dataset.policy] || 'Professional';
        }
      });
    });
    
    // Data management
    if (saveBtn) saveBtn.addEventListener('click', saveGame);
    if (loadBtn) loadBtn.addEventListener('click', loadGame);
    if (exportBtn) exportBtn.addEventListener('click', exportSave);
    if (resetBtn) resetBtn.addEventListener('click', resetGame);
    
    // Chat modal
    if (closeChatBtn) {
      closeChatBtn.addEventListener('click', () => {
        if (chatModal) {
          chatModal.hidden = true;
          chatModal.style.display = 'none';
          chatModal.style.pointerEvents = 'none';
          gameState.activeChat = null;
        }
      });
    }
    
    // Clear chat button
    const clearChatBtn = $('clearChatBtn');
    if (clearChatBtn) {
      clearChatBtn.addEventListener('click', () => {
        if (!gameState.activeChat) return;
        
        const employee = gameState.employees.find(e => e.id === gameState.activeChat);
        if (!employee) return;
        
        // Confirm before clearing
        if (!confirm(`Clear chat history with ${employee.name}?\n\nThis will archive the conversation but remove it from view. Context will be preserved for AI.`)) {
          return;
        }
        
        // Archive current chat history
        const currentHistory = gameState.chatHistory[gameState.activeChat] || [];
        if (currentHistory.length > 0) {
          // Initialize archive if it doesn't exist
          if (!employee.conversationArchive) {
            employee.conversationArchive = [];
          }
          
          // Add current chat to archive with timestamp
          employee.conversationArchive.push({
            timestamp: Date.now(),
            messages: [...currentHistory],
            messageCount: currentHistory.length
          });
          
          // Keep only last 5 archived conversations to prevent bloat
          if (employee.conversationArchive.length > 5) {
            employee.conversationArchive = employee.conversationArchive.slice(-5);
          }
          
          // Clear visible chat
          gameState.chatHistory[gameState.activeChat] = [];
          
          // Update display
          renderChatMessages();
          
          showNotification(`Chat with ${employee.name} cleared and archived.`);
        }
      });
    }
    
    if (chatSendBtn) {
      chatSendBtn.addEventListener('click', sendOrUpdateChatMessage);
    }
    
    if (chatInput) {
      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendOrUpdateChatMessage();
      });
    }
    
    // Emoji picker for chat
    const chatEmojiBtn = $('chatEmojiBtn');
    console.log('Chat emoji button:', chatEmojiBtn, 'Chat input:', chatInput);
    if (chatEmojiBtn && chatInput) {
      chatEmojiBtn.addEventListener('click', (e) => {
        console.log('Chat emoji button clicked!');
        e.stopPropagation();
        emojiPicker.show(chatInput, chatEmojiBtn);
      });
    }
    
    // Emoji picker for post caption
    const postCaptionEmojiBtn = $('postCaptionEmojiBtn');
    const playerPostCaption = $('playerPostCaption');
    if (postCaptionEmojiBtn && playerPostCaption) {
      postCaptionEmojiBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        emojiPicker.show(playerPostCaption, postCaptionEmojiBtn);
      });
    }
    
    // Emoji picker for comments (delegated event)
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('comment-emoji-btn')) {
        e.stopPropagation();
        const postId = e.target.dataset.postId;
        const commentInput = document.querySelector(`.comment-input[data-post-id="${postId}"]`);
        if (commentInput) {
          emojiPicker.show(commentInput, e.target);
        }
      }
    });
    
    // Initialize emoji picker
    emojiPicker.init();
    
    // Player Profile Modal
    const openPlayerProfileBtn = $('openPlayerProfileBtn');
    const playerProfileModal = $('playerProfileModal');
    const closePlayerProfileModal = $('closePlayerProfileModal');
    const cancelPlayerProfile = $('cancelPlayerProfile');
    const savePlayerProfile = $('savePlayerProfile');
    
    if (openPlayerProfileBtn && playerProfileModal) {
      openPlayerProfileBtn.addEventListener('click', () => {
        // Load current profile data into form
        $('playerFirstName').value = gameState.playerProfile.firstName || '';
        $('playerLastName').value = gameState.playerProfile.lastName || '';
        $('playerAge').value = gameState.playerProfile.age || '';
        $('playerGender').value = gameState.playerProfile.gender || '';
        $('playerEthnicity').value = gameState.playerProfile.ethnicity || '';
        $('playerSkinTone').value = gameState.playerProfile.skinTone || '';
        $('playerHeight').value = gameState.playerProfile.height || '';
        $('playerBodyType').value = gameState.playerProfile.bodyType || '';
        $('playerHairColor').value = gameState.playerProfile.hairColor || '';
        $('playerHairStyle').value = gameState.playerProfile.hairStyle || '';
        $('playerEyeColor').value = gameState.playerProfile.eyeColor || '';
        $('playerFacialHair').value = gameState.playerProfile.facialHair || '';
        $('playerGenitalType').value = gameState.playerProfile.genitalType || '';
        $('playerGenitalDetails').value = gameState.playerProfile.genitalDetails || '';
        $('playerChestSize').value = gameState.playerProfile.chestSize || '';
        $('playerBuildDetails').value = gameState.playerProfile.buildDetails || '';
        $('playerAdditionalDetails').value = gameState.playerProfile.additionalDetails || '';
        $('playerPersonality').value = gameState.playerProfile.personality || '';
        
        playerProfileModal.style.display = 'flex';
      });
      
      const closeModal = () => {
        playerProfileModal.style.display = 'none';
      };
      
      if (closePlayerProfileModal) closePlayerProfileModal.addEventListener('click', closeModal);
      if (cancelPlayerProfile) cancelPlayerProfile.addEventListener('click', closeModal);
      
      if (savePlayerProfile) {
        savePlayerProfile.addEventListener('click', () => {
          // Save all fields
          gameState.playerProfile.firstName = $('playerFirstName').value.trim();
          gameState.playerProfile.lastName = $('playerLastName').value.trim();
          gameState.playerProfile.age = parseInt($('playerAge').value) || null;
          gameState.playerProfile.gender = $('playerGender').value;
          gameState.playerProfile.ethnicity = $('playerEthnicity').value.trim();
          gameState.playerProfile.skinTone = $('playerSkinTone').value.trim();
          gameState.playerProfile.height = $('playerHeight').value.trim();
          gameState.playerProfile.bodyType = $('playerBodyType').value.trim();
          gameState.playerProfile.hairColor = $('playerHairColor').value.trim();
          gameState.playerProfile.hairStyle = $('playerHairStyle').value.trim();
          gameState.playerProfile.eyeColor = $('playerEyeColor').value.trim();
          gameState.playerProfile.facialHair = $('playerFacialHair').value.trim();
          gameState.playerProfile.genitalType = $('playerGenitalType').value;
          gameState.playerProfile.genitalDetails = $('playerGenitalDetails').value.trim();
          gameState.playerProfile.chestSize = $('playerChestSize').value.trim();
          gameState.playerProfile.buildDetails = $('playerBuildDetails').value.trim();
          gameState.playerProfile.additionalDetails = $('playerAdditionalDetails').value.trim();
          gameState.playerProfile.personality = $('playerPersonality').value.trim();
          
          showNotification('Player profile saved!');
          playerProfileModal.style.display = 'none';
          saveGame(); // Auto-save after profile update
        });
      }
    }
    
    // Gender Options Modal
    const genderOptionsBtn = $('genderOptionsBtn');
    const genderOptionsModal = $('genderOptionsModal');
    const closeGenderOptionsModal = $('closeGenderOptionsModal');
    const cancelGenderOptions = $('cancelGenderOptions');
    const saveGenderOptions = $('saveGenderOptions');
    
    // Get all slider elements
    const femaleSlider = $('femaleSlider');
    const maleSlider = $('maleSlider');
    const femaleFutaSlider = $('femaleFutaSlider');
    const transManSlider = $('transManSlider');
    const transWomanSlider = $('transWomanSlider');
    
    // Get percentage display elements
    const femalePercentage = $('femalePercentage');
    const malePercentage = $('malePercentage');
    const femaleFutaPercentage = $('femaleFutaPercentage');
    const transManPercentage = $('transManPercentage');
    const transWomanPercentage = $('transWomanPercentage');
    const genderTotalValue = $('genderTotalValue');
    const genderWarning = $('genderWarning');
    
    // Function to update gender distribution display
    function updateGenderDistributionDisplay() {
      const settings = gameState.genderSettings;
      const displayEl = $('genderDistributionDisplay');
      if (!displayEl) return;
      
      const genderColors = {
        female: '#ff6b9d',
        male: '#00d4ff',
        femaleFuta: '#c77dff',
        transMan: '#4ecca3',
        transWoman: '#ffd700'
      };
      
      const genderLabels = {
        female: 'Female',
        male: 'Male',
        femaleFuta: 'Female Futa',
        transMan: 'Trans Man',
        transWoman: 'Trans Woman'
      };
      
      displayEl.innerHTML = Object.entries(settings)
        .filter(([key, value]) => value > 0)
        .map(([key, value]) => `
          <div style="text-align:center; padding:8px; background:#0f3460; border-radius:6px;">
            <div style="color:${genderColors[key]}; font-weight:700; font-size:1.5rem;">${value}%</div>
            <div style="color:#aaa; font-size:0.75rem;">${genderLabels[key]}</div>
          </div>
        `).join('');
      
      if (Object.values(settings).every(v => v === 0)) {
        displayEl.innerHTML = '<div style="grid-column:1/-1; text-align:center; color:#666; padding:20px;">No gender settings configured</div>';
      }
    }
    
    // Function to normalize sliders (make them proportional to 100%)
    function normalizeGenderSliders(changedSlider) {
      const sliders = [femaleSlider, maleSlider, femaleFutaSlider, transManSlider, transWomanSlider];
      const values = sliders.map(s => parseInt(s.value));
      const total = values.reduce((sum, v) => sum + v, 0);
      
      if (total === 0) {
        // If everything is 0, reset to default (100% female)
        femaleSlider.value = 100;
        updateSliderDisplays();
        return;
      }
      
      if (total === 100) {
        // Perfect total, just update displays
        updateSliderDisplays();
        return;
      }
      
      // Normalize all sliders except the one that just changed
      const changedIndex = sliders.indexOf(changedSlider);
      const changedValue = parseInt(changedSlider.value);
      const otherTotal = total - changedValue;
      const remaining = 100 - changedValue;
      
      if (remaining < 0) {
        // Changed slider exceeds 100%, cap it at 100 and zero others
        changedSlider.value = 100;
        sliders.forEach((s, i) => {
          if (i !== changedIndex) s.value = 0;
        });
      } else if (otherTotal > 0) {
        // Proportionally adjust other sliders
        sliders.forEach((s, i) => {
          if (i !== changedIndex) {
            const currentVal = parseInt(s.value);
            const proportion = currentVal / otherTotal;
            s.value = Math.round(proportion * remaining);
          }
        });
        
        // Fix rounding errors - adjust largest other slider
        const newTotal = sliders.reduce((sum, s) => sum + parseInt(s.value), 0);
        if (newTotal !== 100) {
          const diff = 100 - newTotal;
          let largestOtherIndex = -1;
          let largestOtherValue = -1;
          sliders.forEach((s, i) => {
            if (i !== changedIndex) {
              const val = parseInt(s.value);
              if (val > largestOtherValue) {
                largestOtherValue = val;
                largestOtherIndex = i;
              }
            }
          });
          if (largestOtherIndex >= 0) {
            sliders[largestOtherIndex].value = parseInt(sliders[largestOtherIndex].value) + diff;
          }
        }
      }
      
      updateSliderDisplays();
    }
    
    // Function to update slider percentage displays
    function updateSliderDisplays() {
      femalePercentage.textContent = femaleSlider.value;
      malePercentage.textContent = maleSlider.value;
      femaleFutaPercentage.textContent = femaleFutaSlider.value;
      transManPercentage.textContent = transManSlider.value;
      transWomanPercentage.textContent = transWomanSlider.value;
      
      const total = parseInt(femaleSlider.value) + parseInt(maleSlider.value) + 
                    parseInt(femaleFutaSlider.value) + parseInt(transManSlider.value) + 
                    parseInt(transWomanSlider.value);
      
      genderTotalValue.textContent = total;
      
      if (total === 100) {
        genderTotalValue.style.color = '#00d4ff';
        genderWarning.style.display = 'none';
      } else {
        genderTotalValue.style.color = '#e94560';
        genderWarning.style.display = 'block';
      }
    }
    
    // Open gender options modal
    if (genderOptionsBtn && genderOptionsModal) {
      genderOptionsBtn.addEventListener('click', () => {
        // Load current settings
        femaleSlider.value = gameState.genderSettings.female;
        maleSlider.value = gameState.genderSettings.male;
        femaleFutaSlider.value = gameState.genderSettings.femaleFuta;
        transManSlider.value = gameState.genderSettings.transMan;
        transWomanSlider.value = gameState.genderSettings.transWoman;
        
        updateSliderDisplays();
        genderOptionsModal.style.display = 'flex';
      });
      
      const closeModal = () => {
        genderOptionsModal.style.display = 'none';
      };
      
      if (closeGenderOptionsModal) closeGenderOptionsModal.addEventListener('click', closeModal);
      if (cancelGenderOptions) cancelGenderOptions.addEventListener('click', closeModal);
      
      // Add slider listeners
      [femaleSlider, maleSlider, femaleFutaSlider, transManSlider, transWomanSlider].forEach(slider => {
        if (slider) {
          slider.addEventListener('input', () => normalizeGenderSliders(slider));
        }
      });
      
      // Save gender settings
      if (saveGenderOptions) {
        saveGenderOptions.addEventListener('click', () => {
          const total = parseInt(femaleSlider.value) + parseInt(maleSlider.value) + 
                        parseInt(femaleFutaSlider.value) + parseInt(transManSlider.value) + 
                        parseInt(transWomanSlider.value);
          
          if (total !== 100) {
            showNotification('Total must equal 100%!');
            return;
          }
          
          // Save settings
          gameState.genderSettings.female = parseInt(femaleSlider.value);
          gameState.genderSettings.male = parseInt(maleSlider.value);
          gameState.genderSettings.femaleFuta = parseInt(femaleFutaSlider.value);
          gameState.genderSettings.transMan = parseInt(transManSlider.value);
          gameState.genderSettings.transWoman = parseInt(transWomanSlider.value);
          
          showNotification('Gender settings saved! New hires will reflect these percentages.');
          updateGenderDistributionDisplay();
          genderOptionsModal.style.display = 'none';
          saveGame(); // Auto-save after settings update
        });
      }
    }
    
    // Initialize gender distribution display
    updateGenderDistributionDisplay();
    
    // Attachment menu
    const chatAttachBtn = $('chatAttachBtn');
    const attachmentMenu = $('attachmentMenu');
    if (chatAttachBtn && attachmentMenu) {
      chatAttachBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const isVisible = attachmentMenu.style.display === 'block';
        attachmentMenu.style.display = isVisible ? 'none' : 'block';
      });
      
      // Close menu when clicking outside
      document.addEventListener('click', (e) => {
        if (!chatAttachBtn.contains(e.target) && !attachmentMenu.contains(e.target)) {
          attachmentMenu.style.display = 'none';
        }
      });
      
      // Attachment menu items
      document.querySelectorAll('.attach-menu-item').forEach(item => {
        item.addEventListener('click', () => {
          const action = item.dataset.action;
          attachmentMenu.style.display = 'none';
          
          if (action === 'request') {
            $('requestImageModal').style.display = 'flex';
          } else if (action === 'send') {
            $('sendImageModal').style.display = 'flex';
          } else if (action === 'request-post') {
            $('requestPostModal').style.display = 'flex';
          } else if (action === 'visualize') {
            visualizeCurrentScene();
          }
        });
      });
    }
    
    // Send Image Modal
    const sendImageModal = $('sendImageModal');
    const closeSendImageModal = $('closeSendImageModal');
    const cancelSendImage = $('cancelSendImage');
    const confirmSendImage = $('confirmSendImage');
    const sendImagePrompt = $('sendImagePrompt');
    
    if (closeSendImageModal) {
      closeSendImageModal.addEventListener('click', () => {
        sendImageModal.style.display = 'none';
        sendImagePrompt.value = '';
      });
    }
    
    if (cancelSendImage) {
      cancelSendImage.addEventListener('click', () => {
        sendImageModal.style.display = 'none';
        sendImagePrompt.value = '';
      });
    }
    
    if (confirmSendImage) {
      confirmSendImage.addEventListener('click', async () => {
        const prompt = sendImagePrompt.value.trim();
        if (prompt) {
          sendImageModal.style.display = 'none';
          sendImagePrompt.value = '';
          await sendImageToNPC(prompt);
        }
      });
    }
    
    // Request Image Modal
    const requestImageModal = $('requestImageModal');
    const closeRequestImageModal = $('closeRequestImageModal');
    const requestManualBtn = $('requestManualBtn');
    const requestManualInput = $('requestManualInput');
    const requestImageMode = $('requestImageMode');
    const cancelRequestManual = $('cancelRequestManual');
    const confirmRequestManual = $('confirmRequestManual');
    const requestImagePrompt = $('requestImagePrompt');
    
    if (closeRequestImageModal) {
      closeRequestImageModal.addEventListener('click', () => {
        requestImageModal.style.display = 'none';
        requestManualInput.style.display = 'none';
        requestImageMode.querySelector('div').style.display = 'grid';
        requestManualBtn.style.display = 'block';
        requestImagePrompt.value = '';
      });
    }
    
    // Preset buttons
    document.querySelectorAll('.request-preset').forEach(btn => {
      btn.addEventListener('click', async () => {
        const preset = btn.dataset.preset;
        requestImageModal.style.display = 'none';
        await requestImageFromNPC(preset);
      });
      
      // Hover effects
      btn.addEventListener('mouseenter', () => {
        btn.style.background = '#00d4ff';
        btn.style.color = '#0f1419';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.background = '#0f3460';
        btn.style.color = 'white';
      });
    });
    
    // Manual request button
    if (requestManualBtn) {
      requestManualBtn.addEventListener('click', () => {
        requestImageMode.querySelector('div').style.display = 'none';
        requestManualBtn.style.display = 'none';
        requestManualInput.style.display = 'block';
      });
    }
    
    if (cancelRequestManual) {
      cancelRequestManual.addEventListener('click', () => {
        requestManualInput.style.display = 'none';
        requestImageMode.querySelector('div').style.display = 'grid';
        requestManualBtn.style.display = 'block';
        requestImagePrompt.value = '';
      });
    }
    
    if (confirmRequestManual) {
      confirmRequestManual.addEventListener('click', async () => {
        const prompt = requestImagePrompt.value.trim();
        if (prompt) {
          requestImageModal.style.display = 'none';
          requestManualInput.style.display = 'none';
          requestImageMode.querySelector('div').style.display = 'grid';
          requestManualBtn.style.display = 'block';
          requestImagePrompt.value = '';
          await requestImageFromNPC(null, prompt);
        }
      });
    }
    
    // ========== REQUEST POST MODAL HANDLERS ==========
    
    const requestPostModal = $('requestPostModal');
    const closeRequestPostModal = $('closeRequestPostModal');
    const requestPostCustomBtn = $('requestPostCustomBtn');
    const requestPostCustomInput = $('requestPostCustomInput');
    const requestPostMode = $('requestPostMode');
    const cancelRequestPostCustom = $('cancelRequestPostCustom');
    const confirmRequestPostCustom = $('confirmRequestPostCustom');
    const requestPostPrompt = $('requestPostPrompt');
    
    if (closeRequestPostModal) {
      closeRequestPostModal.addEventListener('click', () => {
        requestPostModal.style.display = 'none';
        requestPostCustomInput.style.display = 'none';
        requestPostMode.querySelector('div').style.display = 'grid';
        requestPostCustomBtn.style.display = 'block';
        requestPostPrompt.value = '';
      });
    }
    
    // Post type preset buttons
    document.querySelectorAll('.request-post-preset').forEach(btn => {
      btn.addEventListener('mouseenter', () => {
        btn.style.background = '#00d4ff';
        btn.style.color = '#0f1419';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.background = '#0f3460';
        btn.style.color = 'white';
      });
      btn.addEventListener('click', async () => {
        const preset = btn.dataset.preset;
        requestPostModal.style.display = 'none';
        await requestPostFromNPC(preset);
      });
    });
    
    // Custom post request button
    if (requestPostCustomBtn) {
      requestPostCustomBtn.addEventListener('click', () => {
        requestPostMode.querySelector('div').style.display = 'none';
        requestPostCustomBtn.style.display = 'none';
        requestPostCustomInput.style.display = 'block';
      });
    }
    
    if (cancelRequestPostCustom) {
      cancelRequestPostCustom.addEventListener('click', () => {
        requestPostCustomInput.style.display = 'none';
        requestPostMode.querySelector('div').style.display = 'grid';
        requestPostCustomBtn.style.display = 'block';
        requestPostPrompt.value = '';
      });
    }
    
    if (confirmRequestPostCustom) {
      confirmRequestPostCustom.addEventListener('click', async () => {
        const prompt = requestPostPrompt.value.trim();
        if (prompt) {
          requestPostModal.style.display = 'none';
          requestPostCustomInput.style.display = 'none';
          requestPostMode.querySelector('div').style.display = 'grid';
          requestPostCustomBtn.style.display = 'block';
          requestPostPrompt.value = '';
          await requestPostFromNPC(null, prompt);
        }
      });
    }
    
    // ========== SOCIAL FEED EVENT HANDLERS ==========
    
    // Player post button
    const playerPostBtn = $('playerPostBtn');
    if (playerPostBtn) {
      playerPostBtn.addEventListener('click', () => {
        openPlayerPostComposer();
      });
    }
    
    // Feed filter buttons
    document.querySelectorAll('.feed-filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        // Update active state
        document.querySelectorAll('.feed-filter-btn').forEach(b => {
          b.classList.remove('active');
          b.style.background = 'transparent';
          b.style.color = '#aaa';
        });
        
        btn.classList.add('active');
        btn.style.background = '#0f3460';
        btn.style.color = '#00d4ff';
        
        // Update filter
        gameState.socialNetwork.feedFilter = btn.dataset.filter;
        renderSocialFeed(true); // Force full render on filter change
      });
    });
    
    // Feed sort select
    const feedSortSelect = $('feedSortSelect');
    if (feedSortSelect) {
      feedSortSelect.addEventListener('change', (e) => {
        gameState.socialNetwork.feedSort = e.target.value;
        renderSocialFeed(true); // Force full render on sort change
      });
    }
    
    // Test generate post button
    const testGeneratePostBtn = $('testGeneratePostBtn');
    if (testGeneratePostBtn) {
      testGeneratePostBtn.addEventListener('click', () => {
        generateTestPost();
      });
    }
    
    // Post composer modal close button (X button)
    const closePlayerPostModalBtn = $('closePlayerPostModal');
    if (closePlayerPostModalBtn) {
      closePlayerPostModalBtn.addEventListener('click', () => {
        closePlayerPostModal();
      });
    }
    
    // Post composer cancel button
    const cancelPlayerPost = $('cancelPlayerPost');
    if (cancelPlayerPost) {
      cancelPlayerPost.addEventListener('click', () => {
        closePlayerPostModal();
      });
    }
    
    // Post type buttons
    document.querySelectorAll('.post-type-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        // Update active state
        document.querySelectorAll('.post-type-btn').forEach(b => {
          b.classList.remove('active');
          b.style.borderColor = '#0f3460';
          b.style.color = '#aaa';
        });
        
        btn.classList.add('active');
        btn.style.borderColor = '#00d4ff';
        btn.style.color = 'white';
        
        // Show/hide image sections
        const type = btn.dataset.type;
        const imageSection = $('playerPostImageSection');
        const generateImageBtn = $('generatePlayerPostImage');
        const imagePromptInput = $('playerPostImagePrompt');
        const imageAltInput = $('playerPostAltText');
        
        if (type === 'text') {
          if (imageSection) imageSection.style.display = 'none';
          if (generateImageBtn) generateImageBtn.style.display = 'none';
        } else {
          if (imageSection) imageSection.style.display = 'block';
          if (generateImageBtn) generateImageBtn.style.display = 'inline-block';
          
          // Set default prompt based on type
          if (type === 'image' && imagePromptInput) {
            imagePromptInput.placeholder = 'Describe the image you want to generate...';
          } else if (type === 'selfie' && imagePromptInput) {
            imagePromptInput.placeholder = 'Describe your selfie pose and setting...';
          }
        }
      });
    });
    
    // Generate image button
    const generatePlayerPostImage = $('generatePlayerPostImage');
    if (generatePlayerPostImage) {
      generatePlayerPostImage.addEventListener('click', async () => {
        await generatePlayerPostImage_handler();
      });
    }
    
    // Regenerate image button
    const playerPostRegenerateImg = $('playerPostRegenerateImg');
    if (playerPostRegenerateImg) {
      playerPostRegenerateImg.addEventListener('click', async () => {
        await generatePlayerPostImage_handler();
      });
    }
    
    // Submit player post
    const submitPlayerPost = $('submitPlayerPost');
    if (submitPlayerPost) {
      submitPlayerPost.addEventListener('click', () => {
        submitPlayerPostToFeed();
      });
    }
    
    // Character counter for caption
    const captionCharCount = $('captionCharCount');
    if (playerPostCaption && captionCharCount) {
      playerPostCaption.addEventListener('input', () => {
        const length = playerPostCaption.value.length;
        captionCharCount.textContent = length;
        
        if (length > 500) {
          captionCharCount.style.color = '#e94560';
        } else {
          captionCharCount.style.color = '#666';
        }
      });
    }
    
    // Event delegation for dynamically created post elements
    document.addEventListener('click', (e) => {
      // Like button
      if (e.target.closest('.like-btn')) {
        const btn = e.target.closest('.like-btn');
        const postId = btn.dataset.postId;
        handleLikePost(postId);
      }
      
      // Comment button - open post modal
      if (e.target.closest('.comment-btn')) {
        const btn = e.target.closest('.comment-btn');
        const postId = btn.dataset.postId;
        openPostModal(postId);
      }
      
      // Submit comment button (legacy support - modal has its own)
      if (e.target.closest('.submit-comment-btn')) {
        const btn = e.target.closest('.submit-comment-btn');
        const postId = btn.dataset.postId;
        const input = document.querySelector(`.comment-input[data-post-id="${postId}"]`);
        const replyIndicator = document.querySelector(`.reply-indicator[data-post-id="${postId}"]`);
        const replyToId = replyIndicator && replyIndicator.style.display !== 'none' ? 
                         replyIndicator.getAttribute('data-reply-to-id') : null;
        
        if (input) {
          addCommentToPost(postId, input.value, replyToId);
        }
      }
    });
    
    // Handle Enter key in comment inputs
    document.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && e.target.classList.contains('comment-input')) {
        const postId = e.target.dataset.postId;
        const replyIndicator = document.querySelector(`.reply-indicator[data-post-id="${postId}"]`);
        const replyToId = replyIndicator && replyIndicator.style.display !== 'none' ? 
                         replyIndicator.getAttribute('data-reply-to-id') : null;
        addCommentToPost(postId, e.target.value, replyToId);
      }
    });
    
    // Handle Reply button clicks
    document.addEventListener('click', (e) => {
      if (e.target.closest('.reply-to-comment-btn')) {
        const btn = e.target.closest('.reply-to-comment-btn');
        const postId = btn.dataset.postId;
        const commentId = btn.dataset.commentId;
        const authorName = btn.dataset.authorName;
        const authorId = btn.dataset.authorId;
        const authorUsername = btn.dataset.authorUsername; // CRITICAL FIX: Get actual username
        
        const input = document.querySelector(`.comment-input[data-post-id="${postId}"]`);
        const replyIndicator = document.querySelector(`.reply-indicator[data-post-id="${postId}"]`);
        
        if (input && replyIndicator) {
          // Show reply indicator
          replyIndicator.querySelector('.reply-text').textContent = `Replying to ${authorName}`;
          replyIndicator.style.display = 'block';
          replyIndicator.setAttribute('data-reply-to-id', commentId);
          
          // CRITICAL FIX: Use username, not display name for @mentions
          if (authorId !== 'player' && authorUsername) {
            // Pre-fill with proper @username
            if (!input.value.includes(`@${authorUsername}`)) {
              input.value = `@${authorUsername} `;
            }
          }
          
          // Focus input
          input.focus();
        }
      }
    });
    
    // Handle Cancel Reply button clicks
    document.addEventListener('click', (e) => {
      if (e.target.closest('.cancel-reply-btn')) {
        const btn = e.target.closest('.cancel-reply-btn');
        const postId = btn.dataset.postId;
        
        const replyIndicator = document.querySelector(`.reply-indicator[data-post-id="${postId}"]`);
        if (replyIndicator) {
          replyIndicator.style.display = 'none';
          replyIndicator.removeAttribute('data-reply-to-id');
        }
      }
    });
    
    // Global Upgrades - Click Power Button
    const buyClickPowerBtn = $('buyClickPowerBtn');
    if (buyClickPowerBtn) {
      buyClickPowerBtn.addEventListener('click', buyClickPower);
    }
    
    // ========== PRESTIGE SYSTEM EVENT HANDLERS ==========
    
    // Prestige button - opens confirmation modal
    const prestigeBtn = $('prestigeBtn');
    if (prestigeBtn) {
      prestigeBtn.addEventListener('click', showPrestigeModal);
    }
    
    // Prestige modal - close button
    const closePrestigeModal = $('closePrestigeModal');
    if (closePrestigeModal) {
      closePrestigeModal.addEventListener('click', () => {
        const modal = $('prestigeModal');
        if (modal) modal.style.display = 'none';
      });
    }
    
    // Prestige modal - cancel button
    const cancelPrestige = $('cancelPrestige');
    if (cancelPrestige) {
      cancelPrestige.addEventListener('click', () => {
        const modal = $('prestigeModal');
        if (modal) modal.style.display = 'none';
      });
    }
    
    // Prestige modal - confirm button
    const confirmPrestige = $('confirmPrestige');
    if (confirmPrestige) {
      confirmPrestige.addEventListener('click', executePrestige);
    }
    
    // ========== PAGE VISIBILITY & AFK DETECTION ==========
    
    // Track user interactions to detect AFK state
    const updateInteractionTime = () => {
      gameState.lastInteractionTime = Date.now();
    };
    
    // Listen for actual user interactions
    document.addEventListener('click', updateInteractionTime);
    document.addEventListener('keydown', updateInteractionTime);
    document.addEventListener('touchstart', updateInteractionTime);
    document.addEventListener('scroll', updateInteractionTime);
    
    // Page Visibility API - detect when tab/app goes to background
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Page is now hidden (tab switched, phone locked, etc.)
        const now = Date.now();
        gameState.pageHiddenTime = now;
        gameState.lastPlayTime = now;
        // Save immediately when page goes hidden
        saveGame(false);
      } else {
        // Page is now visible again
        // Check for AFK earnings based on time hidden
        checkAfkIncome();
        // Update interaction time since user is back
        gameState.lastInteractionTime = Date.now();
      }
    });
    
    // Also handle beforeunload to save last active time
    window.addEventListener('beforeunload', () => {
      gameState.lastPlayTime = Date.now();
      // Note: We can't reliably save here in some browsers, but we try
      navigator.sendBeacon && navigator.sendBeacon('/save', JSON.stringify(gameState));
    });
    
    // Additional fallback: If user hasn't interacted in 10 minutes while page is visible,
    // automatically trigger AFK mode
    setInterval(() => {
      if (!document.hidden) {
        const now = Date.now();
        const timeSinceInteraction = now - (gameState.lastInteractionTime || now);
        const TEN_MINUTES = 10 * 60 * 1000;
        
        // If no interaction for 10+ minutes, update lastPlayTime
        if (timeSinceInteraction >= TEN_MINUTES) {
          // Update lastPlayTime to when they last interacted
          if (gameState.lastPlayTime > gameState.lastInteractionTime) {
            gameState.lastPlayTime = gameState.lastInteractionTime;
          }
        }
      }
    }, 60000); // Check every minute
  }
  
  // Switch active tab
  function switchTab(tabName) {
    gameState.activeTab = tabName;
    
    // Update tab buttons
    document.querySelectorAll('.tab-btn').forEach(btn => {
      if (btn.dataset.tab === tabName) {
        btn.classList.add('active');
        btn.style.color = '#e94560';
      } else {
        btn.classList.remove('active');
        btn.style.color = 'white';
      }
    });
    
    // Update tab content
    document.querySelectorAll('.tab-content').forEach(content => {
      content.hidden = true;
    });
    
    const activeTab = $(`${tabName}Tab`);
    if (activeTab) {
      activeTab.hidden = false;
      updateTabContent(tabName);
    }
  }
  
  // Update content for specific tab
  function updateTabContent(tabName) {
    switch (tabName) {
      case 'dashboard':
        updateDashboard();
        refreshDashboardSections(); // Force initial render of interactive sections
        break;
      case 'business':
        updateBusinessTab();
        break;
      case 'upgrades':
        updateUpgradesTab();
        break;
      case 'people':
        updatePeopleTab();
        break;
      case 'gifts':
        updateGiftsTab();
        break;
      case 'hr':
        updateHRTab();
        break;
      case 'social':
        updateSocialTab();
        break;
      case 'invest':
        updatePrestigeUI();
        renderInfluenceUpgrades();
        break;
    }
  }
    // Update Dashboard Tab
    function updateDashboard() {
    // ===== TOP STATS CARDS =====
    
    // Cash & Cash/sec
    const dashCash = $('dashCash');
    const dashCashPerSec = $('dashCashPerSec');
    if (dashCash) dashCash.textContent = formatNumber(Math.floor(gameState.cash));
    if (dashCashPerSec) dashCashPerSec.textContent = formatNumber(calculateCashPerSecond());
    
    // Lifetime Earnings & Prestige Level
    const dashLifetimeEarnings = $('dashLifetimeEarnings');
    const dashPrestigeLevel = $('dashPrestigeLevel');
    if (dashLifetimeEarnings) dashLifetimeEarnings.textContent = formatNumber(Math.floor(gameState.lifetimeEarnings || 0));
    if (dashPrestigeLevel) dashPrestigeLevel.textContent = gameState.prestigeLevel || 0;
    
    // Employees & Managers
    const dashEmployeeCount = $('dashEmployeeCount');
    const dashManagerCount = $('dashManagerCount');
    if (dashEmployeeCount) dashEmployeeCount.textContent = gameState.employees.length;
    const managerCount = gameState.products.filter(p => p.managerHired).length;
    if (dashManagerCount) dashManagerCount.textContent = managerCount;
    
    // Products & Running Products
    const dashProductCount = $('dashProductCount');
    const dashRunningProducts = $('dashRunningProducts');
    const unlockedProducts = gameState.products.filter(p => p.unlocked).length;
    const runningProducts = gameState.products.filter(p => p.running || p.managerHired).length;
    if (dashProductCount) dashProductCount.textContent = unlockedProducts;
    if (dashRunningProducts) dashRunningProducts.textContent = runningProducts;
    
    // ===== RECENT MESSAGES ===== 
    // Only rebuild if the container is empty or data has actually changed
    const dashRecentMessages = $('dashRecentMessages');
    if (dashRecentMessages && !dashRecentMessages.dataset.initialized) {
      renderDashboardMessages();
      dashRecentMessages.dataset.initialized = 'true';
    }
    
    // ===== BOSS FIGHTS PROGRESS =====
    const dashBossProgress = $('dashBossProgress');
    if (dashBossProgress) {
      const totalBosses = Object.keys(bossFightConfig || {}).length;
      const defeatedBosses = (gameState.bossFights?.defeated || []).length;
      
      // Only update if values changed
      const currentProgress = dashBossProgress.dataset.progress;
      const newProgress = `${defeatedBosses}/${totalBosses}`;
      if (currentProgress !== newProgress) {
        dashBossProgress.dataset.progress = newProgress;
        
        if (totalBosses === 0) {
          dashBossProgress.innerHTML = '<div style="text-align:center; color:#666; padding:10px; font-style:italic;">No bosses available</div>';
        } else {
          const percentage = Math.floor((defeatedBosses / totalBosses) * 100);
          dashBossProgress.innerHTML = `
            <div style="margin-bottom:15px;">
              <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                <span style="color:#aaa; font-size:0.9rem;">Progress</span>
                <span style="color:#e94560; font-weight:600;">${defeatedBosses}/${totalBosses}</span>
              </div>
              <div style="background:#0f3460; height:12px; border-radius:6px; overflow:hidden;">
                <div style="background:linear-gradient(90deg, #e94560, #ff6b9d); height:100%; width:${percentage}%; transition:width 0.3s;"></div>
              </div>
            </div>
            ${defeatedBosses < totalBosses ? '<div style="color:#aaa; font-size:0.85rem; text-align:center;">💪 Keep growing to challenge the next boss!</div>' : '<div style="color:#4ecca3; font-size:0.85rem; text-align:center;">🎉 All bosses defeated!</div>'}
          `;
        }
      }
    }
    
    // ===== QUICK STATS =====
    const dashLocationCount = $('dashLocationCount');
    const dashTotalLocations = $('dashTotalLocations');
    const dashEfficiency = $('dashEfficiency');
    const dashInfluencePoints = $('dashInfluencePoints');
    const dashIncomeMultiplier = $('dashIncomeMultiplier');
    
    const unlockedLocations = gameState.locations.filter(loc => loc.unlocked).length;
    const totalLocations = gameState.locations.length;
    if (dashLocationCount) dashLocationCount.textContent = unlockedLocations;
    if (dashTotalLocations) dashTotalLocations.textContent = totalLocations;
    
    const totalEff = gameState.employees.reduce((sum, emp) => sum + (emp.stats?.efficiency ?? 0), 0);
    const maxEff = gameState.employees.length * 100;
    const effPct = maxEff > 0 ? Math.max(0, Math.min(100, Math.floor((totalEff / maxEff) * 100))) : 100;
    if (dashEfficiency) dashEfficiency.textContent = effPct;
    
    if (dashInfluencePoints) dashInfluencePoints.textContent = gameState.influencePoints || 0;
    
    const incomeUpgradeLevel = gameState.influenceUpgrades?.incomeMultiplier || 0;
    const multiplier = influenceUpgrades.incomeMultiplier.effect(incomeUpgradeLevel);
    if (dashIncomeMultiplier) dashIncomeMultiplier.textContent = multiplier.toFixed(1);
    
    // ===== SOCIAL MENTIONS =====
    // Only rebuild if not initialized
    const dashSocialMentions = $('dashSocialMentions');
    if (dashSocialMentions && !dashSocialMentions.dataset.initialized) {
      renderDashboardMentions();
      dashSocialMentions.dataset.initialized = 'true';
    }
    
    // ===== TOP PERFORMERS =====
    // Only rebuild if not initialized
    const dashTopPerformers = $('dashTopPerformers');
    if (dashTopPerformers && !dashTopPerformers.dataset.initialized) {
      renderDashboardTopPerformers();
      dashTopPerformers.dataset.initialized = 'true';
    }
    
    // ===== COMPANY NEWS =====
    updateNewsFeed();
    }

  // Separate render functions that only run once or on demand
  function renderDashboardMessages() {
    const dashRecentMessages = $('dashRecentMessages');
    if (!dashRecentMessages) return;
    
    // Get all chat histories and find unread messages
    const recentMessages = [];
    gameState.employees.forEach(emp => {
      const history = gameState.chatHistory[emp.id] || [];
      // Use the employee's unreadMessages counter instead of filtering history
      const unreadCount = emp.unreadMessages || 0;
      if (history.length > 0) {
        const lastMessage = history[history.length - 1];
        recentMessages.push({
          employee: emp,
          message: lastMessage,
          unreadCount: unreadCount,
          timestamp: lastMessage.timestamp || Date.now()
        });
      }
    });
    
    // Sort by timestamp (most recent first)
    recentMessages.sort((a, b) => b.timestamp - a.timestamp);
    
    if (recentMessages.length === 0) {
      dashRecentMessages.innerHTML = '<div style="text-align:center; color:#666; padding:20px; font-style:italic;">No messages yet. Start chatting with employees!</div>';
    } else {
      dashRecentMessages.innerHTML = recentMessages.slice(0, 5).map(item => {
        const timeAgo = getTimeAgo(item.timestamp);
        const preview = item.message.content.substring(0, 80) + (item.message.content.length > 80 ? '...' : '');
        const unreadBadge = item.unreadCount > 0 ? `<span style="background:#e94560; color:white; padding:2px 8px; border-radius:10px; font-size:0.75rem; font-weight:600;">${item.unreadCount}</span>` : '';
        
        return `
          <div onclick="openChat('${item.employee.id}')" style="background:#0f3460; padding:12px; border-radius:8px; margin-bottom:10px; cursor:pointer; transition:all 0.2s;" onmouseenter="this.style.background='#16213e'" onmouseleave="this.style.background='#0f3460'">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
              <div style="font-weight:600; color:#00d4ff;">${item.employee.name}</div>
              <div style="display:flex; align-items:center; gap:8px;">
                ${unreadBadge}
                <div style="font-size:0.75rem; color:#666;">${timeAgo}</div>
              </div>
            </div>
            <div style="color:#aaa; font-size:0.85rem;">${preview}</div>
          </div>
        `;
      }).join('');
    }
  }
  
  function renderDashboardMentions() {
    const dashSocialMentions = $('dashSocialMentions');
    if (!dashSocialMentions) return;
    
    const allPosts = gameState.socialFeed || [];
    const mentions = allPosts.filter(post => 
      post.content && post.content.toLowerCase().includes('@theboss')
    ).sort((a, b) => b.timestamp - a.timestamp);
    
    if (mentions.length === 0) {
      dashSocialMentions.innerHTML = '<div style="text-align:center; color:#666; padding:20px; font-style:italic;">No mentions yet. Engage with employees!</div>';
    } else {
      dashSocialMentions.innerHTML = mentions.slice(0, 3).map(post => {
        const author = gameState.employees.find(e => e.id === post.authorId);
        if (!author) return '';
        
        const timeAgo = getTimeAgo(post.timestamp);
        const content = post.content.substring(0, 100) + (post.content.length > 100 ? '...' : '');
        
        return `
          <div onclick="switchTab('social')" style="background:#0f3460; padding:12px; border-radius:8px; margin-bottom:10px; cursor:pointer; transition:all 0.2s;" onmouseenter="this.style.background='#16213e'" onmouseleave="this.style.background='#0f3460'">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
              <div style="font-weight:600; color:#ff6b9d;">${author.name}</div>
              <div style="font-size:0.75rem; color:#666;">${timeAgo}</div>
            </div>
            <div style="color:#aaa; font-size:0.85rem;">${content}</div>
            <div style="color:#e94560; font-size:0.75rem; margin-top:5px;">💕 ${post.likes?.length || 0} likes • 💬 ${post.comments?.length || 0} comments</div>
          </div>
        `;
      }).filter(html => html).join('');
    }
  }
  
  function renderDashboardTopPerformers() {
    const dashTopPerformers = $('dashTopPerformers');
    if (!dashTopPerformers) return;
    
    if (gameState.employees.length === 0) {
      dashTopPerformers.innerHTML = '<div style="text-align:center; color:#666; padding:20px; font-style:italic;">No employees yet</div>';
    } else {
      // Sort employees by a combination of stats
      const scoredEmployees = gameState.employees.map(emp => ({
        employee: emp,
        score: (emp.stats?.productivity || 0) + (emp.stats?.efficiency || 0) + (emp.stats?.affection || 0) * 0.5
      })).sort((a, b) => b.score - a.score);
      
      dashTopPerformers.innerHTML = scoredEmployees.slice(0, 3).map((item, index) => {
        const emp = item.employee;
        const medals = ['🥇', '🥈', '🥉'];
        const medal = medals[index] || '🏅';
        
        return `
          <div onclick="showEmployeeProfile('${emp.id}')" style="background:#0f3460; padding:12px; border-radius:8px; margin-bottom:8px; cursor:pointer; transition:all 0.2s;" onmouseenter="this.style.background='#16213e'" onmouseleave="this.style.background='#0f3460'">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <div style="display:flex; align-items:center; gap:10px;">
                <div style="font-size:1.5rem;">${medal}</div>
                <div>
                  <div style="font-weight:600;">${getColoredName(emp)}</div>
                  <div style="color:#666; font-size:0.8rem;">${emp.position || 'Employee'}</div>
                </div>
              </div>
              <div style="text-align:right;">
                <div style="color:#ffd700; font-weight:600; font-size:0.9rem;">${Math.floor(item.score)} pts</div>
                <div style="color:#666; font-size:0.75rem;">Productivity: ${Math.floor(emp.stats?.productivity || 0)}%</div>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }
  }
  
  // Function to refresh dashboard sections on demand (call when data changes)
  function refreshDashboardSections() {
    const dashRecentMessages = $('dashRecentMessages');
    const dashSocialMentions = $('dashSocialMentions');
    const dashTopPerformers = $('dashTopPerformers');
    
    if (dashRecentMessages) {
      dashRecentMessages.dataset.initialized = '';
      renderDashboardMessages();
      dashRecentMessages.dataset.initialized = 'true';
    }
    
    if (dashSocialMentions) {
      dashSocialMentions.dataset.initialized = '';
      renderDashboardMentions();
      dashSocialMentions.dataset.initialized = 'true';
    }
    
    if (dashTopPerformers) {
      dashTopPerformers.dataset.initialized = '';
      renderDashboardTopPerformers();
      dashTopPerformers.dataset.initialized = 'true';
    }
  }

  
  // Helper function to format time ago
  function getTimeAgo(timestamp) {
    const now = Date.now();
    const diff = now - timestamp;
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (days > 0) return `${days}d ago`;
    if (hours > 0) return `${hours}h ago`;
    if (minutes > 0) return `${minutes}m ago`;
    return 'Just now';
  }

  
  // Update Business Tab
  function updateBusinessTab() {
    // Update location subtabs
    const locationSubtabs = $('locationSubtabs');
    if (locationSubtabs) {
      locationSubtabs.innerHTML = '';
      
      gameState.locations.forEach((location, index) => {
        const canUnlock = checkLocationUnlockable(location.id);
        const isLocked = !location.unlocked;
        const isActive = gameState.activeLocationId === location.id;
        const canAfford = gameState.cash >= location.cost;
        const prevLoc = index > 0 ? gameState.locations[index - 1] : null;
        const prevUnlocked = !prevLoc || prevLoc.unlocked;
        const hasPrestigeReq = location.requiresPrestiges && gameState.prestigeLevel < location.requiresPrestiges;
        
        const subtab = document.createElement('button');
        subtab.className = 'location-subtab';
        subtab.dataset.locationId = location.id;
        
        if (isLocked) {
          if (hasPrestigeReq) {
            // Requires prestige
            subtab.style.cssText = 'padding:10px 16px; background:#1a1a2e; border:none; border-bottom:3px solid transparent; color:#666; cursor:not-allowed; white-space:nowrap; opacity:0.5;';
            subtab.innerHTML = `�️ ${location.name}<br><span style="font-size:0.8em;">Requires ${location.requiresPrestiges} Prestige</span>`;
            subtab.disabled = true;
          } else if (!prevUnlocked) {
            // Previous location not unlocked
            subtab.style.cssText = 'padding:10px 16px; background:#1a1a2e; border:none; border-bottom:3px solid transparent; color:#666; cursor:not-allowed; white-space:nowrap; opacity:0.5;';
            subtab.innerHTML = `🔒 ${location.name}`;
            subtab.disabled = true;
          } else if (canAfford) {
            // Can unlock now - check if it requires boss fight (all locations except garage)
            if (index > 0) {
              // Check if boss already defeated - if so, should already be unlocked
              // This is a safety check - normally defeated bosses have unlocked locations
              const boss = bossFightConfig[location.id];
              const alreadyDefeated = boss && gameState.bossFights.defeated.includes(boss.id);
              
              if (alreadyDefeated) {
                // Boss defeated but location not unlocked (shouldn't happen, but handle it)
                subtab.style.cssText = 'padding:10px 16px; background:#0f3460; border:none; border-bottom:3px solid #e94560; color:#4caf50; cursor:pointer; white-space:nowrap; font-weight:bold; animation: pulse 2s infinite;';
                subtab.innerHTML = `🔓 ${location.name}<br><span style="font-size:0.8em;">Claim Victory</span>`;
                subtab.onclick = () => unlockLocation(location.id);
              } else {
                // Boss fight required
                const bossCheck = checkBossFightRequirements(location.id);
                subtab.style.cssText = 'padding:10px 16px; background:#0f3460; border:none; border-bottom:3px solid #e94560; color:#ff6b9d; cursor:pointer; white-space:nowrap; font-weight:bold; animation: pulse 2s infinite;';
                if (bossCheck.reasons.length > 0) {
                  // Show warning about recommendations
                  subtab.innerHTML = `⚔️ ${location.name}<br><span style="font-size:0.7em; color:#ffaa00;">${bossCheck.reasons[0]}</span>`;
                } else {
                  // Ready to fight
                  subtab.innerHTML = `⚔️ ${location.name}<br><span style="font-size:0.8em;">Boss Fight!</span>`;
                }
                subtab.onclick = () => {
                  if (bossCheck.reasons.length > 0) {
                    // Show warning before starting
                    if (confirm(`Warning: This boss may be difficult!\n\n${bossCheck.reasons.join('\n')}\n\nAttempt anyway?`)) {
                      startBossFight(location.id);
                    }
                  } else {
                    startBossFight(location.id);
                  }
                };
              }
            } else {
              // First location (garage) - direct unlock
              subtab.style.cssText = 'padding:10px 16px; background:#0f3460; border:none; border-bottom:3px solid #e94560; color:#4caf50; cursor:pointer; white-space:nowrap; font-weight:bold; animation: pulse 2s infinite;';
              subtab.innerHTML = `🔓 ${location.name}<br><span style="font-size:0.8em;">Unlock: ${formatNumber(location.cost)}</span>`;
              subtab.onclick = () => unlockLocation(location.id);
            }
          } else {
            // Can't afford yet
            subtab.style.cssText = 'padding:10px 16px; background:#1a1a2e; border:none; border-bottom:3px solid transparent; color:#888; cursor:not-allowed; white-space:nowrap; opacity:0.7;';
            subtab.innerHTML = `🔒 ${location.name}<br><span style="font-size:0.8em;">Need: ${formatNumber(location.cost)}</span>`;
            subtab.disabled = true;
          }
        } else {
          // Unlocked - show NSFW level indicator if applicable
          const nsfwIndicator = location.nsfwLevel ? '🔞'.repeat(location.nsfwLevel) : '';
          subtab.style.cssText = `padding:10px 16px; background:${isActive ? '#0f3460' : 'transparent'}; border:none; border-bottom:3px solid ${isActive ? '#e94560' : 'transparent'}; color:${isActive ? '#e94560' : 'white'}; cursor:pointer; white-space:nowrap; font-weight:${isActive ? 'bold' : 'normal'}; transition:all 0.2s;`;
          subtab.innerHTML = `${location.name}${nsfwIndicator ? ' ' + nsfwIndicator : ''}`;
          subtab.onclick = () => {
            gameState.activeLocationId = location.id;
            applyLocationTheme(location);
            updateBusinessTab();
          };
          
          // Hover effect for unlocked tabs
          subtab.addEventListener('mouseenter', () => {
            if (!isActive) {
              subtab.style.borderBottomColor = '#e94560';
              subtab.style.color = '#e94560';
            }
          });
          subtab.addEventListener('mouseleave', () => {
            if (!isActive) {
              subtab.style.borderBottomColor = 'transparent';
              subtab.style.color = 'white';
            }
          });
        }
        
        locationSubtabs.appendChild(subtab);
      });
    }
    
    // Update location info banner
    const locationInfo = document.getElementById('locationInfo');
    if (locationInfo) {
      const activeLocation = gameState.locations.find(loc => loc.id === gameState.activeLocationId);
      if (activeLocation && activeLocation.unlocked && activeLocation.theme) {
        const nsfwWarning = activeLocation.nsfwLevel ? `<span style="color:#ff6b6b; font-weight:bold;">⚠️ NSFW Level ${activeLocation.nsfwLevel}</span> • ` : '';
        locationInfo.style.display = 'block';
        locationInfo.innerHTML = `
          <div style="display:flex; align-items:center; gap:15px;">
            <div style="font-size:2rem;">${activeLocation.name.split(' ')[0]}</div>
            <div style="flex:1;">
              <div style="font-size:1.1rem; font-weight:bold; margin-bottom:5px;">${activeLocation.name}</div>
              <div style="color:#aaa; font-size:0.9rem;">${nsfwWarning}${activeLocation.theme.description}</div>
            </div>
          </div>
        `;
      } else {
        locationInfo.style.display = 'none';
      }
    }
    
    // Update products (only show products from active location)
    updateProductsList();
  }
  
  // Check if a location can be unlocked
  function checkLocationUnlockable(locationId) {
    const location = gameState.locations.find(loc => loc.id === locationId);
    if (!location) return false;
    
    // Already unlocked
    if (location.unlocked) return false;
    
    // Check cash requirement
    if (gameState.cash < location.cost) return false;
    
    // Check prestige requirement
    if (location.requiresPrestiges && gameState.prestigeLevel < location.requiresPrestiges) {
      return false;
    }
    
    // First location is always unlockable (but should start unlocked anyway)
    const locationIndex = gameState.locations.findIndex(loc => loc.id === locationId);
    if (locationIndex === 0) return true;
    
    // Check if previous location is unlocked
    if (locationIndex > 0) {
      const prevLocation = gameState.locations[locationIndex - 1];
      if (!prevLocation.unlocked) return false;
    }
    
    return true;
  }
  
  // Unlock a location
  function unlockLocation(locationId) {
    const location = gameState.locations.find(loc => loc.id === locationId);
    if (!location || location.unlocked) return;
    
    if (!checkLocationUnlockable(locationId)) {
      showNotification('Cannot unlock this location yet!', 'error');
      return;
    }
    
    if (gameState.cash < location.cost) {
      showNotification('Not enough cash to unlock this location!', 'error');
      return;
    }
    
    // Deduct cost and unlock
    gameState.cash -= location.cost;
    location.unlocked = true;
    location.owned = true;
    
    // Unlock the first product in this location automatically
    const firstProduct = gameState.products.find(p => p.locationId === locationId && p.unlockCost === 0);
    if (firstProduct) {
      firstProduct.unlocked = true;
    }
    
    // Switch to newly unlocked location
    gameState.activeLocationId = locationId;
    
    // Apply location theme
    applyLocationTheme(location);
    
    showNotification(`${location.name} unlocked!`, 'success');
    updateUI();
    saveGame();
  }
  
  // Apply visual theme when switching locations
  function applyLocationTheme(location) {
    if (!location || !location.theme) return;
    
    const body = document.body;
    const theme = location.theme;
    
    // Apply background gradient
    if (theme.background) {
      body.style.background = theme.background;
    }
    
    // Store current theme for other UI elements to reference
    gameState.currentTheme = theme;
    
    // Update any dynamic UI elements based on theme
    // This can be expanded later with particle effects, etc.
  }
  
  // Update products list (renders cards only; click handling is delegated elsewhere)
  function updateProductsList() {
    if (!productsList) return;
    
    // Clear cache when re-rendering products
    clearUpgradeButtonCache();
    
    productsList.innerHTML = '';
    
    // Only show products from the active location
    const activeLocation = gameState.locations.find(loc => loc.id === gameState.activeLocationId);
    if (!activeLocation || !activeLocation.unlocked) {
      productsList.innerHTML = '<p style="color:#aaa; text-align:center; padding:40px;">Select an unlocked location to view products.</p>';
      return;
    }
    
    const visibleProducts = gameState.products.filter(p => p.locationId === gameState.activeLocationId);
    
    if (visibleProducts.length === 0) {
      productsList.innerHTML = '<p style="color:#aaa; text-align:center; padding:40px;">No products available in this location.</p>';
      return;
    }
    
    visibleProducts.forEach(p => {
      const card = document.createElement('div');
      card.className = 'product-card';
      card.style.cssText = 'background:#16213e; border-radius:10px; padding:15px; box-shadow:0 4px 10px rgba(0,0,0,0.2);';

      // Check if product is unlocked
      if (!p.unlocked) {
        // Calculate what the actual earnings will be with current multipliers
        const actualEarnings = currentValue(p);
        
        // Render locked product card
        card.innerHTML = `
          <h3 style="margin:0 0 6px 0;">${p.name}</h3>
          <p style="margin:0; color:#aaa;">🔒 Locked</p>
          <p style="margin:6px 0 8px 0; font-size:.9rem; color:#888;">
            Unlock this product to start earning $${formatNumber(actualEarnings)} per unit.
          </p>
          <div style="margin-top:12px;">
            <button class="unlock-product-btn" data-id="${p.id}" style="width:100%; padding:12px; background:#0f3460; border:none; border-radius:6px; color:#fff; cursor:pointer; font-weight:bold;">
              🔓 Unlock ($${formatNumber(p.unlockCost)})
            </button>
          </div>
        `;
        productsList.appendChild(card);
        return;
      }

      // Calculate bulk upgrade cost
      const multiplier = gameState.upgradeMultiplier;
      const MAX_LEVEL = 999;
      const isMaxLevel = p.level >= MAX_LEVEL;
      let upgradeCost, upgradeCount, upgradeText;
      
      if (isMaxLevel) {
        // At max level
        upgradeCost = 0;
        upgradeCount = 0;
        upgradeText = `MAX LEVEL (${MAX_LEVEL})`;
      } else if (multiplier === 'max') {
        // Calculate max affordable upgrades (but cap at MAX_LEVEL)
        const result = calculateMaxAffordableUpgrades(p, gameState.cash);
        upgradeCost = result.totalCost;
        upgradeCount = Math.min(result.count, MAX_LEVEL - p.level);
        upgradeText = `Upgrade x${upgradeCount} (${formatNumber(upgradeCost)})`;
      } else if (multiplier === 1) {
        upgradeCost = p.upgradeCost;
        upgradeCount = 1;
        upgradeText = `Upgrade (${formatNumber(upgradeCost)})`;
      } else {
        upgradeCost = calculateBulkUpgradeCost(p, Math.min(multiplier, MAX_LEVEL - p.level));
        upgradeCount = Math.min(multiplier, MAX_LEVEL - p.level);
        upgradeText = `Upgrade x${upgradeCount} (${formatNumber(upgradeCost)})`;
      }

      // Render unlocked product card
      const cycleTime = currentCycleTimeMs(p);
      const isConstantStream = cycleTime < 1000 && p.managerHired;
      const pct = p.running ? Math.min(100, (1 - (p.timeRemainingMs / cycleTime)) * 100) : 0;
      const onboarding = !!p.managerOnboarding;
      
      // Manager button logic
      let managerCta, managerDisabledAttr, managerCursor, managerOpacity, managerBgColor;
      if (isConstantStream) {
        // Constant stream - lock manager upgrades
        managerCta = '🔒 Optimized (Constant)';
        managerDisabledAttr = 'disabled';
        managerCursor = 'not-allowed';
        managerOpacity = '0.6';
        managerBgColor = '#2a2a2a';
      } else if (onboarding) {
        managerCta = 'Onboarding in Progress';
        managerDisabledAttr = 'disabled';
        managerCursor = 'not-allowed';
        managerOpacity = '0.7';
        managerBgColor = '#533483';
      } else if (p.managerHired) {
        managerCta = `Upgrade Manager (${formatNumber(p.managerUpgradeCost)})`;
        managerDisabledAttr = '';
        managerCursor = 'pointer';
        managerOpacity = '1';
        managerBgColor = '#533483';
      } else {
        managerCta = `Hire Manager (${formatNumber(p.managerHireCost)})`;
        managerDisabledAttr = '';
        managerCursor = 'pointer';
        managerOpacity = '1';
        managerBgColor = '#533483';
      }
      
      // Value display - show per second for constant streams
      const currentVal = currentValue(p);
      const valueDisplay = isConstantStream 
        ? `$<span id="val-${p.id}">${formatNumber(currentVal / (cycleTime / 1000))}</span> / sec`
        : `$<span id="val-${p.id}">${formatNumber(currentVal)}</span> / unit`;

      card.innerHTML = `
        <h3 style="margin:0 0 6px 0;">${p.name}${isConstantStream ? ' ⚡' : ''}</h3>
        <p style="margin:0; color:#aaa;">${valueDisplay}</p>
        <p style="margin:6px 0 8px 0; font-size:.9rem;">
          Cycle: <span id="cyc-${p.id}">${(cycleTime/1000).toFixed(1)}</span>s • Level ${p.level}${isMaxLevel ? ' 🏆' : ''}
        </p>

        <div style="width:100%; background:#0f3460; height:8px; border-radius:4px; margin:8px 0 12px 0;">
          <div id="prog-${p.id}" style="width:${pct}%; background:#e94560; height:100%; border-radius:4px;"></div>
        </div>

        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          ${!isConstantStream ? `
            <button class="sell-btn" data-id="${p.id}" style="flex:1; padding:10px; background:#e94560; border:none; border-radius:6px; color:#fff; cursor:pointer;">
              <span id="selltxt-${p.id}">${p.running ? 'Click: -1s' : 'Sell'}</span>
            </button>
          ` : `
            <div style="flex:1; padding:10px; background:#1a4d2e; border:none; border-radius:6px; color:#4caf50; text-align:center; font-weight:bold;">
              ⚡ Constant Stream
            </div>
          `}
          <button class="upgrade-product-btn" data-id="${p.id}" data-count="${upgradeCount}" data-cost="${upgradeCost}" ${isMaxLevel ? 'disabled' : ''} style="padding:10px; background:${isMaxLevel ? '#333' : '#0f3460'}; border:none; border-radius:6px; color:${isMaxLevel ? '#888' : '#fff'}; cursor:${isMaxLevel ? 'not-allowed' : 'pointer'}; opacity:${isMaxLevel ? '0.7' : '1'};">
            ${upgradeText}
          </button>
          <button class="manager-btn" data-id="${p.id}" ${managerDisabledAttr} style="padding:10px; background:${managerBgColor}; border:none; border-radius:6px; color:#fff; cursor:${managerCursor}; opacity:${managerOpacity};">
            ${managerCta}
          </button>
        </div>

        ${p.managerHired
          ? `<p style="margin:10px 0 0 0; color:${isConstantStream ? '#4caf50' : (onboarding ? '#ffa726' : '#4caf50')};">${isConstantStream ? '⚡ Operating at peak efficiency - no further optimization possible' : (onboarding ? '⏳ Manager onboarding… (auto running)' : `✓ Manager Lv.${p.managerLevel} (auto)`)}</p>`
          : ''}
      `;
      
      // IMPORTANT: Clear the constant stream flag so updateProductProgressBars() will re-apply the animation
      delete p._wasConstantStream;

      productsList.appendChild(card);
    });
  }

  // Cache for upgrade button elements to avoid repeated querySelector calls
  let upgradeButtonCache = new Map();
  
  function updateProductProgressBars() {
    for (const p of gameState.products) {
      // Skip locked products as they don't have progress bars
      if (!p.unlocked) continue;
      
      const bar = $(`prog-${p.id}`);
      const sellTx = $(`selltxt-${p.id}`);
      const valEl = $(`val-${p.id}`);
      const cycEl = $(`cyc-${p.id}`);
      if (!bar) continue;

      const cycleTime = currentCycleTimeMs(p);
      const isConstantStream = cycleTime < 1000 && p.managerHired; // Sub-1-second with manager
      
      // Only update if state changed (prevent unnecessary DOM updates)
      const wasConstantStream = p._wasConstantStream || false;
      
      if (isConstantStream !== wasConstantStream) {
        p._wasConstantStream = isConstantStream;
        
        if (isConstantStream) {
          // Replace progress bar with "Constant Stream" animation
          bar.style.width = '100%';
          bar.style.background = 'linear-gradient(90deg, #4caf50, #00d4ff, #4caf50)';
          bar.style.backgroundSize = '200% 100%';
          bar.style.animation = 'constantStream 1.5s linear infinite';
          
          // Mark as optimized - update display once
          if (valEl) {
            const earningsPerSec = currentValue(p) / (cycleTime / 1000);
            valEl.textContent = formatNumber(earningsPerSec);
          }
          if (cycEl) cycEl.textContent = '⚡ Constant';
        } else {
          // Normal progress bar - reset styles
          bar.style.background = '#e94560';
          bar.style.backgroundSize = '100% 100%';
          bar.style.animation = 'none';
          bar.style.width = '0%'; // Reset width for normal animation
        }
      }
      
      // For constant streams, ensure animation persists (fix for broken bars)
      if (isConstantStream) {
        // Re-apply animation if it was somehow removed
        if (!bar.style.animation || bar.style.animation === 'none' || bar.style.animation === '') {
          bar.style.width = '100%';
          bar.style.background = 'linear-gradient(90deg, #4caf50, #00d4ff, #4caf50)';
          bar.style.backgroundSize = '200% 100%';
          bar.style.animation = 'constantStream 1.5s linear infinite';
        }
        // Skip progress bar, sell text, and frequent value updates
        // Only update upgrade buttons on the throttled schedule
      } else {
        // Normal product - update progress bar and values
        const pct = p.running ? Math.min(100, (1 - (p.timeRemainingMs / cycleTime)) * 100) : 0;
        bar.style.width = `${pct}%`;
        
        if (sellTx) sellTx.textContent = p.running ? 'Click: -1s' : 'Sell';
        if (valEl) valEl.textContent = currentValue(p);
        if (cycEl) {
          const cycleText = (cycleTime/1000).toFixed(1);
          if (cycEl.textContent !== cycleText) {
            cycEl.textContent = cycleText;
          }
        }
      }
      
      // Update upgrade button cost and count in real-time (throttled)
      // Only update every 10 ticks (~1 second) to reduce DOM manipulation
      if (!p._upgradeTickCount) p._upgradeTickCount = 0;
      p._upgradeTickCount++;
      
      if (p._upgradeTickCount >= 10) {
        p._upgradeTickCount = 0;
        
        // Get cached button or query once
        let upgradeBtn = upgradeButtonCache.get(p.id);
        if (!upgradeBtn || !document.contains(upgradeBtn)) {
          upgradeBtn = document.querySelector(`.upgrade-product-btn[data-id="${p.id}"]`);
          if (upgradeBtn) {
            upgradeButtonCache.set(p.id, upgradeBtn);
          }
        }
        
        if (upgradeBtn) {
          const multiplier = gameState.upgradeMultiplier;
          const MAX_LEVEL = 999;
          const isMaxLevel = p.level >= MAX_LEVEL;
          let upgradeCost, upgradeCount, upgradeText;
          
          if (isMaxLevel) {
            upgradeCount = 0;
            upgradeCost = 0;
            upgradeText = `MAX LEVEL (${MAX_LEVEL})`;
          } else if (multiplier === 'max') {
            const result = calculateMaxAffordableUpgrades(p, gameState.cash);
            upgradeCount = Math.min(result.count, MAX_LEVEL - p.level);
            upgradeCost = result.totalCost;
            upgradeText = `Upgrade x${upgradeCount} (${formatNumber(upgradeCost)})`;
          } else if (multiplier === 1) {
            upgradeCount = 1;
            upgradeCost = p.upgradeCost;
            upgradeText = `Upgrade (${formatNumber(upgradeCost)})`;
          } else {
            upgradeCount = Math.min(multiplier, MAX_LEVEL - p.level);
            upgradeCost = calculateBulkUpgradeCost(p, upgradeCount);
            upgradeText = `Upgrade x${upgradeCount} (${formatNumber(upgradeCost)})`;
          }
          
          // Only update if changed
          if (upgradeBtn.textContent !== upgradeText) {
            upgradeBtn.textContent = upgradeText;
          }
          upgradeBtn.dataset.count = upgradeCount;
          upgradeBtn.dataset.cost = upgradeCost;
          
          // Update button state (enabled/disabled) based on affordability
          const shouldBeDisabled = isMaxLevel || gameState.cash < upgradeCost || upgradeCount === 0;
          if (upgradeBtn.disabled !== shouldBeDisabled) {
            upgradeBtn.disabled = shouldBeDisabled;
            
            if (isMaxLevel) {
              upgradeBtn.style.opacity = '0.7';
              upgradeBtn.style.cursor = 'not-allowed';
              upgradeBtn.style.background = '#333';
              upgradeBtn.style.color = '#888';
            } else if (!shouldBeDisabled) {
              upgradeBtn.style.opacity = '1';
              upgradeBtn.style.cursor = 'pointer';
              upgradeBtn.style.background = '#0f3460';
              upgradeBtn.style.color = '#fff';
            } else {
              upgradeBtn.style.opacity = '0.5';
              upgradeBtn.style.cursor = 'not-allowed';
            }
          }
        }
      }
    }
  }
  
  // Clear upgrade button cache when products list is re-rendered
  function clearUpgradeButtonCache() {
    upgradeButtonCache.clear();
  }
  
  // Update People Tab
    function updatePeopleTab() {
    if (!employeesList) return;
    employeesList.innerHTML = '';

    // Onboarding badges
    for (const e of gameState.onboarding) {
        const card = document.createElement('div');
        card.className = 'employee-card';
        card.style.cssText = 'background:#16213e; border-radius:10px; padding:15px; box-shadow:0 4px 10px rgba(0,0,0,0.2); position:relative;';
        card.innerHTML = `
        <div style="display:flex; align-items:center; gap:12px; margin-bottom:10px;">
            <div style="width:44px; height:44px; border-radius:50%; background:#0f3460; display:flex; align-items:center; justify-content:center;">⏳</div>
            <div style="flex:1;">
            <h3 style="margin:0 0 2px 0;">${getColoredName(e)}</h3>
            <p style="margin:0; color:#aaa; font-size:.9rem;">${e.position}</p>
            <span style="display:inline-block; margin-top:6px; padding:3px 8px; font-size:.75rem; border-radius:999px; background:#0f3460; color:#fff;">Onboarding…</span>
            </div>
        </div>
        <button onclick="resetOnboarding('${e.id}')" style="width:100%; padding:8px; background:#ff6b00; border:none; border-radius:6px; color:white; cursor:pointer; font-size:.85rem; font-weight:600; margin-top:8px;">
            🔄 Reset Onboarding (Emergency)
        </button>
        `;
        employeesList.appendChild(card);
    }

    // Hired employees
    for (const e of gameState.employees) {
        const card = document.createElement('div');
        card.className = 'employee-card';
        card.style.cssText = 'background:#16213e; border-radius:10px; padding:15px; box-shadow:0 4px 10px rgba(0,0,0,0.2);';

        const img = e.profileImage || 'https://placehold.co/80x80';

        card.innerHTML = `
        <div style="display:flex; align-items:center; gap:15px; margin-bottom:12px;">
            <img src="${img}" style="width:60px; height:60px; border-radius:50%; object-fit:cover;">
            <div>
            <h3 style="margin:0;">${getColoredName(e)}${e.age ? `, ${e.age}` : ''}</h3>
            <p style="margin:4px 0; color:#aaa;">${e.position}${e.productManaged ? ` • ${e.productManaged}` : ''}</p>
            </div>
        </div>

        ${e.bio ? `<p style="margin:8px 0 12px 0; color:#ddd; font-size:.95rem;">${e.bio}</p>` : ''}

        <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-bottom:12px;">
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Affection</div>
            <div style="color:#e94560; font-weight:600;">${Math.round(e.stats.affection ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Comfort</div>
            <div style="color:#4ecca3; font-weight:600;">${Math.round(e.stats.comfort ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Trust</div>
            <div style="color:#00d4ff; font-weight:600;">${Math.round(e.stats.trust ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Desire</div>
            <div style="color:#ff6b9d; font-weight:600;">${Math.round(e.stats.desire ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Obedience</div>
            <div style="color:#c77dff; font-weight:600;">${Math.round(e.stats.obedience ?? 0)}%</div>
            </div>
            <div style="background:#0f3460; padding:8px; border-radius:6px;">
            <div style="font-size:.75rem; color:#aaa;">Productivity</div>
            <div style="color:#ffd700; font-weight:600;">${Math.round(e.stats.productivity ?? 0)}%</div>
            </div>
        </div>

        ${(() => {
          // Show relationships with other employees
          if (!e.relationships || Object.keys(e.relationships).length === 0) return '';
          
          const relationshipTypes = {
            'friend': { emoji: '👥', color: '#4ecca3', label: 'Friend' },
            'best_friend': { emoji: '💚', color: '#00ff88', label: 'Best Friend' },
            'crush': { emoji: '💖', color: '#ff69b4', label: 'Crush' },
            'rival': { emoji: '⚔️', color: '#ff9500', label: 'Rival' },
            'enemy': { emoji: '💢', color: '#e94560', label: 'Dislikes' },
            'romantic': { emoji: '💕', color: '#ff1493', label: 'Romantic' },
            'neutral': { emoji: '➖', color: '#888', label: 'Coworker' }
          };
          
          // Get top 3 strongest relationships
          const topRelationships = Object.entries(e.relationships)
            .map(([targetId, rel]) => {
              const target = gameState.employees.find(emp => emp.id === targetId);
              if (!target || target.employmentStatus !== 'active') return null;
              return { targetId, rel, target };
            })
            .filter(Boolean)
            .sort((a, b) => b.rel.strength - a.rel.strength)
            .slice(0, 3);
          
          if (topRelationships.length === 0) return '';
          
          const relHTML = topRelationships.map(({rel, target}) => {
            const typeInfo = relationshipTypes[rel.type] || relationshipTypes.neutral;
            return `<div style="display:flex; align-items:center; gap:6px; font-size:.85rem;">
              <span style="font-size:1.1rem;">${typeInfo.emoji}</span>
              <span style="color:${typeInfo.color}; font-weight:600;">${target.name}</span>
              <span style="color:#888; font-size:.75rem;">(${Math.round(rel.strength)}%)</span>
            </div>`;
          }).join('');
          
          return `<div style="background:#0f1419; padding:10px; border-radius:6px; margin-bottom:12px;">
            <div style="font-size:.8rem; color:#aaa; margin-bottom:6px; font-weight:600;">🤝 Relationships</div>
            ${relHTML}
          </div>`;
        })()}

        <div style="display:flex; gap:6px; flex-wrap:wrap;">
            <button class="employee-action-btn" data-employee="${e.id}" data-action="bio" style="padding:6px 10px; background:#00d4ff; border:none; border-radius:6px; color:#0f1419; cursor:pointer; font-size:.85rem; font-weight:600;">Bio</button>
            <button class="employee-action-btn" data-employee="${e.id}" data-action="gift" style="padding:6px 10px; background:#0f3460; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:.85rem;">Gift</button>
            <button class="employee-action-btn" data-employee="${e.id}" data-action="chat" style="padding:6px 10px; background:#e94560; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:.85rem; position:relative; display:flex; align-items:center; gap:6px;">
              Chat
              ${e.unreadMessages > 0 ? `<span style="position:absolute; top:-6px; right:-6px; background:#ff3366; color:white; border-radius:50%; width:20px; height:20px; display:flex; align-items:center; justify-content:center; font-size:.7rem; font-weight:700; box-shadow:0 2px 6px rgba(255,51,102,0.5);">${e.unreadMessages > 9 ? '9+' : e.unreadMessages}</span>` : ''}
            </button>
            <button class="employee-action-btn" data-employee="${e.id}" data-action="promote" style="padding:6px 10px; background:#533483; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:.85rem;">Promote</button>
            <button class="employee-action-btn" data-employee="${e.id}" data-action="fire" style="padding:6px 10px; background:#9e2a2b; border:none; border-radius:6px; color:#fff; cursor:pointer; font-size:.85rem;">Fire</button>
        </div>
        `;

        employeesList.appendChild(card);
    }

    // action handlers
    document.querySelectorAll('.employee-action-btn').forEach(btn => {
        btn.onclick = () => handleEmployeeAction(btn.dataset.employee, btn.dataset.action);
    });
    }

  
  function unlockProduct(id) {
    const p = gameState.products.find(x => x.id === id);
    if (!p) return;
    if (p.unlocked) return showNotification('Product already unlocked!');
    if (gameState.cash < p.unlockCost) return showNotification('Not enough cash to unlock this product!');
    
    gameState.cash -= p.unlockCost;
    p.unlocked = true;
    
    showNotification(`${p.name} unlocked! You can now start selling.`);
    
    // Check if this was the last product in the location - preload boss if so
    checkAndPreloadBossImage(p.locationId);
    
    updateProductsList();
    updateBusinessTab(); // Update location cards to reflect unlock progress
    updateUI();
  }

  function startOrClickProduct(id) {
    const p = gameState.products.find(x => x.id === id);
    if (!p) return;

    if (!p.running) {
      p.running = true;
      p.timeRemainingMs = currentCycleTimeMs(p);
    } else {
      p.timeRemainingMs = Math.max(0, p.timeRemainingMs - clickReductionMs(p));
    }

    // instant feedback without a full re-render
    const sellTxt = $(`selltxt-${p.id}`);
    if (sellTxt) sellTxt.textContent = p.running ? 'Click: -1s' : 'Sell';
  }

  // Helper function to format numbers
  function formatNumber(num) {
    // Abbreviated notation for all numbers >= 1000
    if (num >= 1e18) return (num / 1e18).toFixed(2) + 'Qi'; // Quintillions
    if (num >= 1e15) return (num / 1e15).toFixed(2) + 'Q';  // Quadrillions
    if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';  // Trillions
    if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';    // Billions
    if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';    // Millions
    if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';    // Thousands
    // For numbers under 1000, show up to 2 decimal places (no trailing zeros)
    if (num >= 100) return num.toFixed(0);
    if (num >= 10) return num.toFixed(1);
    return num.toFixed(2).replace(/\.?0+$/, ''); // Remove trailing zeros
  }

  // Format and style cash for top bar display with progressive enhancement
  function formatCashDisplay(cash) {
    let displayText, fontSize, color, textShadow, animation;
    
    if (cash >= 1e18) { // Quintillions (Qi)
      displayText = (cash / 1e18).toFixed(2) + 'Qi';
      fontSize = '2.2rem';
      color = '#FFD700'; // Bright gold
      textShadow = '0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.5)';
      animation = 'cash-glow-intense 2s ease-in-out infinite';
    } else if (cash >= 1e15) { // Quadrillions (Q)
      displayText = (cash / 1e15).toFixed(2) + 'Q';
      fontSize = '2rem';
      color = '#FFA500'; // Orange-gold
      textShadow = '0 0 15px rgba(255, 165, 0, 0.7), 0 0 30px rgba(255, 165, 0, 0.4)';
      animation = 'cash-glow 2.5s ease-in-out infinite';
    } else if (cash >= 1e12) { // Trillions (T)
      displayText = (cash / 1e12).toFixed(2) + 'T';
      fontSize = '1.8rem';
      color = '#FF6347'; // Tomato red
      textShadow = '0 0 10px rgba(255, 99, 71, 0.6)';
      animation = 'none';
    } else if (cash >= 1e9) { // Billions (B)
      displayText = (cash / 1e9).toFixed(2) + 'B';
      fontSize = '1.6rem';
      color = '#FF69B4'; // Hot pink
      textShadow = '0 0 8px rgba(255, 105, 180, 0.5)';
      animation = 'none';
    } else if (cash >= 1e6) { // Millions (M)
      displayText = (cash / 1e6).toFixed(2) + 'M';
      fontSize = '1.4rem';
      color = '#00D4FF'; // Cyan
      textShadow = '0 0 6px rgba(0, 212, 255, 0.4)';
      animation = 'none';
    } else if (cash >= 1e3) { // Thousands (K)
      displayText = (cash / 1e3).toFixed(2) + 'K';
      fontSize = '1.2rem';
      color = '#4ECCA3'; // Green
      textShadow = 'none';
      animation = 'none';
    } else {
      // For numbers under 1000, show clean format
      if (cash >= 100) displayText = cash.toFixed(0);
      else if (cash >= 10) displayText = cash.toFixed(1);
      else displayText = cash.toFixed(2).replace(/\.?0+$/, '');
      fontSize = '1rem';
      color = 'white';
      textShadow = 'none';
      animation = 'none';
    }
    
    return { displayText, fontSize, color, textShadow, animation };
  }

  // Update Upgrades Tab
  function updateUpgradesTab() {
    // Update Click Power section
    const clickPowerLevel = gameState.globalUpgrades.clickPower;
    const currentEffect = 1.0 + (clickPowerLevel * 0.1); // Current effect
    const clickPowerBaseCost = gameBalance.upgradeBaseCosts.clickPower;
    const clickPowerCost = Math.floor(clickPowerBaseCost * Math.pow(2.0, clickPowerLevel));
    
    const clickPowerLevelEl = document.getElementById('clickPowerLevel');
    const clickPowerEffectEl = document.getElementById('clickPowerEffect');
    const clickPowerCostEl = document.getElementById('clickPowerCost');
    
    if (clickPowerLevelEl) clickPowerLevelEl.textContent = `Level ${clickPowerLevel}`;
    if (clickPowerEffectEl) clickPowerEffectEl.textContent = `-${currentEffect.toFixed(1)}s per click`;
    if (clickPowerCostEl) clickPowerCostEl.textContent = `$${formatNumber(clickPowerCost)}`;
    
    // Helper: Calculate income boost percentage with diminishing returns
    function calculateIncomeBoost(level) {
      // Asymptotic formula: approaches but never reaches 100%
      // At level 1: ~9%, level 5: ~38%, level 10: ~58%, level 20: ~74%
      return (1 - Math.pow(0.9, level)) * 100;
    }
    
    // Helper: Calculate cost reduction percentage with diminishing returns (max 90%)
    function calculateCostReduction(level) {
      // Asymptotic formula: approaches 90% max
      // At level 1: ~8.5%, level 5: ~35%, level 10: ~56%, level 20: ~78%, approaches 90%
      return (1 - Math.pow(0.9, level)) * 90;
    }
    
    // Update Income Boost section
    const incomeBoostList = document.getElementById('incomeBoostList');
    if (incomeBoostList) {
      incomeBoostList.innerHTML = '';
      
      // Show buttons for all unlocked locations
      const unlockedLocations = gameState.locations.filter(loc => loc.unlocked);
      unlockedLocations.forEach(location => {
        const level = gameState.globalUpgrades.incomeBoost[location.id] || 0;
        const currentBonus = calculateIncomeBoost(level);
        const nextBonus = calculateIncomeBoost(level + 1);
        const bonusDiff = nextBonus - currentBonus;
        const baseCost = gameBalance.upgradeBaseCosts.incomeBoost;
        const cost = Math.floor(baseCost * Math.pow(2.5, level));
        
        const card = document.createElement('div');
        card.style.cssText = 'background:#0f3460; padding:12px; border-radius:8px; text-align:center;';
        card.innerHTML = `
          <div style="font-weight:bold; margin-bottom:6px; font-size:0.95rem;">${location.name}</div>
          <div style="color:#4caf50; font-size:1.1rem; margin-bottom:4px;">+${currentBonus.toFixed(1)}%</div>
          <div style="color:#888; font-size:0.75rem; margin-bottom:8px;">Level ${level}</div>
          <button onclick="buyIncomeBoost('${location.id}')" style="width:100%; padding:8px; background:#16213e; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:bold; font-size:0.85rem;">
            +${bonusDiff.toFixed(1)}% for $${formatNumber(cost)}
          </button>
        `;
        incomeBoostList.appendChild(card);
      });
    }
    
    // Update Cost Reduction section
    const costReductionList = document.getElementById('costReductionList');
    if (costReductionList) {
      costReductionList.innerHTML = '';
      
      // Show buttons for all unlocked locations
      const unlockedLocations = gameState.locations.filter(loc => loc.unlocked);
      unlockedLocations.forEach(location => {
        const level = gameState.globalUpgrades.costReduction[location.id] || 0;
        const currentReduction = calculateCostReduction(level);
        const nextReduction = calculateCostReduction(level + 1);
        const reductionDiff = nextReduction - currentReduction;
        const baseCost = gameBalance.upgradeBaseCosts.costReduction;
        const cost = Math.floor(baseCost * Math.pow(3.0, level));
        
        const card = document.createElement('div');
        card.style.cssText = 'background:#0f3460; padding:12px; border-radius:8px; text-align:center;';
        card.innerHTML = `
          <div style="font-weight:bold; margin-bottom:6px; font-size:0.95rem;">${location.name}</div>
          <div style="color:#ff6b6b; font-size:1.1rem; margin-bottom:4px;">-${currentReduction.toFixed(1)}%</div>
          <div style="color:#888; font-size:0.75rem; margin-bottom:8px;">Level ${level}</div>
          <button onclick="buyCostReduction('${location.id}')" style="width:100%; padding:8px; background:#16213e; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:bold; font-size:0.85rem;">
            -${reductionDiff.toFixed(1)}% for $${formatNumber(cost)}
          </button>
        `;
        costReductionList.appendChild(card);
      });
    }
  }

  // Calculate the total cost of buying N upgrades
  // Uses geometric series: sum = a * (r^n - 1) / (r - 1)
  // where a = current cost, r = growth rate, n = number of upgrades
  function calculateBulkUpgradeCost(product, count) {
    if (count <= 0) return 0;
    if (count === 1) return product.upgradeCost;
    
    const baseCost = product.baseUpgradeCost || product.upgradeCost;
    const growth = product.costGrowth || 1.35;
    const currentLevel = product.level;
    
    // Apply location-specific cost reduction from upgrades with DIMINISHING RETURNS
    const costReductionLevel = gameState.globalUpgrades?.costReduction?.[product.locationId] || 0;
    let reductionMultiplier = 1;
    if (costReductionLevel > 0) {
      // Asymptotic formula: (1 - 0.9^level) * 90% max
      const reductionPercentage = (1 - Math.pow(0.9, costReductionLevel)) * 90;
      reductionMultiplier = 1 - (reductionPercentage / 100);
    }
    
    // Calculate sum of costs for levels: current+1, current+2, ..., current+count
    let totalCost = 0;
    for (let i = 0; i < count; i++) {
      totalCost += baseCost * Math.pow(growth, currentLevel + i) * reductionMultiplier;
    }
    
    return Math.floor(totalCost);
  }

  // Calculate maximum affordable upgrades with current cash
  function calculateMaxAffordableUpgrades(product, cash) {
    const baseCost = product.baseUpgradeCost || product.upgradeCost;
    const growth = product.costGrowth || 1.35;
    const currentLevel = product.level;
    
    // Apply location-specific cost reduction from upgrades with DIMINISHING RETURNS
    const costReductionLevel = gameState.globalUpgrades?.costReduction?.[product.locationId] || 0;
    let reductionMultiplier = 1;
    if (costReductionLevel > 0) {
      // Asymptotic formula: (1 - 0.9^level) * 90% max
      const reductionPercentage = (1 - Math.pow(0.9, costReductionLevel)) * 90;
      reductionMultiplier = 1 - (reductionPercentage / 100);
    }
    
    let count = 0;
    let totalCost = 0;
    
    // Keep adding upgrades until we can't afford the next one
    while (true) {
      const nextCost = baseCost * Math.pow(growth, currentLevel + count) * reductionMultiplier;
      if (totalCost + nextCost > cash) break;
      totalCost += nextCost;
      count++;
      
      // Safety cap at 1000 upgrades
      if (count >= 1000) break;
    }
    
    return { count, totalCost: Math.floor(totalCost) };
  }

  function upgradeProduct(id) {
    const p = gameState.products.find(x => x.id === id);
    if (!p) return;
    
    // Check level cap
    const MAX_LEVEL = 999;
    if (p.level >= MAX_LEVEL) {
      return showNotification(`${p.name} is at max level (${MAX_LEVEL})!`);
    }
    
    // Get upgrade count from button data attribute (set in updateProductsList)
    const btn = document.querySelector(`.upgrade-product-btn[data-id="${id}"]`);
    const upgradeCount = btn ? parseInt(btn.dataset.count) || 1 : 1;
    let totalCost = btn ? parseInt(btn.dataset.cost) || p.upgradeCost : p.upgradeCost;
    
    // Apply product discount from influence upgrades
    const productDiscountLevel = gameState.influenceUpgrades?.productDiscount || 0;
    const discountMultiplier = influenceUpgrades.productDiscount.effect(productDiscountLevel);
    totalCost = Math.floor(totalCost * discountMultiplier);
    
    if (gameState.cash < totalCost) return showNotification('Not enough cash!');
    
    // Deduct cost and apply upgrades (but cap at MAX_LEVEL)
    gameState.cash -= totalCost;
    
    // Ensure base upgrade cost is set
    if (!p.baseUpgradeCost) {
      const prevGrowth = 1.15;
      const baseEst = p.upgradeCost / Math.pow(prevGrowth, Math.max(0, (p.level - 1)));
      p.baseUpgradeCost = Math.max(1, Math.floor(baseEst));
    }
    
    // Apply upgrades but cap at max level
    const newLevel = Math.min(MAX_LEVEL, p.level + upgradeCount);
    const actualUpgrades = newLevel - p.level;
    p.level = newLevel;
    
    // Calculate new cost for next upgrade (if not at cap)
    if (p.level < MAX_LEVEL) {
      // Don't apply globalCostReduction here - it should only be applied at product initialization
      const growth = p.costGrowth || gameBalance.productCostMultiplier;
      let nextCost = p.baseUpgradeCost * Math.pow(growth, p.level);
      
      // Apply location-specific cost reduction from upgrades with DIMINISHING RETURNS
      const costReductionLevel = gameState.globalUpgrades?.costReduction?.[p.locationId] || 0;
      if (costReductionLevel > 0) {
        // Asymptotic formula: (1 - 0.9^level) * 90% max
        const reductionPercentage = (1 - Math.pow(0.9, costReductionLevel)) * 90;
        const reductionMultiplier = 1 - (reductionPercentage / 100);
        nextCost *= reductionMultiplier;
      }
      
      p.upgradeCost = Math.floor(nextCost);
    }
    
    showNotification(`${p.name} upgraded to Lv.${p.level}${actualUpgrades > 1 ? ` (+${actualUpgrades})` : ''}${p.level >= MAX_LEVEL ? ' [MAX]' : ''}`);
    updateProductsList();
  }

    function hireOrUpgradeManager(id) {
    const p = gameState.products.find(x => x.id === id);
    if (!p) return;

    if (!p.managerHired) {
        // Always show the modal; we’ll charge on selection.
        showManagerHiringModal(id);
    } else {
          // d) Block upgrading while onboarding
          if (p.managerOnboarding) {
            return showNotification('Manager onboarding in progress. Upgrade available after onboarding completes.');
          }
        if (gameState.cash < p.managerUpgradeCost) return showNotification('Not enough cash!');
        gameState.cash -= p.managerUpgradeCost;
        p.managerLevel += 1;
        p.managerUpgradeCost = Math.floor(p.managerUpgradeCost * 1.25);
        showNotification(`${p.name} manager upgraded to Lv.${p.managerLevel}`);
        updatePeopleTab();
        updateProductsList();
    }
    }


  function createOrLinkManagerNPC(product) {
    const id = `mgr_${product.id}`;
    if (gameState.employees.some(e => e.id === id)) return; // already exists
    const names = ['Jade','Morgan','Riley','Avery','Sam','Harper','Quinn','Rowan'];
    const last = ['Park','Davis','Johnson','Garcia','Smith','Lee','Kim','Patel'];
    const emp = {
      id,
      name: `${names[Math.floor(Math.random()*names.length)]} ${last[Math.floor(Math.random()*last.length)]}`,
      position: `Manager – ${product.name}`,
      trait: 'Workhorse',
      personality: 'Friendly',
      stats: { comfort:60, affection:40, desire:25, productivity:70 },
      hired: true,
      level: 1,
      bio: `Keeps ${product.name} on track.`,
      employmentStatus: 'active',
      location: product.locationId || 'headquarters'
    };
    
    // Initialize social network data
    initializeEmployeeSocialData(emp);
    
    gameState.employees.push(emp);
    
    // Refresh dashboard to show new employee
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
    
    // Generate relationships with existing employees
    generateRandomRelationships(emp.id);
    
    // Generate first post
    generateFirstEmployeePost(emp).catch(err => {
      console.error('First post generation failed:', err);
    });
  }

  // Update Gifts Tab
  function updateGiftsTab() {
    if (!giftsList) return;
    
    giftsList.innerHTML = '';
    gameState.gifts.forEach(gift => {
      const giftCard = document.createElement('div');
      giftCard.className = 'gift-card';
      giftCard.style.cssText = 'background:#16213e; border-radius:10px; padding:15px; box-shadow:0 4px 10px rgba(0,0,0,0.2); display:flex; flex-direction:column;';
      
      giftCard.innerHTML = `
        <h3 style="margin-top:0;">${gift.name}</h3>
        <p style="color:#aaa; margin:5px 0;">${gift.description}</p>
        <p style="margin:10px 0; font-weight:bold;">${gift.cost}</p>
        <button class="buy-gift-btn" data-gift="${gift.id}" style="margin-top:auto; padding:8px; background:#e94560; border:none; border-radius:5px; color:white; cursor:pointer;">Purchase</button>
      `;
      
      giftsList.appendChild(giftCard);
    });
    
    // Add event listeners
    document.querySelectorAll('.buy-gift-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const giftId = btn.dataset.gift;
        // Gift purchase logic would go here
        showNotification(`Gift purchased! Select an employee to give it to.`);
      });
    });
  }
  
  // Update HR Tab
  function updateHRTab() {
    // Update slider values
    const atmosphereSlider = $('atmosphereSlider');
    const atmosphereValue = $('atmosphereValue');
    const guidelinesSlider = $('guidelinesSlider');
    const guidelinesValue = $('guidelinesValue');
    const policyValue = $('policyValue');
    
    if (atmosphereSlider && atmosphereValue) {
      atmosphereSlider.value = gameState.settings.atmosphere ?? 50;
      const val = gameState.settings.atmosphere ?? 50;
      let label = 'Balanced';
      if (val < 33) label = 'Professional';
      else if (val > 66) label = 'Relaxed';
      atmosphereValue.textContent = label;
    }
    
    if (guidelinesSlider && guidelinesValue) {
      guidelinesSlider.value = gameState.settings.guidelines ?? 50;
      const val = gameState.settings.guidelines ?? 50;
      let label = 'Standard';
      if (val < 33) label = 'Reserved';
      else if (val > 66) label = 'Outgoing';
      guidelinesValue.textContent = label;
    }
    
    // Update policy buttons and label
    document.querySelectorAll('.policy-btn').forEach(btn => {
      if (btn.dataset.policy === gameState.settings.policy) {
        btn.style.background = '#e94560';
        btn.style.borderColor = '#e94560';
        btn.style.color = 'white';
      } else {
        btn.style.background = '#0f3460';
        btn.style.borderColor = '#00d4ff';
        btn.style.color = 'white';
      }
    });
    
    if (policyValue) {
      const policyLabels = {
        'professional': 'Professional',
        'casual': 'Casual',
        'open': 'Enthusiastic'
      };
      policyValue.textContent = policyLabels[gameState.settings.policy] || 'Professional';
    }
  }
  
  // ========== SOCIAL FEED FUNCTIONS ==========
  
  /**
   * Update the Social Feed tab
   */
  // Virtual scrolling state for social feed
  let virtualScrollState = {
    postsPerPage: 50,
    currentPage: 0,
    allPosts: [],
    renderedRange: { start: 0, end: 50 },
    scrollContainer: null,
    isScrolling: false,
    scrollTimeout: null,
    lastRenderTime: 0,
    pendingUpdates: new Set(), // Track which posts need updates
    updateThrottle: null
  };

  function updateSocialTab() {
    if (gameState.activeTab !== 'social') return;
    
    updateFeedStats();
    renderSocialFeed(); // Direct render on tab load
  }
  
  /**
   * Request a smart feed update (debounced and context-aware)
   * FOR COMMENTS: Use immediate updates instead via updateCommentsSection directly
   */
  function requestSmartFeedUpdate(postId = null) {
    // If specific post needs update, track it
    if (postId) {
      virtualScrollState.pendingUpdates.add(postId);
    }
    
    // Clear existing throttle
    if (virtualScrollState.updateThrottle) {
      clearTimeout(virtualScrollState.updateThrottle);
    }
    
    // SIMPLIFIED: Just do immediate updates for posts
    // The debounce was causing comment visibility issues
    virtualScrollState.updateThrottle = setTimeout(() => {
      performSmartFeedUpdate();
    }, 50); // Reduced from 100ms to 50ms
  }
  
  /**
   * Perform smart feed update without disrupting user experience
   */
  function performSmartFeedUpdate() {
    const feedContent = $('socialFeedContent');
    if (!feedContent) return;
    
    // SIMPLIFIED: Always update posts in place, skip gentle/full render logic
    // The comment immediate updates handle the UI, this is just backup
    if (virtualScrollState.pendingUpdates.size > 0) {
      virtualScrollState.pendingUpdates.forEach(postId => {
        updatePostInPlace(postId);
      });
    }
    
    // Clear pending updates
    virtualScrollState.pendingUpdates.clear();
  }
  
  /**
   * Gentle update: only update specific elements without full re-render
   * DEPRECATED: Keeping for compatibility but not used for comments anymore
   */
  function performGentleUpdate() {
    const feedContent = $('socialFeedContent');
    if (!feedContent) return;
    
    // Get current posts
    const posts = filterAndSortPosts();
    const previousPosts = virtualScrollState.allPosts;
    
    // Check for new posts at the top
    const newPosts = [];
    for (let i = 0; i < posts.length; i++) {
      if (!previousPosts.find(p => p.id === posts[i].id)) {
        newPosts.push(posts[i]);
      } else {
        break; // Stop at first existing post
      }
    }
    
    // Show notification for new posts instead of auto-inserting
    if (newPosts.length > 0) {
      showNewPostsNotification(newPosts.length);
      virtualScrollState.allPosts = posts; // Update state for when they refresh
    }
    
    // Update existing posts in place (likes, comments)
    if (virtualScrollState.pendingUpdates.size > 0) {
      virtualScrollState.pendingUpdates.forEach(postId => {
        updatePostInPlace(postId);
      });
    }
  }
  
  /**
   * Show non-intrusive notification about new posts
   */
  function showNewPostsNotification(count) {
    const existing = $('newPostsNotification');
    if (existing) existing.remove();
    
    const notification = document.createElement('div');
    notification.id = 'newPostsNotification';
    notification.style.cssText = `
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
      color: white;
      padding: 12px 24px;
      border-radius: 24px;
      box-shadow: 0 4px 20px rgba(0, 212, 255, 0.4);
      cursor: pointer;
      z-index: 10000;
      font-weight: 600;
      font-size: 0.9rem;
      animation: slideDown 0.3s ease-out;
      transition: transform 0.2s, box-shadow 0.2s;
    `;
    notification.innerHTML = `
      <span style="margin-right: 8px;">↑</span>
      ${count} new post${count > 1 ? 's' : ''}
      <span style="margin-left: 8px; font-size: 0.8rem; opacity: 0.9;">• Click to view</span>
    `;
    
    notification.onclick = () => {
      const feedContent = $('socialFeedContent');
      if (feedContent) {
        feedContent.scrollTo({ top: 0, behavior: 'smooth' });
        setTimeout(() => {
          renderSocialFeed(true); // Full render at top
        }, 300);
      }
      notification.remove();
    };
    
    // Auto-hide after 8 seconds
    setTimeout(() => {
      if (notification.parentNode) {
        notification.style.opacity = '0';
        notification.style.transform = 'translateX(-50%) translateY(-20px)';
        setTimeout(() => notification.remove(), 300);
      }
    }, 8000);
    
    document.body.appendChild(notification);
  }
  
  /**
   * Update a specific post in place (likes, comments, etc)
   */
  function updatePostInPlace(postId) {
    const postEl = document.querySelector(`[data-post-id="${postId}"]`);
    if (!postEl) {
      console.warn(`[Feed Update] Could not find post element for ID: ${postId}`);
      return;
    }
    
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) {
      console.warn(`[Feed Update] Could not find post data for ID: ${postId}`);
      return;
    }
    
    console.log(`[Feed Update] Updating post ${postId} (${post.comments.length} comments)`);
    
    // Update like count
    const likeBtn = postEl.querySelector('.like-count');
    if (likeBtn) {
      const isLiked = post.likes.includes('player');
      likeBtn.innerHTML = `${isLiked ? '❤️' : '🤍'} ${post.likes.length}`;
      likeBtn.style.color = isLiked ? '#e94560' : '#8899a6';
    }
    
    // Update comment count
    const commentCount = postEl.querySelector('.comment-count');
    if (commentCount) {
      commentCount.innerHTML = `💬 ${post.comments.length}`;
    }
    
    // AGGRESSIVE FIX: ALWAYS update comments section if it exists
    // No more checking visibility - just update it
    const commentsSection = postEl.querySelector('.post-comments-section');
    if (commentsSection) {
      console.log(`[Feed Update] FORCE updating comments for post ${postId} (${post.comments.length} comments)`);
      updateCommentsSection(postEl, post);
      
      // Clear any refresh flags
      delete commentsSection.dataset.needsRefresh;
    }
  }
  
  /**
   * Update comments section without rebuilding entire post
   */
  function updateCommentsSection(postEl, post) {
    const commentsSection = postEl.querySelector('.post-comments-section');
    if (!commentsSection) return;
    
    const commentsList = commentsSection.querySelector('.comments-list');
    if (!commentsList) return;
    
    // Check if user is focused on comment input
    const commentInput = commentsSection.querySelector('textarea');
    const isFocused = commentInput && document.activeElement === commentInput;
    const inputValue = isFocused ? commentInput.value : '';
    const cursorPos = isFocused ? commentInput.selectionStart : 0;
    
    // Save scroll position
    const scrollPos = commentsSection.scrollTop;
    
    // Rebuild comments list
    commentsList.innerHTML = buildCommentsHTML(post);
    
    // Restore scroll
    commentsSection.scrollTop = scrollPos;
    
    // Restore input focus and value if user was typing
    if (isFocused && commentInput) {
      const newInput = commentsSection.querySelector('textarea');
      if (newInput) {
        newInput.value = inputValue;
        newInput.focus();
        newInput.setSelectionRange(cursorPos, cursorPos);
      }
    }
  }
  
  /**
   * Build comments HTML (extracted for reuse)
   */
  function buildCommentsHTML(post) {
    if (post.comments.length === 0) {
      return '<div style="padding: 20px; text-align: center; color: #555; font-style: italic;">No comments yet. Be the first!</div>';
    }
    
    return post.comments.map(comment => {
      const author = comment.authorId === 'player' 
        ? { name: 'You', social: { username: 'TheBoss' } }
        : gameState.employees.find(e => e.id === comment.authorId) || { name: 'Unknown', social: {} };
      
      const isPlayer = comment.authorId === 'player';
      const timeAgo = getTimeAgo(comment.timestamp);
      
      return `
        <div class="comment" style="padding: 12px; border-bottom: 1px solid #1a1a2e; display: flex; gap: 10px; ${comment.replyToCommentId ? 'margin-left: 30px; border-left: 2px solid #0f3460;' : ''}">
          <div style="flex: 1;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
              <span style="color: ${isPlayer ? '#e94560' : '#00d4ff'}; font-weight: 600; font-size: 0.9rem;">${author.name}</span>
              ${author.social?.username ? `<span style="color: #8899a6; font-size: 0.8rem;">@${author.social.username}</span>` : ''}
              <span style="color: #555; font-size: 0.75rem;">${timeAgo}</span>
            </div>
            <div style="color: #eee; font-size: 0.95rem; line-height: 1.5;">${linkifyMentions(comment.content)}</div>
          </div>
        </div>
      `;
    }).join('');
  }
  
  /**
   * Update feed statistics
   */
  function updateFeedStats() {
    const totalPostsEl = $('totalPostsCount');
    const activeUsersEl = $('activeUsersCount');
    const todayPostsEl = $('todayPostsCount');
    
    if (totalPostsEl) {
      totalPostsEl.textContent = gameState.socialNetwork.posts.length;
    }
    
    if (activeUsersEl) {
      const activeCount = gameState.employees.filter(e => e.employmentStatus === 'active').length;
      activeUsersEl.textContent = activeCount;
    }
    
    if (todayPostsEl) {
      const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000);
      const todayPosts = gameState.socialNetwork.posts.filter(p => p.timestamp > oneDayAgo).length;
      todayPostsEl.textContent = todayPosts;
    }
  }
  
  /**
   * ===== NEW SIMPLIFIED SOCIAL FEED SYSTEM =====
   * Direct rendering with no virtual scrolling
   * Posts open in modal for comments
   * Much better performance!
   */
  
  function renderSocialFeed(forceFullRender = false) {
    const feedContent = $('socialFeedContent');
    const emptyState = $('feedEmptyState');
    
    if (!feedContent) return;
    
    // Get filtered and sorted posts
    let posts = filterAndSortPosts();
    
    // Show empty state if no posts
    if (posts.length === 0) {
      if (emptyState) emptyState.style.display = 'block';
      feedContent.innerHTML = '';
      feedContent.appendChild(emptyState);
      return;
    }
    
    // Hide empty state
    if (emptyState) emptyState.style.display = 'none';
    
    // Store scroll position for smooth updates
    const scrollTop = feedContent.scrollTop;
    const firstPost = feedContent.firstElementChild;
    const firstPostTop = firstPost ? firstPost.offsetTop : 0;
    
    // Clear and render all posts
    feedContent.innerHTML = '';
    
    posts.forEach(post => {
      const postCard = createFeedPostCard(post);
      feedContent.appendChild(postCard);
    });
    
    // Restore scroll position to prevent jumping
    if (scrollTop > 0) {
      feedContent.scrollTop = scrollTop;
    }
  }
  
  /**
   * Create a simplified post card for the feed
   * No inline comments - click to open modal
   */
  function createFeedPostCard(post) {
    const postCard = document.createElement('div');
    postCard.className = 'social-post-card';
    postCard.dataset.postId = post.id;
    postCard.style.cssText = 'background:#16181c; border:1px solid #2f3336; border-radius:16px; padding:20px; margin-bottom:14px; box-shadow:0 1px 3px rgba(0,0,0,0.12); transition:all 0.3s ease; cursor:pointer;';
    
    // Hover effect
    postCard.onmouseenter = function() {
      this.style.background = '#1a1d21';
      this.style.borderColor = '#3f4348';
    };
    postCard.onmouseleave = function() {
      this.style.background = '#16181c';
      this.style.borderColor = '#2f3336';
    };
    
    // Click to open modal
    postCard.onclick = function(e) {
      // Don't open if clicking interactive elements
      if (e.target.tagName === 'BUTTON' || e.target.tagName === 'IMG' || e.target.closest('button')) {
        return;
      }
      openPostModal(post.id);
    };
    
    // Get author info
    const author = post.isPlayerPost ? 
      { name: 'You', profileImage: null, employmentStatus: 'active' } :
      gameState.employees.find(e => e.id === post.authorId) || { name: post.authorName, profileImage: null, employmentStatus: 'unknown' };
    
    const avatarUrl = author.profileImage || 'https://placehold.co/50x50?text=' + (author.name?.[0] || '?');
    const isAlumni = author.employmentStatus === 'alumni';
    
    // Format timestamp
    const timeAgo = formatTimeAgo(post.timestamp);
    
    // Check if boss liked this post
    const bossLiked = post.likes.includes('player');
    
    postCard.innerHTML = `
      <!-- Post Header -->
      <div style="display:flex; align-items:center; gap:14px; margin-bottom:16px;">
        <img src="${avatarUrl}" style="width:44px; height:44px; border-radius:50%; object-fit:cover; border:2px solid ${isAlumni ? '#666' : post.isPlayerPost ? '#e94560' : '#00d4ff'}; flex-shrink:0;" onclick="event.stopPropagation(); ${post.isPlayerPost ? '' : `showEmployeeProfile('${post.authorId}')`}">
        <div style="flex:1; min-width:0;">
          <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
            <strong style="font-size:0.95rem; font-weight:600;">${post.isPlayerPost ? '<span style="color:#fff;">You</span>' : getColoredName(author)}</strong>
            ${post.isPlayerPost ? `<span style="color:#e94560; font-size:0.85rem; font-weight:600;">@TheBoss</span>` : author.social?.username ? `<span style="color:#8899a6; font-size:0.85rem;">@${author.social.username}</span>` : ''}
            ${isAlumni ? '<span style="background:#555; padding:3px 10px; border-radius:12px; font-size:0.7rem; color:#ccc;">Alumni</span>' : ''}
            ${post.explicitLevel >= 1 ? '<span style="background:linear-gradient(135deg, #e94560, #d63850); padding:3px 10px; border-radius:12px; font-size:0.7rem; color:white; font-weight:600;">🔞</span>' : ''}
          </div>
          <div style="color:#8899a6; font-size:0.8rem; margin-top:2px;">${timeAgo}</div>
        </div>
      </div>
      
      ${post.explicitLevel >= 3 ? `
        <div style="background:rgba(233, 69, 96, 0.15); padding:10px 14px; border-radius:8px; border-left:4px solid #e94560; margin-bottom:14px; font-size:0.85rem; color:#ff9fb3;">
          <strong style="display:flex; align-items:center; gap:6px;"><span>🔞</span> Explicit Content Warning</strong>
        </div>
      ` : ''}
      
      <!-- Post Content -->
      <div style="color:#e7e9ea; line-height:1.6; margin-bottom:14px; font-size:0.95rem; word-wrap:break-word;">
        ${linkifyMentions(post.content)}
      </div>
      
      <!-- Post Image -->
      ${post.imageUrl ? `
        <div style="margin-bottom:14px; border-radius:12px; overflow:hidden; border:1px solid #2f3336;">
          <img src="${post.imageUrl}" style="width:100%; height:auto; display:block; cursor:pointer;" onclick="event.stopPropagation(); openImageViewer('${post.imageUrl}')">
        </div>
      ` : ''}
      
      <!-- Post Actions -->
      <div style="display:flex; gap:20px; padding-top:10px; border-top:1px solid #2f3336;">
        <button onclick="event.stopPropagation(); handleLikePost('${post.id}')" style="background:transparent; border:none; color:${bossLiked ? '#e94560' : '#8899a6'}; cursor:pointer; display:flex; align-items:center; gap:6px; font-size:0.9rem; padding:8px 12px; border-radius:8px; transition:all 0.2s;" onmouseenter="this.style.background='rgba(255,255,255,0.05)'" onmouseleave="this.style.background='transparent'">
          <span style="font-size:1.1rem;">${bossLiked ? '❤️' : '🤍'}</span>
          <span>${post.likes.length}</span>
        </button>
        <button onclick="event.stopPropagation(); openPostModal('${post.id}')" style="background:transparent; border:none; color:#8899a6; cursor:pointer; display:flex; align-items:center; gap:6px; font-size:0.9rem; padding:8px 12px; border-radius:8px; transition:all 0.2s;" onmouseenter="this.style.background='rgba(255,255,255,0.05)'" onmouseleave="this.style.background='transparent'">
          <span style="font-size:1.1rem;">💬</span>
          <span>${post.comments.length}</span>
        </button>
      </div>
    `;
    
    return postCard;
  }
  
  /**
   * Open post in modal with full comment functionality
   */
  function openPostModal(postId) {
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) return;
    
    // Get author info
    const author = post.isPlayerPost ? 
      { name: 'You', profileImage: null, employmentStatus: 'active', id: 'player' } :
      gameState.employees.find(e => e.id === post.authorId) || { name: post.authorName, profileImage: null, employmentStatus: 'unknown', id: post.authorId };
    
    const avatarUrl = author.profileImage || 'https://placehold.co/50x50?text=' + (author.name?.[0] || '?');
    const isAlumni = author.employmentStatus === 'alumni';
    const timeAgo = formatTimeAgo(post.timestamp);
    const bossLiked = post.likes.includes('player');
    
    // Create modal
    const modal = document.createElement('div');
    modal.id = 'postModal';
    modal.style.background = 'rgba(0,0,0,0.85)';
    modal.style.padding = '10px';
    modal.style.overflow = 'auto';
    
    // Check if mobile for responsive sizing
    const isMobile = window.innerWidth <= 768;
    
    modal.innerHTML = `
      <div style="background:#16181c; border:1px solid #2f3336; border-radius:${isMobile ? '16px' : '20px'}; max-width:${isMobile ? '100%' : '700px'}; width:100%; max-height:${isMobile ? '95vh' : '90vh'}; height:${isMobile ? 'auto' : 'auto'}; overflow:hidden; box-shadow:0 8px 32px rgba(0,0,0,0.5); display:flex; flex-direction:column; margin:auto;">
        <!-- Modal Header -->
        <div style="padding:${isMobile ? '12px 16px' : '16px 20px'}; border-bottom:1px solid #2f3336; display:flex; justify-content:space-between; align-items:center; flex-shrink:0;">
          <h3 style="color:#fff; margin:0; font-size:${isMobile ? '1rem' : '1.1rem'}; font-weight:600;">Post</h3>
          <button onclick="ModalManager.close('postModal')" style="background:transparent; border:none; color:#8899a6; cursor:pointer; font-size:1.5rem; padding:4px 10px; border-radius:50%; transition:all 0.2s; min-width:40px; min-height:40px; display:flex; align-items:center; justify-content:center;" onmouseenter="this.style.background='rgba(255,255,255,0.1)'; this.style.color='#fff'" onmouseleave="this.style.background='transparent'; this.style.color='#8899a6'">×</button>
        </div>
        
        <!-- Post Content (Scrollable with comments) -->
        <div style="flex:1; overflow-y:auto; overflow-x:hidden; -webkit-overflow-scrolling:touch;">
          <div style="padding:${isMobile ? '16px' : '20px'}; border-bottom:1px solid #2f3336;">
            <!-- Post Header -->
          <div style="display:flex; align-items:center; gap:14px; margin-bottom:16px;">
            <img src="${avatarUrl}" style="width:44px; height:44px; border-radius:50%; object-fit:cover; border:2px solid ${isAlumni ? '#666' : post.isPlayerPost ? '#e94560' : '#00d4ff'}; flex-shrink:0; cursor:${post.isPlayerPost ? 'default' : 'pointer'};" ${post.isPlayerPost ? '' : `onclick="ModalManager.close('postModal'); showEmployeeProfile('${post.authorId}')"`}>
            <div style="flex:1; min-width:0;">
              <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                <strong style="font-size:0.95rem; font-weight:600;">${post.isPlayerPost ? '<span style="color:#fff;">You</span>' : getColoredName(author)}</strong>
                ${post.isPlayerPost ? `<span style="color:#e94560; font-size:0.85rem; font-weight:600;">@TheBoss</span>` : author.social?.username ? `<span style="color:#8899a6; font-size:0.85rem;">@${author.social.username}</span>` : ''}
                ${isAlumni ? '<span style="background:#555; padding:3px 10px; border-radius:12px; font-size:0.7rem; color:#ccc;">Alumni</span>' : ''}
                ${post.explicitLevel >= 1 ? '<span style="background:linear-gradient(135deg, #e94560, #d63850); padding:3px 10px; border-radius:12px; font-size:0.7rem; color:white; font-weight:600;">🔞</span>' : ''}
              </div>
              <div style="color:#8899a6; font-size:0.8rem; margin-top:2px;">${timeAgo}</div>
            </div>
          </div>
          
          ${post.explicitLevel >= 3 ? `
            <div style="background:rgba(233, 69, 96, 0.15); padding:10px 14px; border-radius:8px; border-left:4px solid #e94560; margin-bottom:14px; font-size:0.85rem; color:#ff9fb3;">
              <strong style="display:flex; align-items:center; gap:6px;"><span>🔞</span> Explicit Content Warning</strong>
              <div style="margin-top:4px; opacity:0.9;">This post contains adult content</div>
            </div>
          ` : ''}
          
          <!-- Post Text -->
          <div style="color:#e7e9ea; line-height:1.6; margin-bottom:14px; font-size:0.95rem; word-wrap:break-word;">
            ${linkifyMentions(post.content)}
          </div>
          
          <!-- Post Image -->
          ${post.imageUrl ? `
            <div style="margin-bottom:14px; border-radius:12px; overflow:hidden; border:1px solid #2f3336;">
              <img src="${post.imageUrl}" style="width:100%; height:auto; display:block; cursor:pointer;" onclick="openImageViewer('${post.imageUrl}')">
            </div>
          ` : ''}
          
          <!-- Post Actions -->
          <div style="display:flex; gap:20px; padding-top:10px; border-top:1px solid #2f3336;">
            <button onclick="handleLikePost('${post.id}')" style="background:transparent; border:none; color:${bossLiked ? '#e94560' : '#8899a6'}; cursor:pointer; display:flex; align-items:center; gap:6px; font-size:0.9rem; padding:8px 12px; border-radius:8px; transition:all 0.2s;" onmouseenter="this.style.background='rgba(255,255,255,0.05)'" onmouseleave="this.style.background='transparent'">
              <span style="font-size:1.1rem;">${bossLiked ? '❤️' : '🤍'}</span>
              <span id="modalLikeCount">${post.likes.length}</span>
            </button>
            <div style="color:#8899a6; display:flex; align-items:center; gap:6px; font-size:0.9rem; padding:8px 12px;">
              <span style="font-size:1.1rem;">💬</span>
              <span id="modalCommentCount">${post.comments.length}</span>
            </div>
          </div>
        </div>
        
        <!-- Comments Section (Inside scrollable area) -->
        <div id="modalCommentsContainer" style="padding:${isMobile ? '16px' : '20px'}; padding-top:0;">
          <!-- Comments will be rendered here -->
        </div>
        </div>
        
        <!-- Comment Input (Fixed at bottom) -->
        <div style="padding:${isMobile ? '12px 16px' : '16px 20px'}; border-top:1px solid #2f3336; background:#0d0f12; flex-shrink:0;">
          <div style="display:flex; gap:10px; align-items:start;">
            <textarea id="modalCommentInput" placeholder="Write a comment..." style="flex:1; background:#16181c; border:1px solid #2f3336; border-radius:12px; padding:12px; color:#e7e9ea; font-size:${isMobile ? '16px' : '0.9rem'}; resize:none; min-height:${isMobile ? '44px' : '40px'}; max-height:120px; font-family:inherit;" rows="1"></textarea>
            <button onclick="submitModalComment('${post.id}')" style="background:linear-gradient(135deg, #00d4ff, #0099cc); border:none; color:white; padding:${isMobile ? '12px 20px' : '12px 24px'}; border-radius:12px; cursor:pointer; font-weight:600; font-size:0.9rem; transition:all 0.3s; box-shadow:0 2px 8px rgba(0,212,255,0.3); min-height:${isMobile ? '44px' : 'auto'};" onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,212,255,0.4)'" onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,212,255,0.3)'">
              ${isMobile ? '📤' : 'Send'}
            </button>
          </div>
        </div>
      </div>
    `;
    
    // Show modal
    ModalManager.show(modal, 'postModal');
    
    // Close on background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) ModalManager.close('postModal');
    });
    
    // Render comments
    renderModalComments(post.id);
    
    // Auto-resize textarea
    const textarea = $('modalCommentInput');
    if (textarea) {
      textarea.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = this.scrollHeight + 'px';
      });
    }
  }
  
  /**
   * Render comments in the post modal
   */
  function renderModalComments(postId) {
    const container = $('modalCommentsContainer');
    if (!container) return;
    
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) return;
    
    container.innerHTML = '';
    
    if (post.comments.length === 0) {
      container.innerHTML = `
        <div style="text-align:center; padding:40px 20px; color:#8899a6;">
          <div style="font-size:2rem; margin-bottom:10px;">💬</div>
          <div style="font-size:0.9rem;">No comments yet</div>
          <div style="font-size:0.8rem; margin-top:4px; opacity:0.7;">Be the first to comment!</div>
        </div>
      `;
      return;
    }
    
    // Render each comment
    post.comments.forEach(comment => {
      const commentEl = createModalCommentElement(comment, postId);
      container.appendChild(commentEl);
    });
  }
  
  /**
   * Create a comment element for the modal
   */
  function createModalCommentElement(comment, postId) {
    const commentEl = document.createElement('div');
    const isMobile = window.innerWidth <= 768;
    commentEl.style.cssText = `background:#1a1d21; border:1px solid #2f3336; border-radius:12px; padding:${isMobile ? '10px' : '14px'}; margin-bottom:10px;`;
    
    // Get commenter info
    const commenter = comment.isPlayerComment ? 
      { name: 'You', profileImage: null, employmentStatus: 'active' } :
      gameState.employees.find(e => e.id === comment.authorId) || { name: comment.authorName, profileImage: null, employmentStatus: 'unknown' };
    
    const avatarUrl = commenter.profileImage || 'https://placehold.co/40x40?text=' + (commenter.name?.[0] || '?');
    const isAlumni = commenter.employmentStatus === 'alumni';
    const timeAgo = formatTimeAgo(comment.timestamp);
    
    commentEl.innerHTML = `
      <div style="display:flex; gap:${isMobile ? '8px' : '10px'};">
        <img src="${avatarUrl}" style="width:${isMobile ? '28px' : '32px'}; height:${isMobile ? '28px' : '32px'}; border-radius:50%; object-fit:cover; border:2px solid ${isAlumni ? '#666' : comment.isPlayerComment ? '#e94560' : '#00d4ff'}; flex-shrink:0;">
        <div style="flex:1; min-width:0;">
          <div style="display:flex; align-items:center; gap:6px; margin-bottom:4px; flex-wrap:wrap;">
            <strong style="font-size:${isMobile ? '0.8rem' : '0.85rem'}; font-weight:600;">${comment.isPlayerComment ? '<span style="color:#fff;">You</span>' : getColoredName(commenter)}</strong>
            ${comment.isPlayerComment ? `<span style="color:#e94560; font-size:${isMobile ? '0.7rem' : '0.75rem'}; font-weight:600;">@TheBoss</span>` : commenter.social?.username ? `<span style="color:#8899a6; font-size:${isMobile ? '0.7rem' : '0.75rem'};">@${commenter.social.username}</span>` : ''}
            ${isAlumni ? `<span style="background:#555; padding:2px 8px; border-radius:10px; font-size:${isMobile ? '0.6rem' : '0.65rem'}; color:#ccc;">Alumni</span>` : ''}
            <span style="color:#8899a6; font-size:${isMobile ? '0.7rem' : '0.75rem'};">${timeAgo}</span>
          </div>
          <div style="color:#e7e9ea; line-height:1.5; font-size:${isMobile ? '0.85rem' : '0.9rem'}; word-wrap:break-word; overflow-wrap:break-word;">
            ${linkifyMentions(comment.content)}
          </div>
        </div>
      </div>
    `;
    
    return commentEl;
  }
  
  /**
   * Submit a comment from the modal
   */
  function submitModalComment(postId) {
    const input = $('modalCommentInput');
    if (!input) return;
    
    const content = input.value.trim();
    if (!content) return;
    
    // Add comment
    addCommentToPost(postId, content, true);
    
    // Clear input
    input.value = '';
    input.style.height = 'auto';
    
    // Re-render comments
    renderModalComments(postId);
    
    // Update comment count
    const countEl = $('modalCommentCount');
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (countEl && post) {
      countEl.textContent = post.comments.length;
    }
    
    // Update feed to show new comment count
    renderSocialFeed();
  }
  
  // ===== OLD SYSTEM REMOVED FOR CLEAN CODE =====
  
  /**
   * Filter and sort posts based on current settings
   */
  function filterAndSortPosts() {
    let posts = [...gameState.socialNetwork.posts];
    
    // Apply filter
    const filter = gameState.socialNetwork.feedFilter || 'all';
    
    if (filter === 'work') {
      posts = posts.filter(p => p.type === 'work' || p.explicitLevel === 0);
    } else if (filter === 'personal') {
      posts = posts.filter(p => ['text', 'selfie', 'life_update', 'travel'].includes(p.type));
    } else if (filter === 'spicy') {
      posts = posts.filter(p => p.explicitLevel >= 1 && p.explicitLevel <= 2);
    } else if (filter === 'explicit') {
      posts = posts.filter(p => p.explicitLevel >= 3);
    }
    // 'all' shows everything
    
    // Apply sort
    const sort = gameState.socialNetwork.feedSort || 'recent';
    
    if (sort === 'recent') {
      posts.sort((a, b) => b.timestamp - a.timestamp);
    } else if (sort === 'popular') {
      posts.sort((a, b) => b.likes.length - a.likes.length);
    } else if (sort === 'comments') {
      posts.sort((a, b) => b.comments.length - a.comments.length);
    }
    
    return posts;
  }
  
  /**
   * Convert @username mentions to clickable links
   */
  function linkifyMentions(text) {
    if (!text) return '';
    
    // Escape HTML first
    const escaped = escapeHtml(text);
    
    // Replace @username with clickable spans
    return escaped.replace(/@(\w+)/g, (match, username) => {
      // Check if it's @TheBoss (the player)
      if (username.toLowerCase() === 'theboss') {
        return `<span style="color:#e94560; cursor:default; font-weight:700; text-shadow:0 0 8px rgba(233,69,96,0.4);">@TheBoss</span>`;
      }
      
      // Find employee with this username
      const employee = gameState.employees.find(e => e.social?.username === username);
      if (employee) {
        return `<span style="color:#00d4ff; cursor:pointer; font-weight:600; transition:color 0.2s;" onclick="showEmployeeProfile('${employee.id}')" onmouseenter="this.style.color='#fff'; this.style.textDecoration='underline'" onmouseleave="this.style.color='#00d4ff'; this.style.textDecoration='none'">@${username}</span>`;
      }
      // If no employee found, just style it
      return `<span style="color:#00d4ff;">@${username}</span>`;
    });
  }
  
  // ===== OLD createPostElement REMOVED =====
  
  /**
   * Create comment HTML
   */
  function createCommentHTML(comment, postId) {
    const author = gameState.employees.find(e => e.id === comment.authorId) || 
                   { name: comment.authorName, profileImage: null };
    const avatarUrl = author.profileImage || 'https://placehold.co/32x32?text=' + (author.name?.[0] || '?');
    const timeAgo = formatTimeAgo(comment.timestamp);
    const isPlayer = comment.authorId === 'player';
    
    // Reply indicator if this is a reply
    let replyIndicator = '';
    if (comment.replyToCommentId && gameState.socialNetwork?.posts) {
      const replyToComment = gameState.socialNetwork.posts.flatMap(p => p.comments || []).find(c => c.id === comment.replyToCommentId);
      if (replyToComment) {
        replyIndicator = `<div style="color:#8899a6; font-size:0.82rem; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
          <span style="color:#71767b;">↪</span> Replying to <strong style="color:#00d4ff;">@${replyToComment.authorName}</strong>
        </div>`;
      }
    }
    
    return `
      <div class="comment-item" data-comment-id="${comment.id}" style="display:flex; gap:12px; margin-bottom:12px; padding:10px; background:#0d0f12; border-radius:12px; border:1px solid #1a1d23;">
        <img src="${avatarUrl}" style="width:36px; height:36px; border-radius:50%; object-fit:cover; flex-shrink:0; cursor:${isPlayer ? 'default' : 'pointer'};" ${isPlayer ? '' : `onclick="showEmployeeProfile('${comment.authorId}')"`}>
        <div style="flex:1; min-width:0;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; gap:8px;">
            <div style="display:flex; align-items:center; gap:6px;">
              <strong style="font-size:0.88rem; font-weight:600; cursor:${isPlayer ? 'default' : 'pointer'}; transition:opacity 0.2s;" ${isPlayer ? '' : `onclick="showEmployeeProfile('${comment.authorId}')" onmouseenter="this.style.opacity='0.8'" onmouseleave="this.style.opacity='1'"`}>${isPlayer ? '<span style="color:#00d4ff;">You</span>' : getColoredName(author)}</strong>
              ${isPlayer ? `<span style="color:#8899a6; font-size:0.75rem;">@TheBoss</span>` : author.social?.username ? `<span style="color:#8899a6; font-size:0.75rem;">@${author.social.username}</span>` : ''}
            </div>
            <span style="color:#71767b; font-size:0.78rem; white-space:nowrap;">${timeAgo}</span>
          </div>
          ${replyIndicator}
          <p style="color:#e7e9ea; margin:0 0 8px 0; font-size:0.9rem; line-height:1.5; word-wrap:break-word;">${linkifyMentions(comment.content)}</p>
          <button class="reply-to-comment-btn" data-post-id="${postId}" data-comment-id="${comment.id}" data-author-name="${comment.authorName}" data-author-id="${comment.authorId}" data-author-username="${isPlayer ? 'TheBoss' : (author.social?.username || '')}" style="background:transparent; border:none; color:#8899a6; font-size:0.82rem; cursor:pointer; padding:2px 8px; transition:color 0.2s;" onmouseenter="this.style.color='#00d4ff'" onmouseleave="this.style.color='#8899a6'">
            ↪ Reply
          </button>
        </div>
      </div>
    `;
  }
  
  /**
   * Format timestamp to relative time
   */
  function formatTimeAgo(timestamp) {
    const seconds = Math.floor((Date.now() - timestamp) / 1000);
    
    if (seconds < 60) return 'Just now';
    if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
    if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
    if (seconds < 604800) return Math.floor(seconds / 86400) + 'd ago';
    if (seconds < 2592000) return Math.floor(seconds / 604800) + 'w ago';
    return Math.floor(seconds / 2592000) + 'mo ago';
  }
  
  /**
   * Escape HTML to prevent XSS
   */
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  /**
   * Open image viewer (lightbox)
   */
  function openImageViewer(imageUrl) {
    const viewer = document.createElement('div');
    viewer.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:999999; display:flex; justify-content:center; align-items:center; cursor:pointer;';
    viewer.innerHTML = `<img src="${imageUrl}" style="max-width:90%; max-height:90%; border-radius:10px;">`;
    viewer.onclick = () => viewer.remove();
    document.body.appendChild(viewer);
  }
  
  /**
   * Show employee profile modal
   */
  function showEmployeeProfile(employeeId) {
    if (!employeeId || employeeId === 'player') return;
    
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    // Get profile data
    const social = employee.social;
    const avatarUrl = employee.profileImage || `https://placehold.co/120x120?text=${employee.name[0]}`;
    const isAlumni = employee.employmentStatus === 'alumni';
    
    // Get all posts by this employee
    const employeePosts = gameState.socialNetwork.posts.filter(p => p.authorId === employeeId);
    
    // Get mentions of this employee
    const mentions = gameState.socialNetwork.posts.filter(p => {
      if (!social.username) return false;
      return p.content && p.content.includes(`@${social.username}`);
    });
    
    // Get relationships
    const relationships = social.relationships || [];
    
    // Calculate stats
    const stats = {
      posts: employeePosts.length,
      likes: employeePosts.reduce((sum, p) => sum + p.likes.length, 0),
      comments: employeePosts.reduce((sum, p) => sum + p.comments.length, 0),
      mentions: mentions.length,
      followers: gameState.employees.filter(e => 
        e.social?.relationships?.some(r => r.employeeId === employeeId && r.relationshipType !== 'unknown')
      ).length,
      joinDate: social.joinDate ? new Date(social.joinDate).toLocaleDateString() : 'Unknown'
    };
    
    // Create modal
    const modal = document.createElement('div');
    modal.id = 'profileModal';
    // Don't set inline z-index and positioning - ModalManager will handle it
    modal.style.background = 'rgba(0,0,0,0.85)';
    modal.style.padding = '20px';
    modal.style.overflow = 'auto';
    
    modal.innerHTML = `
      <div style="background:#16181c; border:1px solid #2f3336; border-radius:20px; max-width:800px; width:100%; max-height:90vh; overflow:auto; box-shadow:0 8px 32px rgba(0,0,0,0.5);">
        <!-- Close button -->
        <div style="position:sticky; top:0; background:#16181c; padding:16px 20px; border-bottom:1px solid #2f3336; display:flex; justify-content:space-between; align-items:center; z-index:10;">
          <h3 style="color:#fff; margin:0; font-size:1.1rem; font-weight:600;">Profile</h3>
          <button onclick="ModalManager.close('profileModal')" style="background:transparent; border:none; color:#8899a6; cursor:pointer; font-size:1.5rem; padding:4px 10px; border-radius:50%; transition:all 0.2s;" onmouseenter="this.style.background='rgba(255,255,255,0.1)'; this.style.color='#fff'" onmouseleave="this.style.background='transparent'; this.style.color='#8899a6'">×</button>
        </div>
        
        <!-- Profile Header -->
        <div style="padding:24px 20px; border-bottom:1px solid #2f3336;">
          <div style="display:flex; gap:20px; align-items:start; margin-bottom:20px;">
            <img src="${avatarUrl}" style="width:100px; height:100px; border-radius:50%; border:3px solid ${isAlumni ? '#666' : '#00d4ff'}; object-fit:cover;">
            <div style="flex:1;">
              <div style="display:flex; align-items:center; gap:10px; margin-bottom:8px;">
                <h2 style="margin:0; font-size:1.5rem; font-weight:600;">${getColoredName(employee)}</h2>
                ${isAlumni ? '<span style="background:#555; padding:4px 12px; border-radius:14px; font-size:0.75rem; color:#ccc; font-weight:600;">Alumni</span>' : ''}
              </div>
              ${social.username ? `<div style="color:#8899a6; font-size:1rem; margin-bottom:12px;">@${social.username}</div>` : ''}
              ${social.bio ? `<p style="color:#e7e9ea; margin:0 0 12px 0; line-height:1.5;">${social.bio}</p>` : ''}
              
              <!-- Stats -->
              <div style="display:flex; gap:24px; margin-top:16px;">
                <div style="text-align:center;">
                  <div style="color:#fff; font-weight:700; font-size:1.2rem;">${stats.posts}</div>
                  <div style="color:#8899a6; font-size:0.8rem;">Posts</div>
                </div>
                <div style="text-align:center;">
                  <div style="color:#e94560; font-weight:700; font-size:1.2rem;">${stats.likes}</div>
                  <div style="color:#8899a6; font-size:0.8rem;">Likes</div>
                </div>
                <div style="text-align:center;">
                  <div style="color:#00d4ff; font-weight:700; font-size:1.2rem;">${stats.mentions}</div>
                  <div style="color:#8899a6; font-size:0.8rem;">Mentions</div>
                </div>
                <div style="text-align:center;">
                  <div style="color:#fff; font-weight:700; font-size:1.2rem;">${stats.followers}</div>
                  <div style="color:#8899a6; font-size:0.8rem;">Connections</div>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Tabs -->
        <div style="display:flex; border-bottom:1px solid #2f3336; background:#0d0f12;">
          <button class="profile-tab" data-tab="posts" style="flex:1; padding:16px; background:transparent; border:none; color:#8899a6; cursor:pointer; font-weight:600; border-bottom:3px solid transparent; transition:all 0.2s;">
            📝 Their Posts (${stats.posts})
          </button>
          <button class="profile-tab" data-tab="mentions" style="flex:1; padding:16px; background:transparent; border:none; color:#8899a6; cursor:pointer; font-weight:600; border-bottom:3px solid transparent; transition:all 0.2s;">
            @ Mentions (${stats.mentions})
          </button>
          <button class="profile-tab" data-tab="friends" style="flex:1; padding:16px; background:transparent; border:none; color:#8899a6; cursor:pointer; font-weight:600; border-bottom:3px solid transparent; transition:all 0.2s;">
            ❤️ Friends (${stats.followers})
          </button>
          <button class="profile-tab" data-tab="about" style="flex:1; padding:16px; background:transparent; border:none; color:#8899a6; cursor:pointer; font-weight:600; border-bottom:3px solid transparent; transition:all 0.2s;">
            ℹ️ About
          </button>
        </div>
        
        <!-- Tab Content -->
        <div id="profileTabContent" style="padding:20px; min-height:300px; max-height:500px; overflow-y:auto;">
          <!-- Content will be loaded here -->
        </div>
      </div>
    `;
    
    // Use ModalManager to show the modal
    ModalManager.show(modal, 'profileModal');
    
    // Close on background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) ModalManager.close('profileModal');
    });
    
    // Tab switching
    const tabs = modal.querySelectorAll('.profile-tab');
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // Update tab styles
        tabs.forEach(t => {
          t.style.color = '#8899a6';
          t.style.borderBottomColor = 'transparent';
          t.style.background = 'transparent';
        });
        tab.style.color = '#00d4ff';
        tab.style.borderBottomColor = '#00d4ff';
        tab.style.background = 'rgba(0, 212, 255, 0.05)';
        
        // Load tab content
        loadProfileTab(tab.dataset.tab, employeeId, modal);
      });
      
      // Hover effects
      tab.addEventListener('mouseenter', () => {
        if (tab.style.color !== 'rgb(0, 212, 255)') {
          tab.style.background = 'rgba(255,255,255,0.05)';
        }
      });
      tab.addEventListener('mouseleave', () => {
        if (tab.style.color !== 'rgb(0, 212, 255)') {
          tab.style.background = 'transparent';
        }
      });
    });
    
    // Load first tab by default
    tabs[0].click();
  }
  
  /**
   * Load profile tab content
   */
  function loadProfileTab(tab, employeeId, modal) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    const contentDiv = modal.querySelector('#profileTabContent');
    if (!contentDiv) return;
    
    const social = employee.social;
    
    if (tab === 'posts') {
      // Show all posts by this employee
      const employeePosts = gameState.socialNetwork.posts
        .filter(p => p.authorId === employeeId)
        .sort((a, b) => b.timestamp - a.timestamp);
      
      if (employeePosts.length === 0) {
        contentDiv.innerHTML = `
          <div style="text-align:center; padding:60px 20px; color:#8899a6;">
            <div style="font-size:3rem; margin-bottom:12px;">📭</div>
            <div style="font-size:1.1rem; margin-bottom:6px;">No posts yet</div>
            <div style="font-size:0.9rem; opacity:0.7;">This user hasn't posted anything yet</div>
          </div>
        `;
      } else {
        contentDiv.innerHTML = employeePosts.map(post => {
          const timeAgo = formatTimeAgo(post.timestamp);
          return `
            <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:16px; margin-bottom:12px;">
              <div style="color:#8899a6; font-size:0.8rem; margin-bottom:10px;">${timeAgo}</div>
              ${post.content ? `<p style="color:#e7e9ea; margin:0 0 10px 0; line-height:1.6; white-space:pre-wrap;">${linkifyMentions(post.content)}</p>` : ''}
              ${post.imageUrl ? `<img src="${post.imageUrl}" style="width:100%; border-radius:8px; margin-top:10px; object-fit:contain; max-height:400px; background:#000; cursor:pointer;" onclick="openImageViewer('${post.imageUrl}')">` : ''}
              <div style="display:flex; gap:20px; margin-top:12px; padding-top:12px; border-top:1px solid rgba(255,255,255,0.05); font-size:0.85rem;">
                <span style="color:#e94560;">❤️ ${post.likes.length}</span>
                <span style="color:#00d4ff;">💬 ${post.comments.length}</span>
              </div>
            </div>
          `;
        }).join('');
      }
      
    } else if (tab === 'mentions') {
      // Show posts where employee is mentioned
      const mentions = gameState.socialNetwork.posts
        .filter(p => p.content && social.username && p.content.includes(`@${social.username}`))
        .sort((a, b) => b.timestamp - a.timestamp);
      
      if (mentions.length === 0) {
        contentDiv.innerHTML = `
          <div style="text-align:center; padding:60px 20px; color:#8899a6;">
            <div style="font-size:3rem; margin-bottom:12px;">@</div>
            <div style="font-size:1.1rem; margin-bottom:6px;">No mentions yet</div>
            <div style="font-size:0.9rem; opacity:0.7;">Nobody has mentioned this user yet</div>
          </div>
        `;
      } else {
        contentDiv.innerHTML = mentions.map(post => {
          const author = gameState.employees.find(e => e.id === post.authorId) || { name: post.authorName };
          const timeAgo = formatTimeAgo(post.timestamp);
          // Use linkifyMentions to make all mentions clickable, including the highlighted one
          const linkedContent = linkifyMentions(post.content);
          
          return `
            <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:16px; margin-bottom:12px;">
              <div style="display:flex; align-items:center; gap:10px; margin-bottom:10px;">
                <strong style="color:#fff; font-size:0.9rem; cursor:pointer; transition:color 0.2s;" onclick="showEmployeeProfile('${author.id}')" onmouseenter="this.style.color='#00d4ff'" onmouseleave="this.style.color='#fff'">${author.name}</strong>
                ${author.social?.username ? `<span style="color:#8899a6; font-size:0.8rem; cursor:pointer;" onclick="showEmployeeProfile('${author.id}')" onmouseenter="this.style.color='#00d4ff'" onmouseleave="this.style.color='#8899a6'">@${author.social.username}</span>` : ''}
                <span style="color:#8899a6; font-size:0.75rem; margin-left:auto;">${timeAgo}</span>
              </div>
              <p style="color:#e7e9ea; margin:0; line-height:1.6; white-space:pre-wrap;">${linkedContent}</p>
              ${post.imageUrl ? `<img src="${post.imageUrl}" style="width:100%; border-radius:8px; margin-top:10px; object-fit:contain; max-height:300px; background:#000; cursor:pointer;" onclick="openImageViewer('${post.imageUrl}')">` : ''}
            </div>
          `;
        }).join('');
      }
      
    } else if (tab === 'friends') {
      // Show relationships
      const relationships = social.relationships || [];
      const meaningfulRelationships = relationships.filter(r => r.relationshipType !== 'unknown' && r.relationshipType !== 'stranger');
      
      if (meaningfulRelationships.length === 0) {
        contentDiv.innerHTML = `
          <div style="text-align:center; padding:60px 20px; color:#8899a6;">
            <div style="font-size:3rem; margin-bottom:12px;">👥</div>
            <div style="font-size:1.1rem; margin-bottom:6px;">No close relationships yet</div>
            <div style="font-size:0.9rem; opacity:0.7;">This user hasn't formed any close bonds</div>
          </div>
        `;
      } else {
        contentDiv.innerHTML = meaningfulRelationships.map(rel => {
          const relEmployee = gameState.employees.find(e => e.id === rel.employeeId);
          if (!relEmployee) return '';
          
          const relAvatar = relEmployee.profileImage || `https://placehold.co/50x50?text=${relEmployee.name[0]}`;
          const relationshipIcons = {
            'best_friend': '💙',
            'friend': '💚',
            'crush': '💗',
            'close_friend': '💛',
            'rival': '⚔️',
            'acquaintance': '👋'
          };
          const icon = relationshipIcons[rel.relationshipType] || '👤';
          const relationshipNames = {
            'best_friend': 'Best Friend',
            'friend': 'Friend',
            'crush': 'Crush',
            'close_friend': 'Close Friend',
            'rival': 'Rival',
            'acquaintance': 'Acquaintance'
          };
          const relationshipName = relationshipNames[rel.relationshipType] || rel.relationshipType;
          
          return `
            <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:16px; margin-bottom:12px; display:flex; align-items:center; gap:14px; cursor:pointer; transition:all 0.2s;" onclick="showEmployeeProfile('${relEmployee.id}')" onmouseenter="this.style.background='#16181c'; this.style.borderColor='#00d4ff'" onmouseleave="this.style.background='#0d0f12'; this.style.borderColor='#2f3336'">
              <img src="${relAvatar}" style="width:50px; height:50px; border-radius:50%; object-fit:cover; border:2px solid #00d4ff;">
              <div style="flex:1;">
                <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
                  <strong style="font-size:0.95rem;">${getColoredName(relEmployee)}</strong>
                  ${relEmployee.social?.username ? `<span style="color:#8899a6; font-size:0.8rem;">@${relEmployee.social.username}</span>` : ''}
                </div>
                <div style="color:#00d4ff; font-size:0.85rem;">${icon} ${relationshipName}</div>
              </div>
            </div>
          `;
        }).join('');
      }
      
    } else if (tab === 'about') {
      // Show employee details
      const joinDate = social.joinDate ? new Date(social.joinDate).toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
      }) : 'Unknown';
      
      const personality = employee.personality || {};
      const appearance = employee.appearance || {};
      
      contentDiv.innerHTML = `
        <div style="display:grid; gap:20px;">
          <!-- Basic Info -->
          <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:20px;">
            <h4 style="color:#00d4ff; margin:0 0 16px 0; font-size:1rem; font-weight:600;">Basic Info</h4>
            <div style="display:grid; gap:10px;">
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Full Name:</span>
                <span style="font-weight:500;">${getColoredName(employee)}</span>
              </div>
              ${social.username ? `
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Username:</span>
                <span style="color:#00d4ff; font-weight:500;">@${social.username}</span>
              </div>
              ` : ''}
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Joined:</span>
                <span style="color:#e7e9ea; font-weight:500;">${joinDate}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Status:</span>
                <span style="color:${employee.employmentStatus === 'alumni' ? '#999' : '#0f0'}; font-weight:600;">${employee.employmentStatus === 'alumni' ? 'Alumni' : 'Active'}</span>
              </div>
            </div>
          </div>
          
          <!-- Personality -->
          ${personality.traits && personality.traits.length > 0 ? `
          <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:20px;">
            <h4 style="color:#00d4ff; margin:0 0 16px 0; font-size:1rem; font-weight:600;">Personality</h4>
            <div style="display:flex; flex-wrap:wrap; gap:8px;">
              ${personality.traits.map(trait => `
                <span style="background:rgba(0,212,255,0.1); color:#00d4ff; padding:6px 14px; border-radius:16px; font-size:0.85rem; border:1px solid rgba(0,212,255,0.2);">${trait}</span>
              `).join('')}
            </div>
          </div>
          ` : ''}
          
          <!-- Appearance -->
          ${appearance.hairColor || appearance.eyeColor ? `
          <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:20px;">
            <h4 style="color:#00d4ff; margin:0 0 16px 0; font-size:1rem; font-weight:600;">Appearance</h4>
            <div style="display:grid; gap:10px;">
              ${appearance.hairColor ? `
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Hair:</span>
                <span style="color:#e7e9ea; font-weight:500;">${appearance.hairColor}</span>
              </div>
              ` : ''}
              ${appearance.eyeColor ? `
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Eyes:</span>
                <span style="color:#e7e9ea; font-weight:500;">${appearance.eyeColor}</span>
              </div>
              ` : ''}
            </div>
          </div>
          ` : ''}
          
          <!-- Social Stats -->
          <div style="background:#0d0f12; border:1px solid #2f3336; border-radius:12px; padding:20px;">
            <h4 style="color:#00d4ff; margin:0 0 16px 0; font-size:1rem; font-weight:600;">Social Activity</h4>
            <div style="display:grid; gap:10px;">
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Total Posts:</span>
                <span style="color:#e7e9ea; font-weight:600;">${social.postCount || 0}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Likes Received:</span>
                <span style="color:#e94560; font-weight:600;">${social.totalLikesReceived || 0}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Comments Received:</span>
                <span style="color:#00d4ff; font-weight:600;">${social.totalCommentsReceived || 0}</span>
              </div>
              <div style="display:flex; justify-content:space-between;">
                <span style="color:#8899a6;">Times Mentioned:</span>
                <span style="color:#00d4ff; font-weight:600;">${social.totalMentions || 0}</span>
              </div>
            </div>
          </div>
        </div>
      `;
    }
  }
  
  
  /**
   * Handle like button click
   */
  function handleLikePost(postId) {
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) return;
    
    const playerIndex = post.likes.indexOf('player');
    
    if (playerIndex >= 0) {
      // Unlike
      post.likes.splice(playerIndex, 1);
    } else {
      // Like
      post.likes.push('player');
    }
    
    // Smart update: only update this specific post
    requestSmartFeedUpdate(postId);
  }
  
  // ===== OLD toggleComments REMOVED =====
  
  /**
   * Add comment to post
   */
  async function addCommentToPost(postId, commentText, replyToCommentId = null) {
    if (!commentText.trim()) return;
    
    const post = gameState.socialNetwork.posts.find(p => p.id === postId);
    if (!post) return;
    
    // Extract mentions from comment
    const mentionObjects = extractMentions(commentText);
    const mentionedEmployeeIds = mentionObjects.map(m => m.employeeId);
    
    console.log(`[Social] Comment mentions: ${JSON.stringify(mentionObjects)}`);
    
    const comment = createComment({
      postId,
      authorId: 'player',
      authorName: 'You',
      content: commentText.trim(),
      replyToCommentId: replyToCommentId,
      mentionedEmployees: mentionedEmployeeIds
    });
    
    post.comments.push(comment);
    
    console.log(`[Comments] Player added comment to post ${postId}. Total comments: ${post.comments.length}`);
    
    // Track mentions
    mentionedEmployeeIds.forEach(employeeId => {
      trackPlayerMention(employeeId);
    });
    
    // Trigger responses from mentioned NPCs (high likelihood)
    if (mentionedEmployeeIds.length > 0) {
      console.log(`[Social] Scheduling mention responses for: ${mentionedEmployeeIds.join(', ')}`);
      setTimeout(async () => {
        await triggerCommentMentionResponse(comment, post);
      }, 2000 + Math.random() * 3000); // 2-5 second delay
    }
    
    // NEW: Trigger NPC reply if player commented on NPC post
    if (!post.isPlayerPost && post.authorId && mentionedEmployeeIds.length === 0) {
      // Only do this if no mentions (mentions get their own response)
      // Delay reply slightly for realism
      setTimeout(async () => {
        await generateNPCCommentReply(post, comment);
      }, 2000 + Math.random() * 3000); // 2-5 second delay
    }
  }
  
  /**
   * Generate NPC reply to player's comment
   */
  async function generateNPCCommentReply(post, playerComment) {
    const npc = gameState.employees.find(e => e.id === post.authorId);
    if (!npc) return;
    
    // Don't reply if NPC is alumni or certain chance
    if (npc.employmentStatus === 'alumni') return;
    if (Math.random() > 0.7) return; // 70% chance to reply
    
    try {
      // Build context for the reply
      const relationship = npc.relationships?.player || { level: 0, type: 'professional' };
      const intimacy = npc.intimacy || 0;
      
      // Get personality context
      const personality = npc.personality || {};
      const flirty = personality.flirty || 50;
      const confidence = personality.confidence || 50;
      const humor = personality.humor || 50;
      
      // Determine tone based on relationship and comment
      let tone = 'friendly';
      const commentLower = playerComment.content.toLowerCase();
      
      if (intimacy > 60 || relationship.level > 60) {
        tone = 'warm';
      }
      if (intimacy > 80) {
        tone = 'flirty';
      }
      if (commentLower.includes('love') || commentLower.includes('beautiful') || commentLower.includes('gorgeous')) {
        tone = flirty > 60 ? 'flirty' : 'appreciative';
      }
      if (commentLower.includes('lol') || commentLower.includes('haha') || commentLower.includes('😂')) {
        tone = 'playful';
      }
      
      // Build prompt for AI
      const prompt = `You are ${npc.name}, an employee at the company. The boss (@TheBoss) just commented on your social media post.

YOUR POST:
Type: ${post.type}
Content: "${post.content || ''}"
${post.imageAlt ? `Image: ${post.imageAlt}` : ''}

BOSS'S COMMENT:
"${playerComment.content}"

YOUR PERSONALITY:
- Confidence: ${confidence}/100
- Flirtiness: ${flirty}/100  
- Humor: ${humor}/100
${npc.hobbies ? `- Hobbies: ${npc.hobbies.join(', ')}` : ''}

YOUR RELATIONSHIP WITH BOSS:
- Intimacy level: ${intimacy}/100
- Relationship type: ${relationship.type || 'professional'}
- Relationship strength: ${relationship.level || 0}/100

INSTRUCTIONS:
Reply to the boss's comment in a natural, brief way (max 100 characters). Your tone should be ${tone}.

${tone === 'flirty' ? '- Be subtly flirty and playful' : ''}
${tone === 'warm' ? '- Be warm and friendly, show closeness' : ''}
${tone === 'appreciative' ? '- Show appreciation for the compliment' : ''}
${tone === 'playful' ? '- Match their playful energy' : ''}
${intimacy > 50 ? '- You can use emojis and be more casual' : '- Keep it professional but friendly'}
${confidence > 70 ? '- Show confidence in your response' : ''}
${humor > 70 ? '- Feel free to add humor' : ''}

DO NOT:
- Use quotation marks around your reply
- Write "I would reply" or similar meta-commentary
- Be overly formal unless that matches your personality
- Exceed 100 characters

Just write the reply comment directly:`;

      // Generate reply
      const rawReply = await generateText(prompt);
      
      // Sanitize consistently with other comment systems
      let reply = rawReply.trim()
        .replace(/^["']|["']$/g, '') // Remove quotes
        .replace(/\s*\([^)]*personality[^)]*\)\.?$/i, '') // Remove personality notes
        .replace(/^(I would (say|reply|comment):|My comment would be:)\s*/i, ''); // Remove meta-text
      
      // Truncate if too long (instead of rejecting entirely)
      if (reply.length > 150) {
        reply = reply.substring(0, 147) + '...';
      }
      
      if (!reply || reply.length === 0) return; // Safety check
      
      // Create the NPC's reply comment
      const npcComment = createComment({
        postId: post.id,
        authorId: npc.id,
        authorName: npc.name,
        content: reply.trim()
      });
      
      post.comments.push(npcComment);
      
      console.log(`[Comments] ${npc.name} replied to player comment on post ${post.id}. Total comments: ${post.comments.length}`);
      
      // 🌐 Evaluate NPC's reaction to player's comment on their post
      evaluateNPCReactionToPost(npc, gameState.player, post, reply);
      
      // Store in memory
      remember(npc, `Boss commented "${playerComment.content}" on my post, I replied "${reply}"`, 'interaction', 2);
      
      // CRITICAL FIX: Immediate update of comments section
      const postEl = document.querySelector(`[data-post-id="${post.id}"]`);
      const commentsSection = document.querySelector(`.post-comments[data-post-id="${post.id}"]`);
      
      if (postEl && commentsSection) {
        console.log(`[Comments] Immediately updating comments section after NPC reply`);
        
        // Ensure comments section is visible
        commentsSection.style.display = 'block';
        
        // Update comments content immediately
        updateCommentsSection(postEl, post);
        
        // Clear any pending refresh flags
        delete commentsSection.dataset.needsRefresh;
      }
      
      // Also request smart feed update as backup
      requestSmartFeedUpdate(post.id);
      
    } catch (error) {
      console.error('Error generating NPC comment reply:', error);
    }
  }
  
  /**
   * Trigger responses from NPCs mentioned in a comment
   */
  async function triggerCommentMentionResponse(comment, post) {
    if (!comment || !post) {
      console.log('[Social] triggerCommentMentionResponse called with missing comment or post');
      return;
    }
    
    const mentionedIds = comment.mentionedEmployees || [];
    if (mentionedIds.length === 0) {
      console.log('[Social] No mentioned employees in comment');
      return;
    }
    
    console.log(`[Social] Comment mentions ${mentionedIds.length} NPCs - triggering responses`);
    console.log('[Social] Mentioned IDs:', mentionedIds);
    
    for (const employeeId of mentionedIds) {
      console.log(`[Social] Processing mention for employee ID: ${employeeId}`);
      
      const npc = gameState.employees.find(e => e.id === employeeId);
      if (!npc) {
        console.log(`[Social] ✗ Employee ${employeeId} not found`);
        continue;
      }
      if (npc.employmentStatus !== 'active') {
        console.log(`[Social] ✗ ${npc.name} not active (status: ${npc.employmentStatus})`);
        continue;
      }
      
      console.log(`[Social] ✓ Found active employee: ${npc.name}`);
      
      // 90-95% chance to respond when mentioned directly
      const responseChance = 0.90 + Math.random() * 0.05;
      const roll = Math.random();
      console.log(`[Social] ${npc.name} roll: ${roll.toFixed(3)} vs ${responseChance.toFixed(3)}`);
      
      if (roll > responseChance) {
        console.log(`[Social] ${npc.name} chose not to respond (${((1-responseChance)*100).toFixed(1)}% chance)`);
        continue;
      }
      
      console.log(`[Social] ✓ ${npc.name} will respond to mention!`);
      
      try {
        // Get full context: post content, all comments, chat history
        const intimacy = npc.intimacy || 0;
        const relationship = npc.relationships?.player || { level: 0, type: 'professional' };
        const personality = npc.personalityTraits || {};
        const flirty = personality.flirty || 50;
        const confidence = personality.confidence || 50;
        const humor = personality.humor || 50;
        
        // Build conversation context from all comments
        const allComments = post.comments.map(c => {
          return `${c.authorName}: "${c.content}"`;
        }).join('\n');
        
        // Determine tone
        let tone = 'friendly';
        const commentLower = comment.content.toLowerCase();
        if (intimacy > 60 || relationship.level > 60) tone = 'warm';
        if (intimacy > 80) tone = 'flirty';
        if (commentLower.includes('love') || commentLower.includes('beautiful') || commentLower.includes('gorgeous')) {
          tone = flirty > 60 ? 'flirty' : 'appreciative';
        }
        if (commentLower.includes('lol') || commentLower.includes('haha') || commentLower.includes('😂')) {
          tone = 'playful';
        }
        
        // Detect existing comment patterns to avoid repetition
        const existingPatterns = [];
        post.comments.forEach(c => {
          const lower = c.content.toLowerCase();
          if (/\?\s*(girl|dude|bro|man)/i.test(c.content)) existingPatterns.push('question + nickname');
          if (/still\s+(love|like|here|blooming)/i.test(c.content)) existingPatterns.push('"still" continuation');
          if (/you\s+(forgot|watered|planted|remember)/i.test(c.content)) existingPatterns.push('direct "you" callback');
          if (/😂|😅|💀/i.test(c.content)) existingPatterns.push('multiple laughing emojis');
          if (/tho|though$/i.test(c.content)) existingPatterns.push('ending with "tho/though"');
        });
        
        const diversityNote = existingPatterns.length > 0
          ? `\n\n⚠️ OTHER COMMENTS USED THESE PATTERNS - BE DIFFERENT:\n${[...new Set(existingPatterns)].map(p => `- ${p}`).join('\n')}\nUse a completely DIFFERENT approach/structure!`
          : '';
        
        // Build prompt with FULL context
        const prompt = `You are ${npc.name}, an employee at the company. You're viewing a social media post and someone (@TheBoss, the boss) mentioned you in a comment.

ORIGINAL POST:
Author: ${post.authorName}
Type: ${post.type}
Content: "${post.content || ''}"
${post.imageAlt ? `Image: ${post.imageAlt}` : ''}

ALL COMMENTS SO FAR:
${allComments}

BOSS JUST MENTIONED YOU:
"${comment.content}"

YOUR PERSONALITY:
- Confidence: ${confidence}/100
- Flirtiness: ${flirty}/100  
- Humor: ${humor}/100
${npc.hobbies ? `- Hobbies: ${npc.hobbies.join(', ')}` : ''}

YOUR RELATIONSHIP WITH BOSS:
- Intimacy level: ${intimacy}/100
- Relationship type: ${relationship.type || 'professional'}
- Relationship strength: ${relationship.level || 0}/100
${diversityNote}

INSTRUCTIONS:
Reply to being mentioned in a natural, brief way (max 120 characters). Your tone should be ${tone}.
${diversityNote ? 'IMPORTANT: Be ORIGINAL - use a different joke structure/phrasing than existing comments!' : ''}

${tone === 'flirty' ? '- Be subtly flirty and playful' : ''}
${tone === 'warm' ? '- Be warm and friendly, show closeness' : ''}
${tone === 'appreciative' ? '- Show appreciation for the mention' : ''}
${tone === 'playful' ? '- Match their playful energy' : ''}
- React to the full context of the conversation, not just the mention
- You can reference the original post if relevant
${intimacy > 50 ? '- Use emojis and be casual' : '- Keep it professional but friendly'}
${confidence > 70 ? '- Show confidence' : ''}
${humor > 70 ? '- Add humor if appropriate' : ''}

DO NOT:
- Use quotation marks around your reply
- Write "I would reply" or similar
- Be overly formal unless that matches your personality
- Exceed 120 characters
- Copy the structure of existing comments

Just write the reply comment directly:`;

        // Generate response with Perchance AI
        console.log(`[Social] Calling generateText for ${npc.name}'s mention response...`);
        console.log(`[Social] Prompt length: ${prompt.length} characters`);
        
        const rawResponse = await generateText(prompt);
        console.log(`[Social] Raw AI response for ${npc.name}: "${rawResponse}"`);
        
        // Sanitize response - remove quotes, extra whitespace, meta-commentary
        let response = rawResponse.trim();
        
        // Remove surrounding quotes
        response = response.replace(/^["']|["']$/g, '');
        
        // Remove meta-commentary in parentheses at the end
        response = response.replace(/\s*\([^)]*personality[^)]*\)\.?$/i, '');
        response = response.replace(/\s*\([^)]*\d+\/100[^)]*\)\.?$/i, '');
        
        // Remove "I would say" or similar meta phrases
        response = response.replace(/^(I would (say|reply|respond|comment):|My response would be:)\s*/i, '');
        
        // Truncate to 120 chars if needed
        if (response.length > 120) {
          response = response.substring(0, 117) + '...';
        }
        
        response = response.trim();
        console.log(`[Social] Sanitized response for ${npc.name}: "${response}"`);
        
        if (response && response.length > 0) {
          console.log(`[Social] Creating comment object for ${npc.name}...`);
          
          const npcComment = createComment({
            postId: post.id,
            authorId: npc.id,
            authorName: npc.name,
            content: response,
            replyToCommentId: comment.id // Mark as reply to the mentioning comment
          });
          
          console.log(`[Social] Comment object created:`, npcComment);
          console.log(`[Social] Adding comment to post (current comment count: ${post.comments.length})`);
          
          post.comments.push(npcComment);
          
          console.log(`[Social] ✓ ${npc.name} responded to mention: "${response}"`);
          console.log(`[Social] New comment count: ${post.comments.length}`);
          
          // 🌐 Evaluate relationship between mentioned NPC and the commenter who mentioned them
          const originalCommenter = gameState.employees.find(e => e.id === comment.authorId);
          if (originalCommenter && originalCommenter.id !== npc.id) {
            evaluateNPCReactionToPost(npc, originalCommenter, post, response);
          }
          
          // CRITICAL FIX: Immediate update of comments section
          const postEl = document.querySelector(`[data-post-id="${post.id}"]`);
          const commentsSection = document.querySelector(`.post-comments[data-post-id="${post.id}"]`);
          
          if (postEl && commentsSection) {
            console.log(`[Social] Immediately updating comments section after mention response`);
            commentsSection.style.display = 'block';
            updateCommentsSection(postEl, post);
            delete commentsSection.dataset.needsRefresh;
          }
          
          // Also request smart feed update as backup
          console.log(`[Social] Requesting smart update for post ${post.id}...`);
          requestSmartFeedUpdate(post.id);
          
          // CHAIN REACTION: Trigger potential follow-up responses from other NPCs
          setTimeout(async () => {
            await triggerCommentChainReaction(npcComment, post);
          }, 3000 + Math.random() * 4000); // 3-7 seconds later
          
        } else {
          console.log(`[Social] ✗ ${npc.name} got empty response after sanitization`);
        }
        
      } catch (error) {
        console.error(`[Social] ✗ Error generating mention response for ${npc.name}:`, error);
      }
      
      // Stagger responses for realism
      await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
    }
  }
  
  /**
   * CHAIN REACTION: NPCs respond to other NPCs' comments, creating drama and conversation threads
   */
  async function triggerCommentChainReaction(triggerComment, post) {
    if (!triggerComment || !post) return;
    
    // Don't chain if the original comment was from the player
    if (triggerComment.authorId === 'player') return;
    
    const triggerNPC = gameState.employees.find(e => e.id === triggerComment.authorId);
    if (!triggerNPC) return;
    
    console.log(`[Chain] 🔗 Checking for chain reactions to ${triggerNPC.name}'s comment...`);
    
    // Find potential responders
    const activeEmployees = gameState.employees.filter(e => 
      e.employmentStatus === 'active' && 
      e.id !== triggerComment.authorId // Don't respond to yourself
    );
    
    if (activeEmployees.length === 0) return;
    
    // Prioritize certain NPCs for drama:
    // 1. The original post author (if NPC)
    // 2. NPCs mentioned in the trigger comment
    // 3. NPCs with strong relationships to trigger NPC
    // 4. Random other NPCs (low chance)
    
    let potentialResponders = [];
    
    // 1. Original post author - 60% chance to respond if someone comments on their post
    if (post.authorId && post.authorId !== 'player' && post.authorId !== triggerComment.authorId) {
      const postAuthor = activeEmployees.find(e => e.id === post.authorId);
      if (postAuthor && Math.random() < 0.6) {
        potentialResponders.push({ npc: postAuthor, reason: 'post author', priority: 1 });
        console.log(`[Chain] 📝 Post author ${postAuthor.name} might respond (60% chance)`);
      }
    }
    
    // 2. NPCs mentioned in the comment - 70% chance
    if (triggerComment.mentionedEmployees && triggerComment.mentionedEmployees.length > 0) {
      for (const mentionedId of triggerComment.mentionedEmployees) {
        const mentioned = activeEmployees.find(e => e.id === mentionedId);
        if (mentioned && Math.random() < 0.7) {
          potentialResponders.push({ npc: mentioned, reason: 'mentioned', priority: 1 });
          console.log(`[Chain] 👋 ${mentioned.name} was mentioned - might respond (70% chance)`);
        }
      }
    }
    
    // 3. NPCs with relationships to trigger NPC - 40% chance for close friends
    const relationships = triggerNPC.relationships || {};
    for (const [empId, rel] of Object.entries(relationships)) {
      const relatedNPC = activeEmployees.find(e => e.id === empId);
      if (relatedNPC && !potentialResponders.find(p => p.npc.id === empId)) {
        const relStrength = rel.strength || 0;
        if (relStrength > 60 && Math.random() < 0.4) {
          potentialResponders.push({ npc: relatedNPC, reason: `friend (${relStrength}/100)`, priority: 2 });
          console.log(`[Chain] 💕 ${relatedNPC.name} is friends with ${triggerNPC.name} - might chime in`);
        }
      }
    }
    
    // 4. Random other NPCs - 20% chance for general workplace banter
    const randomPool = activeEmployees.filter(e => !potentialResponders.find(p => p.npc.id === e.id));
    if (randomPool.length > 0 && Math.random() < 0.2) {
      const random = randomPool[Math.floor(Math.random() * randomPool.length)];
      potentialResponders.push({ npc: random, reason: 'random observer', priority: 3 });
      console.log(`[Chain] 👀 ${random.name} randomly noticed this thread`);
    }
    
    // Limit to 1-2 responders to avoid spam
    potentialResponders.sort((a, b) => a.priority - b.priority);
    potentialResponders = potentialResponders.slice(0, Math.random() < 0.3 ? 2 : 1);
    
    if (potentialResponders.length === 0) {
      console.log(`[Chain] 🚫 No chain reactions triggered`);
      return;
    }
    
    console.log(`[Chain] ✓ ${potentialResponders.length} NPC(s) will respond`);
    
    // Generate responses
    for (const { npc, reason } of potentialResponders) {
      try {
        console.log(`[Chain] 💬 ${npc.name} responding (${reason})...`);
        
        // Build context
        const allComments = post.comments.map(c => {
          const prefix = c.replyToCommentId ? '  ↪ ' : '';
          return `${prefix}${c.authorName}: "${c.content}"`;
        }).join('\n');
        
        const personality = npc.personality || {};
        const relationship = npc.relationships?.[triggerComment.authorId] || { strength: 50, type: 'colleague' };
        
        // Determine tone based on relationship and context
        let tone = 'casual';
        const commentLower = triggerComment.content.toLowerCase();
        
        if (relationship.strength > 70) tone = 'friendly';
        if (relationship.strength < 30) tone = 'snarky';
        if (reason === 'post author') tone = 'engaged'; // It's their post
        if (commentLower.includes('lol') || commentLower.includes('😂')) tone = 'playful';
        if (commentLower.includes('?')) tone = 'helpful'; // Answering a question
        
        // TAGGING: Build list of people this NPC could tag
        let tagContext = '';
        const otherNPCs = activeEmployees.filter(e => e.id !== npc.id);
        
        if (otherNPCs.length > 0 && Math.random() < 0.35) { // 35% chance to suggest tagging
          // Prioritize: trigger comment author, post author, friends
          let taggable = [];
          
          if (triggerNPC.id !== npc.id) {
            taggable.push({ emp: triggerNPC, rel: 'commenter' });
          }
          if (post.authorId && post.authorId !== 'player' && post.authorId !== npc.id && post.authorId !== triggerNPC.id) {
            const postAuth = otherNPCs.find(e => e.id === post.authorId);
            if (postAuth) taggable.push({ emp: postAuth, rel: 'post author' });
          }
          
          // Add 1 friend if available
          const npcRels = npc.relationships || {};
          const friend = otherNPCs.find(e => {
            const rel = npcRels[e.id];
            return rel && rel.strength > 65 && !taggable.find(t => t.emp.id === e.id);
          });
          if (friend) taggable.push({ emp: friend, rel: 'friend' });
          
          if (taggable.length > 0) {
            tagContext = `\n\nOPTIONAL TAGS (use if natural): `;
            taggable.forEach(({ emp, rel }) => {
              tagContext += `@${emp.social?.username || emp.name.toLowerCase().replace(/\s+/g, '')} (${emp.name} - ${rel}), `;
            });
            tagContext = tagContext.slice(0, -2); // Remove trailing comma
          }
        }
        
        // Detect if other comments used similar patterns (avoid repetition)
        const existingPatterns = [];
        post.comments.forEach(c => {
          const lower = c.content.toLowerCase();
          // Detect common patterns
          if (/\?\s*(girl|dude|bro|man)/i.test(c.content)) existingPatterns.push('question + nickname');
          if (/still\s+(love|like|here|blooming)/i.test(c.content)) existingPatterns.push('"still" continuation');
          if (/you\s+(forgot|watered|planted)/i.test(c.content)) existingPatterns.push('direct "you" callback');
          if (/😂|😅|💀|lol|lmao/i.test(c.content)) existingPatterns.push('laughing response');
        });
        
        const diversityNote = existingPatterns.length > 0 
          ? `\n\n⚠️ AVOID THESE PATTERNS (other comments already used them):\n${[...new Set(existingPatterns)].map(p => `- ${p}`).join('\n')}\nBe creative and use a DIFFERENT angle or joke structure!`
          : '';
        
        const prompt = `You are ${npc.name}, an employee seeing a comment thread on a workplace social feed.

ORIGINAL POST:
Author: ${post.authorName}
Content: "${post.content || ''}"

FULL COMMENT THREAD:
${allComments}

${triggerNPC.name} JUST COMMENTED:
"${triggerComment.content}"

YOUR RELATIONSHIP WITH ${triggerNPC.name}:
- Strength: ${relationship.strength}/100
- Type: ${relationship.type}

YOUR PERSONALITY:
- Confidence: ${personality.confidence || 50}/100
- Outgoing: ${personality.outgoing || 50}/100
- Humor: ${personality.humor || 50}/100

WHY YOU'RE RESPONDING: ${reason}
${tagContext}${diversityNote}

INSTRUCTIONS:
Write a brief comment (max 100 characters) responding to ${triggerNPC.name}'s comment. Tone: ${tone}.
${diversityNote ? 'Be ORIGINAL - don\'t copy the joke structure or phrasing of existing comments!' : ''}

${tone === 'friendly' ? '- Be warm and supportive' : ''}
${tone === 'snarky' ? '- Add a sarcastic or teasing edge' : ''}
${tone === 'engaged' ? '- React as the post author - this is YOUR post they\'re discussing' : ''}
${tone === 'playful' ? '- Keep it light and fun' : ''}
${tone === 'helpful' ? '- Be informative or answer implied questions' : ''}
${personality.humor > 60 ? '- Add humor if natural' : ''}
${relationship.strength > 70 ? '- Show familiarity (inside jokes, nicknames okay)' : ''}
${relationship.strength < 30 ? '- Keep it cool or slightly defensive' : ''}
${tagContext ? '- Can @tag people if it feels natural (e.g., "Right @sarah?", "@mike you seeing this?")' : ''}

DO NOT:
- Quote your response
- Exceed 100 characters
- Say "I would comment" or similar meta-text
- Copy the structure or phrasing of other comments

Just write the comment:`;

        const rawResponse = await generateText(prompt);
        console.log(`[Chain] Raw response from ${npc.name}: "${rawResponse}"`);
        
        // Sanitize
        let response = rawResponse.trim()
          .replace(/^["']|["']$/g, '')
          .replace(/\s*\([^)]*personality[^)]*\)\.?$/i, '')
          .replace(/^(I would (say|reply|comment):|My comment would be:)\s*/i, '');
        
        if (response.length > 100) {
          response = response.substring(0, 97) + '...';
        }
        
        response = response.trim();
        console.log(`[Chain] Sanitized: "${response}"`);
        
        if (response && response.length > 0) {
          const chainComment = createComment({
            postId: post.id,
            authorId: npc.id,
            authorName: npc.name,
            content: response,
            replyToCommentId: triggerComment.id // Reply to the comment that triggered this
          });
          
          post.comments.push(chainComment);
          console.log(`[Chain] ✓ ${npc.name} added to thread: "${response}"`);
          
          // 🌐 Evaluate relationship between chain commenter and original commenter
          if (triggerNPC && triggerNPC.id !== npc.id) {
            evaluateNPCCommentInteraction(npc, triggerNPC, post, triggerComment.content, response);
          }
          
          // 🌐 Also evaluate chain commenter's reaction to the post author
          const postAuthor = gameState.employees.find(e => e.id === post.authorId);
          if (postAuthor && postAuthor.id !== npc.id) {
            evaluateNPCReactionToPost(npc, postAuthor, post, response);
          }
          
          // CRITICAL FIX: Immediate update of comments section
          const postEl = document.querySelector(`[data-post-id="${post.id}"]`);
          const commentsSection = document.querySelector(`.post-comments[data-post-id="${post.id}"]`);
          
          if (postEl && commentsSection) {
            console.log(`[Chain] Immediately updating comments section after chain reaction`);
            commentsSection.style.display = 'block';
            updateCommentsSection(postEl, post);
            delete commentsSection.dataset.needsRefresh;
          }
          
          // Also request smart feed update as backup
          requestSmartFeedUpdate(post.id);
          
          // RECURSIVE CHAIN: 30% chance this comment triggers another response
          if (Math.random() < 0.3 && post.comments.length < 10) { // Cap at 10 comments to prevent infinite loops
            console.log(`[Chain] 🔄 ${npc.name}'s comment might trigger another response...`);
            setTimeout(async () => {
              await triggerCommentChainReaction(chainComment, post);
            }, 4000 + Math.random() * 5000); // 4-9 seconds
          }
        }
        
      } catch (error) {
        console.error(`[Chain] ✗ Error generating chain response for ${npc.name}:`, error);
      }
      
      // Stagger multiple responses
      await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));
    }
  }
  
  /**
   * Trigger automatic NPC reactions to player posts
   */
  async function triggerAutomaticNPCReactions(post) {
    if (!post || !post.isPlayerPost) return;
    
    // Get all active employees
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (activeEmployees.length === 0) return;
    
    // Get mentioned employees
    const mentionedEmployeeIds = post.referencedEmployees || [];
    const mentionedEmployees = activeEmployees.filter(e => mentionedEmployeeIds.includes(e.id));
    const nonMentionedEmployees = activeEmployees.filter(e => !mentionedEmployeeIds.includes(e.id));
    
    console.log(`[Social] Post has ${mentionedEmployees.length} mentions`);
    console.log(`[Social] Mentioned employee IDs:`, mentionedEmployeeIds);
    console.log(`[Social] Active employee IDs:`, activeEmployees.map(e => e.id));
    if (mentionedEmployees.length > 0) {
      console.log(`[Social] Matched employees:`, mentionedEmployees.map(e => `${e.name} (${e.id})`));
    }
    
    // HIGH ENGAGEMENT FOR PLAYER POSTS
    // 60-80% of employees will engage (like or comment)
    // Mentioned employees have 85-95% chance to engage!
    const baseEngagementRate = 0.6 + Math.random() * 0.2;
    const mentionedEngagementRate = 0.85 + Math.random() * 0.1;
    const engagers = [];
    
    // Process mentioned employees first (higher engagement)
    for (const emp of mentionedEmployees) {
      const affection = emp.stats?.affection || 0;
      const desire = emp.stats?.desire || 0;
      const intimacy = emp.intimacy || 0;
      const relationship = emp.relationships?.player?.level || 0;
      
      // Very high chance for mentioned employees
      const baseChance = mentionedEngagementRate;
      const relationshipBonus = (affection + desire + intimacy + relationship) / 400; // 0-1
      const engageChance = Math.min(0.98, baseChance + relationshipBonus);
      
      if (Math.random() < engageChance) {
        engagers.push({ emp, mentioned: true });
      }
    }
    
    // Process non-mentioned employees (normal engagement)
    for (const emp of nonMentionedEmployees) {
      const affection = emp.stats?.affection || 0;
      const desire = emp.stats?.desire || 0;
      const intimacy = emp.intimacy || 0;
      const relationship = emp.relationships?.player?.level || 0;
      
      // Weight by relationship - higher affection = more likely to engage
      const baseChance = baseEngagementRate;
      const relationshipBonus = (affection + desire + intimacy + relationship) / 400; // 0-1
      const engageChance = Math.min(0.95, baseChance + relationshipBonus);
      
      if (Math.random() < engageChance) {
        engagers.push({ emp, mentioned: false });
      }
    }
    
    // Split between likers and commenters
    // Mentioned employees: 70-85% will comment (vs 40-60% for others)
    const commenters = [];
    const likers = [];
    
    for (const engager of engagers) {
      const commentRate = engager.mentioned ? (0.7 + Math.random() * 0.15) : (0.4 + Math.random() * 0.2);
      
      if (Math.random() < commentRate) {
        commenters.push(engager.emp);
      } else {
        likers.push(engager.emp);
      }
    }
    
    console.log(`[Social] Player post triggering ${engagers.length} reactions (${commenters.length} comments, ${likers.length} likes)`);
    
    // Add likes with staggered timing
    for (let i = 0; i < likers.length; i++) {
      const npc = likers[i];
      const delay = (1 + i) * (1000 + Math.random() * 2000); // 1-3 seconds each
      
      setTimeout(() => {
        if (!post.likes.includes(npc.id)) {
          post.likes.push(npc.id);
          remember(npc, `I liked the boss's post: "${post.content || 'image post'}"`, 'interaction', 0.5);
          
          if (gameState.activeTab === 'social') {
            renderSocialFeed();
          }
        }
      }, delay);
    }
    
    // Generate meaningful, context-aware comments
    for (let i = 0; i < commenters.length; i++) {
      const npc = commenters[i];
      const delay = (1 + i) * (2000 + Math.random() * 4000); // 2-6 seconds each
      
      setTimeout(async () => {
        const commentText = await generateContextAwareComment(npc, post);
        
        const comment = createComment({
          postId: post.id,
          authorId: npc.id,
          authorName: npc.name,
          content: commentText
        });
        
        post.comments.push(comment);
        
        // Boost affection slightly for commenting
        if (npc.stats) {
          npc.stats.affection = Math.min(100, (npc.stats.affection || 0) + 1);
        }
        
        remember(npc, `I commented on boss's post: "${commentText}"`, 'interaction', 0.8);
        
        if (gameState.activeTab === 'social') {
          renderSocialFeed();
        }
      }, delay);
    }
  }
  
  /**
   * Generate meaningful, context-aware comments on player posts
   * Uses AI to create natural, personality-driven responses
   */
  async function generateContextAwareComment(employee, post) {
    const affection = employee.stats?.affection || 0;
    const desire = employee.stats?.desire || 0;
    const intimacy = employee.intimacy || 0;
    const personality = employee.personality || {};
    
    // Build relationship context
    const relationshipLevel = 
      intimacy > 70 ? 'very intimate' :
      intimacy > 40 ? 'romantically involved' :
      affection > 70 ? 'very close friends' :
      affection > 40 ? 'friendly' :
      affection > 20 ? 'cordial' : 'professional';
    
    // Analyze post content for context
    const content = post.content || '';
    const hasImage = !!post.imageUrl;
    const imageContext = post.imageAlt || '';
    const isExplicit = post.explicitLevel >= 2;
    
    // Build personality description
    const personalityDesc = `flirty: ${personality.flirty || 50}/100, outgoing: ${personality.outgoing || 50}/100, confidence: ${personality.confidence || 50}/100, professional: ${personality.professional || 50}/100`;
    
    // TAGGING LOGIC: Find potential NPCs to tag in comment
    let tagContext = '';
    let potentialTags = [];
    
    // Get other active employees (excluding this one)
    const otherEmployees = gameState.employees.filter(e => 
      e.employmentStatus === 'active' && 
      e.id !== employee.id &&
      e.id !== 'player'
    );
    
    if (otherEmployees.length > 0) {
      // Find friends (high relationship strength)
      const relationships = employee.relationships || {};
      const friends = otherEmployees.filter(e => {
        const rel = relationships[e.id];
        return rel && rel.strength > 60;
      }).slice(0, 2); // Max 2 friends
      
      // If post author is an NPC and not this employee, they're a prime target
      const postAuthor = otherEmployees.find(e => e.id === post.authorId);
      
      // Build list of taggable people
      if (postAuthor && !friends.find(f => f.id === postAuthor.id)) {
        potentialTags.push({ employee: postAuthor, reason: 'post author' });
      }
      friends.forEach(f => potentialTags.push({ employee: f, reason: 'friend' }));
      
      // Add 1-2 random others if list is short
      if (potentialTags.length < 2) {
        const randomOthers = otherEmployees
          .filter(e => !potentialTags.find(t => t.employee.id === e.id))
          .sort(() => Math.random() - 0.5)
          .slice(0, 2 - potentialTags.length);
        randomOthers.forEach(e => potentialTags.push({ employee: e, reason: 'coworker' }));
      }
      
      // Build tag context for AI (40% chance to suggest tagging)
      if (potentialTags.length > 0 && Math.random() < 0.4) {
        tagContext = `\n\nOPTIONAL: You can tag coworkers if relevant. Available to tag:\n`;
        potentialTags.forEach(({ employee: emp, reason }) => {
          tagContext += `- @${emp.social?.username || emp.name.toLowerCase().replace(/\s+/g, '')} (${emp.name} - ${reason})\n`;
        });
        tagContext += `\nOnly tag if it makes sense for the comment (e.g., "Right @sarah?", "@mike needs to see this", "@jessica told me about this"). Don't force it.`;
      }
    }
    
    // Gender-appropriate description
    const genderDesc = employee.gender ? `, a ${employee.age || 'young'}-year-old ${employee.gender === 'male' ? 'man' : employee.gender === 'transMan' ? 'trans man' : employee.gender === 'transWoman' ? 'trans woman' : employee.gender === 'femaleFuta' ? 'woman' : 'woman'}` : '';
    
    const prompt = `You are ${employee.name}${genderDesc}, commenting on ${post.isPlayerPost ? 'your boss\'s' : 'a coworker\'s'} social media post.

YOUR PERSONALITY: ${personalityDesc}
YOUR RELATIONSHIP WITH ${post.isPlayerPost ? 'BOSS' : 'POST AUTHOR'}: ${relationshipLevel} (affection: ${affection}/100, desire: ${desire}/100, intimacy: ${intimacy}/100)

${post.isPlayerPost ? 'BOSS\'S' : 'COWORKER\'S'} POST:
${content}
${hasImage ? `[Image: ${imageContext}]` : ''}
${isExplicit ? '[This is explicit/suggestive content]' : ''}
${tagContext}

Write a natural, authentic comment that:
- Reflects your personality and relationship with the post author
- References specific content from the post (not generic "nice!")
- Matches the tone of the post (playful, serious, flirty, etc.)
- Is 5-20 words max
- Uses modern social media language (emojis okay but not excessive)
${tagContext ? '- Can include @tags if it feels natural (but not required)' : ''}
${intimacy > 40 ? '- Can be flirty/suggestive since you\'re intimate' : ''}
${affection > 60 ? '- Show warmth and genuine interest' : ''}
${personality.flirty > 70 && desire > 40 ? '- Can include subtle flirtation' : ''}

Examples of GOOD comments:
- "The confidence! 🔥 Love this energy"
- "Okay but why do you look this good on a Monday 👀"
- "This just made my day so much better 😍"
- "Stealing this vibe for myself ✨"
- "The way you just casually serve looks every day"
${tagContext ? '- "@sarah you seeing this?" or "Right @mike? 😂"' : ''}

Examples of BAD comments (too generic):
- "Nice!"
- "Cool post"
- "Love it"

Write ONLY the comment, no quotation marks or explanation:`;

    try {
      const response = await generateText(prompt, { temperature: 0.9, max_tokens: 50 });
      let comment = response.trim();
      
      // Remove quotes if AI added them
      comment = comment.replace(/^["']|["']$/g, '');
      
      // Ensure reasonable length
      if (comment.length > 100) {
        comment = comment.substring(0, 97) + '...';
      }
      
      return comment || '🔥'; // Fallback
      
    } catch (error) {
      console.error('AI comment generation failed:', error);
      
      // Fallback to contextual templates
      return generateTemplateComment(employee, post);
    }
  }
  
  /**
   * Generate template-based comment as fallback
   */
  function generateTemplateComment(employee, post) {
    const affection = employee.stats?.affection || 0;
    const desire = employee.stats?.desire || 0;
    const intimacy = employee.intimacy || 0;
    const personality = employee.personality || {};
    
    const isExplicit = post.explicitLevel >= 2;
    const hasImage = !!post.imageUrl;
    
    // High intimacy + explicit content
    if (intimacy > 60 && isExplicit && personality.flirty > 60) {
      const comments = ['🥵🥵🥵', 'Boss... wow 😍', 'You\'re dangerous 🔥', 'Stop it I can\'t handle this 👀💕', 'The way you look... damn'];
      return comments[Math.floor(Math.random() * comments.length)];
    }
    
    // High intimacy
    if (intimacy > 50) {
      const comments = ['You always know how to make my day 😘', 'Obsessed with everything about this 💕', 'The most beautiful person I know', 'Can\'t stop looking at this 😍', 'How are you even real 🔥'];
      return comments[Math.floor(Math.random() * comments.length)];
    }
    
    // High affection + flirty
    if (affection > 60 && personality.flirty > 60 && desire > 40) {
      const comments = ['Okay but WHY do you look this good 👀', 'The confidence! I\'m here for it 🔥', 'Serving looks as always 😍', 'This energy >>> everything', 'How do you do this every single time'];
      return comments[Math.floor(Math.random() * comments.length)];
    }
    
    // High affection
    if (affection > 50) {
      const comments = ['Love this so much! 💕', 'This just made my whole day better ✨', 'You\'re literally glowing in this 🌟', 'Main character energy right here', 'Absolutely love everything about this'];
      return comments[Math.floor(Math.random() * comments.length)];
    }
    
    // Moderate relationship
    if (affection > 30) {
      const comments = ['This is such a vibe! 😊', 'Love this! 💙', 'Looking amazing boss! ✨', 'Great post! 🔥', 'Absolutely love it!'];
      return comments[Math.floor(Math.random() * comments.length)];
    }
    
    // Professional/lower affection
    const comments = ['Great post boss! 👍', 'Love the energy! ✨', 'This is awesome!', 'Really nice! 😊', 'Love it! 💙'];
    return comments[Math.floor(Math.random() * comments.length)];
  }
  
  /**
   * Check for proactive NPC messages
   * NPCs will reach out to the player based on various triggers
   */
  async function checkForProactiveMessages() {
    // Don't send messages too frequently
    if (!gameState.lastProactiveMessageCheck) {
      gameState.lastProactiveMessageCheck = Date.now();
      return;
    }
    
    const timeSinceLastCheck = Date.now() - gameState.lastProactiveMessageCheck;
    if (timeSinceLastCheck < 60000) return; // Min 1 minute between checks
    
    gameState.lastProactiveMessageCheck = Date.now();
    
    // Get eligible NPCs (active employees only)
    const eligibleNPCs = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (eligibleNPCs.length === 0) return;
    
    // Check each NPC for messaging triggers (but limit to 1-2 per check)
    let messagesThisCheck = 0;
    const maxMessagesPerCheck = Math.random() > 0.7 ? 2 : 1;
    
    for (const npc of eligibleNPCs) {
      if (messagesThisCheck >= maxMessagesPerCheck) break;
      
      // Check if this NPC should message the player
      const shouldMessage = await evaluateProactiveMessageTriggers(npc);
      if (shouldMessage) {
        await sendProactiveNPCMessage(npc, shouldMessage.reason, shouldMessage.context);
        messagesThisCheck++;
      }
    }
  }
  
  /**
   * Evaluate if an NPC should send a proactive message 
   */
  async function evaluateProactiveMessageTriggers(npc) {
    const now = Date.now();
    
    // Get chat history
    const chatHistory = gameState.chatHistory[npc.id] || [];
    const lastMessage = chatHistory[chatHistory.length - 1];
    const lastMessageTime = lastMessage?.timestamp || 0;
    const hoursSinceLastMessage = (now - lastMessageTime) / (1000 * 60 * 60);
    const minutesSinceLastMessage = (now - lastMessageTime) / (1000 * 60);
    const secondsSinceLastMessage = (now - lastMessageTime) / 1000;
    
    // CRITICAL: Don't interrupt active conversations
    // If ANY message (player or NPC) was sent in the last 5 minutes, consider it an active conversation
    if (minutesSinceLastMessage < 5) {
      console.log(`[Proactive Message] ${npc.name}: Blocked - Active conversation (${Math.round(secondsSinceLastMessage)}s since last message)`);
      return false;
    }
    
    // Extra protection: Check for recent player activity specifically
    // If player sent a message in the last 10 minutes, don't send proactive messages
    const lastPlayerMessage = [...chatHistory].reverse().find(msg => msg.isPlayer);
    const timeSincePlayerMessage = lastPlayerMessage?.timestamp ? (now - lastPlayerMessage.timestamp) : Infinity;
    const minutesSincePlayerMessage = timeSincePlayerMessage / (1000 * 60);
    
    if (minutesSincePlayerMessage < 10) {
      console.log(`[Proactive Message] ${npc.name}: Blocked - Recent player activity (${Math.round(minutesSincePlayerMessage)} min since player's last message)`);
      return false;
    }
    
    // Count consecutive NPC messages since the last player message
    // Prevent NPC from spamming multiple messages without player response
    let consecutiveNPCMessages = 0;
    for (let i = chatHistory.length - 1; i >= 0; i--) {
      if (chatHistory[i].isPlayer) {
        break; // Found the last player message
      }
      consecutiveNPCMessages++;
    }
    
    // If NPC has already sent 1+ message since player's last message, don't send more until player responds
    if (consecutiveNPCMessages >= 1) {
      console.log(`[Proactive Message] ${npc.name}: Blocked - Already sent ${consecutiveNPCMessages} message(s) waiting for player response`);
      return false;
    }
    
    // Get relationship stats
    const relationship = npc.relationships?.player || { level: 0, type: 'professional' };
    const intimacy = npc.intimacy || 0;
    const affection = npc.stats?.affection || 0;
    const trust = npc.stats?.trust || 0;
    
    // Higher intimacy/affection = more likely to message
    const baseChance = 0.05; // 5% base chance
    const relationshipBonus = (relationship.level / 100) * 0.15; // Up to +15%
    const intimacyBonus = (intimacy / 100) * 0.20; // Up to +20%
    const timeBonus = Math.min(hoursSinceLastMessage / 24, 0.10); // Up to +10% based on time
    
    const totalChance = baseChance + relationshipBonus + intimacyBonus + timeBonus;
    
    if (Math.random() > totalChance) return false;
    
    // Determine message reason and context
    const reasons = [];
    
    // Work-related messages (always possible)
    reasons.push({ reason: 'work_question', weight: 3, context: 'work' });
    reasons.push({ reason: 'work_update', weight: 2, context: 'work' });
    
    // Personal messages (based on relationship)
    if (affection > 30) {
      reasons.push({ reason: 'casual_chat', weight: 2, context: 'casual' });
    }
    if (affection > 50) {
      reasons.push({ reason: 'sharing_news', weight: 2, context: 'personal' });
    }
    if (trust > 60) {
      reasons.push({ reason: 'asking_advice', weight: 1, context: 'personal' });
    }
    
    // Social media related
    const recentPosts = gameState.socialNetwork.posts
      .filter(p => p.authorId === npc.id && (now - p.timestamp) < 86400000) // Last 24h
      .slice(0, 3);
    if (recentPosts.length > 0) {
      reasons.push({ reason: 'post_followup', weight: 2, context: { type: 'social', post: recentPosts[0] } });
    }
    
    // Flirty/intimate messages (based on intimacy)
    if (intimacy > 40) {
      reasons.push({ reason: 'flirty_message', weight: 1, context: 'flirty' });
    }
    if (intimacy > 70) {
      reasons.push({ reason: 'booty_call', weight: 1, context: 'intimate' });
    }
    
    // Recent events
    const recentEvents = (gameState.companyEvents || [])
      .filter(e => e.involvedEmployees?.includes(npc.id) && (now - e.timestamp) < 86400000)
      .slice(0, 2);
    if (recentEvents.length > 0) {
      reasons.push({ reason: 'event_reaction', weight: 2, context: { type: 'event', event: recentEvents[0] } });
    }
    
    // Weighted random selection
    const totalWeight = reasons.reduce((sum, r) => sum + r.weight, 0);
    let random = Math.random() * totalWeight;
    
    for (const reasonObj of reasons) {
      random -= reasonObj.weight;
      if (random <= 0) {
        return reasonObj;
      }
    }
    
    return reasons[0]; // Fallback
  }
  
  /**
   * Send a proactive message from NPC to player
   */
  async function sendProactiveNPCMessage(npc, reason, context) {
    try {
      // Get personality and relationship info
      const personality = npc.personality || {};
      const relationship = npc.relationships?.player || { level: 0, type: 'professional' };
      const intimacy = npc.intimacy || 0;
      const affection = npc.stats?.affection || 0;
      
      // Build message prompt
      let messageContext = '';
      if (typeof context === 'string') {
        messageContext = context;
      } else if (context.type === 'social' && context.post) {
        messageContext = `Recent post: "${context.post.content || ''}"`;
      } else if (context.type === 'event' && context.event) {
        messageContext = `Recent event: ${context.event.description}`;
      }
      
      // Get recent conversation for context
      const chatHistory = (gameState.chatHistory[npc.id] || []).slice(-5)
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      // NEW: Track recent message types for variety
      if (!npc.recentMessageTypes) npc.recentMessageTypes = [];
      const recentTypes = npc.recentMessageTypes.slice(0, 5).join(', ');
      
      // NEW: Get player description for context
      const playerDesc = getPlayerDescription('conversation');
      const playerContextNote = playerDesc !== 'the boss' ? `\n\n👤 BOSS INFO:\n${playerDesc}` : '';
      
      // NEW: Get gossip context for spicy conversations
      const gossipText = getGossipContext(npc.id, true);
      const gossipNote = gossipText ? `\n\n${gossipText}` : '';
      
      // NEW: Time of day affects message style
      const hour = new Date().getHours();
      let timeContext = '';
      if (hour >= 6 && hour < 12) {
        timeContext = 'It\'s morning. Messages can be about starting the day, morning mood, coffee, etc.';
      } else if (hour >= 12 && hour < 17) {
        timeContext = 'It\'s afternoon. Messages can be about work progress, lunch, midday thoughts.';
      } else if (hour >= 17 && hour < 22) {
        timeContext = 'It\'s evening. Messages can be about wrapping up work, evening plans, relaxing.';
      } else {
        timeContext = 'It\'s late night. Messages can be casual, personal, or about being up late.';
      }
      
      // MASSIVELY ENHANCED PROMPT with personality-driven variety
      const prompt = `You are ${npc.name}, initiating a conversation with your boss (@TheBoss).

YOUR PERSONALITY:
- Confidence: ${personality.confidence || 50}/100
- Flirtiness: ${personality.flirty || 50}/100
- Outgoing: ${personality.outgoing || 50}/100
- Professional: ${personality.professional || 50}/100
- Humor: ${personality.humor || 50}/100
${npc.hobbies ? `- Hobbies: ${npc.hobbies.join(', ')}` : ''}
${npc.position ? `- Job: ${npc.position}` : ''}

YOUR RELATIONSHIP:
- Affection: ${affection}/100 ${affection > 70 ? '(very close)' : affection > 40 ? '(friendly)' : '(professional)'}
- Intimacy: ${intimacy}/100 ${intimacy > 60 ? '(intimate/romantic)' : intimacy > 30 ? '(comfortable)' : '(reserved)'}
- Type: ${relationship.type || 'professional'}${playerContextNote}${gossipNote}

CONTEXT:
- Reason: ${reason}
- ${messageContext || 'No specific context'}
- ${timeContext}
${chatHistory ? `\nRECENT CHAT:\n${chatHistory}` : '\nNo recent conversation'}

${recentTypes ? `\n⚠️ VARIETY: Your recent message types: ${recentTypes}\nWrite something DIFFERENT this time - new angle, different tone, fresh approach!` : ''}

📝 MESSAGE STYLE GUIDE BY REASON:

**work_question**: NOT "Can we discuss the implementation timeline?" - Too robotic!
INSTEAD: Ask genuine questions that show personality:
- "Quick q - do you prefer morning meetings or afternoon? 🤔"
- "Need your input on something when you have a sec"
- "Hey, what's your take on [specific thing]?"
- "Random work thought - mind if I run something by you?"
${personality.humor > 60 ? '- Add humor if it fits your personality!' : ''}

**work_update**: NOT "Project completed successfully" - Too corporate!
INSTEAD: Share updates like a real person:
- "Just crushed that deadline 💪"
- "Update: thing you asked about is done!"
- "FYI - wrapped up early on [project]"
- "Quick win today, thought you'd want to know 🎉"
${affection > 50 ? '- Show enthusiasm if you like the boss!' : ''}

**casual_chat**: NOT "Just checking in" - Too generic!
INSTEAD: Be genuinely casual and varied:
- "Hey! How's your day going?"
- "Random thought: [something interesting]"
- "Saw something that made me think of you"
- "Quick break from work - what are you up to?"
- Time-appropriate: morning coffee check-ins, afternoon energy, evening plans
${personality.humor > 70 ? '- Share funny observations!' : ''}
${intimacy > 50 ? '- Can be more personal and friendly' : ''}

**sharing_news**: NOT "I wanted to share some news" - Be specific!
INSTEAD: Actually share something interesting:
- "Dude, you won't believe what just happened 😅"
- "Okay so [specific thing] just went down"
- "Fun fact I just learned: [something relevant]"
- "This is wild - [share actual news/event]"
${npc.hobbies ? '- Reference your hobbies naturally' : ''}

**asking_advice**: NOT "Could I get your advice?" - Too formal!
INSTEAD: Ask naturally and specifically:
- "Quick dilemma - [specific situation]?"
- "Need a second opinion on something"
- "What would you do if [specific scenario]?"
- "Honest question: [actual question]"
${affection > 60 ? '- Can ask personal advice, not just work' : ''}

**post_followup**: Reference YOUR OWN post naturally:
- "Did you see my post about [topic]? 📱"
- "Posted something earlier that made me think of you"
- "That post got more attention than I expected lol"
- NOT: "I saw you liked my post" (unless context specifically says boss liked it!)

**flirty_message**: ${intimacy > 40 ? 'You can be subtly flirty' : 'Keep it light and playful'}:
- "Hey you 😊"
- "Been thinking about you"
- "Miss talking to you"
- ${intimacy > 60 ? 'Be playful with what they are doing' : 'Light compliments work well'}
${personality.flirty > 70 ? '- Be bolder based on your personality' : '- Keep it subtle and tasteful'}

**booty_call**: ${intimacy > 60 ? 'Be direct but playful' : 'Suggest hanging out casually'}:
- ${intimacy > 70 ? 'Can be direct about tonight' : 'Suggest drinks or hanging out'}
- ${intimacy > 80 ? 'Be flirty and suggestive' : 'Keep it casual'}
- ${intimacy > 60 ? 'Show interest romantically' : 'Friendly hangout vibes'}

**event_reaction**: React naturally to what happened:
- "So about [event] 😅"
- "That was [emotion]!"
- "Can we talk about what just happened?"
- Be specific to the actual event

🎯 TONE GUIDELINES:
${personality.confidence > 70 ? '✓ Be direct and bold' : '✓ Be thoughtful and considerate'}
${personality.outgoing > 70 ? '✓ Be enthusiastic and expressive' : '✓ Be calm and measured'}
${personality.professional > 70 ? '✓ Keep it polished but warm' : '✓ Be casual and relaxed'}
${personality.humor > 70 ? '✓ Add wit and humor' : '✓ Keep it sincere'}
${intimacy > 60 ? '✓ Can be personal and intimate' : intimacy > 30 ? '✓ Friendly and comfortable' : '✓ Professional but friendly'}
${affection > 70 ? '✓ Show warmth and care' : affection > 40 ? '✓ Be friendly' : '✓ Keep it respectful'}

RULES:
- Max 200 characters
- Use 0-2 emojis (use naturally, not forced)
- NO quotation marks
- NO "I would say" or meta-commentary
- NO formal business-speak
- BE SPECIFIC not generic
- SHOW personality
- DON'T invent boss actions not in context
- Sound like an actual person texting

Write ONLY the message:`;

      // Generate message
      const rawMessage = await generateText(prompt);
      let message = sanitizeNpcResponse(rawMessage, 2).trim();
      
      // Additional meta-commentary stripping for DMs
      message = message.split(/\(Character count:/)[0];
      message = message.split(/\(Emojis used:/)[0];
      message = message.split(/\(Approach:/)[0];
      message = message.trim();
      
      if (!message || message.length > 150) return; // Safety check
      
      // Track message type for variety
      npc.recentMessageTypes.unshift(reason);
      if (npc.recentMessageTypes.length > 10) {
        npc.recentMessageTypes = npc.recentMessageTypes.slice(0, 10);
      }
      
      // Add to chat history
      if (!gameState.chatHistory[npc.id]) {
        gameState.chatHistory[npc.id] = [];
      }
      
      gameState.chatHistory[npc.id].push({
        sender: npc.name,
        content: message,
        isPlayer: false,
        timestamp: Date.now()
      });
      
      // Mark as unread
      if (!npc.unreadMessages) npc.unreadMessages = 0;
      npc.unreadMessages++;
      
      // Store in memory
      remember(npc, `I messaged the boss: "${message}"`, 'interaction', 1);
      
      // Update People tab if visible
      if (gameState.activeTab === 'people') {
        updatePeopleTab();
      }
      
      // If chat is currently open for this NPC, show the message
      if (gameState.activeChat?.id === npc.id && chatMessages) {
        const messageIndex = gameState.chatHistory[npc.id].length - 1;
        addChatMessage(npc.name, message, false, null, messageIndex);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        npc.unreadMessages = 0; // Already reading it
      }
      
    } catch (error) {
      console.error('Error sending proactive NPC message:', error);
    }
  }
  
  // Update news feed
  function updateNewsFeed() {
    if (!newsFeed) return;
    
    // Ensure news array exists (backwards compatibility with old saves)
    if (!gameState.news || !Array.isArray(gameState.news)) {
      gameState.news = [
        "Tech startup raises $1M in seed funding",
        "New productivity app trends in office spaces",
        "Remote work policies reshape company cultures",
        "AI integration boosts efficiency across industries"
      ];
    }
    
    newsFeed.innerHTML = '';
    gameState.news.forEach((newsItem, index) => {
      const newsItemEl = document.createElement('div');
      newsItemEl.className = 'news-item';
      newsItemEl.style.cssText = 'background:#16213e; border-radius:8px; padding:12px; margin-bottom:10px;';
      
      newsItemEl.innerHTML = `
        <p style="margin:0;">${newsItem}</p>
        <p style="margin:5px 0 0 0; font-size:0.8rem; color:#aaa;">${new Date().toLocaleDateString()}</p>
      `;
      
      newsFeed.appendChild(newsItemEl);
    });
  }
  
  // Game tick - main update loop
  function gameTick() {
    const dt = GAME_TICK_INTERVAL;

    gameState.products.forEach(p => {
      // Only process unlocked products
      if (!p.unlocked) return;
      
      // Check if constant stream - optimize calculation
      const cycleTime = currentCycleTimeMs(p);
      const isConstantStream = cycleTime < 1000 && p.managerHired;
      
      if (isConstantStream) {
        // Constant stream optimization: direct cash calculation, no cycle tracking
        // Calculate earnings for this tick based on cycle rate
        const earningsPerMs = currentValue(p) / cycleTime;
        const tickEarnings = earningsPerMs * dt;
        
        // Apply prestige income multiplier
        const incomeUpgradeLevel = gameState.influenceUpgrades?.incomeMultiplier || 0;
        const prestigeMultiplier = influenceUpgrades.incomeMultiplier.effect(incomeUpgradeLevel);
        const finalEarnings = tickEarnings * prestigeMultiplier;
        
        gameState.cash += finalEarnings;
        gameState.totalEarnings += finalEarnings;
        gameState.lifetimeEarnings += finalEarnings; // Track for prestige
        
        // Keep running flag true but don't update timeRemaining (not needed)
        p.running = true;
        
        // Skip rest of normal processing
        return;
      }
      
      // Normal product processing (non-constant)
      if (p.running) {
        p.timeRemainingMs -= dt;

        if (p.timeRemainingMs <= 0) {
          // payout
          const payout = currentValue(p);
          
          // Apply prestige income multiplier
          const incomeUpgradeLevel = gameState.influenceUpgrades?.incomeMultiplier || 0;
          const prestigeMultiplier = influenceUpgrades.incomeMultiplier.effect(incomeUpgradeLevel);
          const finalPayout = payout * prestigeMultiplier;
          
          gameState.cash += finalPayout;
          gameState.totalEarnings += finalPayout;
          gameState.lifetimeEarnings += finalPayout; // Track for prestige

          if (p.managerHired) {
            // keep cycling under manager
            p.running = true;
            p.timeRemainingMs = cycleTime;
          } else {
            // stop and instantly sync Sell label for responsiveness
            p.running = false;
            p.timeRemainingMs = 0;
            const sellTxt = $(`selltxt-${p.id}`);
            if (sellTxt) sellTxt.textContent = 'Sell';
          }
        }
      } else if (p.managerHired) {
        // manager auto-starts if idle
        p.running = true;
        p.timeRemainingMs = cycleTime;
      }
    });
    
    // Autonomous social feed generation (runs in background)
    autonomousPostGeneration().catch(err => {
      console.error('Autonomous post generation error:', err);
    });

    // UI refresh (lightweight progress updates recommended)
    updateUI();
  }
  
  // Update UI elements
  function updateUI() {
    // top bar - enhanced cash display
    if (cashEl) {
      const cashStyle = formatCashDisplay(gameState.cash);
      cashEl.textContent = cashStyle.displayText;
      cashEl.style.fontSize = cashStyle.fontSize;
      cashEl.style.color = cashStyle.color;
      cashEl.style.textShadow = cashStyle.textShadow;
      cashEl.style.animation = cashStyle.animation;
      cashEl.style.fontWeight = 'bold';
      cashEl.style.transition = 'all 0.3s ease';
    } else {
      console.warn('cashEl is null in updateUI()');
    }
    if (cashPerSecEl) cashPerSecEl.textContent = formatNumber(calculateCashPerSecond());
    if (employeeCountEl) employeeCountEl.textContent = gameState.employees.length;

    const unlockedProducts = gameState.products.filter(p => p.unlocked).length;
    if (productCountEl) productCountEl.textContent = unlockedProducts;

    // only refresh progress bars/text in Business tab for smoothness
    if (gameState.activeTab === 'business') {
      updateProductProgressBars();
    }
    
    // Update prestige UI in real-time if on Invest tab
    if (gameState.activeTab === 'invest') {
      updatePrestigeUI();
    }
    
    // Update dashboard in real-time if on Dashboard tab
    if (gameState.activeTab === 'dashboard') {
      updateDashboard();
    }
  }
  
  // Calculate cash per second
  function calculateCashPerSecond() {
    let total = 0;
    gameState.products.forEach(p => {
      // Only count unlocked products
      if (!p.unlocked) return;
      
      const cycleTime = currentCycleTimeMs(p);
      // if running or managed, include it; otherwise 0
      if (p.running || p.managerHired) {
        total += currentValue(p) / (cycleTime / 1000);
      }
    });
    
    // Apply prestige multipliers
    const incomeUpgradeLevel = gameState.influenceUpgrades?.incomeMultiplier || 0;
    const prestigeMultiplier = influenceUpgrades.incomeMultiplier.effect(incomeUpgradeLevel);
    total *= prestigeMultiplier;
    
    return total; // Return raw number, format at display time
  }

  // ============================================
  // GLOBAL UPGRADES (UPGRADES TAB)
  // ============================================
  
  function buyClickPower() {
    const level = gameState.globalUpgrades.clickPower;
    const baseCost = gameBalance.upgradeBaseCosts.clickPower;
    const cost = Math.floor(baseCost * Math.pow(2.0, level));
    
    if (gameState.cash < cost) return showNotification('Not enough cash!');
    
    gameState.cash -= cost;
    gameState.globalUpgrades.clickPower += 1;
    
    const newEffect = 1.0 + (gameState.globalUpgrades.clickPower * 0.1);
    showNotification(`Click Power upgraded! Now -${newEffect.toFixed(1)}s per click`);
    updateUpgradesTab();
    updateUI();
  }
  
  function buyIncomeBoost(locationId) {
    const level = gameState.globalUpgrades.incomeBoost[locationId] || 0;
    const baseCost = gameBalance.upgradeBaseCosts.incomeBoost;
    const cost = Math.floor(baseCost * Math.pow(2.5, level));
    
    if (gameState.cash < cost) return showNotification('Not enough cash!');
    
    gameState.cash -= cost;
    gameState.globalUpgrades.incomeBoost[locationId] = level + 1;
    
    // Calculate new bonus with diminishing returns formula
    const newBonus = (1 - Math.pow(0.9, level + 1)) * 100;
    const location = gameState.locations.find(loc => loc.id === locationId);
    showNotification(`${location.name} income boost upgraded! Now +${newBonus.toFixed(1)}%`);
    updateUpgradesTab();
    updateUI();
  }
  
  function buyCostReduction(locationId) {
    const level = gameState.globalUpgrades.costReduction[locationId] || 0;
    const baseCost = gameBalance.upgradeBaseCosts.costReduction;
    const cost = Math.floor(baseCost * Math.pow(3.0, level));
    
    if (gameState.cash < cost) return showNotification('Not enough cash!');
    
    gameState.cash -= cost;
    gameState.globalUpgrades.costReduction[locationId] = level + 1;
    
    // Calculate new reduction with diminishing returns formula (max 90%)
    const newReduction = (1 - Math.pow(0.9, level + 1)) * 90;
    const location = gameState.locations.find(loc => loc.id === locationId);
    showNotification(`${location.name} cost reduction upgraded! Now -${newReduction.toFixed(1)}%`);
    updateUpgradesTab();
    updateUI();
  }
  
  // ============================================
  // BOSS FIGHT SYSTEM
  // ============================================
  
  let bossFightState = null;
  let bossFightInterval = null;
  
  // Boss image preloading system
  // Store preloaded images: { locationId: { attemptCount: number, imageUrl: string, isGenerating: boolean } }
  let preloadedBossImages = {};
  
  /**
   * Preload boss fight image for a location
   * Each attempt gets a unique image (attemptCount increments on defeat)
   */
  async function preloadBossImage(locationId) {
    const boss = bossFightConfig[locationId];
    if (!boss || typeof generateImage !== 'function') return;
    
    // Get attempt count for this boss
    const attemptCount = gameState.bossFights.history.filter(h => h.bossId === boss.id).length;
    
    // Check if already generating or already cached for this attempt
    const cached = preloadedBossImages[locationId];
    if (cached) {
      if (cached.isGenerating) {
        console.log(`Boss image for ${locationId} is already being generated`);
        return;
      }
      if (cached.attemptCount === attemptCount && cached.imageUrl) {
        console.log(`Using preloaded boss image for ${locationId} (attempt ${attemptCount})`);
        return;
      }
    }
    
    console.log(`Preloading boss image for ${locationId} (attempt ${attemptCount})...`);
    
    // Mark as generating to prevent duplicate calls
    if (!preloadedBossImages[locationId]) {
      preloadedBossImages[locationId] = {};
    }
    preloadedBossImages[locationId].isGenerating = true;
    
    try {
      // Add variety to prompt with attempt count
      const varietyModifiers = [
        '', // base prompt
        ', different angle',
        ', different lighting',
        ', different pose',
        ', alternative style',
        ', dramatic lighting',
        ', cinematic angle',
        ', professional photography'
      ];
      const modifier = varietyModifiers[attemptCount % varietyModifiers.length];
      const imageUrl = await generateImage({ prompt: boss.appearance.prompt + modifier });
      
      if (imageUrl) {
        preloadedBossImages[locationId].attemptCount = attemptCount;
        preloadedBossImages[locationId].imageUrl = imageUrl;
        preloadedBossImages[locationId].isGenerating = false;
        console.log(`Boss image preloaded successfully for ${locationId}`);
      } else {
        preloadedBossImages[locationId].isGenerating = false;
      }
    } catch (error) {
      console.error(`Failed to preload boss image for ${locationId}:`, error);
      preloadedBossImages[locationId].isGenerating = false;
    }
  }
  
  /**
   * Get preloaded boss image or return null
   */
  function getPreloadedBossImage(locationId) {
    const boss = bossFightConfig[locationId];
    if (!boss) return null;
    
    const attemptCount = gameState.bossFights.history.filter(h => h.bossId === boss.id).length;
    const cached = preloadedBossImages[locationId];
    
    if (cached && cached.attemptCount === attemptCount && cached.imageUrl) {
      return cached.imageUrl;
    }
    return null;
  }
  
  /**
   * Check if we should preload boss image (when last product unlocked)
   * ONLY CALLED ONCE when unlocking products
   */
  function checkAndPreloadBossImage(locationId) {
    // Count unlocked products in this location
    const locationProducts = gameState.products.filter(p => p.locationId === locationId);
    const unlockedCount = locationProducts.filter(p => p.unlocked).length;
    
    // If all products unlocked, preload boss image ONCE
    if (unlockedCount === locationProducts.length && locationProducts.length > 0) {
      const boss = bossFightConfig[locationId];
      if (boss && !gameState.bossFights.defeated.includes(boss.id)) {
        const cached = preloadedBossImages[locationId];
        // Only preload if not already cached or generating
        if (!cached || (!cached.imageUrl && !cached.isGenerating)) {
          preloadBossImage(locationId);
        }
      }
    }
  }
  
  /**
   * Check if player meets requirements to attempt boss fight
   */
  function checkBossFightRequirements(locationId) {
    const boss = bossFightConfig[locationId];
    if (!boss) return { canAttempt: false, reasons: ['No boss configured for this location'] };
    
    // Check if already defeated
    if (gameState.bossFights.defeated.includes(boss.id)) {
      return { canAttempt: false, reasons: ['Boss already defeated'] };
    }
    
    const clickPowerLevel = gameState.globalUpgrades.clickPower;
    const incomePerSec = parseFloat(calculateCashPerSecond());
    
    // Always allow attempting, but show recommendations
    const warnings = [];
    
    if (clickPowerLevel < boss.recommendedClickPower) {
      warnings.push(`⚠️ Level ${boss.recommendedClickPower} Click Power recommended (you have ${clickPowerLevel})`);
    }
    
    if (incomePerSec < boss.recommendedIncome) {
      warnings.push(`⚠️ $${formatNumber(boss.recommendedIncome)}/sec recommended (you have $${formatNumber(incomePerSec)}/sec)`);
    }
    
    return { canAttempt: true, reasons: warnings, boss };
  }
  
  /**
   * Start a boss fight
   */
  async function startBossFight(locationId) {
    const check = checkBossFightRequirements(locationId);
    
    if (!check.canAttempt) {
      showNotification(`Cannot start boss fight: ${check.reasons.join(', ')}`);
      return;
    }
    
    const boss = check.boss;
    const clickPowerLevel = gameState.globalUpgrades.clickPower || 0;
    const incomePerSec = calculateCashPerSecond() || 0;
    
    console.log('[Boss Fight] Starting calculations:', {
      clickPowerLevel,
      incomePerSec,
      employeeCount: gameState.employees.length
    });
    
    // Calculate team power from employees
    const employees = gameState.employees || [];
    const employeeCount = employees.length;
    
    // Each employee contributes based on their relationship stats
    let teamPower = 0;
    employees.forEach(emp => {
      const trust = emp.trust || 0;
      const friendship = emp.friendship || 0;
      const desire = emp.desire || 0;
      const avgRelationship = (trust + friendship + desire) / 3;
      // Each employee adds a flat damage bonus based on their relationship (more impactful)
      // Base: Each employee = +2% damage
      // Relationship bonus: Up to +3% more at 100 relationship
      const employeeBonus = 2.0 + (avgRelationship * 0.03);
      teamPower += employeeBonus;
    });
    
    // Calculate player attack:
    // Base: Click power still matters (10 damage per level)
    // Income multiplier: Income/sec provides massive boost (0.5 damage per $/sec)
    // Team multiplier: Each employee provides ~2-5% damage bonus
    const baseAttack = 50 + (clickPowerLevel * 10); // Base + click power
    const incomeBonus = incomePerSec * 0.5; // 50% of income/sec as damage
    const teamMultiplier = 1.0 + (teamPower / 100); // Team power directly converts to % bonus
    
    const totalAttack = (baseAttack + incomeBonus) * teamMultiplier;
    
    console.log('[Boss Fight] Damage calculation:', {
      baseAttack,
      incomeBonus,
      teamPower,
      teamMultiplier,
      totalAttack
    });
    
    // Ensure totalAttack is a valid number
    if (isNaN(totalAttack) || !isFinite(totalAttack)) {
      console.error('[Boss Fight] Invalid total attack calculated!', {
        baseAttack,
        incomeBonus,
        teamMultiplier
      });
      showNotification('Error calculating combat stats. Please check console.', 'error');
      return;
    }
    
    // Initialize boss fight state
    bossFightState = {
      boss: boss,
      locationId: locationId,
      bossHealth: boss.health,
      bossMaxHealth: boss.health,
      playerStamina: 100,
      playerMaxStamina: 100,
      playerAttack: totalAttack,
      playerDefense: incomePerSec, // Income/sec acts as defense/regen
      teamPower: teamPower, // Store for display
      employeeCount: employeeCount,
      timeRemaining: 60, // 60 second fight
      combatLog: [],
      damageDealt: 0,
      damageReceived: 0
    };
    
    // Show modal
    const modal = document.getElementById('bossFightModal');
    console.log('Opening boss fight modal:', modal);
    console.log('Modal current state - hidden:', modal?.hidden, 'display:', modal?.style.display);
    
    if (modal) {
      modal.hidden = false;
      modal.style.display = 'flex';
      console.log('Modal new state - hidden:', modal.hidden, 'display:', modal.style.display);
    } else {
      console.error('Boss fight modal element not found!');
    }
    
    // Update UI elements
    document.getElementById('bossName').textContent = boss.name;
    document.getElementById('bossTitle').textContent = boss.title;
    document.getElementById('bossDescription').textContent = boss.description;
    document.getElementById('bossDialogue').textContent = `"${boss.dialogue.intro}"`;
    document.getElementById('playerAttack').textContent = Math.floor(bossFightState.playerAttack) || 0;
    document.getElementById('playerDefense').textContent = formatNumber(bossFightState.playerDefense);
    const teamBonusPct = (teamMultiplier - 1.0) * 100;
    document.getElementById('playerTeamPower').textContent = `+${teamBonusPct.toFixed(1)}%`;
    document.getElementById('playerTeamCount').textContent = employeeCount || 0;
    
    // Use preloaded image if available, otherwise show placeholder
    const preloadedImage = getPreloadedBossImage(locationId);
    const bossImageEl = document.getElementById('bossImage');
    const placeholderEl = document.getElementById('bossImagePlaceholder');
    
    if (preloadedImage) {
      // Use preloaded image immediately
      bossImageEl.src = preloadedImage;
      bossImageEl.style.display = 'block';
      placeholderEl.style.display = 'none';
      console.log('Using preloaded boss image');
    } else {
      // Show placeholder while generating
      placeholderEl.style.display = 'flex';
      bossImageEl.style.display = 'none';
      
      // Generate new image asynchronously
      if (typeof generateImage === 'function') {
        generateImage({ prompt: boss.appearance.prompt }).then(imageUrl => {
          if (imageUrl && bossFightState) { // Only update if fight still active
            bossImageEl.src = imageUrl;
            bossImageEl.style.display = 'block';
            placeholderEl.style.display = 'none';
          }
        }).catch(error => {
          console.error('Boss image generation failed:', error);
        });
      }
    }
    
    // Clear combat log
    document.getElementById('combatLog').innerHTML = '<div style="color:#00d4ff;">⚔️ Combat begins!</div>';
    
    // Start fight timer (boss attacks every 3 seconds)
    let lastBossAttack = Date.now();
    bossFightInterval = setInterval(() => {
      if (!bossFightState) {
        clearInterval(bossFightInterval);
        return;
      }
      
      // Countdown timer
      bossFightState.timeRemaining -= 1;
      document.getElementById('bossTimeRemaining').textContent = bossFightState.timeRemaining;
      
      // Player regenerates stamina based on defense
      const regenAmount = (bossFightState.playerDefense / 100) * 0.5; // 0.5% of defense per second
      bossFightState.playerStamina = Math.min(100, bossFightState.playerStamina + regenAmount);
      updateBossFightUI();
      
      // Boss attacks every 3 seconds
      if (Date.now() - lastBossAttack >= 3000) {
        bossFightBossAttack();
        lastBossAttack = Date.now();
      }
      
      // Check time limit
      if (bossFightState.timeRemaining <= 0) {
        bossFightDefeat('Time ran out!');
      }
      
      // Check player stamina
      if (bossFightState.playerStamina <= 0) {
        bossFightDefeat('Your stamina depleted!');
      }
    }, 1000);
    
    // Log fight start
    addToCombatLog(`🎯 Facing ${boss.name}!`, '#00d4ff');
  }
  
  /**
   * Player attacks boss
   */
  function bossFightAttack() {
    if (!bossFightState) return;
    
    const damage = bossFightState.playerAttack + (Math.random() * 50 - 25); // ±25 variance
    bossFightState.bossHealth -= damage;
    bossFightState.damageDealt += damage;
    
    // Occasionally show team support messages (20% chance)
    const showTeamSupport = Math.random() < 0.2 && bossFightState.employeeCount > 0;
    
    if (showTeamSupport) {
      const teamMessages = [
        `💪 Your team rallies behind you! ${Math.floor(damage)} damage!`,
        `🤝 Your employees boost your attack! ${Math.floor(damage)} damage!`,
        `⭐ Team synergy! ${Math.floor(damage)} damage!`,
        `👥 Your staff empowers your strike! ${Math.floor(damage)} damage!`,
        `✨ United effort! ${Math.floor(damage)} damage!`
      ];
      addToCombatLog(teamMessages[Math.floor(Math.random() * teamMessages.length)], '#ff6b9d');
    } else {
      // Normal attack message
      addToCombatLog(`⚔️ You attack for ${Math.floor(damage)} damage!`, '#e94560');
    }
    
    // Update UI
    updateBossFightUI();
    
    // Check if boss defeated
    if (bossFightState.bossHealth <= 0) {
      bossFightVictory();
      return;
    }
    
    // Update dialogue at 50% health
    if (bossFightState.bossHealth <= bossFightState.bossMaxHealth * 0.5 && bossFightState.bossHealth + damage > bossFightState.bossMaxHealth * 0.5) {
      document.getElementById('bossDialogue').textContent = `"${bossFightState.boss.dialogue.mid}"`;
    }
  }
  
  /**
   * Boss attacks player
   */
  function bossFightBossAttack() {
    if (!bossFightState) return;
    
    const damage = 25 + (Math.random() * 15); // 25-40 stamina damage
    bossFightState.playerStamina -= damage;
    bossFightState.damageReceived += damage;
    
    addToCombatLog(`💥 ${bossFightState.boss.name} strikes! -${Math.floor(damage)} stamina`, '#ff6b9d');
    
    updateBossFightUI();
    
    // Check if player defeated
    if (bossFightState.playerStamina <= 0) {
      bossFightDefeat('Your stamina was depleted!');
    }
  }
  
  /**
   * Update boss fight UI
   */
  function updateBossFightUI() {
    if (!bossFightState) return;
    
    const bossHealthPct = Math.max(0, (bossFightState.bossHealth / bossFightState.bossMaxHealth) * 100);
    const playerStaminaPct = Math.max(0, bossFightState.playerStamina);
    
    document.getElementById('bossHealthBar').style.width = `${bossHealthPct}%`;
    document.getElementById('bossHealthText').textContent = `${Math.floor(bossHealthPct)}%`;
    
    document.getElementById('playerStaminaBar').style.width = `${playerStaminaPct}%`;
    document.getElementById('playerStaminaText').textContent = `${Math.floor(playerStaminaPct)}%`;
  }
  
  /**
   * Add message to combat log
   */
  function addToCombatLog(message, color = '#ddd') {
    const log = document.getElementById('combatLog');
    const entry = document.createElement('div');
    entry.style.color = color;
    entry.style.marginBottom = '5px';
    entry.textContent = message;
    log.appendChild(entry);
    
    // Auto-scroll to bottom
    log.scrollTop = log.scrollHeight;
    
    // Keep log reasonable size
    if (log.children.length > 20) {
      log.removeChild(log.firstChild);
    }
  }
  
  /**
   * Player defeats boss - Victory!
   */
  function bossFightVictory() {
    if (!bossFightState) return;
    
    // Prevent multiple victory calls
    if (bossFightState.isEnding) return;
    bossFightState.isEnding = true;
    
    clearInterval(bossFightInterval);
    
    const boss = bossFightState.boss;
    const reward = bossFightState.bossMaxHealth * boss.rewardMultiplier;
    
    // Record victory in history
    gameState.bossFights.history.push({
      bossId: boss.id,
      result: 'victory',
      timestamp: Date.now()
    });
    
    // Award rewards
    gameState.cash += reward;
    gameState.bossFights.defeated.push(boss.id);
    
    // Unlock location
    const location = gameState.locations.find(loc => loc.id === bossFightState.locationId);
    if (location) {
      location.unlocked = true;
      location.owned = true;
      
      // Unlock first product in location
      const firstProduct = gameState.products.find(p => p.locationId === location.id && p.unlockCost === 0);
      if (firstProduct) {
        firstProduct.unlocked = true;
      }
    }
    
    // Update UI
    document.getElementById('bossDialogue').textContent = `"${boss.dialogue.victory}"`;
    addToCombatLog(`🎉 VICTORY! Earned $${formatNumber(reward)}!`, '#FFD700');
    addToCombatLog(`✅ ${location.name} unlocked!`, '#4ecca3');
    
    // Disable attack button
    document.getElementById('attackBtn').disabled = true;
    document.getElementById('attackBtn').textContent = '✅ VICTORY';
    document.getElementById('attackBtn').style.background = '#4ecca3';
    
    // Change retreat to close
    document.getElementById('retreatBtn').textContent = '🎉 Continue';
    document.getElementById('retreatBtn').style.background = '#00d4ff';
    document.getElementById('retreatBtn').onclick = closeBossFight;
    
    // Save victory
    saveGame();
    
    // Refresh dashboard to show boss progress update
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
    
    showNotification(`${boss.name} defeated! ${location.name} unlocked!`);
  }
  
  /**
   * Boss defeats player
   */
  function bossFightDefeat(reason) {
    if (!bossFightState) return;
    
    // Prevent multiple defeat calls
    if (bossFightState.isEnding) return;
    bossFightState.isEnding = true;
    
    clearInterval(bossFightInterval);
    
    const boss = bossFightState.boss;
    const locationId = bossFightState.locationId;
    
    // Record defeat in history
    gameState.bossFights.history.push({
      bossId: boss.id,
      result: 'defeat',
      timestamp: Date.now()
    });
    
    addToCombatLog(`💀 DEFEAT: ${reason}`, '#e94560');
    addToCombatLog('Try upgrading your Click Power and Income!', '#aaa');
    addToCombatLog('💡 A new challenger awaits your return...', '#ffa726');
    
    document.getElementById('attackBtn').disabled = true;
    document.getElementById('attackBtn').style.opacity = '0.5';
    document.getElementById('retreatBtn').textContent = 'Close';
    document.getElementById('retreatBtn').onclick = closeBossFight;
    
    // Clear cached image so a new one will be generated on retry
    if (preloadedBossImages[locationId]) {
      delete preloadedBossImages[locationId];
    }
    // Preload new image for retry ONCE (each defeat gets a different image)
    setTimeout(() => preloadBossImage(locationId), 1000);
    
    showNotification('Defeated! Upgrade and try again.');
  }
  
  /**
   * Player retreats from fight
   */
  function bossFightRetreat() {
    if (!bossFightState) return;
    
    // Prevent multiple retreat calls
    if (bossFightState.isEnding) return;
    
    if (confirm('Are you sure you want to retreat? No progress will be saved.')) {
      bossFightState.isEnding = true;
      clearInterval(bossFightInterval);
      addToCombatLog('🏃 You retreated from battle.', '#aaa');
      
      setTimeout(closeBossFight, 1000);
    }
  }
  
  /**
   * Close boss fight modal
   */
  function closeBossFight() {
    const modal = document.getElementById('bossFightModal');
    if (modal) {
      modal.hidden = true;
      modal.style.display = 'none';
    }
    
    // Clear state
    bossFightState = null;
    if (bossFightInterval) {
      clearInterval(bossFightInterval);
      bossFightInterval = null;
    }
    
    // Reset button states
    const attackBtn = document.getElementById('attackBtn');
    attackBtn.disabled = false;
    attackBtn.textContent = '⚔️ ATTACK';
    attackBtn.style.background = '#e94560';
    attackBtn.style.opacity = '1';
    attackBtn.onclick = bossFightAttack; // Restore attack handler
    
    const retreatBtn = document.getElementById('retreatBtn');
    retreatBtn.textContent = '🏃 Retreat';
    retreatBtn.style.background = '#666';
    retreatBtn.onclick = bossFightRetreat;
    
    // Clear combat log
    document.getElementById('combatLog').innerHTML = '';
    
    // Refresh UI
    updateUI();
    updateBusinessTab();
  }

  // Employee actions
  /**
   * Emergency reset for stuck onboarding employees
   */
  function resetOnboarding(employeeId) {
    const onboardingEmployee = gameState.onboarding.find(e => e.id === employeeId);
    
    if (!onboardingEmployee) {
      showNotification('Employee not found in onboarding queue');
      return;
    }
    
    if (!confirm(`Reset onboarding for ${onboardingEmployee.name}?\n\nThis will:\n- Remove them from onboarding\n- Clear the manager slot\n- Allow you to hire a new manager\n\nThis is an emergency fix for stuck employees.`)) {
      return;
    }
    
    // Find the product they were being hired for
    const product = gameState.products.find(p => p.managerOnboarding && p.name === onboardingEmployee.productManaged);
    
    // Remove from onboarding array
    gameState.onboarding = gameState.onboarding.filter(e => e.id !== employeeId);
    
    // Clear product onboarding flag
    if (product) {
      product.managerOnboarding = false;
      product.managerHired = false;
      console.log(`Cleared onboarding flag for product: ${product.name}`);
    }
    
    // Update UI
    updatePeopleTab();
    updateProductsList();
    
    showNotification(`${onboardingEmployee.name}'s onboarding has been reset. You can now hire a new manager.`);
    
    console.log(`Emergency reset completed for ${onboardingEmployee.name} (${employeeId})`);
  }

  function handleEmployeeAction(employeeId, action) {
    const employee = gameState.employees.find(e => e.id === employeeId);
    if (!employee) return;
    
    switch (action) {
      case 'bio':
        openBioModal(employee);
        break;
      case 'gift':
        showNotification(`Gift given to ${employee.name}!`);
        // In a full implementation, this would open a gift selection
        break;
      case 'chat':
        openChat(employee);
        break;
      case 'promote':
        employee.level++;
        employee.stats.productivity = Math.min(100, employee.stats.productivity + 10);
        
        // Log promotion event
        logCompanyEvent({
          type: 'promotion',
          involvedEmployees: [employee.id],
          location: employee.locationId,
          description: `${employee.name} promoted to level ${employee.level}`,
          sentiment: 'positive',
          importance: 7
        });
        
        showNotification(`${employee.name} promoted to level ${employee.level}!`);
        updatePeopleTab();
        break;
      case 'fire':
        if (confirm(`Are you sure you want to fire ${employee.name}?`)) {
          // Remove manager from product and disable automation
          if (employee.position && employee.position.startsWith('Manager') && employee.productManaged) {
            const product = gameState.products.find(p => p.name === employee.productManaged);
            if (product) {
              product.managerHired = false;
              product.managerLevel = 0;
              product.managerOnboarding = false;
              product.running = false;
              product.timeRemainingMs = 0;
            }
          }
          
          // Change employment status to alumni (don't remove from array)
          employee.employmentStatus = 'alumni';
          employee.firedDate = Date.now();
          
          // Log fire event
          logCompanyEvent({
            type: 'fire',
            involvedEmployees: [employee.id],
            location: employee.locationId,
            description: `${employee.name} was let go`,
            sentiment: 'negative',
            importance: 8
          });
          
          // Add to recent fires
          if (!gameState.companyContext.recentFires) {
            gameState.companyContext.recentFires = [];
          }
          gameState.companyContext.recentFires.unshift({
            id: employee.id,
            name: employee.name,
            date: Date.now()
          });
          if (gameState.companyContext.recentFires.length > 5) {
            gameState.companyContext.recentFires = gameState.companyContext.recentFires.slice(0, 5);
          }
          
          // Update company awareness
          updateCompanyAwareness();
          
          showNotification(`${employee.name} has been fired.`);
          updatePeopleTab();
          updateProductsList();
        }
        break;
    }
  }
  
  // Open chat with employee
  function openChat(employee) {
    // If passed an ID string, look up the employee object
    if (typeof employee === 'string') {
      employee = gameState.employees.find(e => e.id === employee);
      if (!employee) {
        console.error('Employee not found');
        return;
      }
    }
    
    gameState.activeChat = employee;
    ensureEmployeeMemory(employee);
    
    // Clear unread messages when opening chat
    employee.unreadMessages = 0;
    
    // Hide any existing typing indicator from previous chat
    const chatTypingIndicator = $('chatTypingIndicator');
    if (chatTypingIndicator) {
      chatTypingIndicator.style.display = 'none';
    }
    
    if (chatModal) {
      chatModal.hidden = false;
      chatModal.style.display = 'flex';
      chatModal.style.pointerEvents = 'auto';
    }
    if (chatName) chatName.textContent = employee.name;
    if (chatAvatar) chatAvatar.src = employee.profileImage || 'https://placehold.co/80x80';
    
    // Initialize chat history if not exists
    if (!gameState.chatHistory[employee.id]) {
      gameState.chatHistory[employee.id] = [];
    }
    
    // Load chat history
    loadChatHistory(employee.id);
    
    // Update People tab to remove unread badge
    if (gameState.activeTab === 'people') {
      updatePeopleTab();
    }
  }
  
  // -------- BIO MODAL --------
  // Open detailed bio modal with edit capabilities
  // Helper function to create stat control buttons
  function createStatControls(elementId, currentValue, min = 0, max = 100) {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    const container = element.parentElement;
    const originalHTML = container.innerHTML;
    
    container.innerHTML = `
      <div style="display:flex; flex-direction:column; gap:6px; align-items:center;">
        <div style="font-size:1.5rem; font-weight:bold; color:inherit;">
          <span id="${elementId}">${Math.round(currentValue)}</span>%
        </div>
        <div style="display:flex; gap:2px; flex-wrap:wrap; justify-content:center;">
          <button class="stat-btn" data-change="-10" style="padding:2px 6px; background:#e94560; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&lt;&lt;&lt;</button>
          <button class="stat-btn" data-change="-5" style="padding:2px 6px; background:#ff6b9d; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&lt;&lt;</button>
          <button class="stat-btn" data-change="-1" style="padding:2px 6px; background:#ffa7c4; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&lt;</button>
          <button class="stat-btn" data-change="1" style="padding:2px 6px; background:#4ecca3; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&gt;</button>
          <button class="stat-btn" data-change="5" style="padding:2px 6px; background:#00d4ff; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&gt;&gt;</button>
          <button class="stat-btn" data-change="10" style="padding:2px 6px; background:#0096c7; border:none; border-radius:3px; color:white; font-size:0.7rem; cursor:pointer;">&gt;&gt;&gt;</button>
        </div>
      </div>
    `;
    
    // Add event listeners to buttons
    container.querySelectorAll('.stat-btn').forEach(btn => {
      btn.onclick = (e) => {
        e.stopPropagation();
        const change = parseInt(btn.dataset.change);
        const statElement = document.getElementById(elementId);
        let newValue = parseInt(statElement.textContent) + change;
        newValue = Math.max(min, Math.min(max, newValue));
        statElement.textContent = newValue;
      };
    });
    
    return originalHTML;
  }
  
  // Helper function to create dropdown control
  function createDropdownControl(elementId, currentValue, options) {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    const container = element.parentElement;
    const originalHTML = container.innerHTML;
    
    const optionsHTML = options.map(opt => 
      `<option value="${opt.value}" ${opt.value === currentValue ? 'selected' : ''}>${opt.label}</option>`
    ).join('');
    
    container.innerHTML = `
      <select id="${elementId}" style="width:100%; padding:6px; background:#16213e; border:1px solid #ffd700; border-radius:4px; color:#ffd700; font-weight:600;">
        ${optionsHTML}
      </select>
    `;
    
    return originalHTML;
  }

  function openBioModal(employee) {
    // Initialize photos array if not exists
    if (!employee.photos) employee.photos = [];
    
    const modal = document.createElement('div');
    modal.id = 'bioModal';
    // Don't set inline styles - ModalManager will handle it
    modal.style.background = 'rgba(0,0,0,0.8)';
    
    const isEditing = false; // Toggle state
    
    // Helper to safely get nested values
    const getNestedValue = (obj, path, defaultVal = '') => {
      const parts = path.split('.');
      let current = obj;
      for (const part of parts) {
        if (current && current[part] !== undefined) {
          current = current[part];
        } else {
          return defaultVal;
        }
      }
      return current;
    };
    
    modal.innerHTML = `
      <div class="bio-modal-content" style="background:#16213e; width:92%; max-width:900px; max-height:90vh; border-radius:15px; box-shadow:0 5px 25px rgba(0,0,0,0.5); display:flex; flex-direction:column; overflow:hidden;">
        <!-- Header -->
        <div style="padding:20px; border-bottom:1px solid #0f3460; display:flex; justify-content:space-between; align-items:center;">
          <h2 style="margin:0; color:#fff;">Employee Profile</h2>
          <div style="display:flex; gap:10px; align-items:center;">
            <button id="bioEditToggle" style="background:#00d4ff; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; color:#0f1419; font-weight:600; display:flex; align-items:center; gap:6px;">
              <span style="font-size:1.1rem;">✏️</span> Edit
            </button>
            <button id="closeBioModal" style="background:transparent; border:none; color:white; font-size:1.5rem; cursor:pointer;">✕</button>
          </div>
        </div>
        
        <!-- Content -->
        <div style="flex:1; overflow-y:auto; padding:20px;">
          <!-- Profile Header -->
          <div style="display:flex; gap:20px; margin-bottom:25px; align-items:start;">
            <img src="${employee.profileImage || 'https://placehold.co/150x150'}" style="width:120px; height:120px; border-radius:10px; object-fit:cover; box-shadow:0 2px 10px rgba(0,0,0,0.3);">
            <div style="flex:1;">
              <h3 id="bioName" contenteditable="false" style="margin:0 0 8px 0; font-size:1.8rem; outline:none; padding:4px; border-radius:4px;" data-field="name">${getColoredName(employee)}</h3>
              <p style="margin:0 0 6px 0; color:#aaa;">
                <span id="bioAge" contenteditable="false" style="outline:none; padding:2px 4px; border-radius:4px;" data-field="age">${employee.age || 'N/A'}</span> years old • 
                <span id="bioGender" contenteditable="false" style="outline:none; padding:2px 4px; border-radius:4px; color:${getGenderColor(employee.gender)};" data-field="gender">${employee.gender || 'Female'}</span>
              </p>
              <p style="margin:0; color:#00d4ff; font-weight:600;">
                <span id="bioPosition" contenteditable="false" style="outline:none; padding:2px 4px; border-radius:4px;" data-field="position">${employee.position || 'Employee'}</span>
              </p>
              ${employee.productManaged ? `<p style="margin:4px 0 0 0; color:#aaa;">Product: <span id="bioProduct" contenteditable="false" style="outline:none; padding:2px 4px; border-radius:4px;" data-field="productManaged">${employee.productManaged}</span></p>` : ''}
            </div>
          </div>
          
          <!-- Bio Section -->
          <div style="margin-bottom:25px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">Biography</h4>
            <p id="bioBio" contenteditable="false" style="margin:0; color:#ddd; line-height:1.6; padding:12px; background:#0f3460; border-radius:6px; outline:none; min-height:60px;" data-field="bio">${employee.bio || 'No biography available.'}</p>
          </div>
          
          <!-- Main Stats Section -->
          <div style="margin-bottom:25px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">Primary Statistics</h4>
            <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Affection
                  <span style="cursor:help; font-size:0.9rem;" title="How much they like you personally. Affects conversation warmth, willingness to chat, and proactive messages. Increases with compliments and positive interactions.">ℹ️</span>
                </div>
                <div style="color:#e94560; font-weight:600; font-size:1.2rem;">
                  <span id="bioAffection" contenteditable="false" style="outline:none;" data-field="stats.affection">${Math.round(employee.stats?.affection ?? 0)}</span>%
                </div>
              </div>
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Comfort
                  <span style="cursor:help; font-size:0.9rem;" title="How relaxed they feel around you. Affects openness in conversations, photo sharing willingness, and memory formation. Low comfort reduces productivity. Build with consistent positive interactions.">ℹ️</span>
                </div>
                <div style="color:#4ecca3; font-weight:600; font-size:1.2rem;">
                  <span id="bioComfort" contenteditable="false" style="outline:none;" data-field="stats.comfort">${Math.round(employee.stats?.comfort ?? 0)}</span>%
                </div>
              </div>
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Trust
                  <span style="cursor:help; font-size:0.9rem;" title="How much they believe in you. CRITICAL STAT: Directly boosts manager efficiency (up to +30% speed at 100 trust). Required for promotions. Build with consistent actions and keeping promises.">ℹ️</span>
                </div>
                <div style="color:#00d4ff; font-weight:600; font-size:1.2rem;">
                  <span id="bioTrust" contenteditable="false" style="outline:none;" data-field="stats.trust">${Math.round(employee.stats?.trust ?? 0)}</span>%
                </div>
              </div>
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Desire
                  <span style="cursor:help; font-size:0.9rem;" title="Romantic/sexual attraction level. Affects conversation flavor and flirtiness. Unlocks intimate content at higher levels (60+ for suggestive, 75+ for intimate). Build with flirting and compliments.">ℹ️</span>
                </div>
                <div style="color:#ff6b9d; font-weight:600; font-size:1.2rem;">
                  <span id="bioDesire" contenteditable="false" style="outline:none;" data-field="stats.desire">${Math.round(employee.stats?.desire ?? 0)}</span>%
                </div>
              </div>
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Obedience
                  <span style="cursor:help; font-size:0.9rem;" title="Willingness to follow directions. Increases request success rate (posts, photos, favors). Improves manager consistency (+8% at 100). Balance is key - too high/low can reduce productivity.">ℹ️</span>
                </div>
                <div style="color:#c77dff; font-weight:600; font-size:1.2rem;">
                  <span id="bioObedience" contenteditable="false" style="outline:none;" data-field="stats.obedience">${Math.round(employee.stats?.obedience ?? 0)}</span>%
                </div>
              </div>
              <div style="background:#0f3460; padding:12px; border-radius:6px;">
                <div style="font-size:.75rem; color:#aaa; margin-bottom:4px; display:flex; align-items:center; gap:4px;">
                  Productivity
                  <span style="cursor:help; font-size:0.9rem;" title="Work efficiency. CRITICAL STAT: Directly boosts manager speed (+15% at 100) AND income (+20% at 100). Affected by comfort and trust. Essential for maximizing earnings.">ℹ️</span>
                </div>
                <div style="color:#ffd700; font-weight:600; font-size:1.2rem;">
                  <span id="bioProductivity" contenteditable="false" style="outline:none;" data-field="stats.productivity">${Math.round(employee.stats?.productivity ?? 0)}</span>%
                </div>
              </div>
            </div>
          </div>
          
          <!-- Hidden Stats Section (only visible in edit mode) -->
          <div id="hiddenStatsSection" style="margin-bottom:25px; display:none;">
            <h4 style="margin:0 0 10px 0; color:#ffd700;">🔓 Advanced Stats (Sandbox Mode)</h4>
            
            <!-- Personality Attributes (AI uses these!) -->
            <div style="margin-bottom:15px;">
              <div style="font-size:.9rem; color:#ffd700; margin-bottom:8px; font-weight:600;">Personality Attributes (0-100)</div>
              <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Confidence</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioConfidence" contenteditable="false" style="outline:none;" data-field="personality.confidence">${Math.round(employee.personality?.confidence ?? 50)}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Outgoing</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioOutgoing" contenteditable="false" style="outline:none;" data-field="personality.outgoing">${Math.round(employee.personality?.outgoing ?? 50)}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Flirty</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioFlirty" contenteditable="false" style="outline:none;" data-field="personality.flirty">${Math.round(employee.personality?.flirty ?? 50)}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Professional</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioProfessional" contenteditable="false" style="outline:none;" data-field="personality.professional">${Math.round(employee.personality?.professional ?? 50)}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Humor</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioHumor" contenteditable="false" style="outline:none;" data-field="personality.humor">${Math.round(employee.personality?.humor ?? 50)}</span>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- System Stats -->
            <div style="margin-bottom:15px;">
              <div style="font-size:.9rem; color:#ffd700; margin-bottom:8px; font-weight:600;">System Stats</div>
              <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Intimacy Level</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioIntimacy" contenteditable="false" style="outline:none;" data-field="intimacy">${Math.round(employee.intimacy ?? 0)}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Memory Cap <span style="cursor:help;" title="Max memories this NPC can store. Increasing this allows them to remember more context in conversations.">ℹ️</span></div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioMemoryCap" contenteditable="false" style="outline:none;" data-field="memory.cap">${employee.memory?.cap ?? 300}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Conversation Phase</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioConversationPhase" contenteditable="false" style="outline:none;" data-field="memory.conversationPhase">${employee.memory?.conversationPhase ?? 'early'}</span>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Career Stats -->
            <div>
              <div style="font-size:.9rem; color:#ffd700; margin-bottom:8px; font-weight:600;">Career Stats</div>
              <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Loyalty Bonus</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioLoyaltyBonus" contenteditable="false" style="outline:none;" data-field="loyaltyBonus">${((employee.loyaltyBonus ?? 0) * 100).toFixed(0)}</span>%
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Times Rehired</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioTimesRehired" contenteditable="false" style="outline:none;" data-field="timesRehired">${employee.timesRehired ?? 0}</span>
                  </div>
                </div>
                <div style="background:rgba(255,215,0,0.1); padding:12px; border-radius:6px; border:1px solid #ffd700;">
                  <div style="font-size:.75rem; color:#ffd700; margin-bottom:4px;">Employment Status</div>
                  <div style="color:#ffd700; font-weight:600; font-size:1.1rem;">
                    <span id="bioEmploymentStatus" contenteditable="false" style="outline:none;" data-field="employmentStatus">${employee.employmentStatus ?? 'active'}</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Personality & Traits -->
          <div style="margin-bottom:25px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">Personality & Interests</h4>
            <div style="background:#0f3460; padding:15px; border-radius:6px;">
              <div style="margin-bottom:12px;">
                <div style="font-size:.85rem; color:#aaa; margin-bottom:6px;">Personality Traits</div>
                <div id="bioPersonality" contenteditable="false" style="outline:none; padding:4px; border-radius:4px;" data-field="personalityTraits">${(() => {
                  if (Array.isArray(employee.personalityTraits)) {
                    return employee.personalityTraits.join(', ');
                  } else if (employee.personality && typeof employee.personality === 'object') {
                    return Object.entries(employee.personality).map(([key, val]) => `${key}: ${val}`).join(', ');
                  } else if (Array.isArray(employee.personality)) {
                    return employee.personality.join(', ');
                  }
                  return 'None listed';
                })()}</div>
              </div>
              <div style="margin-bottom:12px;">
                <div style="font-size:.85rem; color:#aaa; margin-bottom:6px;">Hobbies</div>
                <div id="bioHobbies" contenteditable="false" style="outline:none; padding:4px; border-radius:4px;" data-field="hobbies">${Array.isArray(employee.hobbies) ? employee.hobbies.join(', ') : 'None listed'}</div>
              </div>
              <div style="margin-bottom:12px;">
                <div style="font-size:.85rem; color:#aaa; margin-bottom:6px;">Preferences</div>
                <div id="bioKinks" contenteditable="false" style="outline:none; padding:4px; border-radius:4px;" data-field="kinks">${Array.isArray(employee.kinks) ? employee.kinks.join(', ') : 'None listed'}</div>
              </div>
              <div>
                <div style="font-size:.85rem; color:#aaa; margin-bottom:6px;">Key Trait</div>
                <div id="bioKeyTrait" contenteditable="false" style="outline:none; padding:4px; border-radius:4px;" data-field="keyTrait">${employee.keyTrait || employee.traits?.[0] || 'None listed'}</div>
              </div>
            </div>
          </div>
          
          <!-- Physical Appearance -->
          <div style="margin-bottom:25px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">Physical Appearance</h4>
            <div style="background:#0f3460; padding:15px; border-radius:6px;">
              ${employee.physical?.fullDescription ? `
              <div style="margin-bottom:15px; padding:12px; background:rgba(0,212,255,0.1); border-left:3px solid #00d4ff; border-radius:4px;">
                <div style="font-size:.85rem; color:#00d4ff; margin-bottom:6px; font-weight:600;">✨ Full Description</div>
                <div id="bioPhysicalFull" contenteditable="false" style="color:#ddd; line-height:1.6; font-size:.95rem; outline:none;" data-field="physical.fullDescription">${employee.physical.fullDescription}</div>
              </div>
              ` : ''}
              
              <!-- Detailed Breakdown -->
              <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:12px;">
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Height & Build</div>
                  <div id="bioHeightBuild" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.heightBuild">${getNestedValue(employee, 'physical.heightBuild', 'Average')}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Body Shape</div>
                  <div id="bioBodyShape" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.body.shape">${getNestedValue(employee, 'physical.body.shape', getNestedValue(employee, 'physical.bodyShape', 'Average'))}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Hair</div>
                  <div id="bioHair" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.hair.full">${getNestedValue(employee, 'physical.hair.full', 'Not specified')}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Eyes</div>
                  <div id="bioEyes" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.eyes.full">${getNestedValue(employee, 'physical.eyes.full', 'Not specified')}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Face</div>
                  <div id="bioFace" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.face.full">${getNestedValue(employee, 'physical.face.full', getNestedValue(employee, 'physical.face.shape', 'Not specified'))}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Skin</div>
                  <div id="bioSkin" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.skin.full">${getNestedValue(employee, 'physical.skin.full', getNestedValue(employee, 'physical.skin.tone', getNestedValue(employee, 'physical.skinTone', 'Not specified')))}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Fashion Style</div>
                  <div id="bioFashion" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.fashion">${getNestedValue(employee, 'physical.fashion', 'Casual')}</div>
                </div>
                <div>
                  <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Distinguishing Feature</div>
                  <div id="bioDistinguishing" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.distinguishingFeature">${getNestedValue(employee, 'physical.distinguishingFeature', 'None noted')}</div>
                </div>
              </div>
              
              <!-- Genital Information (for image generation) -->
              <div style="margin-top:15px; padding-top:15px; border-top:1px solid rgba(255,215,0,0.2);">
                <div style="font-size:.9rem; color:#ffd700; margin-bottom:8px; font-weight:600;">🔞 Genital Information</div>
                <div style="font-size:.75rem; color:#aaa; margin-bottom:10px; font-style:italic;">Used for accurate image generation</div>
                <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:12px;">
                  <div>
                    <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Type</div>
                    <div id="bioGenitalType" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.genitals.type">${getNestedValue(employee, 'physical.genitals.type', 'Not specified')}</div>
                  </div>
                  <div>
                    <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Size</div>
                    <div id="bioGenitalSize" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.genitals.size">${getNestedValue(employee, 'physical.genitals.size', 'Not specified')}</div>
                  </div>
                  <div>
                    <div style="font-size:.85rem; color:#aaa; margin-bottom:4px;">Characteristics</div>
                    <div id="bioGenitalCharacteristics" contenteditable="false" style="color:#ddd; outline:none; padding:2px;" data-field="physical.genitals.characteristics">${getNestedValue(employee, 'physical.genitals.characteristics', 'Not specified')}</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Photo Gallery -->
          <div style="margin-bottom:20px;">
            <h4 style="margin:0 0 10px 0; color:#00d4ff;">Photo Gallery</h4>
            <div id="bioPhotoGallery" style="display:grid; grid-template-columns:repeat(auto-fill,minmax(150px,1fr)); gap:10px; background:#0f3460; padding:15px; border-radius:6px; min-height:100px;">
              ${employee.photos && employee.photos.length > 0 
                ? employee.photos.map(photo => `<img src="${photo}" style="width:100%; aspect-ratio:1; object-fit:cover; border-radius:6px; cursor:pointer;" onclick="window.open('${photo}', '_blank')">`).join('')
                : '<p style="color:#aaa; margin:0;">No photos yet. Photos will appear here as they are generated.</p>'}
            </div>
          </div>
        </div>
        
        <!-- Footer -->
        <div style="padding:15px; border-top:1px solid #0f3460; display:flex; justify-content:flex-end; gap:10px;">
          <button id="bioSaveBtn" style="display:none; padding:10px 20px; background:#4ecca3; border:none; border-radius:6px; color:#0f1419; font-weight:600; cursor:pointer;">💾 Save Changes</button>
          <button id="bioCancelBtn" style="display:none; padding:10px 20px; background:#e94560; border:none; border-radius:6px; color:#fff; font-weight:600; cursor:pointer;">✖️ Cancel</button>
        </div>
      </div>
    `;
    
    // Use ModalManager to show the modal with proper z-index management
    ModalManager.show(modal, 'bioModal');
    
    // Edit toggle functionality
    let editMode = false;
    let originalHTMLs = new Map(); // Store original HTML for restoration
    const editToggle = modal.querySelector('#bioEditToggle');
    const saveBtn = modal.querySelector('#bioSaveBtn');
    const cancelBtn = modal.querySelector('#bioCancelBtn');
    const editableElements = modal.querySelectorAll('[contenteditable]');
    const hiddenStatsSection = modal.querySelector('#hiddenStatsSection');
    
    editToggle.onclick = () => {
      editMode = !editMode;
      
      if (editMode) {
        // Enter edit mode (SANDBOX MODE)
        editToggle.innerHTML = '<span style="font-size:1.1rem;">🔒</span> View';
        editToggle.style.background = '#ffd700';
        editToggle.style.color = '#0f1419';
        saveBtn.style.display = 'block';
        cancelBtn.style.display = 'block';
        
        // Show hidden stats section
        if (hiddenStatsSection) {
          hiddenStatsSection.style.display = 'block';
        }
        
        // Make text fields editable
        editableElements.forEach(el => {
          // Skip stat values - they get buttons instead
          if (!el.id || !el.id.startsWith('bio') || el.id.includes('Name') || el.id.includes('Bio') || el.id.includes('Personality') || el.id.includes('Hobbies') || el.id.includes('Kinks') || el.id.includes('KeyTrait') || el.id.includes('Position') || el.id.includes('Age') || el.id.includes('Gender') || el.id.includes('Product') || el.id.includes('Physical') || el.id.includes('Height') || el.id.includes('Body') || el.id.includes('Hair') || el.id.includes('Eyes') || el.id.includes('Face') || el.id.includes('Skin') || el.id.includes('Fashion') || el.id.includes('Distinguishing') || el.id.includes('Genital')) {
            el.contentEditable = 'true';
            el.style.background = 'rgba(255, 215, 0, 0.15)';
            el.style.border = '1px dashed #ffd700';
            el.style.padding = '4px';
          }
        });
        
        // Add increment controls for primary stats
        originalHTMLs.set('bioAffection', createStatControls('bioAffection', employee.stats?.affection ?? 0));
        originalHTMLs.set('bioComfort', createStatControls('bioComfort', employee.stats?.comfort ?? 0));
        originalHTMLs.set('bioTrust', createStatControls('bioTrust', employee.stats?.trust ?? 0));
        originalHTMLs.set('bioDesire', createStatControls('bioDesire', employee.stats?.desire ?? 0));
        originalHTMLs.set('bioObedience', createStatControls('bioObedience', employee.stats?.obedience ?? 0));
        originalHTMLs.set('bioProductivity', createStatControls('bioProductivity', employee.stats?.productivity ?? 0));
        
        // Add increment controls for hidden stats
        originalHTMLs.set('bioIntimacy', createStatControls('bioIntimacy', employee.intimacy ?? 0));
        originalHTMLs.set('bioMemoryCap', createStatControls('bioMemoryCap', employee.memory?.cap ?? 300, 50, 1000));
        originalHTMLs.set('bioTimesRehired', createStatControls('bioTimesRehired', employee.timesRehired ?? 0, 0, 100));
        originalHTMLs.set('bioLoyaltyBonus', createStatControls('bioLoyaltyBonus', (employee.loyaltyBonus ?? 0) * 100, 0, 50));
        
        // Add increment controls for personality attributes
        originalHTMLs.set('bioConfidence', createStatControls('bioConfidence', employee.personality?.confidence ?? 50, 0, 100));
        originalHTMLs.set('bioOutgoing', createStatControls('bioOutgoing', employee.personality?.outgoing ?? 50, 0, 100));
        originalHTMLs.set('bioFlirty', createStatControls('bioFlirty', employee.personality?.flirty ?? 50, 0, 100));
        originalHTMLs.set('bioProfessional', createStatControls('bioProfessional', employee.personality?.professional ?? 50, 0, 100));
        originalHTMLs.set('bioHumor', createStatControls('bioHumor', employee.personality?.humor ?? 50, 0, 100));
        
        // Add dropdowns for enum fields
        originalHTMLs.set('bioConversationPhase', createDropdownControl('bioConversationPhase', employee.memory?.conversationPhase ?? 'early', [
          { value: 'early', label: 'Early (Getting to know you)' },
          { value: 'familiar', label: 'Familiar (Comfortable)' },
          { value: 'intimate', label: 'Intimate (Very close)' }
        ]));
        
        originalHTMLs.set('bioEmploymentStatus', createDropdownControl('bioEmploymentStatus', employee.employmentStatus ?? 'active', [
          { value: 'active', label: 'Active (Working)' },
          { value: 'candidate', label: 'Candidate (Not hired yet)' },
          { value: 'onboarding', label: 'Onboarding (In training)' },
          { value: 'former', label: 'Former (Left company)' }
        ]));
        
        // Add dropdowns for genital information (gender-specific options)
        const gender = employee.gender || 'Female';
        
        // Genital Type options based on gender
        let typeOptions = [];
        if (gender === 'Male') {
          typeOptions = [
            { value: 'penis', label: 'Penis' }
          ];
        } else if (gender === 'Trans Man') {
          typeOptions = [
            { value: 'enlarged clitoris', label: 'Enlarged Clitoris (Pre-HRT)' },
            { value: 'post-op penis', label: 'Post-Op Penis (Phalloplasty)' },
            { value: 'pre-op anatomy', label: 'Pre-Op Anatomy' }
          ];
        } else if (gender === 'Female Futa') {
          typeOptions = [
            { value: 'penis and vagina', label: 'Penis and Vagina (Dual)' }
          ];
        } else if (gender === 'Trans Woman') {
          typeOptions = [
            { value: 'vagina (post-op)', label: 'Vagina (Post-Op)' },
            { value: 'penis (pre-op)', label: 'Penis (Pre-Op)' },
            { value: 'tucked', label: 'Tucked (HRT)' }
          ];
        } else { // Female
          typeOptions = [
            { value: 'vagina', label: 'Vagina' }
          ];
        }
        
        // Genital Size options based on gender and type
        let sizeOptions = [];
        const currentType = employee.physical?.genitals?.type || typeOptions[0]?.value || 'vagina';
        
        if (currentType.includes('penis') && !currentType.includes('vagina')) {
          if (gender === 'Trans Man' && currentType === 'post-op penis') {
            sizeOptions = [
              { value: 'small', label: 'Small (Typical for phalloplasty)' },
              { value: 'modest', label: 'Modest' },
              { value: 'average', label: 'Average' }
            ];
          } else {
            sizeOptions = [
              { value: 'small', label: 'Small' },
              { value: 'modest', label: 'Modest' },
              { value: 'average', label: 'Average' },
              { value: 'above average', label: 'Above Average' },
              { value: 'large', label: 'Large' },
              { value: 'very large', label: 'Very Large' }
            ];
          }
        } else if (currentType === 'penis and vagina') {
          sizeOptions = [
            { value: 'average', label: 'Average' },
            { value: 'above average', label: 'Above Average' },
            { value: 'large', label: 'Large' },
            { value: 'very large', label: 'Very Large' },
            { value: 'impressive', label: 'Impressive' }
          ];
        } else if (currentType.includes('vagina') || currentType === 'pre-op anatomy') {
          sizeOptions = [
            { value: 'tight', label: 'Tight' },
            { value: 'snug', label: 'Snug' },
            { value: 'average', label: 'Average' },
            { value: 'relaxed', label: 'Relaxed' },
            { value: 'accommodating', label: 'Accommodating' }
          ];
        } else if (currentType === 'enlarged clitoris') {
          sizeOptions = [
            { value: 'slightly enlarged', label: 'Slightly Enlarged' },
            { value: 'noticeably enlarged', label: 'Noticeably Enlarged' },
            { value: 'significantly enlarged', label: 'Significantly Enlarged' }
          ];
        } else {
          sizeOptions = [
            { value: 'average', label: 'Average' }
          ];
        }
        
        // Characteristics options based on gender and type
        let characteristicsOptions = [];
        
        if (currentType.includes('penis') && !currentType.includes('vagina')) {
          characteristicsOptions = [
            { value: 'circumcised', label: 'Circumcised' },
            { value: 'uncircumcised', label: 'Uncircumcised' }
          ];
        } else if (currentType === 'penis and vagina') {
          characteristicsOptions = [
            { value: 'fully functional dual anatomy', label: 'Fully Functional Dual Anatomy' },
            { value: 'prominent dual features', label: 'Prominent Dual Features' }
          ];
        } else if (currentType.includes('vagina') || currentType === 'pre-op anatomy') {
          characteristicsOptions = [
            { value: 'waxed smooth', label: 'Waxed Smooth' },
            { value: 'neatly trimmed', label: 'Neatly Trimmed' },
            { value: 'natural', label: 'Natural' },
            { value: 'fully shaved', label: 'Fully Shaved' },
            { value: 'landing strip', label: 'Landing Strip' },
            { value: 'shaped', label: 'Shaped' }
          ];
        } else if (currentType === 'enlarged clitoris') {
          characteristicsOptions = [
            { value: 'sensitive and prominent', label: 'Sensitive and Prominent' },
            { value: 'HRT-enhanced', label: 'HRT-Enhanced' }
          ];
        } else if (currentType === 'tucked') {
          characteristicsOptions = [
            { value: 'carefully tucked', label: 'Carefully Tucked' },
            { value: 'HRT-softened', label: 'HRT-Softened' }
          ];
        } else {
          characteristicsOptions = [
            { value: 'natural', label: 'Natural' }
          ];
        }
        
        originalHTMLs.set('bioGenitalType', createDropdownControl('bioGenitalType', employee.physical?.genitals?.type ?? typeOptions[0]?.value, typeOptions));
        originalHTMLs.set('bioGenitalSize', createDropdownControl('bioGenitalSize', employee.physical?.genitals?.size ?? sizeOptions[0]?.value, sizeOptions));
        originalHTMLs.set('bioGenitalCharacteristics', createDropdownControl('bioGenitalCharacteristics', employee.physical?.genitals?.characteristics ?? characteristicsOptions[0]?.value, characteristicsOptions));
        
      } else {
        // Exit edit mode without saving - restore original HTML
        editToggle.innerHTML = '<span style="font-size:1.1rem;">✏️</span> Edit';
        editToggle.style.background = '#00d4ff';
        editToggle.style.color = '#0f1419';
        saveBtn.style.display = 'none';
        cancelBtn.style.display = 'none';
        
        // Hide hidden stats section
        if (hiddenStatsSection) {
          hiddenStatsSection.style.display = 'none';
        }
        
        // Restore original HTML for all modified elements
        originalHTMLs.forEach((html, elementId) => {
          const element = document.getElementById(elementId);
          if (element && element.parentElement) {
            element.parentElement.innerHTML = html;
          }
        });
        originalHTMLs.clear();
        
        editableElements.forEach(el => {
          el.contentEditable = 'false';
          el.style.background = '';
          el.style.border = '';
          el.style.padding = '';
        });
      }
    };
    
    // Save changes
    saveBtn.onclick = () => {
      // Read from stat buttons/dropdowns first
      const statIds = ['bioAffection', 'bioComfort', 'bioTrust', 'bioDesire', 'bioObedience', 'bioProductivity'];
      statIds.forEach(id => {
        const el = document.getElementById(id);
        if (el && employee.stats) {
          const statName = id.replace('bio', '').toLowerCase();
          employee.stats[statName] = parseInt(el.textContent) || 0;
        }
      });
      
      // Read hidden stats
      const intimacyEl = document.getElementById('bioIntimacy');
      if (intimacyEl) employee.intimacy = parseInt(intimacyEl.textContent) || 0;
      
      const memoryCapEl = document.getElementById('bioMemoryCap');
      if (memoryCapEl) {
        if (!employee.memory) employee.memory = {};
        employee.memory.cap = parseInt(memoryCapEl.textContent) || 300;
      }
      
      const timesRehiredEl = document.getElementById('bioTimesRehired');
      if (timesRehiredEl) employee.timesRehired = parseInt(timesRehiredEl.textContent) || 0;
      
      const loyaltyBonusEl = document.getElementById('bioLoyaltyBonus');
      if (loyaltyBonusEl) employee.loyaltyBonus = (parseInt(loyaltyBonusEl.textContent) || 0) / 100;
      
      // Read personality attributes
      if (!employee.personality) employee.personality = {};
      const confidenceEl = document.getElementById('bioConfidence');
      if (confidenceEl) employee.personality.confidence = parseInt(confidenceEl.textContent) || 50;
      
      const outgoingEl = document.getElementById('bioOutgoing');
      if (outgoingEl) employee.personality.outgoing = parseInt(outgoingEl.textContent) || 50;
      
      const flirtyEl = document.getElementById('bioFlirty');
      if (flirtyEl) employee.personality.flirty = parseInt(flirtyEl.textContent) || 50;
      
      const professionalEl = document.getElementById('bioProfessional');
      if (professionalEl) employee.personality.professional = parseInt(professionalEl.textContent) || 50;
      
      const humorEl = document.getElementById('bioHumor');
      if (humorEl) employee.personality.humor = parseInt(humorEl.textContent) || 50;
      
      // Read dropdowns
      const conversationPhaseEl = document.getElementById('bioConversationPhase');
      if (conversationPhaseEl && employee.memory) {
        employee.memory.conversationPhase = conversationPhaseEl.value || 'early';
      }
      
      const employmentStatusEl = document.getElementById('bioEmploymentStatus');
      if (employmentStatusEl) {
        employee.employmentStatus = employmentStatusEl.value || 'active';
      }
      
      // Read genital information dropdowns
      const genitalTypeEl = document.getElementById('bioGenitalType');
      const genitalSizeEl = document.getElementById('bioGenitalSize');
      const genitalCharacteristicsEl = document.getElementById('bioGenitalCharacteristics');
      
      if (genitalTypeEl || genitalSizeEl || genitalCharacteristicsEl) {
        if (!employee.physical) employee.physical = {};
        if (!employee.physical.genitals) employee.physical.genitals = {};
        
        if (genitalTypeEl) {
          employee.physical.genitals.type = genitalTypeEl.value || 'Not specified';
        }
        if (genitalSizeEl) {
          employee.physical.genitals.size = genitalSizeEl.value || 'Not specified';
        }
        if (genitalCharacteristicsEl) {
          employee.physical.genitals.characteristics = genitalCharacteristicsEl.value || 'Not specified';
        }
        
        // Update the full description
        if (employee.physical.genitals.type && employee.physical.genitals.size && employee.physical.genitals.characteristics) {
          employee.physical.genitals.full = `${employee.physical.genitals.size} ${employee.physical.genitals.type}, ${employee.physical.genitals.characteristics}`;
          
          // Also update fullDescription if it exists
          if (employee.physical.fullDescription) {
            // Replace the genitals line in fullDescription
            const genitalLine = `Genitals: ${employee.physical.genitals.full}`;
            const genitalRegex = /Genitals:.*?(?=\n|$)/;
            if (genitalRegex.test(employee.physical.fullDescription)) {
              employee.physical.fullDescription = employee.physical.fullDescription.replace(genitalRegex, genitalLine);
            } else {
              // Add it if not present
              employee.physical.fullDescription += `\nGenitals: ${employee.physical.genitals.full}`;
            }
          }
        }
      }
      
      // Read from text fields
      editableElements.forEach(el => {
        const field = el.dataset.field;
        const value = el.textContent.trim();
        
        if (field) {
          // Handle nested fields (e.g., "stats.affection", "physical.hair.full")
          const parts = field.split('.');
          let target = employee;
          
          for (let i = 0; i < parts.length - 1; i++) {
            if (!target[parts[i]]) target[parts[i]] = {};
            target = target[parts[i]];
          }
          
          const lastPart = parts[parts.length - 1];
          
          // Special handling for different field types
          if (field === 'personalityTraits' || field === 'hobbies' || field === 'kinks') {
            // Arrays - split by comma
            target[lastPart] = value.split(',').map(s => s.trim()).filter(Boolean);
          } 
          else if (field === 'age') {
            // Integer
            target[lastPart] = parseInt(value) || 0;
          }
          else if (!field.startsWith('stats.') && field !== 'intimacy' && field !== 'memory.cap' && field !== 'timesRehired' && field !== 'loyaltyBonus' && field !== 'memory.conversationPhase' && field !== 'employmentStatus') {
            // String fields (skip the ones we already handled above)
            target[lastPart] = value;
          }
        }
      });
      
      // Ensure stats are clamped to valid ranges
      if (employee.stats) {
        Object.keys(employee.stats).forEach(key => {
          employee.stats[key] = Math.max(0, Math.min(100, employee.stats[key]));
        });
      }
      
      // Ensure personality stats are clamped
      if (employee.personality) {
        ['confidence', 'outgoing', 'flirty', 'professional', 'humor'].forEach(key => {
          if (employee.personality[key] !== undefined) {
            employee.personality[key] = Math.max(0, Math.min(100, employee.personality[key]));
          }
        });
      }
      
      // Ensure intimacy is clamped
      if (employee.intimacy !== undefined) {
        employee.intimacy = Math.max(0, Math.min(100, employee.intimacy));
      }
      
      // Ensure memory cap is reasonable
      if (employee.memory && employee.memory.cap !== undefined) {
        employee.memory.cap = Math.max(50, Math.min(1000, employee.memory.cap));
      }
      
      showNotification('💾 Bio updated successfully! All changes saved.');
      saveGame(); // Save the game state
      updatePeopleTab(); // Refresh the people list
      ModalManager.close('bioModal');
    };
    
    // Cancel changes
    cancelBtn.onclick = () => {
      if (confirm('Discard changes?')) {
        ModalManager.close('bioModal');
      }
    };
    
    // Close modal
    modal.querySelector('#closeBioModal').onclick = () => {
      if (editMode) {
        if (confirm('You have unsaved changes. Close anyway?')) {
          ModalManager.close('bioModal');
        }
      } else {
        ModalManager.close('bioModal');
      }
    };
    
    // Click outside to close
    modal.onclick = (e) => {
      if (e.target === modal) {
        if (editMode) {
          if (confirm('You have unsaved changes. Close anyway?')) {
            ModalManager.close('bioModal');
          }
        } else {
          ModalManager.close('bioModal');
        }
      }
    };
  }
  
  // Load chat history
  function loadChatHistory(employeeId) {
    if (!chatMessages) return;
    
    chatMessages.innerHTML = '';
    const history = gameState.chatHistory[employeeId] || [];
    
    history.forEach((msg, index) => {
      // Handle scene visualizations specially
      if (msg.imageType === 'scene') {
        const messageEl = document.createElement('div');
        messageEl.style.cssText = 'max-width:80%; padding:10px; margin:10px auto; text-align:center; position:relative;';
        
        const imageContainer = document.createElement('div');
        imageContainer.style.cssText = 'position:relative; display:inline-block; max-width:400px; width:100%;';
        
        const img = document.createElement('img');
        img.src = msg.imageUrl;
        img.style.cssText = 'width:100%; border-radius:10px; cursor:pointer; box-shadow:0 2px 10px rgba(0,0,0,0.3); display:block;';
        img.onclick = () => {
          const viewer = document.createElement('div');
          viewer.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:99999; display:flex; justify-content:center; align-items:center; cursor:pointer;';
          viewer.innerHTML = `<img src="${msg.imageUrl}" style="max-width:90%; max-height:90%; border-radius:10px;">`;
          viewer.onclick = () => viewer.remove();
          document.body.appendChild(viewer);
        };
        imageContainer.appendChild(img);
        
        // Add regenerate button for scene images if we have the prompt
        if (msg.imagePrompt) {
          const imgRegenBtn = document.createElement('button');
          imgRegenBtn.innerHTML = '🔄';
          imgRegenBtn.style.cssText = 'position:absolute; top:5px; right:5px; background:rgba(0,0,0,0.6); border:none; border-radius:50%; width:28px; height:28px; color:white; cursor:pointer; font-size:1rem; opacity:0; transition:opacity 0.2s; display:flex; align-items:center; justify-content:center;';
          imgRegenBtn.title = 'Regenerate image';
          
          imageContainer.appendChild(imgRegenBtn);
          
          // Show/hide on hover
          imageContainer.addEventListener('mouseenter', () => {
            imgRegenBtn.style.opacity = '1';
          });
          imageContainer.addEventListener('mouseleave', () => {
            imgRegenBtn.style.opacity = '0';
          });
          
          // Handle image regeneration
          imgRegenBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            await regenerateImage(index, msg.imagePrompt);
          });
        }
        
        const caption = document.createElement('p');
        caption.style.cssText = 'margin:8px 0 0 0; color:#aaa; font-size:0.85rem; font-style:italic;';
        caption.textContent = msg.content;
        
        messageEl.appendChild(imageContainer);
        messageEl.appendChild(caption);
        chatMessages.appendChild(messageEl);
      } else {
        // Pass index for both player and NPC messages so edit/resend/regenerate buttons work
        addChatMessage(msg.sender, msg.content, msg.isPlayer, msg.imageUrl, index, msg.imagePrompt);
      }
    });
    
    // Scroll to bottom
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }
  
  // Helper function to style action text (enclosed in asterisks)
  function styleActionText(text) {
    if (!text) return '';
    
    // Escape HTML first to prevent XSS
    const escaped = text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
    
    // Replace *action text* with styled span
    // Match text between asterisks, but not standalone asterisks
    const styled = escaped.replace(/\*([^*]+)\*/g, (match, content) => {
      return `<span style="color:#888; font-style:italic; opacity:0.85;">${content}</span>`;
    });
    
    return styled;
  }
  
  // Add chat message to UI
  function addChatMessage(sender, content, isPlayer, imageUrl = null, messageIndex = null, imagePrompt = null) {
    if (!chatMessages) return;
    
    const messageEl = document.createElement('div');
    messageEl.style.cssText = `max-width:80%; padding:10px 15px; border-radius:18px; margin-bottom:10px; word-wrap:break-word; position:relative; ${isPlayer ? 'background:#e94560; align-self:flex-end;' : 'background:#0f3460; align-self:flex-start;'}`;
    
    // Add edit/resend buttons for PLAYER messages
    if (isPlayer && messageIndex !== null) {
      const actionContainer = document.createElement('div');
      actionContainer.style.cssText = 'position:absolute; top:5px; right:5px; display:flex; gap:4px; opacity:0.01; transition:opacity 0.2s;';
      actionContainer.className = 'message-action-buttons';
      
      // Edit button
      const editBtn = document.createElement('button');
      editBtn.innerHTML = '✏️';
      editBtn.className = 'edit-msg-btn';
      editBtn.style.cssText = 'background:rgba(255,152,0,0.8); border:none; border-radius:50%; width:24px; height:24px; color:white; cursor:pointer; font-size:0.8rem; display:flex; align-items:center; justify-content:center; padding:0;';
      editBtn.setAttribute('data-message-index', messageIndex);
      editBtn.title = 'Edit message';
      editBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        editPlayerMessage(messageIndex);
      });
      
      // Resend button
      const resendBtn = document.createElement('button');
      resendBtn.innerHTML = '🔄';
      resendBtn.className = 'resend-msg-btn';
      resendBtn.style.cssText = 'background:rgba(76,175,80,0.8); border:none; border-radius:50%; width:24px; height:24px; color:white; cursor:pointer; font-size:0.8rem; display:flex; align-items:center; justify-content:center; padding:0;';
      resendBtn.setAttribute('data-message-index', messageIndex);
      resendBtn.title = 'Resend message';
      resendBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        resendPlayerMessage(messageIndex);
      });
      
      actionContainer.appendChild(editBtn);
      actionContainer.appendChild(resendBtn);
      messageEl.appendChild(actionContainer);
      
      // Show/hide on hover
      messageEl.addEventListener('mouseenter', () => {
        actionContainer.style.opacity = '1';
      });
      messageEl.addEventListener('mouseleave', () => {
        actionContainer.style.opacity = '0.01';
      });
    }
    
    // Add regenerate button for NPC messages
    if (!isPlayer && messageIndex !== null) {
      const regenBtn = document.createElement('button');
      regenBtn.innerHTML = '♻️';
      regenBtn.className = 'regenerate-btn';
      regenBtn.style.cssText = 'position:absolute; top:5px; right:5px; background:rgba(33,150,243,0.8); border:none; border-radius:50%; width:24px; height:24px; color:white; cursor:pointer; font-size:0.9rem; opacity:0.01; transition:opacity 0.2s; display:flex; align-items:center; justify-content:center; padding:0;';
      regenBtn.setAttribute('data-message-index', messageIndex);
      regenBtn.title = 'Regenerate response (click for new variation)';
      
      messageEl.appendChild(regenBtn);
      
      // Show/hide on hover
      messageEl.addEventListener('mouseenter', () => {
        regenBtn.style.opacity = '1';
      });
      messageEl.addEventListener('mouseleave', () => {
        regenBtn.style.opacity = '0.01';
      });
      
      // Handle regeneration
      regenBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        await regenerateMessage(messageIndex);
      });
    }
    
    // Add image if present
    if (imageUrl) {
      const imageContainer = document.createElement('div');
      imageContainer.style.cssText = 'position:relative; display:inline-block; width:100%; max-width:300px;';
      
      const img = document.createElement('img');
      img.src = imageUrl;
      img.style.cssText = 'width:100%; border-radius:10px; margin-bottom:8px; cursor:pointer; display:block;';
      img.onclick = () => {
        // Open image in larger view
        const viewer = document.createElement('div');
        viewer.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:99999; display:flex; justify-content:center; align-items:center; cursor:pointer;';
        viewer.innerHTML = `<img src="${imageUrl}" style="max-width:90%; max-height:90%; border-radius:10px;">`;
        viewer.onclick = () => viewer.remove();
        document.body.appendChild(viewer);
      };
      imageContainer.appendChild(img);
      
      // Add regenerate button for images if we have the prompt and messageIndex
      if (imagePrompt && messageIndex !== null) {
        const imgRegenBtn = document.createElement('button');
        imgRegenBtn.innerHTML = '🔄';
        imgRegenBtn.style.cssText = 'position:absolute; top:5px; right:5px; background:rgba(0,0,0,0.6); border:none; border-radius:50%; width:28px; height:28px; color:white; cursor:pointer; font-size:1rem; opacity:0; transition:opacity 0.2s; display:flex; align-items:center; justify-content:center;';
        imgRegenBtn.title = 'Regenerate image';
        
        imageContainer.appendChild(imgRegenBtn);
        
        // Show/hide on hover
        imageContainer.addEventListener('mouseenter', () => {
          imgRegenBtn.style.opacity = '1';
        });
        imageContainer.addEventListener('mouseleave', () => {
          imgRegenBtn.style.opacity = '0';
        });
        
        // Handle image regeneration
        imgRegenBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          await regenerateImage(messageIndex, imagePrompt);
        });
      }
      
      messageEl.appendChild(imageContainer);
    }
    
    const textEl = document.createElement('p');
    textEl.style.margin = '0';
    
    // Process content to style asterisk-enclosed text (actions/thoughts)
    const processedContent = styleActionText(content);
    textEl.innerHTML = processedContent;
    
    messageEl.appendChild(textEl);
    
    chatMessages.appendChild(messageEl);
  }
  
  // Send chat message
  async function sendChatMessage() {
    if (!chatInput || !chatMessages) return;
    
    const message = chatInput.value.trim();
    if (!message || !gameState.activeChat) return;
    
    // Store employee ID for async operations
    const employeeId = gameState.activeChat.id;
    const employeeName = gameState.activeChat.name;
    
    // Add player message
    addChatMessage('You', message, true);
    
    // Add to history
    if (!gameState.chatHistory[employeeId]) {
      gameState.chatHistory[employeeId] = [];
    }
    gameState.chatHistory[employeeId].push({
      sender: 'You',
      content: message,
      isPlayer: true,
      timestamp: Date.now()
    });
    // Extract salient facts from user's message
    const facts = extractSalientFacts(message, gameState.activeChat);
    for (const f of facts) remember(gameState.activeChat, `Player ${f.text}`, f.type, f.importance);
    
    // Clear input
    chatInput.value = '';
    
    // Show typing indicator
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = employeeName;
    }
    
    // Generate AI response (async - continues even if chat closes)
    try {
      const conversationHistory = gameState.chatHistory[employeeId]
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');

      const emp = gameState.employees.find(e => e.id === employeeId);
      if (!emp) return;
      
      ensureEmployeeMemory(emp);
      const { prompt, personalAllowed } = buildChatPrompt(emp, conversationHistory, message);
      const raw = await generateText(prompt);
      const response = sanitizeNpcResponse(raw, 5);
      
      // Add to history first (works even if chat is closed)
      gameState.chatHistory[employeeId].push({
        sender: employeeName,
        content: response,
        isPlayer: false,
        timestamp: Date.now()
      });
      
      // Mark as unread if chat is now closed
      if (!gameState.activeChat || gameState.activeChat.id !== employeeId) {
        if (!emp.unreadMessages) emp.unreadMessages = 0;
        emp.unreadMessages++;
      }
      
      // Hide typing indicator (only if still showing this chat)
      if (chatTypingIndicator && gameState.activeChat?.id === employeeId) {
        chatTypingIndicator.style.display = 'none';
      }
      
      // Add AI response to UI (only if chat is still open for this employee)
      if (gameState.activeChat?.id === employeeId && chatMessages) {
        const messageIndex = gameState.chatHistory[employeeId].length - 1;
        addChatMessage(employeeName, response, false, null, messageIndex);
        // Scroll to bottom
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Memory: capture key NPC claims minimally
      const respFacts = extractSalientFacts(response, emp);
      for (const f of respFacts) remember(emp, `${emp.name} ${f.text}`, f.type, f.importance);
      
      // Style counters: detect personal detail usage
      const mentionedHobby = (emp.hobbies || []).some(h => new RegExp(`\\b${h}\\b`, 'i').test(response));
      const mentionedJob = emp.productManaged && new RegExp(`\\b${emp.productManaged}\\b`, 'i').test(response);
      const mentionedPosition = emp.position && new RegExp(`\\b${emp.position}\\b`, 'i').test(response);
      
      emp.memory.styleCounters.total += 1;
      emp.memory.styleCounters.sincePersonal = (mentionedHobby || mentionedJob || mentionedPosition) ? 0 : Math.min(10, (emp.memory.styleCounters.sincePersonal || 0) + 1);
      
      // Track specific mention types
      if (mentionedJob || mentionedPosition) {
        emp.memory.styleCounters.jobMentions += 1;
        emp.memory.styleCounters.lastJobMention = emp.memory.styleCounters.total;
      }
      if (mentionedHobby) {
        emp.memory.styleCounters.hobbyMentions += 1;
        emp.memory.styleCounters.lastHobbyMention = emp.memory.styleCounters.total;
      }
      
      // Check if player is requesting a social post
      await detectPostRequest(emp, message, response);
      
      // Check if player is requesting an image/photo
      await detectImageRequest(emp, message, response);
      
      // Update employee stats based on conversation
      await updateEmployeeStatsFromChat(emp, message, response);
      
      // Log significant boss interactions as events (for potential social posts)
      const isSignificant = 
        /\b(date|dinner|coffee|love|cute|beautiful|sexy|promotion|raise|fire|bonus)\b/i.test(message) ||
        /\b(date|dinner|coffee|love|cute|beautiful|sexy|thank|appreciate)\b/i.test(response);
      
      if (isSignificant) {
        logCompanyEvent({
          type: 'boss_interaction',
          involvedEmployees: [employeeId],
          location: emp.locationId,
          description: `Boss chat with ${employeeName}: "${message.slice(0, 50)}${message.length > 50 ? '...' : ''}"`,
          sentiment: 'neutral',
          importance: 5
        });
      }
      
      // Update People tab if visible (to show unread badge)
      if (gameState.activeTab === 'people') {
        updatePeopleTab();
      }
      
      // Refresh dashboard to show new messages
      if (gameState.activeTab === 'dashboard') {
        refreshDashboardSections();
      }
      
    } catch (error) {
      console.error('Error generating chat response:', error);
      // Hide typing indicator if chat still open for this employee
      if (chatTypingIndicator && gameState.activeChat?.id === employeeId) {
        chatTypingIndicator.style.display = 'none';
      }
      // Only show error message if chat is still open for this employee
      if (gameState.activeChat?.id === employeeId && chatMessages) {
        addChatMessage(employeeName, "Sorry, I'm having trouble responding right now.", false);
      }
    }
  }
  
  // -------- PLAYER MESSAGE EDITING FUNCTIONS --------
  
  /**
   * Edit a previously sent player message
   */
  function editPlayerMessage(messageIndex) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    const history = gameState.chatHistory[emp.id];
    
    if (!history || messageIndex < 0 || messageIndex >= history.length) return;
    
    const message = history[messageIndex];
    if (!message.isPlayer) return; // Only edit player messages
    
    // Populate chat input with existing message
    if (chatInput) {
      chatInput.value = message.content;
      chatInput.focus();
      
      // Store the message index we're editing
      chatInput.dataset.editingIndex = messageIndex;
      
      // Change the send button to indicate we're editing
      const sendBtn = document.getElementById('chatSendBtn');
      if (sendBtn) {
        sendBtn.textContent = '✏️ Update';
        sendBtn.style.backgroundColor = '#ff9800';
      }
      
      // Show a visual indicator
      showNotification('💬 Editing message. Press Update to replace it and regenerate response.', 3000);
    }
  }
  
  /**
   * Resend a player message (regenerates AI response without editing)
   */
  async function resendPlayerMessage(messageIndex) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    const history = gameState.chatHistory[emp.id];
    
    if (!history || messageIndex < 0 || messageIndex >= history.length) return;
    
    const message = history[messageIndex];
    if (!message.isPlayer) return; // Only resend player messages
    
    // Update timestamp to show it was resent
    history[messageIndex].timestamp = Date.now();
    
    // Delete all messages after this one
    gameState.chatHistory[emp.id] = history.slice(0, messageIndex + 1);
    
    // Reload chat to show truncated conversation
    loadChatHistory(emp.id);
    
    // Show typing indicator
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = emp.name;
    }
    
    // Show feedback
    showNotification('🔄 Resending message and generating new response...', 2000);
    
    // Generate new AI response with the same message
    try {
      const conversationHistory = gameState.chatHistory[emp.id]
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      ensureEmployeeMemory(emp);
      const { prompt } = buildChatPrompt(emp, conversationHistory, message.content);
      const raw = await generateText(prompt);
      const response = sanitizeNpcResponse(raw, 5);
      
      // Add new response to history
      gameState.chatHistory[emp.id].push({
        sender: emp.name,
        content: response,
        isPlayer: false,
        timestamp: Date.now()
      });
      
      // Hide typing indicator
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      
      // Reload chat to show new response
      loadChatHistory(emp.id);
      
      // Update stats
      await updateEmployeeStatsFromChat(emp, message.content, response);
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
      
      showNotification('✅ Message resent and new response generated!', 2000);
      
    } catch (error) {
      console.error('Error generating response after resend:', error);
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      showNotification('Failed to generate new response. Please try again.');
    }
  }
  
  /**
   * Modified send function to handle edits
   */
  async function sendOrUpdateChatMessage() {
    if (!chatInput || !chatMessages) return;
    
    const message = chatInput.value.trim();
    if (!message || !gameState.activeChat) return;
    
    const editingIndex = chatInput.dataset.editingIndex;
    
    // If we're editing, update the message and regenerate
    if (editingIndex !== undefined && editingIndex !== null) {
      const messageIndex = parseInt(editingIndex);
      const emp = gameState.activeChat;
      const history = gameState.chatHistory[emp.id];
      
      if (history && messageIndex >= 0 && messageIndex < history.length) {
        // Update the player message
        history[messageIndex].content = message;
        history[messageIndex].timestamp = Date.now();
        
        // Delete all messages after this one
        gameState.chatHistory[emp.id] = history.slice(0, messageIndex + 1);
        
        // Clear editing state
        delete chatInput.dataset.editingIndex;
        const sendBtn = document.getElementById('chatSendBtn');
        if (sendBtn) {
          sendBtn.textContent = 'Send';
          sendBtn.style.backgroundColor = '#4CAF50';
        }
        
        // Reload chat to show updated message
        loadChatHistory(emp.id);
        
        // Clear input
        chatInput.value = '';
        
        // Show typing indicator
        if (chatTypingIndicator && chatTypingName) {
          chatTypingIndicator.style.display = 'block';
          chatTypingName.textContent = emp.name;
        }
        
        // Generate new AI response
        try {
          const conversationHistory = gameState.chatHistory[emp.id]
            .map(msg => `${msg.sender}: ${msg.content}`)
            .join('\n');
          
          ensureEmployeeMemory(emp);
          const { prompt } = buildChatPrompt(emp, conversationHistory, message);
          const raw = await generateText(prompt);
          const response = sanitizeNpcResponse(raw, 5);
          
          // Add new response to history
          gameState.chatHistory[emp.id].push({
            sender: emp.name,
            content: response,
            isPlayer: false,
            timestamp: Date.now()
          });
          
          // Hide typing indicator
          if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
          
          // Reload chat to show new response
          loadChatHistory(emp.id);
          
          // Update stats
          await updateEmployeeStatsFromChat(emp, message, response);
          
          // Scroll to bottom
          chatMessages.scrollTop = chatMessages.scrollHeight;
          
          showNotification('✅ Message updated and response regenerated!', 2000);
          
        } catch (error) {
          console.error('Error generating response after edit:', error);
          if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
          showNotification('Failed to generate new response. Please try again.');
        }
        
        return; // Don't execute normal send logic
      }
    }
    
    // Normal send (not editing)
    await sendChatMessage();
  }
  
  // -------- POST REQUEST DETECTION AND HANDLING --------
  
  /**
   * Detect if player is requesting NPC to make a social post
   */
  async function detectPostRequest(employee, playerMessage, npcResponse) {
    // Keywords that suggest a post request
    const postKeywords = /\b(post|share|put.*on.*feed|upload|publish|make.*post|dare.*you.*to.*post)\b/i;
    const socialKeywords = /\b(social|feed|instagram|twitter|snap)\b/i;
    const contentKeywords = /\b(picture|photo|selfie|video|nude|naked|masturbat|explicit|sexy|hot)\b/i;
    
    // Check if player message looks like a post request
    const looksLikeRequest = postKeywords.test(playerMessage) && 
                             (socialKeywords.test(playerMessage) || contentKeywords.test(playerMessage));
    
    if (!looksLikeRequest) return;
    
    // Determine requested post type
    let requestedType = 'text';
    let requestContent = playerMessage;
    
    if (/\b(nude|naked|explicit)\b/i.test(playerMessage)) {
      requestedType = 'explicit';
    } else if (/\b(masturbat|touch.*yourself|play.*with.*yourself)\b/i.test(playerMessage)) {
      requestedType = 'explicit';
      requestContent = playerMessage;
    } else if (/\b(thirst.*trap|sexy|hot.*pic|revealing)\b/i.test(playerMessage)) {
      requestedType = 'thirst_trap';
    } else if (/\b(selfie|picture.*of.*you|photo.*of.*you)\b/i.test(playerMessage)) {
      requestedType = 'selfie';
    }
    
    // NPC evaluates request based on comfort level
    // If they already agreed in the response, actually make the post
    const agreedInResponse = /\b(okay|sure|alright|fine|will.*do|post|share)\b/i.test(npcResponse) &&
                             !/\b(don't|not|can't|won't|shouldn't|uncomfortable|not.*ready)\b/i.test(npcResponse);
    
    if (agreedInResponse) {
      // NPC agreed! Generate and post it
      setTimeout(async () => {
        await generateRequestedPost(employee, requestedType, requestContent);
      }, 2000 + Math.random() * 3000); // 2-5 seconds delay
    }
  }
  
  /**
   * Detect if player is requesting NPC to send an image/photo
   */
  async function detectImageRequest(employee, playerMessage, npcResponse) {
    // Keywords that suggest an image request (but NOT a post request)
    const imageKeywords = /\b(send|show|picture|photo|selfie|pic|image|snap)\b/i;
    const meKeywords = /\b(me|to.*me)\b/i;
    const contentKeywords = /\b(nude|naked|lewd|sexy|revealing|underwear|lingerie|body|yourself)\b/i;
    
    // Must NOT look like a post request (those are handled separately)
    const postKeywords = /\b(post|share|put.*on.*feed|upload|publish|make.*post)\b/i;
    const socialKeywords = /\b(social|feed|instagram|twitter|snap.*chat)\b/i;
    
    // Check if this looks like a post request - if so, skip (handled by detectPostRequest)
    const looksLikePostRequest = postKeywords.test(playerMessage) || socialKeywords.test(playerMessage);
    if (looksLikePostRequest) return;
    
    // Check if player message looks like an image request
    const looksLikeImageRequest = imageKeywords.test(playerMessage) && 
                                  (meKeywords.test(playerMessage) || contentKeywords.test(playerMessage));
    
    if (!looksLikeImageRequest) return;
    
    // Determine requested image type
    let requestedType = 'casual';
    let requestContent = playerMessage;
    
    if (/\b(nude|naked|nothing.*on|completely.*nude)\b/i.test(playerMessage)) {
      requestedType = 'nude';
    } else if (/\b(lewd|sexy|revealing|underwear|lingerie|bra|panties|topless)\b/i.test(playerMessage)) {
      requestedType = 'lewd';
    } else if (/\b(work|office|professional)\b/i.test(playerMessage)) {
      requestedType = 'work';
    } else if (/\b(selfie|picture|photo)\b/i.test(playerMessage)) {
      requestedType = 'casual';
    }
    
    // Check if NPC agreed in their response
    const agreedInResponse = /\b(okay|sure|alright|fine|here|sending|sent|check.*this)\b/i.test(npcResponse) &&
                             !/\b(don't|not|can't|won't|shouldn't|uncomfortable|not.*ready|too.*much)\b/i.test(npcResponse);
    
    if (agreedInResponse) {
      // NPC agreed! Generate and send the image
      setTimeout(async () => {
        await generateAndSendRequestedImage(employee, requestedType, requestContent);
      }, 2000 + Math.random() * 4000); // 2-6 seconds delay
    }
  }
  
  /**
   * Request a post from NPC via attachment menu
   */
  async function requestPostFromNPC(preset = null, customPrompt = null) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    let requestType = preset || 'text';
    let requestDescription = '';
    
    // Build request description based on preset or custom
    if (customPrompt) {
      requestDescription = customPrompt;
      // Try to detect type from custom prompt
      if (/\b(nude|naked|explicit)\b/i.test(customPrompt)) {
        requestType = 'explicit';
      } else if (/\b(thirst.*trap|sexy|revealing)\b/i.test(customPrompt)) {
        requestType = 'thirst_trap';
      } else if (/\b(selfie|picture)\b/i.test(customPrompt)) {
        requestType = 'selfie';
      }
    } else {
      // Use preset descriptions
      const presetDescriptions = {
        text: 'post a status update',
        selfie: 'post a selfie',
        thirst_trap: 'post a thirst trap (sexy/revealing photo)',
        explicit: 'post an explicit/nude photo'
      };
      requestDescription = presetDescriptions[requestType] || 'make a post';
    }
    
    // Add request message to chat
    const requestMessage = customPrompt || `Could you ${requestDescription}?`;
    if (chatInput) chatInput.value = requestMessage;
    
    // Simulate clicking send
    await sendChatMessage();
    
    // Wait a moment, then check if NPC will agree
    setTimeout(async () => {
      await evaluateAndExecutePostRequest(emp, requestType, requestDescription);
    }, 3000);
  }
  
  /**
   * Evaluate if NPC agrees to post request and execute
   */
  async function evaluateAndExecutePostRequest(employee, requestType, requestDescription) {
    const intimacy = employee.intimacy || 0;
    const affection = employee.stats?.affection || 0;
    const comfort = employee.stats?.comfort || 0;
    const personality = employee.personality || {};
    
    // Determine comfort level with request
    let comfortThreshold = 0;
    
    switch (requestType) {
      case 'text':
        comfortThreshold = 10; // Almost always okay
        break;
      case 'selfie':
        comfortThreshold = 20; // Pretty easy
        break;
      case 'thirst_trap':
        comfortThreshold = 50; // Need some comfort/attraction
        break;
      case 'explicit':
        comfortThreshold = 75; // Need high intimacy
        break;
    }
    
    // Calculate willingness score
    const willingnessScore = (intimacy * 0.4) + (affection * 0.3) + (comfort * 0.2) + (personality.flirty || 50) * 0.1;
    
    // Determine if they'll do it
    const willDo = willingnessScore >= comfortThreshold || (willingnessScore >= comfortThreshold * 0.8 && Math.random() < 0.3);
    
    if (willDo) {
      // Generate and post it after a delay
      setTimeout(async () => {
        await generateRequestedPost(employee, requestType, requestDescription);
      }, 3000 + Math.random() * 5000); // 3-8 seconds
    }
  }
  
  /**
   * Generate a requested post from NPC
   */
  async function generateRequestedPost(employee, postType, requestContext) {
    try {
      // Get context for post generation
      const context = getEmployeeAwarenessForPost(employee.id);
      if (!context) return;
      
      // Add request context to the generation
      context.requestedByBoss = true;
      context.requestContext = requestContext;
      
      // Generate the post
      const generated = await generateOrganicPost(employee, postType, context);
      
      if (!generated || !generated.content) return;
      
      // Generate image if needed
      let imageUrl = null;
      if (generated.imagePrompt && ['selfie', 'thirst_trap', 'explicit'].includes(postType)) {
        try {
          imageUrl = await generateImage({ prompt: generated.imagePrompt });
        } catch (error) {
          console.error('Image generation failed for requested post:', error);
        }
      }
      
      // Create and add the post
      const post = createPost({
        authorId: employee.id,
        content: generated.content,
        type: postType,
        imageUrl: imageUrl,
        imagePrompt: generated.imagePrompt,
        explicitLevel: generated.explicitLevel || 0,
        tags: generated.tags || [],
        location: employee.locationId || 'headquarters'
      });
      
      gameState.socialNetwork.posts.unshift(post);
      
      // Refresh dashboard to show new posts/mentions
      if (gameState.activeTab === 'dashboard') {
        refreshDashboardSections();
      }
      
      // Track this post type
      if (!gameState.socialNetwork.recentPostTypes) {
        gameState.socialNetwork.recentPostTypes = [];
      }
      gameState.socialNetwork.recentPostTypes.unshift(postType);
      if (gameState.socialNetwork.recentPostTypes.length > 20) {
        gameState.socialNetwork.recentPostTypes = gameState.socialNetwork.recentPostTypes.slice(0, 20);
      }
      
      // Store in employee's awareness
      remember(employee, `I posted on social media: "${generated.content}"`, 'action', 2);
      remember(employee, `The boss requested I make this post`, 'interaction', 2);
      
      // Send them a chat message about it
      if (gameState.activeChat?.id === employee.id && chatMessages) {
        const followUpMessages = [
          "Done! Check the feed 😊",
          "Posted! Hope you like it 😏",
          "There you go... posted",
          "Okay, it's up now",
          "Posted as requested 😳"
        ];
        const followUp = followUpMessages[Math.floor(Math.random() * followUpMessages.length)];
        
        gameState.chatHistory[employee.id].push({
          sender: employee.name,
          content: followUp,
          isPlayer: false,
          timestamp: Date.now()
        });
        
        const messageIndex = gameState.chatHistory[employee.id].length - 1;
        addChatMessage(employee.name, followUp, false, null, messageIndex);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Refresh feed if on social tab
      if (gameState.activeTab === 'social') {
        renderSocialFeed();
      }
      
    } catch (error) {
      console.error('Error generating requested post:', error);
    }
  }
  
  // -------- MESSAGE REGENERATION --------
  async function regenerateMessage(messageIndex) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    const history = gameState.chatHistory[emp.id];
    
    if (!history || messageIndex < 1 || messageIndex >= history.length) return;
    
    // Get the message before the one we're regenerating (the player's prompt)
    const playerMessage = history[messageIndex - 1]?.content;
    if (!playerMessage) return;
    
    // Show typing indicator
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = emp.name;
    }
    
    try {
      // Build conversation history up to this point
      const conversationHistory = history.slice(0, messageIndex)
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      // IMPROVED REGENERATION: Add variation strategies
      const variationStrategies = [
        '\n\nIMPORTANT: Generate a COMPLETELY DIFFERENT response. Use a different tone, approach the topic from a new angle, and include different details. Do NOT just rephrase the same ideas.',
        '\n\nIMPORTANT: This is a regeneration. Provide a FRESH perspective. If the previous response was formal, be casual. If it was short, elaborate more. If it was serious, add personality. Make this feel like a different person responding.',
        '\n\nIMPORTANT: Create a UNIQUE variation. Focus on different aspects of the conversation. Use different examples, emotions, or topics. Avoid repeating the same sentence structures or phrases.',
        '\n\nIMPORTANT: Generate an ALTERNATIVE response with a different emotional tone. If previous was playful, try thoughtful. If it was enthusiastic, try subtle. Show a different facet of this character.',
        '\n\nIMPORTANT: Respond DIFFERENTLY this time. Include new information, different reactions, or alternative suggestions. Vary your word choice significantly from what you might have said before.'
      ];
      
      // Randomly select a variation strategy
      const strategy = variationStrategies[Math.floor(Math.random() * variationStrategies.length)];
      
      // Track regeneration count to increase temperature
      if (!history[messageIndex].regenerationCount) {
        history[messageIndex].regenerationCount = 0;
      }
      history[messageIndex].regenerationCount++;
      
      // Build prompt with variation instruction
      const { prompt } = buildChatPrompt(emp, conversationHistory, playerMessage);
      const enhancedPrompt = prompt + strategy;
      
      // Increase temperature for more variation (0.7 + 0.1 per regeneration, max 1.2)
      const temperature = Math.min(1.2, 0.7 + (history[messageIndex].regenerationCount * 0.1));
      
      // Generate with enhanced variation
      const raw = await generateText(enhancedPrompt, {
        temperature: temperature,
        top_p: 0.95, // Slightly higher for more diversity
        frequency_penalty: 0.3 // Reduce repetition
      });
      
      const response = sanitizeNpcResponse(raw, 5);
      
      // Hide typing indicator
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      
      // Update the message in history
      history[messageIndex].content = response;
      
      // Delete all messages after this one (truncate the conversation)
      gameState.chatHistory[emp.id] = history.slice(0, messageIndex + 1);
      
      // Reload chat to show updated message
      loadChatHistory(emp.id);
      
      // Update stats based on new response
      await updateEmployeeStatsFromChat(emp, playerMessage, response);
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
      
      // Show feedback to user
      showNotification(`♻️ Response regenerated with new variation (${history[messageIndex].regenerationCount}x)`, 2000);
      
    } catch (error) {
      console.error('Error regenerating message:', error);
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      showNotification('Failed to regenerate message. Please try again.');
    }
  }
  
  // Regenerate an image in the chat history
  async function regenerateImage(messageIndex, imagePrompt) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    const history = gameState.chatHistory[emp.id];
    
    if (!history || messageIndex < 0 || messageIndex >= history.length) return;
    
    const message = history[messageIndex];
    if (!message.imageUrl) return; // Not an image message
    
    try {
      // Show loading indicator on the image
      const loadingMsg = document.createElement('div');
      loadingMsg.textContent = '🎨 Regenerating image...';
      loadingMsg.style.cssText = 'text-align:center; padding:10px; opacity:0.7; font-style:italic;';
      if (chatMessages) {
        chatMessages.appendChild(loadingMsg);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Generate new image using the same prompt
      const newImageUrl = await generateImage({ prompt: imagePrompt });
      
      // Remove loading message
      if (loadingMsg && loadingMsg.parentElement) {
        loadingMsg.remove();
      }
      
      // Update the image URL in history
      message.imageUrl = newImageUrl;
      
      // Reload chat to show updated image
      loadChatHistory(emp.id);
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
    } catch (error) {
      console.error('Error regenerating image:', error);
      showNotification('Failed to regenerate image');
    }
  }
  
  // -------- IMAGE SYSTEM --------
  // Build comprehensive image prompt using NPC bio and context
  async function buildImagePrompt(emp, requestType, customPrompt = null) {
    // Get consistent physical description using the new system
    const physicalDesc = getPhysicalDescriptionForPrompt(emp);
    
    // Get player description for [PLAYER] token
    const playerBio = getPlayerDescription('image'); // Uses new profile system
    
    // Get recent conversation context
    const recentContext = gameState.chatHistory[emp.id]
      ?.slice(-10)
      .map(msg => `${msg.sender}: ${msg.content}`)
      .join('\n') || '';
    
    // Determine intimacy level for appropriate image type
    const affection = emp.stats?.affection || 0;
    const desire = emp.stats?.desire || 0;
    const intimacyLevel = (affection + desire) / 2;
    
    let imagePrompt = '';
    
    // Handle preset request types
    if (requestType === 'casual') {
      imagePrompt = `casual selfie, ${physicalDesc}, friendly smile, relaxed setting, natural lighting, smartphone photo quality`;
    } else if (requestType === 'work') {
      imagePrompt = `professional workplace selfie, ${physicalDesc}, ${emp.position || 'office worker'}, office environment, professional attire, confident expression`;
    } else if (requestType === 'lewd') {
      if (intimacyLevel < 40) {
        imagePrompt = `suggestive selfie, ${physicalDesc}, flirty expression, casual clothing, teasing pose, playful atmosphere`;
      } else {
        imagePrompt = `seductive selfie, ${physicalDesc}, alluring expression, revealing clothing, intimate pose, bedroom or private setting`;
      }
    } else if (requestType === 'nude') {
      if (intimacyLevel < 60) {
        imagePrompt = `artistic nude selfie, ${physicalDesc}, tasteful pose, soft lighting, partial nudity, intimate setting`;
      } else {
        imagePrompt = `explicit nude selfie, ${physicalDesc}, seductive pose, full nudity, intimate bedroom setting, aroused expression`;
      }
    } else if (requestType === 'explicit') {
      // Sexually explicit content - variety of acts
      const explicitVariations = [
        `explicit sexual content, ${physicalDesc}, masturbating with hand, intense pleasure expression, legs spread, intimate bedroom setting, aroused and exposed`,
        `explicit sexual content, ${physicalDesc}, using sex toy, dildo or vibrator, eyes closed in ecstasy, intimate bedroom setting, very aroused`,
        `explicit sexual content, ${physicalDesc}, self-pleasure, fingers inside, intense orgasm expression, intimate bedroom setting, completely exposed`,
        `explicit sexual content, ${physicalDesc}, degrading body writing, marked with text, submissive expression, intimate setting, fully nude`,
        `explicit sexual content, ${physicalDesc}, masturbating, very aroused expression, touching self intimately, bedroom setting, explicit pose`,
        `explicit sexual content, ${physicalDesc}, anal play with toy, intense pleasure face, intimate bedroom setting, very exposed and aroused`,
        `explicit sexual content, ${physicalDesc}, using multiple toys, overwhelmed with pleasure, intimate bedroom setting, extremely explicit`,
        `explicit sexual content, ${physicalDesc}, squirting orgasm, intense climax expression, legs spread wide, intimate bedroom setting, very wet`
      ];
      imagePrompt = explicitVariations[Math.floor(Math.random() * explicitVariations.length)];
    } else if (customPrompt) {
      // Replace [PLAYER] token with player bio (escape to prevent Perchance interpretation)
      let processedPrompt = customPrompt.replace(/\[PLAYER\]/gi, playerBio);
      
      // For custom prompts, AI analyzes and builds comprehensive prompt
      // Note: Use "the player" or actual bio instead of [PLAYER] to avoid Perchance list conflicts
      const playerDescription = playerBio !== 'the player' ? `Player description: ${playerBio}` : '';
      
      const analysisPrompt = `You are helping generate an image prompt for ${emp.name}, a character with this description: ${physicalDesc}

Recent conversation context:
${recentContext}

${playerDescription}
The user has requested: "${processedPrompt}"

Build a comprehensive, detailed image generation prompt that:
1. Describes ${emp.name}'s physical appearance (using the character description: ${physicalDesc})
2. Incorporates the user's request
3. Adds relevant details based on conversation context
4. Uses technical prompt language (tags, descriptors, quality indicators)

Be specific about pose, expression, clothing, setting, lighting, and mood. Return ONLY the image prompt, no explanation.`;

      try {
        imagePrompt = await generateText(analysisPrompt);
        // Clean up any quotes or extra text
        imagePrompt = imagePrompt.replace(/^["']|["']$/g, '').trim();
      } catch (error) {
        console.error('Error building custom image prompt:', error);
        imagePrompt = `${processedPrompt}, ${physicalDesc}`;
      }
    }
    
    return imagePrompt;
  }
  
  // Handle sending an image (player to NPC)
  async function sendImageToNPC(imagePrompt) {
    if (!gameState.activeChat || !imagePrompt.trim()) return;
    
    const emp = gameState.activeChat;
    
    // Show typing indicator
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = emp.name;
    }
    
    try {
      // Show loading message
      const loadingMsg = addChatMessage('You', '🎨 Generating image...', true);
      
      // Generate image using Perchance generateImage plugin
      const imageUrl = await generateImage({ prompt: imagePrompt });
      
      // Remove loading message and add actual image message
      if (loadingMsg && loadingMsg.parentElement) {
        loadingMsg.remove();
      }
      
      // Add to history first to get the message index
      if (!gameState.chatHistory[emp.id]) {
        gameState.chatHistory[emp.id] = [];
      }
      gameState.chatHistory[emp.id].push({
        sender: 'You',
        content: imagePrompt,
        isPlayer: true,
        imageUrl: imageUrl,
        imagePrompt: imagePrompt,
        imageType: 'sent',
        timestamp: Date.now()
      });
      
      // Add image message with index for regenerate button
      const sentImageIndex = gameState.chatHistory[emp.id].length - 1;
      addChatMessage('You', imagePrompt, true, imageUrl, sentImageIndex, imagePrompt);
      
      // Build AI response prompt - NPC "sees" and responds to image
      const conversationHistory = gameState.chatHistory[emp.id]
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n');
      
      const playerBio = gameState.settings?.playerBio || '';
      const playerContext = playerBio ? `\nPlayer description: ${playerBio}` : '';
      
      const responsePrompt = `${buildChatPrompt(emp, conversationHistory, '').prompt}${playerContext}

The player just sent you an image. Based on this description: "${imagePrompt}", respond naturally to what they sent. Consider:
- What the image shows (understand the CONTEXT and meaning, not just literal technical tags)
- Your relationship with the player
- The context of your conversation
- Your personality and current mood

Respond as if you actually saw the image. Keep it conversational (3-5 sentences, completing your thought).

${emp.name}'s response:`;

      const raw = await generateText(responsePrompt);
      const response = sanitizeNpcResponse(raw, 5);
      
      // Hide typing indicator
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      
      // Add to history first to get the correct index
      gameState.chatHistory[emp.id].push({
        sender: emp.name,
        content: response,
        isPlayer: false,
        timestamp: Date.now()
      });
      
      // Add AI response with message index for regenerate button
      const messageIndex = gameState.chatHistory[emp.id].length - 1;
      addChatMessage(emp.name, response, false, null, messageIndex);
      
      // Memory: remember the image
      remember(emp, `Player sent image: ${imagePrompt}`, 'event', 1.5);
      
      // Update stats
      await updateEmployeeStatsFromChat(emp, `[Sent image: ${imagePrompt}]`, response);
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
    } catch (error) {
      console.error('Error handling sent image:', error);
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      addChatMessage(emp.name, "Sorry, I couldn't process that image.", false);
    }
  }
  
  // Handle requesting an image from NPC
  /**
   * Request an image from NPC via attachment menu
   */
  async function requestImageFromNPC(preset = null, customPrompt = null) {
    if (!gameState.activeChat) return;
    
    const emp = gameState.activeChat;
    let requestType = preset || 'casual';
    let requestDescription = '';
    
    // Build request description based on preset or custom
    if (customPrompt) {
      requestDescription = customPrompt;
      // Try to detect type from custom prompt
      if (/\b(masturbat|dildo|toy|vibrator|orgasm|degradation|body.*writing|explicit.*act)\b/i.test(customPrompt)) {
        requestType = 'explicit';
      } else if (/\b(nude|naked|full.*nude)\b/i.test(customPrompt)) {
        requestType = 'nude';
      } else if (/\b(lewd|sexy|revealing|underwear|lingerie|topless)\b/i.test(customPrompt)) {
        requestType = 'lewd';
      } else if (/\b(work|office|professional)\b/i.test(customPrompt)) {
        requestType = 'work';
      } else if (/\b(selfie|picture|photo)\b/i.test(customPrompt)) {
        requestType = 'casual';
      }
    } else {
      // Use preset descriptions
      const presetDescriptions = {
        casual: 'send a casual selfie',
        work: 'send a work selfie',
        lewd: 'send a lewd/sexy photo',
        nude: 'send a nude photo',
        explicit: 'send explicit sexual content'
      };
      requestDescription = presetDescriptions[requestType] || 'send a photo';
    }
    
    // Add request message to chat directly (bypass normal AI response)
    const requestMessage = customPrompt || `Could you ${requestDescription}?`;
    
    // Add to chat history
    if (!gameState.chatHistory[emp.id]) {
      gameState.chatHistory[emp.id] = [];
    }
    gameState.chatHistory[emp.id].push({
      sender: 'You',
      content: requestMessage,
      isPlayer: true,
      timestamp: Date.now()
    });
    
    // Display the message
    addChatMessage('You', requestMessage, true);
    if (chatMessages) chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Clear input if it was set
    if (chatInput) chatInput.value = '';
    
    // Wait a moment, then check if NPC will agree and respond
    setTimeout(async () => {
      await evaluateAndExecuteImageRequest(emp, requestType, requestDescription, customPrompt);
    }, 1500);
  }
  
  /**
   * Evaluate if NPC agrees to image request and execute
   */
  async function evaluateAndExecuteImageRequest(employee, requestType, requestDescription, customPrompt = null) {
    const intimacy = employee.intimacy || 0;
    const affection = employee.stats?.affection || 0;
    const comfort = employee.stats?.comfort || 0;
    const desire = employee.stats?.desire || 0;
    const personality = employee.personality || {};
    
    // Determine comfort level with request
    let comfortThreshold = 0;
    
    switch (requestType) {
      case 'casual':
        comfortThreshold = 5; // Almost always okay
        break;
      case 'work':
        comfortThreshold = 10; // Very easy
        break;
      case 'lewd':
        comfortThreshold = 45; // Need some attraction
        break;
      case 'nude':
        comfortThreshold = 70; // Need high intimacy
        break;
      case 'explicit':
        comfortThreshold = 85; // Need very high intimacy + desire
        break;
    }
    
    // Calculate willingness score
    const willingnessScore = (intimacy * 0.35) + (affection * 0.25) + (desire * 0.25) + (comfort * 0.15);
    
    // Determine if they'll do it
    const willDo = willingnessScore >= comfortThreshold || 
                   (willingnessScore >= comfortThreshold * 0.8 && Math.random() < 0.25);
    
    if (willDo) {
      // Generate and send it after a delay
      setTimeout(async () => {
        await generateAndSendRequestedImage(employee, requestType, customPrompt);
      }, 2000 + Math.random() * 4000); // 2-6 seconds
    } else {
      // Send a rejection message
      const rejectionMessages = [
        "I'm not really comfortable with that",
        "Maybe when we know each other better",
        "That's a bit too much for me right now",
        "I don't think I'm ready for that yet",
        "Sorry, but that's crossing a line for me"
      ];
      const rejection = rejectionMessages[Math.floor(Math.random() * rejectionMessages.length)];
      
      setTimeout(() => {
        if (gameState.activeChat?.id === employee.id && chatMessages) {
          gameState.chatHistory[employee.id].push({
            sender: employee.name,
            content: rejection,
            isPlayer: false,
            timestamp: Date.now()
          });
          
          const messageIndex = gameState.chatHistory[employee.id].length - 1;
          addChatMessage(employee.name, rejection, false, null, messageIndex);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }, 2000 + Math.random() * 2000);
    }
  }
  
  /**
   * Generate and send requested image from NPC
   */
  async function generateAndSendRequestedImage(employee, requestType, customPrompt = null) {
    if (!gameState.activeChat || gameState.activeChat.id !== employee.id) return;
    
    const emp = employee;
    
    // Show typing indicator
    if (chatTypingIndicator && chatTypingName) {
      chatTypingIndicator.style.display = 'block';
      chatTypingName.textContent = emp.name;
    }
    
    try {
      // Build comprehensive image prompt
      const imagePrompt = await buildImagePrompt(emp, requestType, customPrompt);
      
      // Show loading message in chat
      const loadingMsg = document.createElement('div');
      loadingMsg.textContent = '🎨 Generating image...';
      loadingMsg.style.cssText = 'text-align:center; padding:10px; opacity:0.7; font-style:italic;';
      if (chatMessages) {
        chatMessages.appendChild(loadingMsg);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      // Generate image using Perchance generateImage plugin
      const imageUrl = await generateImage({ prompt: imagePrompt });
      
      // Remove loading message
      if (loadingMsg && loadingMsg.parentElement) {
        loadingMsg.remove();
      }
      
      // Get AI to generate a message accompanying the image
      const conversationHistory = gameState.chatHistory[emp.id]
        ?.map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n') || '';
      
      const messagePrompt = `${buildChatPrompt(emp, conversationHistory, '').prompt}

The player has requested a ${requestType || 'custom'} photo from you. You've agreed and are sending them an image that shows: ${imagePrompt}

Write a brief, natural message (1 sentence) to accompany the photo you're sending. Match your tone to the image type and your relationship:
- Casual/Work: Friendly, maybe playful
- Lewd: Flirty, teasing, confident  
- Nude: Bold, seductive, intimate
- Explicit: Intensely sexual, uninhibited, aroused, raw

${emp.name}'s message:`;

      const raw = await generateText(messagePrompt);
      const message = sanitizeNpcResponse(raw, 1);
      
      // Hide typing indicator
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      
      // Add to history first to get the correct index
      if (!gameState.chatHistory[emp.id]) {
        gameState.chatHistory[emp.id] = [];
      }
      gameState.chatHistory[emp.id].push({
        sender: emp.name,
        content: message,
        isPlayer: false,
        imageUrl: imageUrl,
        imagePrompt: imagePrompt,
        imageType: 'received',
        timestamp: Date.now()
      });
      
      // Add image message from NPC with message index for regenerate button
      const receivedImageIndex = gameState.chatHistory[emp.id].length - 1;
      addChatMessage(emp.name, message, false, imageUrl, receivedImageIndex, imagePrompt);
      
      // Memory: remember sending this image
      remember(emp, `Sent ${requestType || 'custom'} photo to player`, 'event', 1.5);
      remember(emp, `The boss requested this photo`, 'interaction', 1.5);
      
      // Add to employee photos gallery
      if (!emp.photos) emp.photos = [];
      emp.photos.push({
        url: imageUrl,
        prompt: imagePrompt,
        type: requestType || 'custom',
        timestamp: Date.now()
      });
      
      // Update stats based on image type
      if (requestType === 'explicit') {
        emp.stats.desire = Math.min(100, (emp.stats.desire || 0) + 8);
        emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 4);
        emp.intimacy = Math.min(100, (emp.intimacy || 0) + 5);
        emp.stats.comfort = Math.min(100, (emp.stats.comfort || 0) + 3);
      } else if (requestType === 'nude') {
        emp.stats.desire = Math.min(100, (emp.stats.desire || 0) + 5);
        emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 3);
        emp.intimacy = Math.min(100, (emp.intimacy || 0) + 3);
      } else if (requestType === 'lewd') {
        emp.stats.desire = Math.min(100, (emp.stats.desire || 0) + 3);
        emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 2);
        emp.intimacy = Math.min(100, (emp.intimacy || 0) + 2);
      } else {
        emp.stats.affection = Math.min(100, (emp.stats.affection || 0) + 1);
      }
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
    } catch (error) {
      console.error('Error handling image request:', error);
      if (chatTypingIndicator) chatTypingIndicator.style.display = 'none';
      addChatMessage(emp.name, "Sorry, I can't send that right now.", false);
    }
  }
  
  // Visualize current scene without NPC response
  async function visualizeCurrentScene() {
    if (!gameState.activeChat) return;
    
    // IMPORTANT: Capture the employee at the START to prevent chat-switching bugs
    const emp = gameState.activeChat;
    const empId = emp.id;
    const empName = emp.name;
    
    try {
      // Build comprehensive scene description from context
      const recentMessages = gameState.chatHistory[empId]
        ?.slice(-15)
        .map(msg => `${msg.sender}: ${msg.content}`)
        .join('\n') || '';
      
      // Get consistent character description
      const empDesc = getPhysicalDescriptionForPrompt(emp);
      
      const playerBio = gameState.settings?.playerBio || 'the player';
      
      // AI analyzes scene and builds visual prompt
      const scenePrompt = `Based on this conversation between the player and ${empName}:

${recentMessages}

Character descriptions:
- ${empName}: ${empDesc}
- Player: ${playerBio}

Generate a detailed image prompt that visualizes the CURRENT SCENE from the conversation. Consider:
1. Where they are (office, home, restaurant, etc.)
2. What they're doing (working, talking, eating, etc.)
3. Their positions/poses
4. Their expressions and body language
5. The atmosphere and mood
6. Lighting and setting details

Create a comprehensive image generation prompt that captures this moment. Use technical prompt language. Return ONLY the image prompt, no explanation.`;

      const imagePrompt = await generateText(scenePrompt);
      
      // Show loading message in chat (but verify we're still in the right chat)
      const loadingMsg = document.createElement('div');
      loadingMsg.textContent = '🎨 Visualizing current scene...';
      loadingMsg.style.cssText = 'text-align:center; padding:10px; opacity:0.7; font-style:italic;';
      
      // Only add loading message if we're still viewing this chat
      if (gameState.activeChat?.id === empId) {
        if (chatMessages) {
          chatMessages.appendChild(loadingMsg);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }
      
      // Generate image using Perchance generateImage plugin
      const imageUrl = await generateImage({ prompt: imagePrompt });
      
      // Remove loading message (if it exists)
      if (loadingMsg && loadingMsg.parentElement) {
        loadingMsg.remove();
      }
      
      // Add to history with special type FIRST (so it persists even if chat switches)
      if (!gameState.chatHistory[empId]) {
        gameState.chatHistory[empId] = [];
      }
      gameState.chatHistory[empId].push({
        sender: 'System',
        content: '🎬 Scene visualization',
        isPlayer: false,
        imageUrl: imageUrl,
        imagePrompt: imagePrompt,
        imageType: 'scene',
        timestamp: Date.now()
      });
      
      // Only add image to visible chat if we're still viewing this employee's chat
      if (gameState.activeChat?.id === empId) {
        const messageEl = document.createElement('div');
        messageEl.style.cssText = 'max-width:80%; padding:10px; margin:0 auto; text-align:center;';
        
        const img = document.createElement('img');
        img.src = imageUrl;
        img.style.cssText = 'width:100%; max-width:400px; border-radius:10px; cursor:pointer; box-shadow:0 2px 10px rgba(0,0,0,0.3);';
        img.onclick = () => {
          const viewer = document.createElement('div');
          viewer.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:99999; display:flex; justify-content:center; align-items:center; cursor:pointer;';
          viewer.innerHTML = `<img src="${imageUrl}" style="max-width:90%; max-height:90%; border-radius:10px;">`;
          viewer.onclick = () => viewer.remove();
          document.body.appendChild(viewer);
        };
        
        const caption = document.createElement('p');
        caption.style.cssText = 'margin:8px 0 0 0; color:#aaa; font-size:0.85rem; font-style:italic;';
        caption.textContent = '🎬 Scene visualization';
        
        messageEl.appendChild(img);
        messageEl.appendChild(caption);
        chatMessages.appendChild(messageEl);
        
        // Scroll to bottom
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      // If chat switched, the image is already in history and will show when they return to this chat
      
    } catch (error) {
      console.error('Error visualizing scene:', error);
      // Only show error in the original chat
      if (gameState.activeChat?.id === empId) {
        addChatMessage('System', 'Could not generate scene visualization.', false);
      }
    }
  }
  
  // -------- AI-POWERED STAT EVALUATION --------
  // Analyzes conversation and updates employee stats naturally
  async function updateEmployeeStatsFromChat(emp, playerMessage, npcResponse) {
    if (!emp || !emp.stats) return;
    
    // Get office culture settings
    const policy = gameState.settings?.policy || 'professional';
    const guidelines = gameState.settings?.guidelines ?? 50;
    const atmosphere = gameState.settings?.atmosphere ?? 50;
    
    // Build evaluation context based on settings
    const atmosphereContext = (() => {
      if (atmosphere < 33) {
        return 'PROFESSIONAL office: Formal behavior expected. Personal topics, flirting, or casual banter may DECREASE comfort/affection unless trust is already very high. Work-focused conversations are valued.';
      } else if (atmosphere > 66) {
        return 'RELAXED office: Casual, friendly environment. Personal topics, humor, and informal chat INCREASE comfort/affection easily. Formality might seem stiff or awkward.';
      } else {
        return 'BALANCED office: Friendly professionalism. Personal topics are fine when rapport exists. Both formal and casual approaches can work depending on relationship level.';
      }
    })();
    
    const guidelineContext = (() => {
      if (guidelines < 33) {
        return 'NPC has RESERVED personality: Slow to warm up, guarded. Compliments and friendliness may DECREASE comfort initially (seems too forward). Trust builds slowly. Pushback and sarcasm are normal. Rate harshly on pushy/forward behavior.';
      } else if (guidelines > 66) {
        return 'NPC has OUTGOING personality: Warm and open. Friendly behavior and compliments INCREASE affection easily. Coldness or distance DECREASES stats. Be lenient - they want to connect.';
      } else {
        return 'NPC has STANDARD personality: Balanced responses. Rate authentically based on the message quality. Not overly harsh or lenient.';
      }
    })();
    
    const policyContext = (() => {
      if (policy === 'open') {
        return 'ENTHUSIASTIC consent model: NPCs are receptive to romantic/intimate advances. Flirting and personal interest INCREASE desire and affection. Be lenient with advances - they\'re welcome. Only decrease stats for genuinely disrespectful behavior.';
      } else if (policy === 'professional') {
        return 'PROFESSIONAL consent model: Boundaries are important. Romantic/intimate advances may DECREASE comfort/trust unless relationship stats are already very high (70+). Respect for boundaries is valued.';
      } else {
        return 'CASUAL consent model: NPCs need moderate trust/comfort before being receptive. Advances when stats are low (below 40) may decrease comfort. When stats are good (50+), advances are welcome.';
      }
    })();
    
    // Build evaluation prompt with extended context
    const conversationContext = gameState.chatHistory[emp.id]
      ?.slice(-60) // Last 30 exchanges for comprehensive stat evaluation
      .map(msg => `${msg.sender}: ${msg.content}`)
      .join('\n') || '';
    
    const currentStats = `Affection: ${emp.stats.affection ?? 0}, Comfort: ${emp.stats.comfort ?? 0}, Trust: ${emp.stats.trust ?? 0}, Desire: ${emp.stats.desire ?? 0}, Obedience: ${emp.stats.obedience ?? 0}`;
    
    const evaluationPrompt = `You are evaluating how an NPC employee's feelings changed based on a conversation exchange.

NPC: ${emp.name} (${emp.personality || 'balanced'} personality)
Current stats: ${currentStats}

OFFICE CULTURE CONTEXT:
${atmosphereContext}
${guidelineContext}
${policyContext}

Recent context:
${conversationContext}

CRITICAL EVALUATION RULES:
1. **Judge the EXCHANGE, not just the player's message**
2. **The NPC's response reveals their TRUE feelings** - If they respond positively, enthusiastically, or agree to something, that means they LIKED it
3. **Consent is KEY**: If the NPC agrees, participates willingly, or responds positively to intimate/personal topics, DO NOT decrease stats
4. **High stats = more tolerance**: When stats are already high (70+), the relationship is STRONG and can handle more intimate/forward behavior
5. **Match the response tone**: Enthusiastic NPC response = INCREASE stats. Hesitant/uncomfortable NPC response = decrease stats
6. **Context matters**: Consider the conversation history and current relationship level

**GOSSIP HANDLING** (IMPORTANT):
- **Gossiping ABOUT other people** (sharing juicy details, drama, stories about coworkers) is DIFFERENT from being mean TO this person
- If player is sharing gossip/tea about OTHER employees, this can INCREASE bonding (sharing secrets = trust/comfort up)
- Only decrease stats if: (a) Gossip is mean-spirited AND NPC defends the person, OR (b) NPC explicitly says they don't want to hear it
- **Juicy/explicit gossip about others** often INCREASES intimacy and trust (shared secrets bond people)
- **Talking about intimate acts with others** ≠ being inappropriate TO this person
- Context: "I hooked up with Sarah" = gossip/sharing (can increase trust), NOT harassment of current NPC

Examples of GOSSIP (usually POSITIVE for relationship):
- "Sarah sent me nudes" → sharing tea, can increase trust/comfort if NPC responds positively
- "Did you hear about Emily and Jake?" → workplace drama, bonding opportunity
- "Can you believe what happened at the party?" → shared excitement
- Talking about explicit encounters with others → intimate secret sharing

Only negative if:
- NPC response shows they're uncomfortable with gossip
- NPC is close friends with the person being gossiped about and defends them
- Gossip is malicious and NPC has high moral standards

Rate the impact of this exchange on these stats using a -10 to +10 scale:
- Affection: How much they like you personally (mutual enjoyment, chemistry, kindness increase; rejection, rudeness decrease)
- Comfort: How comfortable they feel around you (willing participation, ease, enjoyment increase; discomfort, hesitation decrease)
- Trust: How much they trust you (honesty, respect, follow-through, SHARING SECRETS increase; lies, broken promises decrease)
- Desire: Romantic/sexual attraction (mutual interest, chemistry, flirting increase; rejection, boundaries decrease)
- Obedience: Willingness to follow your lead (agreement, cooperation, respect increase; defiance, pushback decrease)

Player's message: "${playerMessage}"
NPC's response: "${npcResponse}"

**ANALYZE THE NPC'S RESPONSE CAREFULLY**: 
- Did they agree? Did they seem happy? Enthusiastic? Willing? If YES → POSITIVE interaction
- Are they engaging with gossip eagerly? If YES → Trust/Comfort INCREASE (shared secrets)
- Are they uncomfortable or defending someone? If YES → might decrease Comfort slightly

Reply with ONLY 5 numbers separated by spaces (Affection Comfort Trust Desire Obedience), each from -10 to +10.
Example: "5 3 2 4 1" or "-2 0 1 -1 3"

Numbers only:`;

    try {
      const raw = await generateText(evaluationPrompt);
      const numbers = raw.trim().split(/\s+/).map(n => parseFloat(n)).filter(n => !isNaN(n));
      
      if (numbers.length >= 5) {
        // Detect if NPC response shows consent/enthusiasm
        const npcResponseLower = (npcResponse || '').toLowerCase();
        const showsConsent = /\b(yes|okay|sure|love|want|enjoy|feel.*good|amazing|please|more|don't.*stop|keep.*going|feels.*so|like.*that|mm+|ah+|oh+.*god|fuck.*yes)\b/.test(npcResponseLower);
        const showsEnthusiasm = /\b(love|amazing|incredible|perfect|yes+|god.*yes|so.*good|feels.*amazing|want.*more|don't.*stop)\b/.test(npcResponseLower);
        const showsDiscomfort = /\b(no|stop|don't|uncomfortable|not.*ready|too.*much|can't|won't|shouldn't|wait|slow.*down)\b/.test(npcResponseLower);
        
        // Calculate average current stat level (for relationship strength check)
        const avgStats = ((emp.stats.affection ?? 50) + (emp.stats.comfort ?? 50) + (emp.stats.trust ?? 50) + (emp.stats.desire ?? 20)) / 4;
        const strongRelationship = avgStats >= 70;
        
        // Apply stat changes with smart moderation
        const applyChange = (current, change, statName, max = 100, min = 0) => {
          // SAFETY CHECK: Prevent harsh drops in consensual scenarios
          if (change < -3 && showsConsent && !showsDiscomfort) {
            // NPC clearly consented - cap the negative change
            console.log(`[Stat Protection] ${emp.name}'s ${statName}: Capping drop from ${change} to -2 (NPC showed consent)`);
            change = Math.max(change, -2);
          }
          
          // SAFETY CHECK: Strong relationships are more resilient
          if (change < -5 && strongRelationship && !showsDiscomfort) {
            // High stats = strong bond, can handle more
            console.log(`[Stat Protection] ${emp.name}'s ${statName}: Capping drop from ${change} to -3 (strong relationship)`);
            change = Math.max(change, -3);
          }
          
          // BONUS: Amplify gains when NPC shows enthusiasm
          if (change > 0 && showsEnthusiasm) {
            change = change * 1.5;
            console.log(`[Stat Bonus] ${emp.name}'s ${statName}: Amplifying gain to ${change.toFixed(1)} (NPC enthusiastic)`);
          }
          
          let newVal = current + change;
          
          // Diminishing returns near caps
          if (change > 0 && current > 80) {
            newVal = current + (change * 0.5); // Half effect above 80
          } else if (change > 0 && current > 90) {
            newVal = current + (change * 0.25); // Quarter effect above 90
          }
          
          return Math.max(min, Math.min(max, newVal));
        };
        
        emp.stats.affection = applyChange(emp.stats.affection ?? 50, numbers[0], 'Affection');
        emp.stats.comfort = applyChange(emp.stats.comfort ?? 50, numbers[1], 'Comfort');
        emp.stats.trust = applyChange(emp.stats.trust ?? 50, numbers[2], 'Trust');
        emp.stats.desire = applyChange(emp.stats.desire ?? 20, numbers[3], 'Desire');
        emp.stats.obedience = applyChange(emp.stats.obedience ?? 50, numbers[4], 'Obedience');
        
        // Log stat changes for debugging
        console.log(`[Stat Update] ${emp.name}: Aff${numbers[0]>0?'+':''}${numbers[0]} Com${numbers[1]>0?'+':''}${numbers[1]} Tru${numbers[2]>0?'+':''}${numbers[2]} Des${numbers[3]>0?'+':''}${numbers[3]} Obe${numbers[4]>0?'+':''}${numbers[4]}${showsConsent?' [CONSENT]':''}${showsEnthusiasm?' [ENTHUSIASTIC]':''}${showsDiscomfort?' [DISCOMFORT]':''}`);
        
        // Update UI if on people tab
        if (gameState.activeTab === 'people') {
          updatePeopleTab();
        }
      } else {
        // Fallback: Basic keyword analysis if AI fails
        console.warn('[Stat Update] AI evaluation failed, using fallback');
        fallbackStatUpdate(emp, playerMessage, npcResponse);
      }
    } catch (error) {
      console.error('[Stat Update] Error:', error);
      fallbackStatUpdate(emp, playerMessage, npcResponse);
    }
  }
  
  // Fallback stat update using keyword analysis
  function fallbackStatUpdate(emp, playerMsg, npcMsg) {
    const p = (playerMsg || '').toLowerCase();
    const n = (npcMsg || '').toLowerCase();
    
    // Affection changes
    if (/\b(thank|appreciate|grateful|wonderful|amazing|great job)\b/.test(p)) {
      emp.stats.affection = Math.min(100, (emp.stats.affection ?? 50) + 3);
    }
    if (/\b(stupid|idiot|useless|hate)\b/.test(p)) {
      emp.stats.affection = Math.max(0, (emp.stats.affection ?? 50) - 5);
    }
    
    // Comfort changes
    if (/\b(comfortable|relaxed|casual|easy|chill)\b/.test(p)) {
      emp.stats.comfort = Math.min(100, (emp.stats.comfort ?? 50) + 2);
    }
    if (/\b(nervous|anxious|worried|uncomfortable)\b/.test(n)) {
      emp.stats.comfort = Math.max(0, (emp.stats.comfort ?? 50) - 3);
    }
    
    // Trust changes
    if (/\b(honest|truth|trust|believe|promise)\b/.test(p)) {
      emp.stats.trust = Math.min(100, (emp.stats.trust ?? 50) + 2);
    }
    if (/\b(lie|lied|dishonest|deceive)\b/.test(p)) {
      emp.stats.trust = Math.max(0, (emp.stats.trust ?? 50) - 4);
    }
    
    // Desire changes
    if (/\b(beautiful|gorgeous|sexy|hot|attractive|cute)\b/.test(p)) {
      emp.stats.desire = Math.min(100, (emp.stats.desire ?? 20) + 4);
    }
    if (/\b(date|dinner|kiss|touch|want you)\b/.test(p)) {
      emp.stats.desire = Math.min(100, (emp.stats.desire ?? 20) + 3);
    }
    
    // Obedience changes
    if (/\b(good job|well done|excellent|perfect)\b/.test(p)) {
      emp.stats.obedience = Math.min(100, (emp.stats.obedience ?? 50) + 2);
    }
    if (/\b(no|won't|refuse|can't make me)\b/.test(n)) {
      emp.stats.obedience = Math.max(0, (emp.stats.obedience ?? 50) - 2);
    }
    
    // Productivity is more stable, changes slowly
    if (/\b(work|project|task|deadline)\b/.test(p)) {
      emp.stats.productivity = Math.min(100, (emp.stats.productivity ?? 50) + 1);
    }
    
    // Check for gossip-worthy interactions!
    checkForGossipWorthyInteraction(emp, playerMsg, npcMsg);
  }
  
  /**
   * ═══════════════════════════════════════════════════════════════════
   * 🌐 SOCIAL DYNAMICS SYSTEM: NPC-to-NPC Relationship Evolution
   * ═══════════════════════════════════════════════════════════════════
   * Evaluates how NPCs feel about each other based on social interactions
   * Posts, comments, likes, and tags all influence relationships
   */
  
  /**
   * Evaluate NPC reaction to another NPC's post
   * Called when NPC views/comments on another NPC's post
   */
  async function evaluateNPCReactionToPost(viewer, postAuthor, post, comment = null) {
    if (!viewer || !postAuthor || viewer.id === postAuthor.id) return;
    
    // Get or initialize relationship
    if (!viewer.relationships) viewer.relationships = {};
    if (!viewer.relationships[postAuthor.id]) {
      viewer.relationships[postAuthor.id] = {
        strength: 50,
        type: 'colleague',
        history: []
      };
    }
    
    const relationship = viewer.relationships[postAuthor.id];
    const currentStrength = relationship.strength || 50;
    
    // Build context
    const postType = post.type || 'text';
    const explicitLevel = post.explicitLevel || 0;
    const hasComment = !!comment;
    
    // Get viewer's personality to determine reaction style
    const viewerPersonality = viewer.personality || {};
    const viewerFlirty = viewerPersonality.flirty || 50;
    const viewerProfessional = viewerPersonality.professional || 50;
    const viewerHumor = viewerPersonality.humor || 50;
    
    const evaluationPrompt = `You are evaluating how ${viewer.name} feels about ${postAuthor.name} after seeing their social media post.

CURRENT RELATIONSHIP:
- Strength: ${currentStrength}/100
- Type: ${relationship.type}

${viewer.name}'S PERSONALITY:
- Flirty: ${viewerFlirty}/100
- Professional: ${viewerProfessional}/100
- Humor: ${viewerHumor}/100

THE POST:
Type: ${postType}
${explicitLevel > 0 ? `Explicit Level: ${explicitLevel}/4` : ''}
Content: "${post.content || ''}"
${post.imageAlt ? `Image: ${post.imageAlt}` : ''}

${hasComment ? `${viewer.name}'S COMMENT:\n"${comment}"` : `${viewer.name} viewed this post but didn't comment.`}

EVALUATION GUIDELINES:
**Positive Reactions** (+1 to +5):
- Funny/relatable posts: +2 to +4 (especially if viewer has high humor)
- Impressive achievements: +3 to +5
- Shared interests/hobbies: +3 to +4
- Supportive/kind posts: +2 to +3
- Flirty posts (if viewer is flirty): +2 to +4
- Made viewer laugh or feel good: +3 to +5

**Negative Reactions** (-1 to -5):
- Offensive/insensitive content: -3 to -5
- Showing off/bragging (if viewer is insecure): -2 to -4
- Inappropriate content (if viewer is very professional): -2 to -3
- Passive-aggressive or shady: -3 to -4
- Attacking someone viewer cares about: -4 to -5

**Neutral** (0):
- Boring/mundane content
- Don't care about topic
- Already knew this information

**Amplifiers**:
- If viewer COMMENTED enthusiastically: +50% to change
- If viewer COMMENTED supportively: +30% to change
- If viewer COMMENTED negatively: amplify negative change by 50%
- If post MENTIONS viewer: +50% to change (showing they think of viewer)

Consider: Would ${viewer.name} like this? Does it align with their values? Does it make them feel closer or more distant?

Reply with ONE number from -5 to +5 representing relationship strength change.
JUST the number:`;

    try {
      const raw = await generateText(evaluationPrompt, { temperature: 0.7, max_tokens: 10 });
      const change = parseFloat(raw.trim());
      
      if (!isNaN(change) && change >= -5 && change <= 5) {
        const oldStrength = relationship.strength;
        relationship.strength = Math.max(0, Math.min(100, oldStrength + change));
        
        // Update relationship type based on strength
        if (relationship.strength > 80) relationship.type = 'best_friend';
        else if (relationship.strength > 65) relationship.type = 'friend';
        else if (relationship.strength > 35) relationship.type = 'colleague';
        else if (relationship.strength > 15) relationship.type = 'acquaintance';
        else relationship.type = 'distant';
        
        if (change !== 0) {
          console.log(`[Social Dynamics] ${viewer.name} → ${postAuthor.name}: ${change > 0 ? '+' : ''}${change} (${oldStrength} → ${relationship.strength}, ${relationship.type})`);
          
          // Add to history
          relationship.history.push({
            timestamp: Date.now(),
            type: 'post_reaction',
            description: hasComment ? `Commented on ${postAuthor.name}'s ${postType} post` : `Viewed ${postAuthor.name}'s ${postType} post`,
            change: change
          });
          
          // Keep history reasonable
          if (relationship.history.length > 20) {
            relationship.history = relationship.history.slice(-20);
          }
          
          // Create gossip if relationship changed significantly
          if (Math.abs(change) >= 3) {
            createGossipFromSocialInteraction(viewer, postAuthor, post, comment, change);
          }
        }
      }
    } catch (error) {
      console.error(`[Social Dynamics] Error evaluating ${viewer.name}'s reaction:`, error);
    }
  }
  
  /**
   * Evaluate NPC-to-NPC comment interaction
   * Called when one NPC comments on another NPC's comment
   */
  async function evaluateNPCCommentInteraction(commenter, originalCommenter, post, comment, replyComment) {
    if (!commenter || !originalCommenter || commenter.id === originalCommenter.id) return;
    
    // Initialize relationships
    if (!commenter.relationships) commenter.relationships = {};
    if (!commenter.relationships[originalCommenter.id]) {
      commenter.relationships[originalCommenter.id] = {
        strength: 50,
        type: 'colleague',
        history: []
      };
    }
    
    const relationship = commenter.relationships[originalCommenter.id];
    const currentStrength = relationship.strength || 50;
    
    const evaluationPrompt = `Evaluate how ${commenter.name} and ${originalCommenter.name}'s relationship changed after this comment exchange.

CURRENT RELATIONSHIP: ${currentStrength}/100 (${relationship.type})

${originalCommenter.name}'S COMMENT:
"${comment}"

${commenter.name}'S REPLY:
"${replyComment}"

Rate the interaction from -5 to +5:
+5: Amazing connection, bonding moment, inside joke, supportive
+3: Positive, friendly, helpful, agreeable
+1: Slightly positive, polite acknowledgment
0: Neutral, no real impact
-1: Slightly annoying or dismissive
-3: Disagreement, passive-aggressive, snarky
-5: Hostile, attacking, relationship-damaging

Consider tone, whether they're agreeing/disagreeing, if there's humor/warmth/conflict.

JUST the number:`;

    try {
      const raw = await generateText(evaluationPrompt, { temperature: 0.7, max_tokens: 10 });
      const change = parseFloat(raw.trim());
      
      if (!isNaN(change) && change >= -5 && change <= 5) {
        const oldStrength = relationship.strength;
        relationship.strength = Math.max(0, Math.min(100, oldStrength + change));
        
        // Update type
        if (relationship.strength > 80) relationship.type = 'best_friend';
        else if (relationship.strength > 65) relationship.type = 'friend';
        else if (relationship.strength > 35) relationship.type = 'colleague';
        else relationship.type = 'distant';
        
        if (change !== 0) {
          console.log(`[Comment Dynamics] ${commenter.name} ↔ ${originalCommenter.name}: ${change > 0 ? '+' : ''}${change} (${oldStrength} → ${relationship.strength})`);
          
          relationship.history.push({
            timestamp: Date.now(),
            type: 'comment_exchange',
            description: `Replied to ${originalCommenter.name}'s comment`,
            change: change
          });
          
          if (relationship.history.length > 20) {
            relationship.history = relationship.history.slice(-20);
          }
        }
      }
    } catch (error) {
      console.error(`[Comment Dynamics] Error:`, error);
    }
  }
  
  /**
   * Create gossip from notable social interactions
   */
  function createGossipFromSocialInteraction(viewer, postAuthor, post, comment, relationshipChange) {
    // Only create gossip for significant changes or explicit content
    if (Math.abs(relationshipChange) < 3 && post.explicitLevel < 2) return;
    
    let gossipContent = '';
    
    if (relationshipChange >= 4) {
      // Positive bonding
      gossipContent = `${viewer.name} and ${postAuthor.name} seem to be getting really close on social media`;
    } else if (relationshipChange <= -4) {
      // Drama/conflict
      gossipContent = `${viewer.name} and ${postAuthor.name} had tension on social media`;
    } else if (post.explicitLevel >= 3) {
      // Explicit content reaction
      gossipContent = `${postAuthor.name} posted something VERY explicit and ${viewer.name} ${comment ? 'commented on it' : 'saw it'}`;
    }
    
    if (gossipContent) {
      // Add to gossip engine for other NPCs to discover
      if (!gameState.activeGossip) gameState.activeGossip = [];
      
      gameState.activeGossip.push({
        id: `gossip_${Date.now()}_${Math.random()}`,
        subjectId: postAuthor.id,
        targetId: viewer.id,
        content: gossipContent,
        juiciness: Math.abs(relationshipChange) + post.explicitLevel,
        timestamp: Date.now(),
        accuracy: 100, // Direct observation
        knownBy: [viewer.id] // Viewer knows it firsthand
      });
      
      // Keep gossip list manageable
      if (gameState.activeGossip.length > 50) {
        gameState.activeGossip = gameState.activeGossip.slice(-50);
      }
      
      console.log(`[Gossip Created] ${gossipContent} (juiciness: ${Math.abs(relationshipChange) + post.explicitLevel})`);
    }
  }
  
  /**
   * Check if a conversation interaction is juicy enough to create gossip
   */
  function checkForGossipWorthyInteraction(emp, playerMsg, npcMsg) {
    const p = (playerMsg || '').toLowerCase();
    const n = (npcMsg || '').toLowerCase();
    const intimacy = emp.intimacy || 0;
    const desire = emp.stats?.desire || 0;
    
    // HOOKUP/SEXUAL interactions (Very juicy!)
    if (intimacy > 60 && desire > 50) {
      if (/\b(sex|fuck|bed|sleep together|hook up|come over)\b/.test(p + n)) {
        createPlayerGossip({
          type: 'hookup',
          npcId: emp.id,
          description: `${emp.name} and the boss hooked up`,
          juiciness: 90
        });
        return;
      }
    }
    
    // DATING/ROMANTIC interactions (Juicy!)
    if (desire > 40) {
      if (/\b(date|dating|girlfriend|boyfriend|relationship|love you)\b/.test(p + n)) {
        createPlayerGossip({
          type: 'date',
          npcId: emp.id,
          description: `${emp.name} and the boss went on a date`,
          juiciness: 70
        });
        return;
      }
      
      if (/\b(kiss|kissing|kissed|make out)\b/.test(p + n)) {
        createPlayerGossip({
          type: 'hookup',
          npcId: emp.id,
          description: `${emp.name} and the boss kissed`,
          juiciness: 65
        });
        return;
      }
    }
    
    // FLIRTING interactions (Moderately juicy)
    if (desire > 25 && /\b(flirt|sexy|hot|gorgeous|beautiful|cute)\b/.test(p)) {
      if (Math.random() < 0.3) { // 30% chance to gossip about flirting
        createPlayerGossip({
          type: 'rumor',
          npcId: emp.id,
          description: `the boss was flirting with ${emp.name}`,
          juiciness: 45
        });
      }
    }
    
    // PROMOTION/FAVORITISM (Office politics!)
    if (/\b(promot|raise|bonus|favor|special treatment)\b/.test(p)) {
      createPlayerGossip({
        type: 'promotion',
        npcId: emp.id,
        description: `${emp.name} got special treatment from the boss`,
        juiciness: 55
      });
    }
    
    // FIRED/CONFLICT (Drama!)
    if (/\b(fire|fired|quit|resign|argument|fight|angry)\b/.test(p + n)) {
      createPlayerGossip({
        type: 'scandal',
        npcId: emp.id,
        description: `${emp.name} and the boss had a heated argument`,
        juiciness: 60
      });
    }
  }

  
  // Update news
  function updateNews() {
    // Add new news item
    const newsItems = [
      `${gameState.employees.length > 0 ? gameState.employees[0].name : 'Your company'} makes headlines with innovative approach`,
      `Industry experts praise ${gameState.employees.length > 0 ? gameState.employees[0].name : 'your team'}'s performance`,
      `New workplace policies at your company set industry standards`,
      `Your business growth outpaces competitors this quarter`,
      `Employee satisfaction at your company reaches all-time high`,
      `Tech community buzzing about your latest product launch`
    ];
    
    const randomNews = newsItems[Math.floor(Math.random() * newsItems.length)];
    gameState.news.unshift(randomNews);
    
    // Keep only latest 5 news items
    if (gameState.news.length > 5) {
      gameState.news = gameState.news.slice(0, 5);
    }
    
    // Update news ticker
    if (newsContent) newsContent.textContent = randomNews;
    
    // Update news feed if dashboard is active
    if (gameState.activeTab === 'dashboard') {
      updateNewsFeed();
    }
  }
  
  // ========== PLAYER POST COMPOSER FUNCTIONS ==========
  
  // ============================================
  // MENTION SUGGESTION SYSTEM (@suggest)
  // ============================================
  
  /**
   * Get suggested employees for @mentions
   * Ranked by: recent mentions > frequent mentions > affection > alphabetical
   */
  function getMentionSuggestions(searchQuery = '') {
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (activeEmployees.length === 0) return [];
    
    const now = Date.now();
    const stats = gameState.playerMentionStats || { mentionHistory: [], mentionCounts: {} };
    
    // Calculate scores for each employee
    const suggestions = activeEmployees.map(emp => {
      let score = 0;
      
      // Frequency score (how often mentioned) - weight: 50
      const mentionCount = stats.mentionCounts[emp.id] || 0;
      score += mentionCount * 50;
      
      // Recency score (how recently mentioned) - weight: 100
      const recentMentions = stats.mentionHistory.filter(m => 
        m.employeeId === emp.id && (now - m.timestamp) < 86400000 * 7 // Last 7 days
      );
      if (recentMentions.length > 0) {
        const latestMention = Math.max(...recentMentions.map(m => m.timestamp));
        const daysAgo = (now - latestMention) / 86400000;
        score += Math.max(0, 100 - (daysAgo * 10)); // Decay over 10 days
      }
      
      // Relationship score - weight: 30
      const affection = emp.stats?.affection || 0;
      const intimacy = emp.intimacy || 0;
      score += (affection + intimacy) / 2 * 0.3;
      
      // Search query match boost
      const username = emp.social?.username || emp.name.toLowerCase().replace(/\s+/g, '');
      const name = emp.name.toLowerCase();
      const query = searchQuery.toLowerCase();
      
      if (query && (username.startsWith(query) || name.startsWith(query))) {
        score += 1000; // High priority for matches
      } else if (query && (username.includes(query) || name.includes(query))) {
        score += 500; // Medium priority for partial matches
      }
      
      return {
        employee: emp,
        username: emp.social?.username || username,
        name: emp.name,
        affection: affection,
        mentionCount: mentionCount,
        score: score
      };
    });
    
    // Sort by score descending
    suggestions.sort((a, b) => b.score - a.score);
    
    // Filter by search query if provided
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      return suggestions.filter(s => 
        s.username.toLowerCase().includes(query) || 
        s.name.toLowerCase().includes(query)
      );
    }
    
    return suggestions;
  }
  
  /**
   * Track when player mentions someone
   */
  function trackPlayerMention(employeeId) {
    if (!gameState.playerMentionStats) {
      gameState.playerMentionStats = {
        mentionHistory: [],
        mentionCounts: {}
      };
    }
    
    const stats = gameState.playerMentionStats;
    
    // Add to history
    stats.mentionHistory.push({
      employeeId: employeeId,
      timestamp: Date.now()
    });
    
    // Increment count
    if (!stats.mentionCounts[employeeId]) {
      stats.mentionCounts[employeeId] = 0;
    }
    stats.mentionCounts[employeeId]++;
    
    // Keep history manageable (last 100 mentions)
    if (stats.mentionHistory.length > 100) {
      stats.mentionHistory.shift();
    }
    
    console.log(`[Mentions] Tracked mention of ${employeeId}, total: ${stats.mentionCounts[employeeId]}`);
  }
  
  /**
   * Extract @mentions from text
   * Returns array of { username, employeeId }
   */
  function extractMentions(text) {
    const mentions = [];
    const mentionRegex = /@([\w.]+)/g; // Allow dots in usernames
    let match;
    
    while ((match = mentionRegex.exec(text)) !== null) {
      const mentionedUsername = match[1].toLowerCase();
      
      // Find employee with this username - try multiple matching strategies
      const employee = gameState.employees.find(e => {
        if (!e.social?.username) return false;
        
        const storedUsername = e.social.username.toLowerCase();
        
        // Strategy 1: Exact match
        if (storedUsername === mentionedUsername) return true;
        
        // Strategy 2: Remove all separators (_, ., numbers, prefixes) and compare
        const normalizeUsername = (u) => u.replace(/[_.\-\d]/g, '').replace(/^(the|real)|official$/g, '');
        if (normalizeUsername(storedUsername) === normalizeUsername(mentionedUsername)) return true;
        
        // Strategy 3: Check if it's just firstname
        const firstName = e.name.split(' ')[0].toLowerCase();
        if (mentionedUsername === firstName) return true;
        
        // Strategy 4: Check if it's firstname + lastname no separator
        const firstLast = e.name.toLowerCase().replace(/\s+/g, '');
        if (mentionedUsername === firstLast) return true;
        
        // Strategy 5: Check if mentioned is contained in stored (for prefixes like the_, real_)
        if (storedUsername.includes(mentionedUsername) || mentionedUsername.includes(storedUsername.replace(/^(the_|real_)|_official$/g, ''))) {
          return true;
        }
        
        return false;
      });
      
      if (employee) {
        mentions.push({
          username: match[1],
          employeeId: employee.id,
          fullMention: match[0]
        });
        console.log(`[Mention] Found @${match[1]} -> ${employee.name} (username: ${employee.social.username}, ID: ${employee.id})`);
      } else {
        console.warn(`[Mention] Could not find employee for @${match[1]}`);
      }
    }
    
    console.log(`[Mention] Extracted ${mentions.length} mentions:`, mentions);
    return mentions;
  }
  
  /**
   * Show mention suggestions dropdown
   */
  function showMentionSuggestions(input, searchQuery = '') {
    const dropdown = $('mentionSuggestions');
    if (!dropdown) return;
    
    const suggestions = getMentionSuggestions(searchQuery);
    
    if (suggestions.length === 0) {
      dropdown.style.display = 'none';
      return;
    }
    
    // Limit to top 8 suggestions
    const topSuggestions = suggestions.slice(0, 8);
    
    dropdown.innerHTML = topSuggestions.map((s, index) => {
      const relationshipIcon = s.affection > 70 ? '💕' : s.affection > 40 ? '😊' : '👤';
      const mentionBadge = s.mentionCount > 0 ? `<span style="background:#0f3460; padding:2px 6px; border-radius:4px; font-size:0.75rem; color:#00d4ff;">${s.mentionCount}x</span>` : '';
      
      return `
        <div class="mention-suggestion-item" data-index="${index}" data-username="${s.username}" data-employee-id="${s.employee.id}" style="padding:10px 15px; cursor:pointer; border-bottom:1px solid #0f3460; display:flex; align-items:center; justify-content:space-between; transition:background 0.2s;">
          <div style="display:flex; align-items:center; gap:10px; flex:1;">
            <span style="font-size:1.2rem;">${relationshipIcon}</span>
            <div style="flex:1;">
              <div style="color:white; font-weight:600;">@${s.username}</div>
              <div style="color:#aaa; font-size:0.85rem;">${s.name}</div>
            </div>
          </div>
          ${mentionBadge}
        </div>
      `;
    }).join('');
    
    // Add hover effects
    dropdown.querySelectorAll('.mention-suggestion-item').forEach(item => {
      item.addEventListener('mouseenter', () => {
        item.style.background = '#0f3460';
      });
      item.addEventListener('mouseleave', () => {
        item.style.background = 'transparent';
      });
      item.addEventListener('click', () => {
        const username = item.dataset.username;
        const employeeId = item.dataset.employeeId;
        insertMention(input, username, employeeId);
      });
    });
    
    dropdown.style.display = 'block';
  }
  
  /**
   * Insert @mention into text input
   */
  function insertMention(input, username, employeeId, dropdownId = 'mentionSuggestions') {
    if (!input) return;
    
    const text = input.value;
    const cursorPos = input.selectionStart;
    
    // Find the @ symbol position
    let atPos = cursorPos - 1;
    while (atPos >= 0 && text[atPos] !== '@') {
      atPos--;
    }
    
    if (atPos >= 0) {
      // Replace from @ to cursor with @username
      const before = text.substring(0, atPos);
      const after = text.substring(cursorPos);
      input.value = before + '@' + username + ' ' + after;
      
      // Set cursor after mention
      const newPos = atPos + username.length + 2;
      input.selectionStart = newPos;
      input.selectionEnd = newPos;
      
      // Track the mention
      trackPlayerMention(employeeId);
      
      // Trigger input event for char counter
      input.dispatchEvent(new Event('input'));
    }
    
    // Hide dropdown
    const dropdown = dropdownId === 'mentionSuggestions' ? $(dropdownId) : 
                     document.querySelector(`.comment-mention-suggestions[data-post-id="${dropdownId}"]`);
    if (dropdown) dropdown.style.display = 'none';
    
    // Focus back on input
    input.focus();
  }
  
  /**
   * Setup mention autocomplete on an input
   */
  function setupMentionAutocomplete(input, dropdownId = 'mentionSuggestions') {
    if (!input) return;
    
    let mentionActive = false;
    let mentionStartPos = -1;
    let currentHighlightIndex = 0;
    
    const getDropdown = () => {
      return dropdownId === 'mentionSuggestions' ? $(dropdownId) : 
             document.querySelector(`.comment-mention-suggestions[data-post-id="${dropdownId}"]`);
    };
    
    const updateHighlight = () => {
      const dropdown = getDropdown();
      if (!dropdown) return;
      
      const items = dropdown.querySelectorAll('.mention-suggestion-item');
      items.forEach((item, index) => {
        if (index === currentHighlightIndex) {
          item.style.background = '#0f3460';
          item.setAttribute('data-highlighted', 'true');
        } else {
          item.style.background = 'transparent';
          item.removeAttribute('data-highlighted');
        }
      });
    };
    
    const showDropdownForInput = (searchQuery) => {
      const suggestions = getMentionSuggestions(searchQuery);
      const topSuggestions = suggestions.slice(0, 6);
      
      if (topSuggestions.length === 0) {
        const dropdown = getDropdown();
        if (dropdown) dropdown.style.display = 'none';
        return;
      }
      
      const dropdown = getDropdown();
      if (!dropdown) return;
      
      dropdown.innerHTML = topSuggestions.map((s, index) => {
        const relationshipIcon = s.affection > 70 ? '💕' : s.affection > 40 ? '😊' : '👤';
        const mentionBadge = s.mentionCount > 0 ? `<span style="background:#0f3460; padding:2px 6px; border-radius:4px; font-size:0.75rem; color:#00d4ff;">${s.mentionCount}x</span>` : '';
        
        return `
          <div class="mention-suggestion-item" data-index="${index}" data-username="${s.username}" data-employee-id="${s.employee.id}" style="padding:10px 15px; cursor:pointer; border-bottom:1px solid #0f3460; display:flex; align-items:center; justify-content:space-between; transition:background 0.2s;">
            <div style="display:flex; align-items:center; gap:10px; flex:1;">
              <span style="font-size:1.2rem;">${relationshipIcon}</span>
              <div style="flex:1;">
                <div style="color:white; font-weight:600;">@${s.username}</div>
                <div style="color:#aaa; font-size:0.85rem;">${s.name}</div>
              </div>
            </div>
            ${mentionBadge}
          </div>
        `;
      }).join('');
      
      // Add hover and click effects
      dropdown.querySelectorAll('.mention-suggestion-item').forEach((item, index) => {
        item.addEventListener('mouseenter', () => {
          currentHighlightIndex = index;
          updateHighlight();
        });
        item.addEventListener('click', () => {
          const username = item.dataset.username;
          const employeeId = item.dataset.employeeId;
          insertMention(input, username, employeeId, dropdownId);
          mentionActive = false;
        });
      });
      
      currentHighlightIndex = 0;
      updateHighlight();
      dropdown.style.display = 'block';
    };
    
    input.addEventListener('input', (e) => {
      const text = input.value;
      const cursorPos = input.selectionStart;
      
      // Check if @ was just typed or we're in a mention
      const charBefore = cursorPos > 0 ? text[cursorPos - 1] : '';
      const charBeforeThat = cursorPos > 1 ? text[cursorPos - 2] : '';
      
      // Detect @ at start or after space/newline
      if (charBefore === '@' && (cursorPos === 1 || charBeforeThat === ' ' || charBeforeThat === '\n')) {
        mentionActive = true;
        mentionStartPos = cursorPos - 1;
        showDropdownForInput('');
      } else if (mentionActive) {
        // Get text after @
        const textAfterAt = text.substring(mentionStartPos + 1, cursorPos);
        
        // Check if we're still in the mention (no space yet)
        if (textAfterAt.includes(' ') || textAfterAt.includes('\n')) {
          mentionActive = false;
          const dropdown = getDropdown();
          if (dropdown) dropdown.style.display = 'none';
        } else {
          // Update suggestions based on search
          showDropdownForInput(textAfterAt);
        }
      }
    });
    
    // Handle keyboard navigation and Tab autocomplete
    input.addEventListener('keydown', (e) => {
      const dropdown = getDropdown();
      if (!dropdown || dropdown.style.display === 'none') return;
      
      const items = dropdown.querySelectorAll('.mention-suggestion-item');
      if (items.length === 0) return;
      
      if (e.key === 'Escape') {
        dropdown.style.display = 'none';
        mentionActive = false;
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        currentHighlightIndex = (currentHighlightIndex + 1) % items.length;
        updateHighlight();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        currentHighlightIndex = (currentHighlightIndex - 1 + items.length) % items.length;
        updateHighlight();
      } else if (e.key === 'Tab' || e.key === 'Enter') {
        // Tab or Enter to insert highlighted suggestion
        e.preventDefault();
        const highlightedItem = items[currentHighlightIndex];
        if (highlightedItem) {
          const username = highlightedItem.dataset.username;
          const employeeId = highlightedItem.dataset.employeeId;
          insertMention(input, username, employeeId, dropdownId);
          mentionActive = false;
        }
      }
    });
    
    // Close dropdown when clicking outside
    const clickHandler = (e) => {
      const dropdown = getDropdown();
      if (dropdown && !input.contains(e.target) && !dropdown.contains(e.target)) {
        dropdown.style.display = 'none';
        mentionActive = false;
      }
    };
    
    document.addEventListener('click', clickHandler);
  }
  
  /**
   * Open player post composer modal
   */
  function openPlayerPostComposer() {
    const modal = $('playerPostModal');
    if (!modal) return;
    
    // Reset form
    const captionInput = $('playerPostCaption');
    const imagePromptInput = $('playerPostImagePrompt');
    const imageAltInput = $('playerPostAltText');
    const explicitCheckbox = $('playerPostExplicit');
    const charCount = $('captionCharCount');
    const previewContainer = $('playerPostImagePreview');
    
    if (captionInput) captionInput.value = '';
    if (imagePromptInput) imagePromptInput.value = '';
    if (imageAltInput) imageAltInput.value = '';
    if (explicitCheckbox) explicitCheckbox.checked = false;
    if (charCount) charCount.textContent = '0';
    if (previewContainer) {
      previewContainer.style.display = 'none';
    }
    
    // Reset to text type
    document.querySelectorAll('.post-type-btn').forEach(btn => {
      btn.classList.remove('active');
      btn.style.borderColor = '#0f3460';
      btn.style.color = '#aaa';
    });
    
    const textTypeBtn = document.querySelector('.post-type-btn[data-type="text"]');
    if (textTypeBtn) {
      textTypeBtn.classList.add('active');
      textTypeBtn.style.borderColor = '#00d4ff';
      textTypeBtn.style.color = 'white';
    }
    
    const imageSection = $('playerPostImageSection');
    const generateImageBtn = $('generatePlayerPostImage');
    if (imageSection) imageSection.style.display = 'none';
    if (generateImageBtn) generateImageBtn.style.display = 'none';
    
    // Clear stored image
    delete gameState.tempPostImage;
    
    // Setup mention autocomplete
    if (captionInput) {
      setupMentionAutocomplete(captionInput);
    }
    
    // Show modal with flex display
    modal.style.display = 'flex';
  }
  
  /**
   * Close player post composer modal
   */
  function closePlayerPostModal() {
    const modal = $('playerPostModal');
    if (modal) modal.style.display = 'none';
    
    // Clear temp data
    delete gameState.tempPostImage;
  }
  
  /**
   * Generate image for player post
   */
  /**
   * Generate image for player post
   * ENHANCED WITH DETAILED LOGGING FOR IMAGE GENERATION PIPELINE
   */
  async function generatePlayerPostImage_handler() {
    console.log('═══════════════════════════════════════════════════════');
    console.log('🎨 [IMAGE GENERATION PIPELINE] Starting...');
    console.log('═══════════════════════════════════════════════════════');
    
    const promptInput = $('playerPostImagePrompt');
    const altInput = $('playerPostAltText');
    const generateBtn = $('generatePlayerPostImage');
    const previewContainer = $('playerPostImagePreview');
    const previewImg = $('playerPostPreviewImg');
    
    if (!promptInput || !generateBtn) {
      console.error('[IMAGE GEN] ❌ Required DOM elements not found');
      return;
    }
    
    const prompt = promptInput.value.trim();
    
    console.log('[IMAGE GEN] STEP 1: Validate Input');
    console.log('[IMAGE GEN] User Prompt:', prompt || '(empty)');
    
    if (!prompt) {
      console.warn('[IMAGE GEN] ❌ Validation failed: Empty prompt');
      alert('Please enter an image description first!');
      return;
    }
    
    console.log('[IMAGE GEN] ✅ Validation passed');
    console.log('[IMAGE GEN] Prompt length:', prompt.length, 'characters');
    
    console.log('───────────────────────────────────────────────────────');
    console.log('[IMAGE GEN] STEP 2: Analyze Prompt Context');
    console.log('───────────────────────────────────────────────────────');
    
    // Analyze prompt for content flags
    const promptLower = prompt.toLowerCase();
    const contentAnalysis = {
      mentions: {
        person: /\b(person|people|man|woman|guy|girl|employee|worker)\b/i.test(prompt),
        location: /\b(office|desk|room|outside|park|beach|home|building)\b/i.test(prompt),
        object: /\b(desk|chair|computer|phone|coffee|car|food)\b/i.test(prompt),
        clothing: /\b(dress|suit|shirt|pants|outfit|uniform|casual|formal)\b/i.test(prompt),
        action: /\b(sitting|standing|walking|working|smiling|looking|holding)\b/i.test(prompt)
      },
      style: {
        selfie: /\b(selfie|self portrait)\b/i.test(prompt),
        professional: /\b(professional|business|work|formal|corporate)\b/i.test(prompt),
        casual: /\b(casual|relaxed|informal|candid)\b/i.test(prompt),
        artistic: /\b(artistic|creative|stylized|aesthetic)\b/i.test(prompt)
      },
      suggestiveKeywords: ['sexy', 'hot', 'revealing', 'attractive', 'seductive', 'provocative', 'intimate', 'sensual'].filter(word => promptLower.includes(word))
    };
    
    console.log('[IMAGE GEN] Content Analysis:', {
      hasPerson: contentAnalysis.mentions.person,
      hasLocation: contentAnalysis.mentions.location,
      hasAction: contentAnalysis.mentions.action,
      style: Object.keys(contentAnalysis.style).filter(k => contentAnalysis.style[k]),
      suggestiveWords: contentAnalysis.suggestiveKeywords.length > 0 ? contentAnalysis.suggestiveKeywords : 'none'
    });
    
    console.log('───────────────────────────────────────────────────────');
    console.log('[IMAGE GEN] STEP 3: Prepare Generation');
    console.log('───────────────────────────────────────────────────────');
    
    // Show loading state
    generateBtn.textContent = '⏳ Generating...';
    generateBtn.disabled = true;
    generateBtn.style.opacity = '0.6';
    
    console.log('[IMAGE GEN] UI State: Loading');
    console.log('[IMAGE GEN] Calling generateImage API...');
    
    const startTime = Date.now();
    
    try {
      console.log('───────────────────────────────────────────────────────');
      console.log('[IMAGE GEN] STEP 4: Generate Image (AI Processing)');
      console.log('───────────────────────────────────────────────────────');
      console.log('[IMAGE GEN] Prompt sent to AI:', prompt);
      
      // Generate image using Perchance AI
      const imageUrl = await generateImage({ prompt: prompt });
      
      const generationTime = ((Date.now() - startTime) / 1000).toFixed(2);
      console.log(`[IMAGE GEN] ✅ Image generated successfully in ${generationTime}s`);
      console.log('[IMAGE GEN] Image URL:', imageUrl.substring(0, 100) + '...');
      
      console.log('───────────────────────────────────────────────────────');
      console.log('[IMAGE GEN] STEP 5: Store & Display Image');
      console.log('───────────────────────────────────────────────────────');
      
      // Store in temp state
      gameState.tempPostImage = imageUrl;
      console.log('[IMAGE GEN] ✅ Image stored in gameState.tempPostImage');
      
      // Show preview
      if (previewContainer && previewImg) {
        previewImg.src = imageUrl;
        previewContainer.style.display = 'block';
        console.log('[IMAGE GEN] ✅ Preview displayed');
      } else {
        console.warn('[IMAGE GEN] ⚠️ Preview container not found');
      }
      
      // Auto-fill alt text if empty
      if (altInput && !altInput.value.trim()) {
        altInput.value = prompt;
        console.log('[IMAGE GEN] ✅ Alt text auto-filled with prompt');
      } else {
        console.log('[IMAGE GEN] Alt text already present, not overwriting');
      }
      
      console.log('───────────────────────────────────────────────────────');
      console.log('[IMAGE GEN] STEP 6: Update UI State');
      console.log('───────────────────────────────────────────────────────');
      
      // Success feedback
      generateBtn.textContent = '✓ Image Generated!';
      generateBtn.style.background = '#00d4ff';
      console.log('[IMAGE GEN] UI State: Success');
      
      setTimeout(() => {
        generateBtn.textContent = '🎨 Generate Image';
        generateBtn.style.background = '#533483';
        generateBtn.disabled = false;
        generateBtn.style.opacity = '1';
        console.log('[IMAGE GEN] UI State: Reset to ready');
      }, 2000);
      
      console.log('═══════════════════════════════════════════════════════');
      console.log('✅ [IMAGE GENERATION PIPELINE] COMPLETE');
      console.log(`   Total time: ${generationTime}s`);
      console.log('═══════════════════════════════════════════════════════\n');
      
    } catch (error) {
      const failTime = ((Date.now() - startTime) / 1000).toFixed(2);
      console.log('═══════════════════════════════════════════════════════');
      console.error('❌ [IMAGE GENERATION PIPELINE] FAILED');
      console.error(`   Time to failure: ${failTime}s`);
      console.error('   Error:', error);
      console.log('═══════════════════════════════════════════════════════\n');
      
      alert('Failed to generate image. Please try again.');
      
      generateBtn.textContent = '🎨 Generate Image';
      generateBtn.disabled = false;
      generateBtn.style.opacity = '1';
    }
  }
  
  /**
   * Regenerate player post image
   */
  async function regeneratePlayerPostImage() {
    await generatePlayerPostImage_handler();
  }
  
  /**
   * Submit player post to feed
   * ENHANCED WITH DETAILED LOGGING FOR EACH STEP
   */
  function submitPlayerPostToFeed() {
    console.log('═══════════════════════════════════════════════════════');
    console.log('🚀 [POST CREATION PIPELINE] STEP 1: Initialize Post');
    console.log('═══════════════════════════════════════════════════════');
    
    const captionInput = $('playerPostCaption');
    const imageAltInput = $('playerPostAltText');
    const explicitCheckbox = $('playerPostExplicit');
    
    const caption = captionInput?.value.trim() || '';
    const imageUrl = gameState.tempPostImage || null;
    const imageAlt = imageAltInput?.value.trim() || '';
    const isExplicit = explicitCheckbox?.checked || false;
    
    console.log('[POST CREATION] Input Data:', {
      caption: caption || '(none)',
      imageUrl: imageUrl ? 'Present' : 'None',
      imageAlt: imageAlt || '(none)',
      isExplicitMarked: isExplicit
    });
    
    // Validate
    if (!caption && !imageUrl) {
      console.warn('[POST CREATION] ❌ Validation failed: No caption or image');
      alert('Please add either a caption or an image!');
      return;
    }
    
    if (imageUrl && !imageAlt) {
      console.warn('[POST CREATION] ❌ Validation failed: Image without alt text');
      alert('Please add alt text for your image (helps NPCs understand it)!');
      return;
    }
    
    if (caption.length > 500) {
      console.warn('[POST CREATION] ❌ Validation failed: Caption too long');
      alert('Caption is too long! Maximum 500 characters.');
      return;
    }
    
    console.log('[POST CREATION] ✅ Validation passed');
    
    console.log('───────────────────────────────────────────────────────');
    console.log('📋 [POST CREATION PIPELINE] STEP 2: Determine Content/Type');
    console.log('───────────────────────────────────────────────────────');
    
    // Determine post type
    let postType = 'text';
    const activeTypeBtn = document.querySelector('.post-type-btn.active');
    if (activeTypeBtn) {
      postType = activeTypeBtn.dataset.type;
    }
    
    console.log('[POST CREATION] Post Type:', postType);
    
    // Determine explicit level
    let explicitLevel = 0;
    if (isExplicit) {
      explicitLevel = 3; // Player marked as explicit
      console.log('[POST CREATION] Explicit Level: 3 (player marked as explicit)');
    } else if (imageUrl) {
      // Check for suggestive keywords in alt text
      const suggestiveWords = ['sexy', 'hot', 'revealing', 'underwear', 'lingerie', 'bikini'];
      const hasSuggestive = suggestiveWords.some(word => 
        imageAlt.toLowerCase().includes(word) || caption.toLowerCase().includes(word)
      );
      if (hasSuggestive) {
        explicitLevel = 1;
        console.log('[POST CREATION] Explicit Level: 1 (suggestive keywords detected)');
      } else {
        console.log('[POST CREATION] Explicit Level: 0 (safe content)');
      }
    } else {
      console.log('[POST CREATION] Explicit Level: 0 (text-only post)');
    }
    
    console.log('───────────────────────────────────────────────────────');
    console.log('🔍 [POST CREATION PIPELINE] STEP 3: Extract Context');
    console.log('───────────────────────────────────────────────────────');
    
    // Extract @mentions from caption
    const mentions = extractMentions(caption) || []; // Safety: default to empty array
    const mentionedEmployeeIds = mentions.map(m => m.employeeId);
    
    console.log('[POST CREATION] Mention Analysis:');
    console.log(`  - Found ${mentions.length} @mentions`);
    if (mentions.length > 0) {
      mentions.forEach(m => {
        const emp = gameState.employees.find(e => e.id === m.employeeId);
        console.log(`  - @${m.username} → ${emp?.name} (ID: ${m.employeeId})`);
      });
    }
    
    // Analyze caption for context
    const captionLower = caption.toLowerCase();
    const contextFlags = {
      hasQuestion: captionLower.includes('?'),
      hasEmoji: /[\u{1F600}-\u{1F64F}|\u{1F300}-\u{1F5FF}|\u{1F680}-\u{1F6FF}|\u{2600}-\u{26FF}|\u{2700}-\u{27BF}]/u.test(caption),
      wordCount: caption.split(/\s+/).length,
      hasHashtag: caption.includes('#'),
      hasMention: caption.includes('@'),
      hasExclamation: caption.includes('!')
    };
    
    console.log('[POST CREATION] Caption Context:', contextFlags);
    
    console.log('───────────────────────────────────────────────────────');
    console.log('📝 [POST CREATION PIPELINE] STEP 4: Create Post Object');
    console.log('───────────────────────────────────────────────────────');
    
    // Create post
    const post = createPost({
      authorId: 'player',
      authorName: 'You',
      type: postType,
      content: caption,
      imageUrl: imageUrl,
      imageAlt: imageAlt,
      explicitLevel: explicitLevel,
      tags: [],
      location: gameState.activeLocationId || 'headquarters',
      isPlayerPost: true,
      referencedEmployees: mentionedEmployeeIds // Store mentioned employee IDs (correct param name)
    });
    
    console.log('[POST CREATION] Post Object Created:', {
      id: post.id,
      type: post.type,
      explicitLevel: post.explicitLevel,
      hasImage: !!post.imageUrl,
      mentions: (post.referencedEmployees || []).length,
      location: post.location,
      timestamp: new Date(post.timestamp).toLocaleTimeString()
    });
    
    console.log('───────────────────────────────────────────────────────');
    console.log('📤 [POST CREATION PIPELINE] STEP 5: Publish to Feed');
    console.log('───────────────────────────────────────────────────────');
    
    // Add to feed
    gameState.socialNetwork.posts.unshift(post);
    console.log('[POST CREATION] ✅ Post added to feed (position: 0)');
    console.log(`[POST CREATION] Total posts in feed: ${gameState.socialNetwork.posts.length}`);
    
    // Refresh dashboard to show new posts/mentions
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
      console.log('[POST CREATION] Dashboard refreshed');
    }
    
    console.log('───────────────────────────────────────────────────────');
    console.log('🧠 [POST CREATION PIPELINE] STEP 6: Update NPC Awareness');
    console.log('───────────────────────────────────────────────────────');
    
    // Store in all employees' awareness - they can see the player's posts
    const imageNote = imageUrl ? ' with image' : '';
    const postSummary = `The boss posted${imageNote}: "${caption}"`;
    let awareEmployees = 0;
    for (const emp of gameState.employees) {
      if (emp.employmentStatus === 'active') {
        remember(emp, postSummary, 'event', 1.5);
        awareEmployees++;
      }
    }
    console.log(`[POST CREATION] Updated memory for ${awareEmployees} active employees`);
    
    console.log('───────────────────────────────────────────────────────');
    console.log('💬 [POST CREATION PIPELINE] STEP 7: Trigger NPC Reactions');
    console.log('───────────────────────────────────────────────────────');
    
    const reactionDelay = 3000 + Math.random() * 5000;
    console.log(`[POST CREATION] NPC reactions will trigger in ${(reactionDelay/1000).toFixed(1)}s`);
    
    // Trigger automatic NPC reactions (delayed slightly for realism)
    setTimeout(() => {
      console.log('[POST CREATION] 🎬 Triggering NPC reactions now...');
      triggerAutomaticNPCReactions(post);
    }, reactionDelay); // 3-8 seconds
    
    console.log('═══════════════════════════════════════════════════════');
    console.log('✅ [POST CREATION PIPELINE] COMPLETE');
    console.log('═══════════════════════════════════════════════════════\n');
    
    // Close modal
    closePlayerPostModal();
    
    // Switch to social tab if not already there
    if (gameState.activeTab !== 'social') {
      switchTab('social');
    } else {
      // Just refresh feed
      renderSocialFeed();
    }
    
    // Show success message
    const feedHeader = document.querySelector('#socialTab h2');
    if (feedHeader) {
      const successMsg = document.createElement('div');
      successMsg.style.cssText = 'position:fixed; top:80px; right:20px; background:#00d4ff; color:#0f1419; padding:12px 20px; border-radius:8px; font-weight:600; box-shadow:0 4px 12px rgba(0,212,255,0.4); z-index:9999;';
      successMsg.textContent = '✓ Post published!';
      document.body.appendChild(successMsg);
      
      setTimeout(() => successMsg.remove(), 3000);
    }
  }
  
  /**
   * Generate a test post
   */
  function generateTestPost() {
    // Pick random employee or player
    const isPlayerPost = Math.random() < 0.3;
    
    let authorId, authorName;
    if (isPlayerPost) {
      authorId = 'player';
      authorName = 'You';
    } else {
      const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
      if (activeEmployees.length === 0) {
        alert('No employees to post! Hire someone first.');
        return;
      }
      const emp = activeEmployees[Math.floor(Math.random() * activeEmployees.length)];
      authorId = emp.id;
      authorName = emp.name;
    }
    
    // Random post types
    const types = ['text', 'work', 'selfie', 'meme', 'life_update'];
    const type = types[Math.floor(Math.random() * types.length)];
    
    // Random content
    const textContents = [
      "Just finished a great meeting! 💼",
      "Coffee break vibes ☕✨",
      "Feeling productive today! 🚀",
      "Anyone else excited for the weekend? 🎉",
      "New project, who dis? 👀",
      "Office life got me like... 😅",
      "Team lunch was amazing! 🍕",
      "Crushing these deadlines! 💪",
      "Best coworkers ever! ❤️",
      "Friday feeling! 🎊"
    ];
    
    const content = textContents[Math.floor(Math.random() * textContents.length)];
    
    // Random explicit level (mostly safe)
    const explicitLevel = Math.random() < 0.8 ? 0 : (Math.random() < 0.7 ? 1 : 2);
    
    // Create post
    const post = createPost({
      authorId,
      authorName,
      type,
      content,
      imageUrl: null,
      imageAlt: '',
      explicitLevel,
      tags: [],
      location: gameState.activeLocationId || 'headquarters',
      isPlayerPost
    });
    
    // Add some random likes (20-70% chance per employee)
    const allEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    allEmployees.forEach(emp => {
      if (Math.random() < 0.4 && emp.id !== authorId) {
        post.likes.push(emp.id);
      }
    });
    
    // Add some random comments (10% chance per employee)
    const commentTexts = [
      "Love this! 😍",
      "So true!",
      "Haha same here!",
      "Amazing! 🔥",
      "Can't wait!",
      "You're the best!",
      "This made my day!",
      "Absolutely!",
      "👍👍👍",
      "Facts! 💯"
    ];
    
    allEmployees.forEach(emp => {
      if (Math.random() < 0.15 && emp.id !== authorId) {
        const commentText = commentTexts[Math.floor(Math.random() * commentTexts.length)];
        const comment = createComment({
          postId: post.id,
          authorId: emp.id,
          authorName: emp.name,
          content: commentText
        });
        post.comments.push(comment);
      }
    });
    
    // Add to feed
    gameState.socialNetwork.posts.unshift(post);
    
    // Refresh dashboard to show new posts/mentions
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
    
    // Refresh feed
    renderSocialFeed();
  }
  
  // ========== AUTONOMOUS POST GENERATION SYSTEM ==========
  
  /**
   * Main autonomous post generation loop
   * Called from gameTick to continuously generate posts
   */
  async function autonomousPostGeneration() {
    // Early return if social features not initialized
    if (!gameState.socialNetwork || !gameState.employees) return;
    
    // Check if enough time has passed since last generation
    const now = Date.now();
    const timeSinceLastPost = now - (gameState.socialNetwork.lastPostGeneration || 0);
    
    // Base interval: 2-6 minutes between posts (reduced frequency to focus on comments)
    const baseInterval = 120000 + Math.random() * 240000; // 2-6 min (was 1.5-4.5 min)
    
    if (timeSinceLastPost < baseInterval) return;
    
    // Must have at least 1 employee
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (activeEmployees.length === 0) return;
    
    // Update last generation time
    gameState.socialNetwork.lastPostGeneration = now;
    
    // Determine how many posts to generate (1-3 based on employee count)
    const postCount = Math.min(3, Math.floor(1 + activeEmployees.length / 5));
    
    // Generate posts
    for (let i = 0; i < postCount; i++) {
      try {
        await generateEmployeePost();
      } catch (err) {
        console.error('Error generating employee post:', err);
      }
      
      // Small delay between posts for realism
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // Also generate autonomous comments and likes on recent posts
    try {
      await generateAutonomousComments();
      await generateAutonomousLikes();
    } catch (err) {
      console.error('Error generating autonomous interactions:', err);
    }
    
    // Refresh feed if social tab is active
    if (gameState.activeTab === 'social') {
      renderSocialFeed();
    }
  }
  
  /**
   * Check if content is too similar to recent posts by the same author
   * Uses simple keyword overlap and phrase matching
   */
  function isContentTooSimilar(content, authorId, maxRecentPosts = 5) {
    if (!content) return false;
    
    // Get recent posts by this author
    const authorPosts = gameState.socialNetwork.posts
      .filter(p => p.authorId === authorId)
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, maxRecentPosts);
    
    if (authorPosts.length === 0) return false;
    
    // Normalize content for comparison
    const normalizeText = (text) => {
      return text.toLowerCase()
        .replace(/[^\w\s]/g, '') // Remove punctuation
        .split(/\s+/)
        .filter(word => word.length > 3); // Only words longer than 3 chars
    };
    
    const newWords = normalizeText(content);
    
    // Check each recent post
    for (const post of authorPosts) {
      const existingWords = normalizeText(post.content);
      
      // Calculate word overlap
      const commonWords = newWords.filter(word => existingWords.includes(word));
      const overlapRatio = commonWords.length / Math.min(newWords.length, existingWords.length);
      
      // If more than 50% overlap, consider it too similar
      if (overlapRatio > 0.5) {
        console.log(`Content similarity detected: ${Math.round(overlapRatio * 100)}% overlap with recent post`);
        return true;
      }
      
      // Check for exact phrase repetition (3+ word sequences)
      const newText = content.toLowerCase();
      const existingText = post.content.toLowerCase();
      for (let i = 0; i < newWords.length - 2; i++) {
        const phrase = newWords.slice(i, i + 3).join(' ');
        if (phrase.length > 15 && existingText.includes(phrase)) {
          console.log(`Duplicate phrase detected: "${phrase}"`);
          return true;
        }
      }
    }
    
    return false;
  }
  
  /**
   * Generate a single post from a random employee
   */
  async function generateEmployeePost() {
    // Select random active employee
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    if (activeEmployees.length === 0) return;
    
    const author = activeEmployees[Math.floor(Math.random() * activeEmployees.length)];
    
    // Get employee context (pass ID, not object)
    const context = getEmployeeAwarenessForPost(author.id);
    
    // Safety check - if context is null, skip this post
    if (!context) {
      console.error('Failed to get context for employee:', author.name);
      return;
    }
    
    // Determine post type based on personality and recent activity
    const postType = selectPostType(author, context);
    
    // Check if this is an event-triggered post
    const recentEvents = getRelevantEvents(author.id, 3);
    const shouldReactToEvent = recentEvents.length > 0 && Math.random() < 0.4;
    
    let postContent, imagePrompt, imageUrl, explicitLevel, tags;
    
    if (shouldReactToEvent) {
      // Event-triggered post
      const event = recentEvents[0];
      const reaction = await generateEventReaction(author, event, context);
      
      // Safety check - if reaction generation failed, fall back to organic post
      if (!reaction) {
        console.warn('Event reaction generation failed, falling back to organic post');
        const generated = await generateOrganicPost(author, postType, context);
        postContent = generated.content;
        imagePrompt = generated.imagePrompt;
        explicitLevel = generated.explicitLevel;
        tags = generated.tags || [];
      } else {
        postContent = reaction.content;
        imagePrompt = reaction.imagePrompt;
        explicitLevel = reaction.explicitLevel;
        tags = reaction.tags || [];
      }
    } else {
      // Organic post based on personality
      const generated = await generateOrganicPost(author, postType, context);
      postContent = generated.content;
      imagePrompt = generated.imagePrompt;
      explicitLevel = generated.explicitLevel;
      tags = generated.tags || [];
    }
    
    // Check for content similarity with recent posts
    if (isContentTooSimilar(postContent, author.id)) {
      console.log(`Skipping similar post from ${author.name}, will try again later`);
      return null; // Skip this post, will generate a different one next time
    }
    
    // Generate image if needed
    if (imagePrompt && ['selfie', 'meme', 'thirst_trap', 'explicit', 'food', 'travel', 'life_update'].includes(postType)) {
      try {
        imageUrl = await generateImage({ prompt: imagePrompt });
      } catch (error) {
        console.error('Image generation failed:', error);
        imageUrl = null;
      }
    }
    
    // Create post
    const post = createPost({
      authorId: author.id,
      authorName: author.name,
      type: postType,
      content: postContent,
      imageUrl: imageUrl || null,
      imageAlt: imagePrompt || '',
      explicitLevel: explicitLevel,
      tags: tags,
      location: author.location || 'headquarters',
      isPlayerPost: false
    });
    
    // Add to feed
    gameState.socialNetwork.posts.unshift(post);
    
    // Refresh dashboard to show new posts/mentions
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
    
    // Store post in employee memory
    const imageNote = imageUrl ? ' with image' : '';
    remember(author, `I posted${imageNote}: "${postContent}"`, 'event', 2.0);
    
    // Track post type for variety
    gameState.socialNetwork.recentPostTypes.push(postType);
    if (gameState.socialNetwork.recentPostTypes.length > 20) {
      gameState.socialNetwork.recentPostTypes.shift();
    }
    
    // Trigger targeted comments for tea_spilling posts
    if (postType === 'tea_spilling') {
      setTimeout(() => {
        triggerTeaSpillingComments(post, author);
      }, 3000 + Math.random() * 5000); // 3-8 seconds delay
    }
    
    // Log event
    logCompanyEvent('post_created', {
      authorId: author.id,
      authorName: author.name,
      postType: postType,
      explicitLevel: explicitLevel
    });
    
    return post;
  }
  
  /**
   * Select post type based on employee personality
   */
  function selectPostType(employee, context) {
    const social = employee.social;
    if (!social) return 'text';
    
    // Get recent post types to ensure variety
    const recentTypes = gameState.socialNetwork.recentPostTypes || [];
    
    // EXPANDED post type weights with NEW categories
    const prefs = social.contentPreferences || {};
    const weights = {
      // Original types
      text: 20,
      work: prefs.workPosts ? Math.round(prefs.workPosts * 50) : 20,
      selfie: prefs.selfies ? Math.round(prefs.selfies * 50) : 30,
      meme: prefs.memes ? Math.round(prefs.memes * 50) : 20,
      life_update: prefs.lifeUpdates ? Math.round(prefs.lifeUpdates * 50) : 15,
      thirst_trap: prefs.thirstTraps ? Math.round(prefs.thirstTraps * 50) : 10,
      explicit: prefs.explicitContent ? Math.round(prefs.explicitContent * 50) : 5,
      travel: prefs.travelPosts ? Math.round(prefs.travelPosts * 50) : 10,
      food: 10,
      
      // NEW expanded types for more variety
      fitness: 12,        // Workout, gym, health
      hobby: 15,          // Specific hobbies/interests
      entertainment: 15,  // Movies, shows, music, books
      mood: 18,           // Pure vibe/feeling posts
      question: 12,       // Asking followers something
      achievement: 10,    // Personal wins (not just work)
      throwback: 8,       // Memories, nostalgia
      pet: 10,            // Pets/animals (if they have them)
      fashion: 12,        // Outfit, style
      complaint: 8,       // Venting (keeps it real)
      inspiration: 10,    // Motivational/philosophical
      weather: 8,         // Weather-related mood
      random: 12,         // Completely random thoughts
      gossip: 10,         // CRYPTIC/VAGUE drama (mysterious hints)
      tea_spilling: 10    // DIRECT/SPECIFIC drama (calling people out)
    };
    
    // Boost certain post types if there's recent chat context
    if (context.chatContext?.hasRecentChat) {
      const themes = context.chatContext.themes || [];
      
      // If conversation was flirty, boost suggestive post types
      if (themes.includes('flirty/romantic')) {
        weights.text += 15;
        weights.selfie += 20;
        weights.thirst_trap += 25;
        weights.mood += 10;
        if (employee.intimacy > 60) {
          weights.explicit += 15;
        }
      }
      
      // If conversation was work-related, slightly boost work posts
      if (themes.includes('work-related')) {
        weights.work += 10;
        weights.text += 5;
        weights.achievement += 8;
      }
      
      // If conversation was emotional/personal, boost personal content
      if (themes.includes('emotional/personal')) {
        weights.text += 15;
        weights.life_update += 10;
        weights.mood += 12;
        weights.inspiration += 8;
      }
      
      // If conversation was about food/social, boost related content
      if (themes.includes('food/social')) {
        weights.food += 15;
        weights.life_update += 10;
      }
    }
    
    // Reduce weights for recently used types (variety) - MORE AGGRESSIVE
    Object.keys(weights).forEach(type => {
      const recentUseCount = recentTypes.filter(t => t === type).length;
      // More aggressive penalty: -8 per use (was -5)
      weights[type] = Math.max(1, weights[type] - (recentUseCount * 8));
    });
    
    // Apply personality modifiers
    const personality = employee.personality || {};
    if (personality.outgoing > 70) {
      weights.selfie += 15;
      weights.life_update += 10;
      weights.question += 10;
    }
    if (personality.professional > 70) {
      weights.work += 20;
      weights.explicit -= 5;
      weights.achievement += 10;
      weights.inspiration += 8;
    }
    if (personality.flirty > 70) {
      weights.thirst_trap += 20;
      weights.selfie += 10;
      weights.mood += 5;
      weights.fashion += 8;
    }
    
    // NEW: Confidence affects boldness of posts
    if (personality.confidence > 70) {
      weights.selfie += 10;
      weights.achievement += 12;
      weights.question += 5;
    } else if (personality.confidence < 40) {
      weights.mood += 10;
      weights.random += 8;
      weights.complaint += 5;
    }
    
    // NEW: Boost gossip if employee knows juicy gossip!
    initializeGossipSystem(employee);
    const knownGossip = getKnownGossip(employee.id, 1);
    if (knownGossip.length > 0) {
      const gossipJuiciness = knownGossip[0].juiciness || 50;
      const gossipBoost = Math.floor(gossipJuiciness / 5); // Up to +20 for very juicy gossip
      
      weights.gossip += gossipBoost;
      weights.tea_spilling += gossipBoost;
      
      // Super juicy gossip (80+) makes tea_spilling more likely
      if (gossipJuiciness >= 80) {
        weights.tea_spilling += 20;
      }
      
      // Gossipy people post gossip more
      if (employee.gossip.gossipTendency > 60) {
        weights.gossip += 15;
        weights.tea_spilling += 10;
      }
      
      // Bold/confident people more likely to spill tea directly
      if (personality.confidence > 65) {
        weights.tea_spilling += 15;
      }
    } else {
      // No gossip to share, reduce weight
      weights.gossip = 1;
      weights.tea_spilling = 1;
    }
    
    // NEW: Add time-of-day bonuses for realism
    const hour = new Date().getHours();
    if (hour >= 6 && hour < 9) {
      // Morning posts
      weights.mood += 8;
      weights.fitness += 10;
      weights.food += 5; // Coffee/breakfast
    } else if (hour >= 9 && hour < 17) {
      // Work hours
      weights.work += 12;
      weights.complaint += 5;
      weights.food += 5; // Lunch
    } else if (hour >= 17 && hour < 22) {
      // Evening
      weights.life_update += 10;
      weights.entertainment += 10;
      weights.food += 8; // Dinner/drinks
    } else {
      // Late night
      weights.mood += 10;
      weights.random += 8;
      weights.throwback += 8;
    }
    
    // Apply company policy modifiers
    const policy = gameState.settings.consentModel || 'casual';
    if (policy === 'professional') {
      weights.explicit = Math.max(1, weights.explicit - 10);
      weights.thirst_trap = Math.max(5, weights.thirst_trap - 5);
    } else if (policy === 'open') {
      weights.thirst_trap += 10;
      weights.explicit += 10;
    }
    
    // Weighted random selection
    const totalWeight = Object.values(weights).reduce((sum, w) => sum + Math.max(0, w), 0);
    let random = Math.random() * totalWeight;
    
    for (const [type, weight] of Object.entries(weights)) {
      random -= Math.max(0, weight);
      if (random <= 0) return type;
    }
    
    return 'text'; // Fallback
  }
  
  /**
   * Generate event reaction post using AI
   */
  async function generateEventReaction(employee, event, context) {
    const personality = employee.personality || {};
    const social = employee.social || {};
    
    // Safety check for event structure
    if (!event || !event.type) {
      console.warn('Invalid event structure in generateEventReaction:', event);
      return null;
    }
    
    // Build context for AI
    // Events have properties directly on them (description, involvedEmployees, etc.)
    const eventDescription = (() => {
      switch (event.type) {
        case 'hire': 
          // Extract name from description
          const hireName = event.description ? event.description.split(' ')[0] : 'someone';
          return `${hireName} just joined the company`;
        case 'fire': 
          const fireName = event.description ? event.description.split(' ')[0] : 'someone';
          return `${fireName} left the company`;
        case 'promotion': 
          const promoName = event.description ? event.description.split(' ')[0] : 'someone';
          const newRole = event.description ? event.description.match(/as (.+)/)?.[1] || 'a new role' : 'a new role';
          return `${promoName} got promoted to ${newRole}`;
        case 'chat': 
          return `Had a ${event.sentiment || 'interesting'} chat with a coworker`;
        case 'gift': 
          return `Received a gift`;
        case 'achievement': 
          return `Reached a milestone: ${event.description || 'an achievement'}`;
        default: 
          return event.description || 'Something happened at work';
      }
    })();
    
    const personalityDesc = `${employee.name} is ${personality.outgoing || 50}/100 outgoing, ${personality.professional || 50}/100 professional, ${personality.flirty || 50}/100 flirty`;
    
    const relationshipContext = (context.coworkers || []).slice(0, 3).map(c => 
      `${c.coworkerName} (${c.relationship})`
    ).join(', ');
    
    // Get player/boss description for relevant events
    const playerDesc = getPlayerDescription('post');
    const bossContextNote = (event.type === 'chat' || event.type === 'gift' || event.type === 'promotion') && playerDesc !== 'the boss'
      ? `\nYour boss: ${playerDesc}`
      : '';
    
    // Gender-appropriate description
    const genderDesc = employee.gender ? `, a ${employee.age || 'young'}-year-old ${employee.gender === 'male' ? 'man' : employee.gender === 'transMan' ? 'trans man' : employee.gender === 'transWoman' ? 'trans woman' : employee.gender === 'femaleFuta' ? 'woman' : 'woman'}` : '';
    
    const prompt = `You are ${employee.name}${genderDesc}, an employee posting on an uncensored social media about a recent event.

Event: ${eventDescription}
Your personality: ${personalityDesc}
Your coworkers: ${relationshipContext}
Location: ${employee.location || 'office'}${bossContextNote}

Write a SHORT (1-3 sentences) social media post reacting to this event. Be authentic to the personality. Use emojis sparingly (0-2). Be conversational and natural.

${social.contentStyle === 'casual' ? 'Style: Casual and relaxed' : social.contentStyle === 'professional' ? 'Style: Professional but friendly' : 'Style: Balanced between casual and professional'}

Post:`;

    try {
      const content = await generateText(prompt);
      
      // Determine explicit level
      let explicitLevel = 0;
      if (event.type === 'chat' && event.sentiment === 'flirty') {
        explicitLevel = Math.min(2, Math.floor(personality.flirty / 40));
      }
      
      // Determine if image should be generated
      let imagePrompt = null;
      if (event.type === 'promotion' && Math.random() < 0.6) {
        const physDesc = employee.physical?.shortDescription || `${employee.age || 'young'}-year-old ${employee.gender === 'male' ? 'man' : employee.gender === 'transMan' ? 'trans man' : 'woman'}`;
        imagePrompt = `Professional celebration selfie: ${physDesc} smiling, office setting, happy expression, high quality`;
      } else if (event.type === 'achievement' && Math.random() < 0.5) {
        const physDesc = employee.physical?.shortDescription || `${employee.age || 'young'}-year-old ${employee.gender === 'male' ? 'man' : employee.gender === 'transMan' ? 'trans man' : 'woman'}`;
        imagePrompt = `Excited celebration photo: ${physDesc} celebrating achievement, office environment, triumphant pose, high quality`;
      }
      
      return {
        content: content.trim(),
        imagePrompt,
        explicitLevel,
        tags: [event.type]
      };
    } catch (error) {
      console.error('AI generation failed:', error);
      // Fallback to template
      return {
        content: `${eventDescription}! 🎉`,
        imagePrompt: null,
        explicitLevel: 0,
        tags: [event.type]
      };
    }
  }
  
  /**
   * Generate organic post using AI
   */
  async function generateOrganicPost(employee, postType, context) {
    const personality = employee.personality || {};
    const social = employee.social || {};
    
    // Build rich context
    const personalityDesc = `outgoing: ${personality.outgoing || 50}/100, professional: ${personality.professional || 50}/100, flirty: ${personality.flirty || 50}/100, confidence: ${personality.confidence || 50}/100`;
    
    // Get coworkers with their usernames for potential mentions
    const coworkersWithUsernames = (context.coworkers || []).slice(0, 5).map(c => {
      const coworker = gameState.employees.find(e => e.id === c.coworkerId);
      const username = coworker?.social?.username || null;
      return {
        name: c.coworkerName,
        username: username,
        relationship: c.relationship,
        knownFor: c.knownFor || 'coworker'
      };
    });
    
    const relationshipContext = coworkersWithUsernames.map(c => 
      c.username 
        ? `${c.name} (@${c.username}) - ${c.relationship}, ${c.knownFor}` 
        : `${c.name} - ${c.relationship}, ${c.knownFor}`
    ).join(', ') || 'new to the team';
    
    const locationContext = (context.knownLocations || []).join(', ') || 'office';
    
    // Get boss relationship
    const bossRelationship = employee.relationships?.player || { level: 0, type: 'professional' };
    const intimacy = employee.intimacy || 0;
    const affection = employee.stats?.affection || 0;
    
    // Randomly decide if this post should mention someone (30% chance for relevant post types)
    const shouldMention = Math.random() < 0.3 && 
                          ['text', 'work', 'life_update', 'food'].includes(postType) &&
                          (coworkersWithUsernames.length > 0 && coworkersWithUsernames.some(c => c.username));
    
    // Boss mention (lower chance, but increases with relationship)
    const shouldMentionBoss = Math.random() < (0.05 + (affection / 100) * 0.15) && // 5-20% chance based on affection
                              ['text', 'work', 'food', 'life_update'].includes(postType);
    
    const mentionableCoworkers = coworkersWithUsernames.filter(c => c.username);
    let mentionInstruction = '';
    
    if (shouldMentionBoss) {
      const bossTone = intimacy > 60 ? 'warmly and casually' : affection > 50 ? 'appreciatively' : 'professionally';
      mentionInstruction = `\n💡 Consider naturally mentioning your boss @TheBoss if relevant. Be ${bossTone}. Examples: "Meeting with @TheBoss went great!", "Thanks @TheBoss for the feedback", "@TheBoss really came through today". Only mention if it feels natural!`;
    } else if (shouldMention && mentionableCoworkers.length > 0) {
      const randomCoworker = mentionableCoworkers[Math.floor(Math.random() * mentionableCoworkers.length)];
      mentionInstruction = `\n💡 Consider naturally mentioning @${randomCoworker.username} (${randomCoworker.name}) if relevant to your post. Examples: "Coffee with @${randomCoworker.username} hit different today", "Thanks @${randomCoworker.username} for the help!", "Spotted @${randomCoworker.username} in the break room". Only mention if it feels natural - don't force it!`;
    }
    
    // Post type specific instructions - MASSIVELY EXPANDED
    const typeInstructions = {
      // Original types (enhanced)
      text: 'Write a casual status update about your day, thoughts, or feelings. Be authentic and varied - NOT always about work. Topics: how you\'re feeling, observations, random thoughts, what you\'re doing. 1-2 sentences. Examples: "Why does Monday exist 😩", "Feeling like a main character today ✨", "That moment when you realize it\'s only Tuesday", "Honestly just vibing", "Send coffee or leave me alone ☕"',
      
      work: 'Write about work BUT make it interesting and varied. NOT just "meetings" or "deadlines". Topics: interesting project moments, team dynamics, wins, frustrations, learning something new, funny work moment. 1-2 sentences. Examples: "Actually proud of what we shipped today 🚀", "When the code finally works on the first try 🎉", "Debugging since 9am send help 💀", "Best brainstorm session ever", "Coffee and spreadsheets, living the dream"',
      
      selfie: 'Write a SHORT caption for a selfie. Show personality - NOT generic "feeling cute". Topics: your mood, confidence, what you\'re doing, where you are, or just pure vibe. Max 15 words. Examples: "Main character energy 💫", "No thoughts, just vibes", "Serving looks and chaos", "That post-workout glow though", "Unapologetically me", "Caught in the act of existing"',
      
      meme: 'Write a humorous, relatable caption. Reference real life, pop culture, common experiences. Be funny and current. 1 sentence. Examples: "Me: *buys coffee* / My bank account: 👁️👄👁️", "POV: You said you\'d be productive today 💀", "Everyone else: weekend plans / Me:", "Not me stress eating at my desk again 😅", "When they ask if I\'m okay: *insert image of everything on fire*"',
      
      life_update: 'Share a genuine personal life update - hobbies, weekend, personal news, life moments. Be specific and interesting. 1-2 sentences. Examples: "Finally finished that book I\'ve been reading for 6 months 📚", "Learned a new recipe and didn\'t burn the kitchen down 🎉", "Adopting a plant parent lifestyle, wish me luck 🌱", "Started binging a new show and can\'t stop 📺"',
      
      thirst_trap: `Write a CONFIDENT, FLIRTY caption for a revealing/attractive photo. Be bold, suggestive, playful. ${personality.flirty > 60 ? 'Be explicitly flirtatious' : 'Be subtly seductive'}. Reference confidence, your look, or energy. Max 10 words. Examples: "Confidence looks good on me 😏", "You\'re welcome 💋", "Just thinking out loud 🤔🔥", "Felt cute, felt powerful", "No caption needed 👀", "Making Monday better", "Dangerous mood today"`,
      
      explicit: `Write a SEXUALLY BOLD caption for explicit content. Be provocative and unapologetic. ${personality.flirty > 70 ? 'Be very direct' : 'Use suggestive language'}. Max 12 words. Examples: "After hours 🔥", "Private show 💦", "What they don't see at work 😈", "Special delivery", "No rules tonight", "Taking requests 👀", "Feeling dangerous", "Handle with care"`,
      
      travel: 'Post about travel, places, or wanting to travel. Show excitement or wanderlust. 1 sentence. Examples: "Daydreaming about beaches and zero responsibilities 🏖️", "Next vacation can\'t come soon enough", "That travel bug hitting different lately ✈️", "Exploring local spots hits different 🗺️"',
      
      food: 'Post about food, drinks, or cravings with enthusiasm. Be specific or playful. 1 sentence. Examples: "This coffee is single-handedly keeping me alive ☕", "Taco Tuesday is the only thing I believe in 🌮", "Why does food taste better when someone else makes it 🍕", "Currently accepting dinner recommendations", "That post-meal satisfaction 😌"',
      
      // NEW expanded types for variety
      fitness: 'Post about workout, gym, health, or physical activity. Show effort, results, or motivation. 1-2 sentences. Examples: "That post-workout high hits different 💪", "Gym session: crushed / My legs: destroyed", "Actually showed up today, proud of myself 🏋️", "Running on endorphins and stubbornness", "Started my fitness journey, we\'ll see how this goes 🏃"',
      
      hobby: `Post about a specific hobby or interest. Be passionate and specific - reference what you DO. Include details. 1-2 sentences. ${employee.hobbies && employee.hobbies.length > 0 ? `Your hobbies: ${employee.hobbies.join(', ')}. Reference one of these!` : ''} Examples: "Finally beat that level I\'ve been stuck on 🎮", "New vinyl just dropped and it\'s 🔥", "Spent the afternoon painting and lost track of time 🎨", "Photography walk was exactly what I needed 📸"`,
      
      entertainment: 'Post about movies, shows, music, books, or pop culture. Share opinions, recommendations, or what you\'re into. 1-2 sentences. Examples: "Just finished that show everyone\'s talking about and WOW 🎬", "This song is living rent-free in my head 🎵", "Reading a book that\'s actually making me think 📖", "Can we talk about that plot twist though 😱", "New album on repeat, absolute fire 🔥"',
      
      mood: 'Pure vibe/feeling post. Express current mood, energy, or emotional state. Be authentic and relatable. 1 sentence. Examples: "Big chaotic energy today 🌪️", "Soft girl hours 🌸", "Feeling myself a little too much today ✨", "Main character syndrome activated", "That unexplainable good mood", "Tired but make it aesthetic 😴", "Existing and thriving", "No thoughts, head empty, vibes immaculate"',
      
      question: 'Ask followers something - opinion, recommendation, this-or-that. Be engaging. 1 sentence with question mark. Examples: "Coffee or tea, and why is coffee the only right answer? ☕", "What\'s a show I NEED to watch right now? 📺", "Hot take: pineapple on pizza is valid. Fight me or agree? 🍕", "Weekend plans or just winging it? 🎉", "What\'s your go-to comfort food when life gets weird? 🍜"',
      
      achievement: 'Share a personal win - small or big. NOT always work (can be life, personal growth, random wins). Show pride. 1-2 sentences. Examples: "Didn\'t hit snooze once this week, I\'m basically unstoppable", "Finally organized my closet and found clothes I forgot existed 🎉", "Made it through the week without a breakdown, new personal record 💪", "Hit a goal I didn\'t think I could reach 🎯", "Small win but it feels big ✨"',
      
      throwback: 'Nostalgic post about a memory, past experience, or "remember when". Be specific and reflective. 1-2 sentences. Examples: "Remember when we all thought 2020 would be our year 💀", "Thinking about that summer where everything just hit different ☀️", "Found old photos and the nostalgia is hitting hard 📸", "Miss the days when my biggest worry was what to eat 🥺", "Throwback to when life was simpler"',
      
      pet: 'Post about pets, animals, or wanting a pet. Show affection or humor. 1 sentence. Examples: "My cat judges every life decision I make and she\'s not wrong 🐱", "Dogs really are too pure for this world 🐕", "That moment when your pet becomes your therapist 💕", "Saw the cutest dog today and it made my whole week", "Considering adopting a pet just for the emotional support"',
      
      fashion: 'Post about outfit, style, clothing, or fashion choices. Show confidence in your look. 1 sentence. Examples: "Serving looks and confidence today 💃", "This outfit said main character and I listened ✨", "When your outfit matches your energy >>", "Feeling this style lately 👗", "Comfortable AND cute, we love to see it"',
      
      complaint: 'Vent about something annoying, frustrating, or relatable. Keep it real and funny. 1-2 sentences. Examples: "Why does everything decide to break at the same time 😩", "Being an adult is just constantly asking wait do I have plans 💀", "My back hurts and I didn\'t even do anything this is 25", "Can life give me a break or is that too much to ask", "Monday can take several seats 💺"',
      
      inspiration: 'Share something motivational, philosophical, or reflective. Be genuine not corporate-cheesy. 1-2 sentences. Examples: "Growth is uncomfortable but staying the same is worse 🌱", "Normalize doing what\'s best for you even if others don\'t get it ✨", "You don\'t have to be perfect just keep showing up 💪", "Small steps still count as progress 🚶", "Be the energy you want to attract"',
      
      weather: 'Comment on weather and how it affects mood or plans. Be relatable. 1 sentence. Examples: "This weather is giving main character energy ☀️", "Rain + cozy vibes = perfect day for doing nothing 🌧️", "Why is it so hot I\'m literally melting 🥵", "Cold weather = excuse to stay in bed all day ❄️", "Perfect weather for absolutely nothing productive"',
      
      random: 'Completely random thought observation or chaotic energy. Be spontaneous and unexpected. 1 sentence. Examples: "Thinking about how penguins have knees and now I can\'t unthink it 🐧", "What if plants are actually farming us 🌱🤔", "The word bed looks like a bed", "Why do we say heads up when we actually mean duck 💀", "Random urge to completely change my life at 2am", "Not all thoughts need to be said but here we are"',
      
      gossip: `Post about office gossip/drama you know about. Be VAGUE and MYSTERIOUS but juicy. Use cryptic language or emojis. DON'T name names. 1-2 sentences. ${employee.gossip?.knownGossip?.length > 0 ? 'Reference the gossip you know but DON\'T name names directly - keep it mysterious!' : ''} Examples: "Someone at work is MESSY and I'm here for it 👀☕", "The tea is piping hot today and I'm observing from a safe distance 🍿", "Not me knowing things I probably shouldn't know 🤐", "Office drama >>> any reality TV show 📺", "Just heard something WILD but my lips are sealed... for now 🤫", "Y'all I can't even—workplace is SPICY lately 🌶️"`,
      
      tea_spilling: `SPILL THE TEA! Post about office gossip/drama you know with SPECIFIC NAMES using @mentions. Be DIRECT and call people out, but keep it playful/dramatic not mean. ${employee.gossip?.knownGossip?.length > 0 ? 'Reference the gossip you know and USE NAMES with @ mentions!' : ''} 1-2 sentences max. Examples: "Sooo @sarah and @mike definitely hooked up after work yesterday, I'm just saying 👀", "Wait @jessica has been wearing @kevin's hoodie all week? TEA 🍵", "Not @emma posting thirst traps right after her breakup with @alex... we see you queen 💅", "@chris really thought nobody would notice him sneaking out with @amber 😏", "The way @madison looked at @tyler during the meeting... PLEASE 💕"`
    };
    
    const contentStyleNote = social.contentStyle === 'casual' ? 'Use casual language, contractions, slang' :
                            social.contentStyle === 'professional' ? 'Use professional but friendly tone' :
                            'Use balanced conversational tone';
    
    // Get recent posts by this employee to encourage variety
    const recentPosts = gameState.socialNetwork.posts
      .filter(p => p.authorId === employee.id)
      .slice(0, 3)
      .map(p => p.content)
      .join(' | ');
    
    // Check recent community posts for overused themes
    const recentCommunityPosts = gameState.socialNetwork.posts
      .slice(0, 20)
      .map(p => p.content.toLowerCase());
    
    // EXPANDED theme detection to catch more repetitive patterns
    const overusedThemes = [];
    const themeChecks = [
      // Original checks
      { keywords: ['garage', 'park', 'parking'], theme: 'garage/parking' },
      { keywords: ['keys', 'lost', 'looking for', 'hunting for', 'found'], theme: 'lost items' },
      { keywords: ['reorganiz', 'organiz', 'clean', 'tidy'], theme: 'organization' },
      { keywords: ['server', 'rack', 'cable', 'wifi'], theme: 'IT equipment' },
      
      // NEW expanded checks for common repetitive themes
      { keywords: ['coffee', 'caffeine', 'espresso', 'latte'], theme: 'coffee' },
      { keywords: ['monday', 'mondays'], theme: 'Monday complaints' },
      { keywords: ['weekend', 'friday', 'tgif'], theme: 'weekend vibes' },
      { keywords: ['meeting', 'meetings', 'zoom', 'conference'], theme: 'meetings' },
      { keywords: ['deadline', 'due date', 'crunch'], theme: 'deadlines' },
      { keywords: ['tired', 'exhausted', 'sleep', 'nap'], theme: 'being tired' },
      { keywords: ['vibe', 'vibing', 'vibes'], theme: 'vibe posts' },
      { keywords: ['main character', 'mc energy'], theme: 'main character' },
      { keywords: ['chaos', 'chaotic'], theme: 'chaos energy' },
      { keywords: ['broke', 'money', 'paycheck', 'bank account'], theme: 'money struggles' }
    ];
    
    themeChecks.forEach(check => {
      const matchCount = recentCommunityPosts.filter(post => 
        check.keywords.some(kw => post.includes(kw))
      ).length;
      // More strict: 2+ posts (was 3+) about same theme triggers avoidance
      if (matchCount >= 2) {
        overusedThemes.push(check.theme);
      }
    });
    
    const themeAvoidanceNote = overusedThemes.length > 0 
      ? `\n⚠️ AVOID these overused themes: ${overusedThemes.join(', ')} - pick something completely different!`
      : '';
    
    const varietyNote = recentPosts 
      ? `\nYour recent posts: "${recentPosts}"\n⚠️ Write something DIFFERENT - new topic, different angle, fresh perspective!${themeAvoidanceNote}` 
      : themeAvoidanceNote;
    
    // Build chat context instruction
    let chatContextNote = '';
    if (context.chatContext?.hasRecentChat) {
      const chat = context.chatContext;
      const timeAgoText = chat.timeAgo < 60 ? `${chat.timeAgo} minutes ago` : `${Math.round(chat.timeAgo / 60)} hours ago`;
      const themesText = chat.themes.length > 0 ? chat.themes.join(', ') : 'casual conversation';
      
      // Get last few message previews
      const messagePreview = chat.lastMessages
        .map(msg => `${msg.sender}: "${msg.preview}${msg.preview.length >= 100 ? '...' : ''}"`)
        .join('\n');
      
      // Check relationship level to determine tone
      const relationshipTone = intimacy > 60 
        ? '🔥 IMPORTANT: You have a HIGH-INTIMACY, CONSENSUAL relationship with your boss. Don\'t post negatively about flirty/explicit requests - you ENJOY this dynamic! If posting about photo requests or intimate conversations, be POSITIVE, excited, teasing, or playful (NOT uncomfortable or complaining).'
        : intimacy > 30
        ? '💕 You have a developing intimate relationship with your boss. Flirty/explicit content should be framed positively or teasingly, not as harassment.'
        : affection > 60
        ? '😊 You have good rapport with your boss. Keep posts about work interactions positive or playful.'
        : '';
      
      chatContextNote = `\n\n💬 RECENT CHAT WITH BOSS (${timeAgoText}):
Conversation themes: ${themesText}
Last messages:
${messagePreview}

${relationshipTone}

💡 OPTIONAL: You could make a post inspired by this conversation! Examples:
- If it was flirty: "Still thinking about that conversation... 😏" or "Feeling some type of way today 🔥"
- If it was work: "Excited about the new project!" or "Time to crush these deadlines 💪"
- If it was personal: "Good talks hit different" or "Grateful for good listeners"
- Or post about something COMPLETELY DIFFERENT - you don't have to reference the chat!

${chat.themes.includes('flirty/romantic') && ['text', 'selfie', 'thirst_trap'].includes(postType) 
  ? '🔥 Since you had a flirty chat recently, feel free to make a suggestive/spicy post if it feels natural!' 
  : ''}`;
    }
    
    // Build boss request context
    let bossRequestNote = '';
    if (context.requestedByBoss) {
      bossRequestNote = `\n\n🎯 BOSS REQUESTED THIS POST:
The boss specifically asked you to make this post${context.requestContext ? `: "${context.requestContext}"` : ''}.
You've already agreed to do it, so make the post they requested!
Be confident and match the tone they were asking for.
${postType === 'explicit' || postType === 'thirst_trap' ? 'They want something bold and provocative - don\'t hold back!' : ''}`;
    }
    
    // Get player/boss description for context when mentioning
    const playerDesc = getPlayerDescription('post'); // Use 'post' context for social media
    const bossContextNote = playerDesc !== 'the boss' ? `\n\n👤 ABOUT YOUR BOSS:\n${playerDesc}` : '';
    
    // Add gossip context for gossip posts
    let gossipContextNote = '';
    if (postType === 'gossip' || postType === 'tea_spilling') {
      const knownGossip = getKnownGossip(employee.id, 3);
      if (knownGossip.length > 0) {
        const gossipDetails = knownGossip.map(g => {
          const subject = g.subjectId === 'player' ? 'the boss' : 
                        gameState.employees.find(e => e.id === g.subjectId)?.name || 'someone';
          const subjectUsername = g.subjectId === 'player' ? '@boss' :
                                 gameState.employees.find(e => e.id === g.subjectId)?.social?.username || null;
          const target = g.targetId ? 
                        (g.targetId === 'player' ? 'the boss' : 
                         gameState.employees.find(e => e.id === g.targetId)?.name || 'someone') : '';
          const targetUsername = g.targetId ? 
                                (g.targetId === 'player' ? '@boss' :
                                 gameState.employees.find(e => e.id === g.targetId)?.social?.username || null) : '';
          const accuracy = g.accuracy < 50 ? ' (might be a rumor)' : 
                          g.accuracy < 80 ? ' (heard through grapevine)' : '';
          
          if (postType === 'tea_spilling' && subjectUsername) {
            // For tea spilling, provide names with usernames
            return `- ${subject} (${subjectUsername})${target ? ` and ${target} (${targetUsername})` : ''}: ${g.content}${accuracy}`;
          } else {
            return `- ${g.content}${accuracy}`;
          }
        }).join('\n');
        
        if (postType === 'tea_spilling') {
          gossipContextNote = `\n\n🍵 TEA TO SPILL:
${gossipDetails}

🎯 SPILL IT! Use @usernames to call people out directly! Be dramatic and juicy but playful. Examples:
- "Not @sarah hooking up with @mike in the supply closet 👀"
- "@kevin has been acting SUS around @jessica lately... just saying 🫖"
- "Everyone pretending they don't see @alex and @emma sneaking around 😏"`;
        } else {
          gossipContextNote = `\n\n🫖 GOSSIP YOU KNOW:
${gossipDetails}

⚠️ DON'T name names directly! Keep it mysterious and vague. Hint at the drama without being too specific. Use "someone", "people", "coworkers", etc.`;
        }
      } else {
        if (postType === 'tea_spilling') {
          gossipContextNote = `\n\n⚠️ You don't have specific tea right now, so make a teasing post about ALMOST spilling tea or hinting that you know something without details.`;
        } else {
          gossipContextNote = `\n\n⚠️ You don't actually know any specific gossip right now, so make a generic "something's happening" type post or pretend you heard something vague.`;
        }
      }
    }
    
    // Gender and physical description for full self-awareness
    const genderDesc = employee.gender ? `, a ${employee.age || 'young'}-year-old ${employee.gender === 'Male' ? 'man' : employee.gender === 'Trans Man' ? 'trans man' : employee.gender === 'Trans Woman' ? 'trans woman' : employee.gender === 'Female Futa' ? 'woman with unique anatomy' : 'woman'}` : '';
    const physicalDesc = context.employee?.physicalDescription || getPhysicalDescriptionForPrompt(employee);
    
    const prompt = `You are ${employee.name}${genderDesc}, posting on an uncensored social media.

YOUR PHYSICAL APPEARANCE: ${physicalDesc}
(You are fully aware of your body, gender, and physical characteristics. Reference them naturally if relevant to your post, especially in selfies or intimate content.)

Personality: ${personalityDesc}
Post type: ${postType}
Coworkers: ${relationshipContext}
Style: ${contentStyleNote}${varietyNote}${mentionInstruction}${chatContextNote}${bossRequestNote}${bossContextNote}${gossipContextNote}

${typeInstructions[postType] || typeInstructions.text}

CRITICAL RULES: 
- Write ONLY the post itself - NO explanations, notes, or meta-commentary
- NO parenthetical notes like "(Note: ...)" or style explanations
- Be SHORT and authentic (1-2 sentences MAX)
- Hashtags: Use 0-1 hashtags, make them natural and varied (avoid #Garage unless truly relevant)
- Emojis: 0-2 max, use sparingly
- Don't always mention location - posts can be about ANYTHING
- Vary your topics - avoid repetitive scenarios (keys, parking, garage organization)
- Sound like a real person, not AI
- When mentioning coworkers, use their @username format naturally

Write ONLY the social media post text:`;

    try {
      let content = await generateText(prompt);
      
      // AGGRESSIVE meta-commentary removal for posts
      // Remove bold name headers (e.g., "**Beverly Elliott**" or "**Sophia Harrell**")
      content = content.replace(/^\*\*[^*]+\*\*\s*/g, '');
      
      // Remove "Posted:" prefixes (e.g., "Posted: 3 hours ago")
      content = content.replace(/^Posted:\s*[^\n]+\n\s*/i, '');
      
      // Remove everything after common meta-commentary markers
      content = content.split(/\n\s*\(/)[0]; // Remove "(Note: ...)" style comments
      content = content.split(/\n\s*\*/)[0];  // Remove "*(...)" style comments
      content = content.split(/\(Note:/)[0];  // Remove inline notes
      content = content.split(/\(Character count:/)[0]; // Remove character count analysis
      content = content.split(/\(Emojis used:/)[0]; // Remove emoji analysis
      content = content.split(/\(Approach:/)[0]; // Remove approach analysis
      content = content.split(/\(Style note:/)[0]; // Remove style notes
      content = content.split(/\*\(Balanced/)[0]; // Remove specific patterns
      content = content.split(/\*\(Casual/)[0];
      content = content.split(/\*\(Keeps/)[0];
      content = content.split(/\*\(Style/)[0];
      // Remove trailing analysis markers
      content = content.replace(/\s*\(Tagged coworkers.*?\)$/i, ''); // Remove tagging thoughts
      content = content.replace(/\s*\*\s*$/g, ''); // Remove trailing asterisks
      content = content.trim();
      
      // Track mentions for stats
      const mentionedUsernames = [];
      const mentionRegex = /@([\w.]+)/g; // Allow dots in usernames
      let match;
      while ((match = mentionRegex.exec(content)) !== null) {
        mentionedUsernames.push(match[1]);
      }
      
      // Update mention counts for mentioned employees (use same smart matching as extractMentions)
      mentionedUsernames.forEach(mentionedUsername => {
        const mentionedEmployee = gameState.employees.find(e => {
          if (!e.social?.username) return false;
          const storedUsername = e.social.username.toLowerCase();
          const mentioned = mentionedUsername.toLowerCase();
          
          // Try multiple matching strategies
          if (storedUsername === mentioned) return true;
          const normalize = (u) => u.replace(/[_.\-\d]/g, '').replace(/^(the|real)|official$/g, '');
          if (normalize(storedUsername) === normalize(mentioned)) return true;
          return false;
        });
        if (mentionedEmployee && mentionedEmployee.social) {
          mentionedEmployee.social.totalMentions = (mentionedEmployee.social.totalMentions || 0) + 1;
        }
      });
      
      // Determine explicit level based on post type and personality
      let explicitLevel = 0;
      if (postType === 'thirst_trap') {
        // Thirst traps are always at least level 2 (lewd/revealing)
        explicitLevel = personality.flirty > 70 ? 3 : 2;
      } else if (postType === 'explicit') {
        // Explicit posts are always level 4 (very explicit/NSFW)
        explicitLevel = 4;
      } else if (postType === 'selfie' && personality.flirty > 65) {
        explicitLevel = Math.random() < 0.3 ? 1 : 0;
      }
      
      // Generate image prompt for visual post types
      let imagePrompt = null;
      if (['selfie', 'thirst_trap', 'explicit', 'meme', 'food', 'travel', 'life_update'].includes(postType)) {
        imagePrompt = await generateImagePrompt(employee, postType, content, context);
      }
      
      return {
        content: content.trim(),
        imagePrompt,
        explicitLevel,
        tags: [postType]
      };
    } catch (error) {
      console.error('AI generation failed:', error);
      // Fallback templates
      const templates = {
        text: ['Just vibing ✨', 'Mood today 💭', 'Thoughts? 🤔'],
        work: ['Productive day! 💼', 'Meeting done! ✓', 'Project update 📊'],
        selfie: ['Feeling good', 'Current mood', 'Quick snap'],
        meme: ['Office life be like 😅', 'Relatable content', 'Story of my life'],
        life_update: ['Weekend plans loading... 🎉', 'New hobby unlocked', 'Life update ✨'],
        thirst_trap: ['Confidence level: 100', 'Feeling myself', 'Good vibes only'],
        explicit: ['After hours mood', 'No caption needed', 'You know the vibe']
      };
      
      const fallbackContent = templates[postType] || templates.text;
      const content = fallbackContent[Math.floor(Math.random() * fallbackContent.length)];
      
      return {
        content,
        imagePrompt: null,
        explicitLevel: postType === 'explicit' ? 3 : postType === 'thirst_trap' ? 1 : 0,
        tags: [postType]
      };
    }
  }
  
  /**
   * Analyze post caption to extract key subjects, themes, and context
   * MASSIVELY EXPANDED for comprehensive coverage!
   */
  function analyzeCaption(caption) {
    const lower = caption.toLowerCase();
    
    // ===== FOOD ITEMS (50+ categories) =====
    const foodMatches = {
      'coffee': ['coffee', 'latte', 'espresso', 'cappuccino', 'mocha', 'americano', 'cold brew', 'iced coffee', 'frappe', 'macchiato'],
      'burger': ['burger', 'hamburger', 'cheeseburger', 'whopper', 'big mac'],
      'pizza': ['pizza', 'slice', 'pie', 'pepperoni', 'margherita', 'deep dish'],
      'sushi': ['sushi', 'sashimi', 'roll', 'maki', 'nigiri', 'california roll', 'spicy tuna'],
      'ramen': ['ramen', 'noodle soup', 'tonkotsu', 'miso ramen', 'shoyu'],
      'taco': ['taco', 'tacos', 'burrito', 'quesadilla', 'enchilada', 'nachos'],
      'sandwich': ['sandwich', 'sub', 'hoagie', 'panini', 'grilled cheese', 'blt', 'club sandwich'],
      'salad': ['salad', 'greens', 'lettuce', 'caesar', 'cobb salad', 'greek salad'],
      'pasta': ['pasta', 'spaghetti', 'fettuccine', 'ravioli', 'linguine', 'penne', 'carbonara', 'alfredo', 'bolognese'],
      'cake': ['cake', 'birthday cake', 'cheesecake', 'chocolate cake', 'vanilla cake', 'red velvet'],
      'cookie': ['cookie', 'cookies', 'chocolate chip', 'oatmeal cookie', 'sugar cookie'],
      'ice cream': ['ice cream', 'gelato', 'sundae', 'cone', 'scoop'],
      'donut': ['donut', 'doughnut', 'glazed', 'jelly donut', 'cruller'],
      'brownie': ['brownie', 'brownies', 'fudge brownie'],
      'lemon bars': ['lemon bar', 'lemon bars', 'lemon square', 'lemon dessert'],
      'boba': ['boba', 'bubble tea', 'milk tea', 'pearl tea', 'tapioca'],
      'smoothie': ['smoothie', 'smoothie bowl', 'acai bowl', 'protein shake'],
      'breakfast': ['breakfast', 'brunch'],
      'pancakes': ['pancake', 'pancakes', 'flapjack', 'stack'],
      'waffles': ['waffle', 'waffles', 'belgian waffle'],
      'eggs': ['eggs', 'scrambled', 'fried egg', 'omelet', 'omelette', 'poached egg'],
      'bacon': ['bacon', 'strips', 'crispy bacon'],
      'toast': ['toast', 'buttered toast'],
      'avocado toast': ['avocado toast', 'avo toast', 'smashed avo'],
      'cereal': ['cereal', 'cheerios', 'corn flakes', 'granola'],
      'cocktail': ['cocktail', 'martini', 'mojito', 'margarita', 'whiskey', 'vodka', 'gin', 'tequila', 'rum'],
      'beer': ['beer', 'brew', 'ale', 'lager', 'ipa', 'pint'],
      'wine': ['wine', 'red wine', 'white wine', 'rosé', 'champagne', 'prosecco'],
      'tea': ['tea', 'green tea', 'black tea', 'chai', 'herbal tea', 'iced tea'],
      'wings': ['wing', 'wings', 'buffalo wings', 'chicken wings', 'hot wings'],
      'fries': ['fries', 'french fries', 'chips', 'waffle fries', 'curly fries'],
      'soup': ['soup', 'stew', 'chowder', 'bisque', 'pho', 'gumbo'],
      'steak': ['steak', 'ribeye', 'sirloin', 'filet', 'beef', 't-bone'],
      'chicken': ['chicken', 'poultry', 'fried chicken', 'grilled chicken', 'chicken breast'],
      'seafood': ['seafood', 'fish', 'salmon', 'tuna', 'shrimp', 'lobster', 'crab', 'oyster'],
      'bbq': ['bbq', 'barbecue', 'ribs', 'brisket', 'pulled pork', 'smoked'],
      'hotdog': ['hot dog', 'hotdog', 'frank', 'corn dog'],
      'popcorn': ['popcorn', 'kettle corn'],
      'chips': ['chips', 'potato chips', 'tortilla chips', 'pretzels', 'crisps'],
      'cheese': ['cheese', 'cheddar', 'mozzarella', 'brie', 'gouda', 'parmesan', 'cheese board', 'charcuterie'],
      'poke bowl': ['poke', 'poke bowl', 'ahi'],
      'curry': ['curry', 'indian food', 'tikka masala', 'vindaloo'],
      'dim sum': ['dim sum', 'dumpling', 'dumplings', 'bao', 'steamed bun'],
      'bagel': ['bagel', 'bagels', 'cream cheese'],
      'muffin': ['muffin', 'muffins', 'blueberry muffin'],
      'croissant': ['croissant', 'pastry', 'danish'],
      'fruit': ['fruit', 'apple', 'banana', 'orange', 'berry', 'berries', 'strawberry', 'mango', 'watermelon'],
      'vegetables': ['veggie', 'vegetables', 'carrot', 'broccoli', 'spinach'],
      'snack': ['snack', 'snacking', 'munchies']
    };
    
    let detectedFood = null;
    for (const [category, keywords] of Object.entries(foodMatches)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedFood = category;
        break;
      }
    }
    
    // ===== MOODS & EMOTIONS (30+ states) =====
    const moods = {
      tired: ['tired', 'exhausted', 'sleepy', 'dead', 'drained', 'worn out', 'beat', 'fatigue', 'zombie', 'need sleep', 'can\'t even'],
      happy: ['happy', 'excited', 'great', 'amazing', 'wonderful', 'fantastic', 'vibing', 'blessed', 'grateful', 'joyful', 'thrilled', 'elated', 'stoked'],
      confident: ['confident', 'feeling myself', 'good vibes', 'powerful', 'unstoppable', 'boss', 'killing it', 'on top', 'got this', 'crushing'],
      flirty: ['flirt', 'mood', 'you know', 'wink', 'after hours', 'naughty', 'cheeky', 'tease', 'playful', 'spicy', 'wild', 'devil'],
      stressed: ['stress', 'busy', 'hectic', 'overwhelm', 'deadline', 'crazy', 'panic', 'anxiety', 'nervous', 'worried', 'pressure'],
      relaxed: ['chill', 'relax', 'calm', 'peaceful', 'zen', 'cozy', 'serene', 'tranquil', 'ease', 'unwind', 'mellow'],
      sad: ['sad', 'down', 'depressed', 'blue', 'melancholy', 'heartbroken', 'crying', 'tears', 'upset', 'hurt'],
      angry: ['angry', 'mad', 'furious', 'pissed', 'annoyed', 'irritated', 'rage', 'frustrated', 'livid'],
      silly: ['silly', 'goofy', 'funny', 'derp', 'weird', 'quirky', 'random', 'chaos', 'unhinged'],
      proud: ['proud', 'accomplished', 'achievement', 'success', 'win', 'nailed it', 'crushed it'],
      bored: ['bored', 'boring', 'meh', 'whatever', 'yawn', 'nothing to do'],
      hungover: ['hungover', 'hangover', 'regret', 'last night', 'never again', 'why did i'],
      motivated: ['motivated', 'motivated', 'inspired', 'determined', 'focused', 'driven', 'hustle', 'grind'],
      romantic: ['romantic', 'love', 'date night', 'valentine', 'crush', 'heart', 'swooning'],
      mysterious: ['mysterious', 'secret', 'cryptic', 'enigma', 'wonder', 'curious'],
      sassy: ['sassy', 'attitude', 'unbothered', 'petty', 'shade', 'savage']
    };
    
    let detectedMood = 'neutral';
    for (const [mood, keywords] of Object.entries(moods)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedMood = mood;
        break;
      }
    }
    
    // ===== ACTIVITIES (40+ types) =====
    const activities = {
      workout: ['workout', 'gym', 'exercise', 'fitness', 'lift', 'lifting', 'cardio', 'run', 'running', 'jog', 'jogging', 'weights', 'training', 'sweat', 'gains', 'leg day', 'arm day'],
      yoga: ['yoga', 'meditation', 'meditate', 'stretch', 'stretching', 'pilates'],
      travel: ['travel', 'trip', 'vacation', 'holiday', 'getaway', 'adventure', 'explore', 'wanderlust'],
      work: ['work', 'working', 'meeting', 'project', 'deadline', 'presentation', 'client', 'boss', 'coworker'],
      cooking: ['cook', 'cooking', 'baking', 'bake', 'recipe', 'homemade', 'chef', 'kitchen', 'meal prep'],
      reading: ['read', 'reading', 'book', 'novel', 'page', 'chapter', 'library', 'literature'],
      gaming: ['game', 'gaming', 'play', 'playing', 'controller', 'stream', 'streaming', 'twitch', 'console', 'pc gaming', 'esports'],
      art: ['paint', 'painting', 'draw', 'drawing', 'art', 'sketch', 'sketching', 'canvas', 'illustration', 'digital art'],
      music: ['music', 'song', 'singing', 'guitar', 'piano', 'drums', 'concert', 'band', 'playlist', 'jam', 'practice'],
      dancing: ['dance', 'dancing', 'moves', 'choreography', 'ballet', 'salsa', 'club', 'party'],
      shopping: ['shopping', 'shop', 'store', 'mall', 'bought', 'purchase', 'retail therapy', 'haul'],
      cleaning: ['clean', 'cleaning', 'organize', 'organizing', 'tidy', 'laundry', 'dishes', 'vacuum'],
      studying: ['study', 'studying', 'homework', 'exam', 'test', 'cramming', 'research', 'learning'],
      driving: ['drive', 'driving', 'commute', 'traffic', 'road trip', 'cruise'],
      walking: ['walk', 'walking', 'stroll', 'strolling', 'hike', 'hiking'],
      swimming: ['swim', 'swimming', 'pool', 'lap', 'dive', 'diving'],
      biking: ['bike', 'biking', 'cycle', 'cycling', 'bicycle', 'ride', 'riding'],
      photography: ['photo', 'photography', 'camera', 'shoot', 'shooting', 'pictures', 'snap', 'capture'],
      movie: ['movie', 'film', 'cinema', 'theater', 'watching', 'binge', 'netflix', 'tv show', 'series'],
      socializing: ['friends', 'hanging out', 'hangout', 'party', 'gathering', 'social', 'meet up', 'catch up'],
      sleeping: ['sleep', 'sleeping', 'nap', 'napping', 'bed', 'rest', 'snooze'],
      drinking: ['drinking', 'drinks', 'bar', 'pub', 'tipsy', 'drunk', 'shots', 'cheers'],
      selfcare: ['self care', 'spa', 'facial', 'massage', 'manicure', 'pedicure', 'pamper', 'treat myself'],
      grooming: ['shower', 'bath', 'shave', 'hair', 'makeup', 'skincare', 'getting ready'],
      diy: ['diy', 'build', 'building', 'craft', 'crafting', 'project', 'handmade', 'woodwork'],
      gardening: ['garden', 'gardening', 'plant', 'plants', 'flower', 'flowers', 'grow', 'growing'],
      pets: ['pet', 'dog', 'cat', 'puppy', 'kitten', 'fur baby', 'doggo', 'pupper', 'kitty'],
      celebration: ['celebrate', 'celebrating', 'birthday', 'anniversary', 'promotion', 'milestone', 'achievement']
    };
    
    let detectedActivity = null;
    for (const [activity, keywords] of Object.entries(activities)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedActivity = activity;
        break;
      }
    }
    
    // ===== LOCATIONS (30+ places) =====
    const locations = {
      home: ['home', 'house', 'apartment', 'room', 'living room', 'couch', 'sofa', 'staying in'],
      bedroom: ['bedroom', 'bed', 'bedroom vibes'],
      bathroom: ['bathroom', 'mirror', 'restroom'],
      kitchen: ['kitchen', 'counter', 'stove', 'oven'],
      office: ['office', 'desk', 'cubicle', 'workspace', 'conference room', 'meeting room', 'work'],
      gym: ['gym', 'fitness center', 'weight room', 'locker room'],
      outdoor: ['outside', 'outdoor', 'outdoors', 'fresh air'],
      park: ['park', 'playground', 'green space'],
      beach: ['beach', 'shore', 'sand', 'ocean', 'sea', 'waves', 'coastline'],
      mountains: ['mountain', 'mountains', 'peak', 'summit', 'trail', 'hike'],
      car: ['car', 'vehicle', 'driving', 'front seat', 'back seat'],
      restaurant: ['restaurant', 'diner', 'eatery', 'bistro'],
      cafe: ['cafe', 'coffee shop', 'café', 'coffeehouse', 'starbucks'],
      bar: ['bar', 'pub', 'tavern', 'lounge', 'club', 'nightclub'],
      airport: ['airport', 'terminal', 'gate', 'flight', 'plane', 'airplane'],
      hotel: ['hotel', 'resort', 'motel', 'inn', 'room service'],
      mall: ['mall', 'shopping center', 'store', 'retail'],
      library: ['library', 'bookstore', 'book shop'],
      hospital: ['hospital', 'clinic', 'doctor', 'medical'],
      school: ['school', 'university', 'college', 'campus', 'class', 'classroom'],
      pool: ['pool', 'swimming pool', 'poolside'],
      elevator: ['elevator', 'lift'],
      parking: ['parking lot', 'parking garage', 'garage'],
      subway: ['subway', 'train', 'metro', 'station'],
      rooftop: ['rooftop', 'roof', 'terrace'],
      balcony: ['balcony', 'patio', 'deck'],
      garden: ['garden', 'backyard', 'yard'],
      forest: ['forest', 'woods', 'trees', 'nature'],
      city: ['city', 'downtown', 'urban', 'skyline', 'street'],
      countryside: ['countryside', 'rural', 'farm', 'field']
    };
    
    let detectedLocation = null;
    for (const [location, keywords] of Object.entries(locations)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedLocation = location;
        break;
      }
    }
    
    // ===== TIME OF DAY =====
    const timeOfDay = {
      morning: ['morning', 'breakfast', 'sunrise', 'dawn', 'am', 'woke up', 'wake up'],
      afternoon: ['afternoon', 'lunch', 'midday', 'noon'],
      evening: ['evening', 'dinner', 'sunset', 'dusk', 'pm'],
      night: ['night', 'nighttime', 'late night', 'midnight', 'dark'],
      latenight: ['late', '2am', '3am', '4am', 'can\'t sleep', 'insomnia']
    };
    
    let detectedTimeOfDay = null;
    for (const [time, keywords] of Object.entries(timeOfDay)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedTimeOfDay = time;
        break;
      }
    }
    
    // ===== WEATHER =====
    const weather = {
      sunny: ['sunny', 'sun', 'sunshine', 'bright', 'clear', 'beautiful day'],
      rainy: ['rain', 'raining', 'rainy', 'wet', 'umbrella', 'drizzle', 'storm', 'stormy'],
      snowy: ['snow', 'snowing', 'snowy', 'winter', 'cold', 'freezing', 'ice'],
      cloudy: ['cloudy', 'overcast', 'gray', 'grey', 'gloomy'],
      hot: ['hot', 'heat', 'sweat', 'humid', 'melting'],
      windy: ['windy', 'wind', 'breezy', 'breeze']
    };
    
    let detectedWeather = null;
    for (const [condition, keywords] of Object.entries(weather)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedWeather = condition;
        break;
      }
    }
    
    // ===== CLOTHING & STYLE =====
    const clothing = {
      casual: ['casual', 'comfy', 'comfortable', 'sweats', 'hoodie', 'jeans', 't-shirt', 'tshirt'],
      formal: ['formal', 'dress', 'suit', 'tie', 'heels', 'blazer', 'professional'],
      athletic: ['athletic', 'workout clothes', 'gym clothes', 'activewear', 'leggings', 'sports bra', 'tank'],
      pajamas: ['pajamas', 'pjs', 'pj', 'sleepwear', 'nightgown'],
      swimwear: ['swimsuit', 'bikini', 'swimwear', 'bathing suit', 'trunks'],
      cozy: ['cozy', 'cosy', 'fuzzy', 'blanket', 'warm']
    };
    
    let detectedClothing = null;
    for (const [style, keywords] of Object.entries(clothing)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedClothing = style;
        break;
      }
    }
    
    // ===== LIGHTING & AESTHETIC =====
    const lighting = {
      golden_hour: ['golden hour', 'sunset', 'sunrise', 'magic hour'],
      natural: ['natural light', 'daylight', 'sunlight'],
      dark: ['dark', 'darkness', 'dim', 'shadow', 'shadows'],
      bright: ['bright', 'well lit', 'flash'],
      moody: ['moody', 'dramatic', 'noir', 'cinematic'],
      soft: ['soft', 'gentle', 'warm', 'ambient']
    };
    
    let detectedLighting = null;
    for (const [light, keywords] of Object.entries(lighting)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedLighting = light;
        break;
      }
    }
    
    // ===== SOCIAL CONTEXT =====
    const socialContext = {
      alone: ['alone', 'solo', 'by myself', 'me time', 'solo'],
      with_friends: ['friends', 'squad', 'crew', 'gang', 'besties', 'bff'],
      with_partner: ['boyfriend', 'girlfriend', 'partner', 'bae', 'boo', 'date'],
      with_coworkers: ['coworker', 'colleague', 'team', 'work friend'],
      with_family: ['family', 'mom', 'dad', 'sister', 'brother', 'parents']
    };
    
    let detectedSocialContext = null;
    for (const [context, keywords] of Object.entries(socialContext)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedSocialContext = context;
        break;
      }
    }
    
    // ===== OBJECTS & ITEMS =====
    const objects = {
      phone: ['phone', 'iphone', 'android', 'mobile', 'cell'],
      laptop: ['laptop', 'computer', 'macbook', 'pc'],
      book: ['book', 'novel', 'reading'],
      headphones: ['headphones', 'earbuds', 'airpods', 'music'],
      sunglasses: ['sunglasses', 'shades'],
      hat: ['hat', 'cap', 'beanie'],
      bag: ['bag', 'purse', 'backpack', 'tote']
    };
    
    let detectedObject = null;
    for (const [obj, keywords] of Object.entries(objects)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedObject = obj;
        break;
      }
    }
    
    // ===== SEASON =====
    const season = {
      spring: ['spring', 'springtime', 'bloom', 'flowers'],
      summer: ['summer', 'summertime', 'hot', 'beach season'],
      fall: ['fall', 'autumn', 'leaves', 'pumpkin', 'halloween'],
      winter: ['winter', 'wintertime', 'snow', 'cold', 'holiday', 'christmas']
    };
    
    let detectedSeason = null;
    for (const [s, keywords] of Object.entries(season)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedSeason = s;
        break;
      }
    }
    
    // ===== BODY LANGUAGE & POSES =====
    const pose = {
      sitting: ['sitting', 'sit', 'seated', 'chair'],
      standing: ['standing', 'stand'],
      lying: ['lying', 'laying', 'lay down', 'horizontal'],
      leaning: ['lean', 'leaning'],
      walking: ['walking', 'walk'],
      looking_back: ['looking back', 'over shoulder', 'glance back']
    };
    
    let detectedPose = null;
    for (const [p, keywords] of Object.entries(pose)) {
      if (keywords.some(kw => lower.includes(kw))) {
        detectedPose = p;
        break;
      }
    }
    
    // ===== EXTRACT SPECIFIC DETAILS (cities, landmarks, unique features) =====
    // This captures custom details that aren't in our predefined categories
    const specificDetails = [];
    
    // Famous cities/places
    const cities = ['tokyo', 'kyoto', 'paris', 'london', 'rome', 'barcelona', 'amsterdam', 'berlin', 'prague', 'vienna', 'venice', 'florence', 'milan', 'athens', 'santorini', 'mykonos', 'bali', 'phuket', 'bangkok', 'singapore', 'hong kong', 'seoul', 'beijing', 'shanghai', 'dubai', 'istanbul', 'cairo', 'marrakech', 'cape town', 'sydney', 'melbourne', 'auckland', 'fiji', 'hawaii', 'maui', 'oahu', 'tahiti', 'bora bora', 'maldives', 'seychelles', 'mauritius', 'bali', 'cancun', 'cabo', 'tulum', 'playa del carmen', 'costa rica', 'jamaica', 'bahamas', 'aruba', 'new york', 'nyc', 'manhattan', 'brooklyn', 'los angeles', 'la', 'hollywood', 'malibu', 'san francisco', 'miami', 'vegas', 'las vegas', 'chicago', 'boston', 'seattle', 'portland', 'austin', 'nashville', 'new orleans', 'montreal', 'toronto', 'vancouver', 'whistler', 'mexico city', 'buenos aires', 'rio', 'sao paulo', 'lima', 'santiago', 'bogota', 'cartagena', 'havana', 'lisboa', 'lisbon', 'porto', 'madrid', 'seville', 'ibiza', 'mallorca', 'valencia', 'geneva', 'zurich', 'lucerne', 'copenhagen', 'stockholm', 'oslo', 'helsinki', 'reykjavik', 'iceland', 'dublin', 'edinburgh', 'glasgow', 'belfast', 'budapest', 'krakow', 'warsaw', 'dubrovnik', 'split', 'zagreb', 'bucharest', 'sofia', 'belgrade', 'tel aviv', 'jerusalem', 'petra', 'dubai', 'abu dhabi', 'doha', 'muscat', 'mumbai', 'delhi', 'jaipur', 'agra', 'goa', 'kathmandu', 'pokhara', 'colombo', 'manila', 'hanoi', 'ho chi minh', 'siem reap', 'angkor', 'luang prabang', 'yangon', 'bagan', 'kuala lumpur', 'penang', 'langkawi', 'jakarta', 'ubud', 'queenstown', 'rotorua', 'perth', 'brisbane', 'gold coast', 'cairns', 'great barrier reef'];
    cities.forEach(city => {
      if (lower.includes(city)) specificDetails.push(city);
    });
    
    // Unique features (bamboo, cherry blossoms, etc.)
    const features = ['bamboo', 'cherry blossom', 'cherry blossoms', 'sakura', 'palm tree', 'palm trees', 'coconut tree', 'pine tree', 'redwood', 'sequoia', 'cactus', 'desert', 'dunes', 'sand dunes', 'waterfall', 'volcano', 'geyser', 'hot springs', 'aurora', 'northern lights', 'southern lights', 'milky way', 'stars', 'starry sky', 'full moon', 'sunset', 'sunrise', 'rainbow', 'double rainbow', 'lighthouse', 'windmill', 'windmills', 'castle', 'temple', 'shrine', 'pagoda', 'mosque', 'cathedral', 'church', 'monastery', 'ruins', 'ancient', 'colosseum', 'eiffel tower', 'big ben', 'statue of liberty', 'golden gate', 'brooklyn bridge', 'times square', 'central park', 'taj mahal', 'great wall', 'pyramids', 'sphinx', 'acropolis', 'parthenon', 'stonehenge', 'machu picchu', 'christ the redeemer', 'sugarloaf mountain', 'mount fuji', 'mount everest', 'kilimanjaro', 'matterhorn', 'swiss alps', 'rocky mountains', 'andes', 'himalayas', 'grand canyon', 'yosemite', 'yellowstone', 'zion', 'bryce canyon', 'glacier', 'fjord', 'fjords', 'iceberg', 'ice cave', 'blue lagoon', 'cenote', 'cave', 'cavern', 'grotto', 'canyon', 'valley', 'meadow', 'prairie', 'savanna', 'jungle', 'rainforest', 'mangrove', 'coral reef', 'kelp forest', 'vineyard', 'winery', 'lavender field', 'tulip field', 'sunflower field', 'rice paddy', 'terraces', 'rice terraces', 'tea plantation', 'coffee farm', 'olive grove', 'orchard', 'botanical garden', 'japanese garden', 'zen garden', 'rooftop', 'skyline', 'skyscraper', 'penthouse', 'balcony', 'terrace', 'patio', 'deck', 'pier', 'dock', 'marina', 'harbor', 'port', 'boardwalk', 'promenade', 'cobblestone', 'alley', 'alleyway', 'street art', 'mural', 'graffiti', 'neon lights', 'neon signs', 'lanterns', 'fairy lights', 'string lights', 'christmas lights', 'fireworks', 'bonfire', 'campfire', 'fire pit'];
    features.forEach(feature => {
      if (lower.includes(feature)) specificDetails.push(feature);
    });
    
    // Activities with specific details
    const specificActivities = ['dance party', 'dancing party', 'coding session', 'coding marathon', 'coding', 'hackathon', 'photoshoot', 'photo shoot', 'wine tasting', 'beer tasting', 'brunch', 'dinner party', 'house party', 'rooftop party', 'pool party', 'beach party', 'bbq party', 'birthday party', 'karaoke', 'trivia night', 'game night', 'movie night', 'girls night', 'boys night', 'date night', 'spa day', 'beach day', 'snow day', 'road trip', 'camping trip', 'backpacking', 'glamping', 'safari', 'cruise', 'boat trip', 'yacht', 'sailing', 'snorkeling', 'scuba diving', 'surfing', 'paddleboarding', 'kayaking', 'rafting', 'zip lining', 'rock climbing', 'bouldering', 'skiing', 'snowboarding', 'ice skating', 'sledding', 'tubing', 'parasailing', 'skydiving', 'bungee jumping', 'hot air balloon', 'helicopter ride', 'scenic flight'];
    specificActivities.forEach(activity => {
      if (lower.includes(activity)) specificDetails.push(activity);
    });
    
    return {
      food: detectedFood,
      mood: detectedMood,
      activity: detectedActivity,
      location: detectedLocation,
      timeOfDay: detectedTimeOfDay,
      weather: detectedWeather,
      clothing: detectedClothing,
      lighting: detectedLighting,
      socialContext: detectedSocialContext,
      object: detectedObject,
      season: detectedSeason,
      pose: detectedPose,
      specificDetails: specificDetails.length > 0 ? specificDetails : null,
      rawCaption: caption // Pass full caption for AI context
    };
  }

  /**
   * Generate image prompt for visual posts
   * NOW WITH CAPTION ANALYSIS FOR PERFECT CONTINUITY!
   */
  async function generateImagePrompt(employee, postType, postCaption, context = null) {
    const personality = employee.personality || {};
    
    // Get consistent physical description for THIS employee
    const physicalDesc = getPhysicalDescriptionForPrompt(employee);
    
    // ===== NEW: AI-POWERED IMAGE PROMPT GENERATION =====
    // Use AI to intelligently generate image prompt based on full context
    
    // Only include chat context for explicit/thirst_trap posts or boss-requested posts
    let chatContextForImage = '';
    let bossRequestContext = '';
    
    const shouldIncludeContext = postType === 'explicit' || postType === 'thirst_trap' || context?.requestedByBoss;
    
    if (shouldIncludeContext) {
      // Get recent chat context if available
      const chatHistory = gameState.chatHistory[employee.id] || [];
      const twoHoursAgo = Date.now() - (2 * 60 * 60 * 1000);
      const recentChats = chatHistory
        .filter(msg => (msg.timestamp || 0) > twoHoursAgo)
        .slice(-5); // Last 5 messages within 2 hours
      
      if (recentChats.length >= 2) {
        const recentMessages = recentChats.slice(-3).map(msg => `${msg.sender}: "${msg.content}"`).join('\n');
        chatContextForImage = `\n\nRECENT CONVERSATION WITH BOSS:\n${recentMessages}\n(Consider if the post is responding to or related to this conversation)`;
      }
      
      // Check if this was a boss-requested post
      if (context?.requestedByBoss) {
        bossRequestContext = `\n\nBOSS REQUESTED THIS POST: The boss specifically asked for this type of post${context.requestContext ? `: "${context.requestContext}"` : ''}. The image should fulfill their request.`;
      }
    }
    
    // Build AI prompt for image generation
    const imagePromptGenerationPrompt = `You are creating an image prompt for a social media post.

EMPLOYEE PHYSICAL DESCRIPTION:
${physicalDesc}

POST TYPE: ${postType}
POST CAPTION: "${postCaption}"
${chatContextForImage}${bossRequestContext}

CRITICAL INSTRUCTIONS:
1. Generate a DETAILED image prompt that EXACTLY matches what the caption describes or implies
2. Use the employee's EXACT physical description (copy it verbatim - don't summarize)
3. If caption mentions specific clothing, pose, location, mood - include ALL of it
4. If caption implies nudity/explicit content, describe it explicitly (this is for adult content)
5. If caption references a conversation (like "your request"), consider recent chat context
6. Be HIGHLY SPECIFIC about pose, clothing, expression, setting, camera angle
7. For explicit posts: describe anatomy visibility in detail (use anatomical terms from physical description)
8. For Female Futa: explicitly mention BOTH penis and vagina if nude/explicit
9. For Trans characters: use their appropriate anatomy from physical description
10. Make the image and caption tell ONE COHESIVE STORY

EXAMPLES OF GOOD IMAGE PROMPTS:

Caption: "Locked door, unlocked desires... your special request delivered fresh 😈"
Type: explicit
Context: Boss requested nude photo
Image Prompt: "[Physical description] stands in front of a locked wooden door in bedroom. She is completely nude, full frontal nudity. Her [specific breast description from profile] are fully exposed, nipples visible. Her [specific genital description - both penis and vagina for futa] are on full display in an erotic showcase. Face shows passionate, teasing expression looking directly at camera. Hands on hips, confident pose. Soft bedroom lighting. NSFW explicit content for boss's private request."

Caption: "That post-workout glow though 💪"
Type: selfie
Image Prompt: "[Physical description] taking gym mirror selfie. Wearing sports bra and leggings, slightly sweaty from workout. Face shows accomplished smile with flushed cheeks from exercise. Gym equipment visible in background. Phone in hand. Natural gym lighting. Athletic, healthy vibe."

Caption: "Coffee and chaos, the Monday mood ☕😩"
Type: text/food
Image Prompt: "Close-up of artisan coffee cup on messy office desk. Laptop visible, papers scattered. Morning natural lighting through window. Cozy but slightly overwhelmed atmosphere. No person visible, focus on coffee and workspace chaos."

NOW GENERATE THE IMAGE PROMPT:
Write ONLY the detailed image prompt - no explanations, no meta-commentary:`;

    try {
      // Generate AI-powered image prompt
      let aiImagePrompt = await generateText(imagePromptGenerationPrompt);
      
      // Clean up any meta-commentary
      aiImagePrompt = aiImagePrompt.replace(/^\*\*[^*]+\*\*\s*/g, '');
      aiImagePrompt = aiImagePrompt.split(/\n\s*\(/)[0];
      aiImagePrompt = aiImagePrompt.split(/\(Note:/)[0];
      aiImagePrompt = aiImagePrompt.trim();
      
      // Validate it's not empty
      if (aiImagePrompt && aiImagePrompt.length > 20) {
        console.log(`AI-generated image prompt for ${employee.name}:`, aiImagePrompt.substring(0, 100) + '...');
        return aiImagePrompt;
      } else {
        console.warn('AI image prompt too short, falling back to template');
      }
    } catch (error) {
      console.error('AI image prompt generation failed:', error);
    }
    
    // ===== FALLBACK: Template-based system (if AI fails) =====
    const analysis = analyzeCaption(postCaption);
    
    const basePrompts = {
      selfie: [
        `${physicalDesc} taking a casual selfie, natural lighting, friendly smile, office setting`,
        `Close-up selfie of ${physicalDesc}, relaxed expression, neutral background, good lighting`,
        `${physicalDesc} taking selfie with soft smile, professional casual look, modern aesthetic`,
        `Mirror selfie of ${physicalDesc}, casual outfit, phone in hand, clean background`,
        `${physicalDesc} bathroom mirror selfie, good lighting, casual pose, modern style`,
        `Car selfie of ${physicalDesc}, golden hour lighting, windshield reflection, relaxed vibe`,
        `${physicalDesc} desk selfie, workspace visible, laptop in background, professional casual`,
        `Outdoor selfie of ${physicalDesc}, natural daylight, blurred background, genuine smile`,
        `${physicalDesc} elevator selfie, mirror reflection, going to work vibes, morning energy`,
        `Coffee shop selfie of ${physicalDesc}, drink in frame, cozy atmosphere, casual Monday mood`,
        `${physicalDesc} post-workout selfie, gym mirror, athletic wear, accomplishment glow`,
        `${physicalDesc} bedroom selfie, soft morning light, messy hair, authentic moment`,
        `${physicalDesc} lunch break selfie, restaurant background, food nearby, happy expression`,
        `Late night work selfie of ${physicalDesc}, desk lamp lighting, tired but determined look`,
        `Weekend selfie of ${physicalDesc}, casual home setting, relaxed vibe, natural smile`
      ],
      thirst_trap: [
        `Provocative photo of ${physicalDesc} in form-fitting gym attire, sports bra and leggings, toned body visible, gym mirror selfie, showing off physique, confident sexy pose`,
        `${physicalDesc} in tight dress, curves emphasized, low neckline, showing cleavage, mirror selfie, bedroom setting, seductive expression, body on display`,
        `${physicalDesc} in lingerie, lace bra and panties, bedroom mirror selfie, sensual pose, showing off body, intimate setting, confident and sexy`,
        `${physicalDesc} in bikini, beach or poolside, wet from water, body glistening, revealing swimwear, showing skin, attractive pose, summer vibes`,
        `${physicalDesc} wearing unbuttoned shirt, cleavage visible, messy hair, bedroom eyes, seductive morning look, showing skin suggestively`,
        `${physicalDesc} in tight yoga pants and crop top, cameltoe visible, toned stomach showing, gym setting, athletic but sexy, mirror selfie`,
        `${physicalDesc} in short skirt and crop top, midriff exposed, legs on display, confident pose, urban setting, showing off body`,
        `${physicalDesc} in silk robe barely covering body, cleavage visible, bare legs showing, bedroom setting, morning after vibe, sultry expression`,
        `${physicalDesc} in wet white shirt, see-through fabric, outline visible, water droplets, provocative accidental reveal aesthetic`,
        `${physicalDesc} from behind, tight pants emphasizing butt, looking over shoulder, flirty expression, showing off curves, confident pose`,
        `${physicalDesc} in sports bra only, bare midriff, athletic shorts low on hips, post-workout selfie, toned body on display, sweaty and sexy`,
        `${physicalDesc} in backless dress, bare back visible, side curves showing, elegant but provocative, looking over shoulder seductively`,
        `${physicalDesc} in low-cut top, deep cleavage visible, leaning forward, close-up angle, showing assets, bedroom eyes, flirty vibe`,
        `${physicalDesc} lying on bed in underwear, body stretched out, intimate angle, showing curves, messy bedroom hair, come-hither expression`,
        `${physicalDesc} sitting with legs spread in short skirt, inner thighs visible, provocative pose, confident expression, daring photo`
      ],
      explicit: [
        `NSFW photo of ${physicalDesc} topless, breasts exposed, hands covering nipples, bedroom setting, nude from waist up, sensual lighting, explicit content`,
        `${physicalDesc} completely nude, full frontal nudity, strategic hand placement, bedroom or bathroom, soft lighting, artistic nude photography, explicit NSFW`,
        `${physicalDesc} in transparent lingerie, nipples visible through fabric, see-through panties, body fully on display, bedroom, explicit intimate wear`,
        `${physicalDesc} topless from behind, bare back and butt visible, looking over shoulder, nude photography, sensual pose, NSFW explicit content`,
        `${physicalDesc} nude in shower, water running over naked body, wet skin glistening, intimate bathroom setting, full nudity, explicit content`,
        `${physicalDesc} on bed completely naked, lying seductively, intimate bedroom angle, full body nudity visible, explicit NSFW photography`,
        `${physicalDesc} wearing only unbuttoned shirt open exposing breasts, bare pussy visible, sitting pose, bedroom, explicit nude content`,
        `${physicalDesc} topless mirror selfie, breasts fully exposed, nipples visible, confident pose, bathroom or bedroom, explicit NSFW content`,
        `${physicalDesc} in spread eagle pose wearing nothing, full frontal nudity, lying on bed, intimate explicit angle, NSFW adult content`,
        `${physicalDesc} nude from side angle, breast and butt visible, artistic nude pose, bedroom setting, sensual lighting, explicit photography`,
        `${physicalDesc} wearing collar and nothing else, submissive kneeling pose, bedroom floor, fetish content, explicit NSFW`,
        `${physicalDesc} in bed sheets barely covering, breast peeking out, implied full nudity underneath, intimate morning scene, explicit suggestion`,
        `${physicalDesc} bent over showing bare ass, topless, looking back at camera, bedroom, explicit provocative pose, NSFW adult content`,
        `${physicalDesc} with legs spread wide in lingerie, crotch area visible, extremely revealing, bedroom, explicit sexual pose, NSFW`,
        `${physicalDesc} masturbating, hand between legs, topless, bedroom, explicit sexual content, NSFW adult photography, orgasmic expression`
      ],
      meme: [
        `Funny relatable meme image, office humor, modern internet meme style, text overlay space`,
        `Humorous workplace situation image, meme format, relatable content, funny expression`,
        `Comic-style meme about office life, funny scenario, internet humor aesthetic`,
        `Distracted boyfriend meme style, office edition, three people, dramatic pointing`,
        `Drake yes/no meme template, office scenarios, contrasting situations, clear panels`,
        `Expanding brain meme style, office productivity levels, ascending intelligence joke`,
        `This is fine dog meme, office on fire metaphor, coffee drinking, everything burning`,
        `Woman yelling at cat meme, office meeting drama, pointing and confused expressions`,
        `Two buttons sweating choice meme, work-life balance dilemma, person struggling to decide`,
        `Surprised Pikachu face, office edition, shocked reaction, yellow character, meme format`,
        `Galaxy brain meme style, office hacks, ascending ideas, space background evolution`,
        `Batman slapping Robin meme, office suggestion rejected, dramatic slap action`,
        `Change my mind meme, controversial office opinion, person at table, debate setup`,
        `Always has been meme, astronauts in space, office realization, gun pointing revelation`,
        `Is this a butterfly meme, confused person, office task misidentification, pointing gesture`,
        `Vince McMahon reaction meme, increasing excitement, office scenarios, four panel progression`,
        `Bernie Sanders sitting meme, office edition, folded arms, chair sitting, waiting mood`,
        `Roll Safe thinking meme, office life hack, pointing at head, can't fail logic`
      ],
      food: [
        `Delicious artisan coffee in ceramic mug, latte art, wooden table, morning light, cafe aesthetic`,
        `Gourmet lunch plate, colorful ingredients, restaurant presentation, overhead shot, Instagram-worthy`,
        `Mouth-watering burger and fries, golden crispy, food truck setting, casual dining vibe`,
        `Fresh sushi platter, colorful rolls, elegant presentation, Japanese restaurant, chopsticks`,
        `Steaming bowl of ramen, soft-boiled egg, green onions, noodles lifted, authentic Asian cuisine`,
        `Decadent dessert plate, chocolate cake, drizzle, fork ready, cafe setting, indulgent`,
        `Healthy breakfast bowl, acai berries, granola, fruits, colorful presentation, morning energy`,
        `Pizza slice with cheese pull, wood-fired crust, melty goodness, casual dining, shareable`,
        `Fancy cocktail with garnish, colorful drink, ice cubes, bar setting, evening vibes`,
        `Street taco plate, three tacos, authentic Mexican, lime wedge, casual food truck aesthetic`,
        `Starbucks cup on desk, laptop nearby, work setup, coffee shop vibes, productivity mood`,
        `Homemade pasta dish, fork twirling, fresh basil, rustic Italian, warm lighting`,
        `Smoothie bowl, tropical fruits, granola topping, bright colors, healthy lifestyle aesthetic`,
        `Takeout containers on desk, late night work, Chinese food, chopsticks, office grind`,
        `Avocado toast, poached egg, artisan bread, brunch aesthetic, millennial food culture`,
        `Boba tea with straw, colorful drink, pearls visible, trendy cafe, aesthetic background`,
        `Charcuterie board, cheese, meats, grapes, crackers, sharing platter, sophisticated snacking`
      ],
      travel: [
        `Beautiful beach sunset, palm trees silhouette, orange sky, vacation vibes, peaceful scene`,
        `${physicalDesc} at mountain summit, arms raised, scenic overlook, adventure achievement`,
        `Stunning city skyline at night, lights reflecting, urban exploration, travel photography`,
        `Tropical beach scene, turquoise water, white sand, paradise destination, vacation mode`,
        `${physicalDesc} at famous landmark, tourist pose, iconic background, travel memories`,
        `Airport terminal view, planes visible, travel excitement, departure board, wanderlust`,
        `Hotel room view, city skyline through window, morning coffee, business travel aesthetic`,
        `Hiking trail panorama, mountains in distance, nature path, outdoor adventure, scenic beauty`,
        `Beach footprints in sand, ocean waves, sunset lighting, peaceful moment, coastal vibes`,
        `${physicalDesc} on airplane, window seat, clouds outside, travel mood, flying high`,
        `European cobblestone street, historic buildings, charming alley, cultural exploration`,
        `Desert landscape, vast horizon, golden hour, road trip adventure, American Southwest`,
        `Ski resort view, snowy mountains, winter sports, cold weather travel, alpine scenery`,
        `Tropical poolside, resort view, palm trees, lounging, luxury vacation aesthetic`,
        `${physicalDesc} backpack on, train station, solo travel, adventure beginning, wanderlust mood`,
        `National park vista, natural wonder, dramatic landscape, outdoor exploration, bucket list`,
        `Cruise ship deck view, ocean horizon, maritime travel, luxurious journey, sea adventure`
      ],
      life_update: [
        `${physicalDesc} reading book in cozy chair, home setting, warm lighting, relaxation time`,
        `${physicalDesc} with new pet, happy cuddle, home environment, life milestone moment`,
        `Yoga mat and water bottle, fitness journey, home workout setup, healthy lifestyle`,
        `${physicalDesc} painting on canvas, art supplies, creative hobby, focused expression`,
        `New apartment empty room, moving boxes, fresh start, life transition, excited energy`,
        `${physicalDesc} playing guitar, music hobby, casual home setting, creative pursuit`,
        `Garden with growing plants, dirt hands, outdoor hobby, nature connection, satisfying growth`,
        `${physicalDesc} at graduation, cap and gown, achievement moment, proud expression`,
        `Cozy reading nook, books stacked, coffee nearby, personal space, intellectual hobby`,
        `${physicalDesc} running on trail, athletic gear, fitness goal, outdoor exercise`,
        `Home office setup, organized desk, plants, productivity space, work-from-home life`,
        `${physicalDesc} cooking in kitchen, ingredients visible, culinary hobby, domestic scene`,
        `Meditation space, cushions, candles, zen atmosphere, wellness practice, self-care`,
        `${physicalDesc} with baked goods, oven mitt, proud baker, kitchen accomplishment`,
        `Bicycle leaned against wall, outdoor adventure gear, active lifestyle, weekend plans`,
        `${physicalDesc} at pottery wheel, clay hands, craft hobby, artistic concentration`,
        `Home gym equipment, weights visible, fitness dedication, personal space, health journey`
      ]
    };
    
    // ===== CAPTION-AWARE IMAGE GENERATION =====
    let prompt = '';
    
    // FOOD POSTS - Match specific food item from caption
    if (postType === 'food' && analysis.food) {
      const foodPrompts = {
        'coffee': `Delicious artisan coffee in ceramic mug, latte art, wooden table, morning light, cafe aesthetic`,
        'burger': `Mouth-watering burger and fries, golden crispy, sesame bun, melted cheese, casual dining vibe`,
        'pizza': `Pizza slice with cheese pull, wood-fired crust, melty goodness, toppings visible, shareable`,
        'sushi': `Fresh sushi platter, colorful rolls, elegant presentation, Japanese restaurant, chopsticks, soy sauce`,
        'ramen': `Steaming bowl of ramen, soft-boiled egg, green onions, noodles lifted, authentic Asian cuisine`,
        'taco': `Street taco plate, three tacos, authentic Mexican, lime wedge, cilantro, casual food truck aesthetic`,
        'sandwich': `Delicious sandwich, layers visible, fresh ingredients, deli presentation, toasted bread`,
        'salad': `Fresh colorful salad bowl, mixed greens, vegetables, healthy presentation, fork ready`,
        'pasta': `Homemade pasta dish, fork twirling, fresh basil, parmesan cheese, rustic Italian, warm lighting`,
        'cake': `Decadent layered cake, frosting, slice cut, celebratory dessert, bakery quality`,
        'cookie': `Fresh baked cookies on plate, chocolate chips, homemade, warm and delicious`,
        'ice cream': `Ice cream scoops in bowl or cone, colorful, melting slightly, sweet treat, dessert vibes`,
        'donut': `Glazed donuts on plate, sprinkles or icing, bakery fresh, sweet breakfast treat`,
        'brownie': `Fudgy brownie squares, chocolate richness, dessert plate, indulgent treat`,
        'lemon bars': `Fresh lemon bars on a plate, powdered sugar dusted, bright yellow filling, dessert presentation`,
        'boba': `Boba tea with thick straw, colorful drink, tapioca pearls visible, trendy cafe, aesthetic background`,
        'smoothie': `Smoothie bowl, tropical fruits, granola topping, bright colors, healthy lifestyle aesthetic`,
        'breakfast': `Healthy breakfast plate, eggs, toast, bacon, morning meal, colorful presentation`,
        'pancakes': `Stack of fluffy pancakes, syrup drizzle, butter pat, breakfast perfection, morning vibes`,
        'waffles': `Belgian waffles with toppings, syrup, whipped cream, breakfast indulgence`,
        'eggs': `Perfectly cooked eggs, breakfast plate, toast, morning meal, protein-rich`,
        'bacon': `Crispy bacon strips, breakfast side, sizzling, delicious protein`,
        'toast': `Toasted bread, butter spreading, golden brown, breakfast staple`,
        'avocado toast': `Avocado toast, poached egg, artisan bread, microgreens, brunch aesthetic, millennial food culture`,
        'cereal': `Cereal bowl with milk, spoon, breakfast table, morning meal, nostalgic`,
        'cocktail': `Fancy cocktail with garnish, colorful drink, ice cubes, bar setting, evening vibes`,
        'beer': `Cold beer in glass or bottle, foam head, bar setting, relaxation drink, social vibes`,
        'wine': `Wine glass with red or white wine, elegant presentation, sophisticated drink, evening mood`,
        'tea': `Hot tea in cup, tea bag or loose leaf, steam rising, cozy drink, calming`,
        'wings': `Chicken wings plate, buffalo sauce, celery sticks, ranch dip, sports bar vibe`,
        'fries': `Golden crispy french fries, sea salt, ketchup, casual dining, shareable basket`,
        'soup': `Steaming bowl of soup, spoon ready, bread on side, comfort food, cozy presentation`,
        'steak': `Perfectly cooked steak, grill marks, sides visible, upscale dinner, meat lover's dream`,
        'chicken': `Delicious chicken dish, cooked to perfection, protein main course, satisfying meal`,
        'seafood': `Fresh seafood platter, ocean-to-table, elegant presentation, coastal cuisine`,
        'bbq': `BBQ plate with ribs or brisket, smoky char, barbecue sauce, Southern comfort food`,
        'hotdog': `Hot dog with toppings, classic American, stadium food, casual dining`,
        'popcorn': `Bowl of popcorn, movie snack, butter or seasoning, entertainment food`,
        'chips': `Bag or bowl of chips, snack food, crunchy, casual munchies`,
        'cheese': `Cheese board or charcuterie, variety of cheeses, crackers, grapes, sophisticated snacking`,
        'poke bowl': `Colorful poke bowl, fresh fish, rice, vegetables, Hawaiian cuisine, healthy bowl`,
        'curry': `Aromatic curry dish, rice, Indian spices, warm comfort food, flavorful`,
        'dim sum': `Dim sum basket, steamed dumplings, Asian cuisine, variety platter, chopsticks`,
        'bagel': `Fresh bagel with cream cheese, toasted, breakfast favorite, New York style`,
        'muffin': `Freshly baked muffins, bakery quality, breakfast pastry, warm and fluffy`,
        'croissant': `Flaky croissant, buttery pastry, French bakery, coffee companion`,
        'fruit': `Fresh fruit plate or bowl, colorful, healthy, natural sweetness, vibrant`,
        'vegetables': `Fresh vegetable plate, healthy eating, colorful produce, nutritious meal`,
        'snack': `Snack plate with variety, munchies, casual eating, satisfying treats`
      };
      
      prompt = foodPrompts[analysis.food] || `Appetizing ${analysis.food}, restaurant presentation, overhead shot, Instagram-worthy, delicious`;
      
      // Add location context to food
      if (analysis.location === 'home' || analysis.location === 'kitchen') {
        prompt += ', homemade, cozy kitchen setting';
      } else if (analysis.location === 'office') {
        prompt += ', on office desk, work lunch vibes';
      } else if (analysis.location === 'restaurant' || analysis.location === 'cafe') {
        prompt += ', restaurant setting, dining out atmosphere';
      } else if (analysis.location === 'outdoor' || analysis.location === 'park') {
        prompt += ', outdoor eating, picnic vibes, al fresco';
      }
      
      // Add time of day context
      if (analysis.timeOfDay === 'morning') {
        prompt += ', morning breakfast vibes, fresh start';
      } else if (analysis.timeOfDay === 'afternoon') {
        prompt += ', lunch time, midday meal';
      } else if (analysis.timeOfDay === 'evening' || analysis.timeOfDay === 'night') {
        prompt += ', dinner setting, evening meal';
      } else if (analysis.timeOfDay === 'latenight') {
        prompt += ', late night snack, midnight munchies';
      }
      
      // Add mood context
      if (analysis.mood === 'happy' || analysis.mood === 'excited') {
        prompt += ', joyful eating moment, satisfying';
      } else if (analysis.mood === 'stressed') {
        prompt += ', comfort food, stress eating, needed this';
      } else if (analysis.mood === 'hungover') {
        prompt += ', hangover cure, recovery food';
      }
      
      // Add social context
      if (analysis.socialContext === 'with_friends') {
        prompt += ', shared meal, group dining, social eating';
      } else if (analysis.socialContext === 'alone') {
        prompt += ', solo meal, treating myself';
      }
    }
    
    // SELFIE POSTS - Match mood from caption
    else if (postType === 'selfie') {
      const moodModifiers = {
        tired: 'tired expression, dark circles, exhausted but authentic',
        happy: 'genuine big smile, happy eyes, joyful energy',
        confident: 'confident expression, direct eye contact, powerful presence',
        flirty: 'playful smile, flirtatious gaze, knowing look',
        stressed: 'stressed expression, messy hair, overwhelmed but coping',
        relaxed: 'relaxed expression, peaceful vibe, calm energy',
        sad: 'sad expression, vulnerable moment, emotional',
        angry: 'frustrated expression, intense gaze, strong emotion',
        silly: 'goofy expression, funny face, playful energy',
        proud: 'proud smile, accomplished look, confident stance',
        bored: 'bored expression, unamused face, whatever mood',
        hungover: 'hungover look, messy hair, regretful expression, sunglasses indoors',
        motivated: 'determined expression, focused energy, driven look',
        romantic: 'soft romantic expression, dreamy eyes, gentle smile',
        mysterious: 'mysterious gaze, enigmatic expression, subtle smile',
        sassy: 'sassy expression, attitude, side-eye, confident smirk'
      };
      
      const locationModifiers = {
        home: 'casual home setting, relaxed vibe',
        bedroom: 'bedroom setting, soft morning light, authentic moment',
        bathroom: 'bathroom mirror selfie, good lighting, casual pose',
        kitchen: 'kitchen background, casual home vibe',
        office: 'office setting, professional casual, desk visible',
        gym: 'gym mirror, athletic wear, post-workout glow',
        car: 'car selfie, windshield reflection, driving vibes',
        outdoor: 'outdoor setting, natural daylight, fresh air',
        park: 'park background, nature setting, green scenery',
        beach: 'beach setting, ocean background, vacation vibes',
        cafe: 'coffee shop background, cozy atmosphere, casual vibe',
        bar: 'bar or club setting, nightlife energy, dim lighting',
        airport: 'airport terminal, travel mode, wanderlust energy',
        hotel: 'hotel room, travel vibes, away from home',
        mall: 'shopping mall background, retail therapy mood',
        elevator: 'elevator mirror selfie, going to work vibes',
        parking: 'parking lot background, casual outdoor setting',
        rooftop: 'rooftop view, city background, elevated perspective',
        balcony: 'balcony background, outdoor home space'
      };
      
      const activityModifiers = {
        workout: 'post-workout selfie, gym mirror, athletic wear, accomplishment glow, sweaty',
        yoga: 'post-yoga selfie, zen energy, workout mat visible, peaceful',
        work: 'desk selfie, workspace visible, laptop in background, professional casual',
        dancing: 'mid-dance energy, movement blur, party vibes',
        shopping: 'shopping bags visible, retail therapy energy, store background',
        grooming: 'fresh after shower, clean look, getting ready vibes',
        selfcare: 'spa day vibes, face mask, pampered look, relaxation mode',
        pets: 'selfie with pet, cuddles, animal in frame, wholesome',
        celebration: 'celebration energy, party mode, festive atmosphere'
      };
      
      const timeModifiers = {
        morning: 'morning light, sunrise glow, fresh day energy',
        afternoon: 'midday lighting, bright natural light',
        evening: 'golden hour lighting, warm sunset tones',
        night: 'evening lighting, night vibes, darker atmosphere',
        latenight: 'late night lighting, desk lamp or dim light, tired but awake'
      };
      
      const weatherModifiers = {
        sunny: 'bright sunny day, clear skies, natural sunlight',
        rainy: 'rainy day vibes, window droplets visible, cozy indoors',
        snowy: 'snowy weather, winter vibes, cold weather gear',
        hot: 'hot weather, summer vibes, dealing with heat'
      };
      
      const clothingModifiers = {
        casual: 'casual comfy outfit, relaxed style',
        formal: 'formal dressed up outfit, professional look',
        athletic: 'athletic wear, gym clothes, sporty style',
        pajamas: 'pajamas or sleepwear, cozy home mode',
        swimwear: 'swimsuit or beach wear, vacation mode',
        cozy: 'cozy outfit, blanket visible, warm and comfortable'
      };
      
      const socialModifiers = {
        alone: 'solo selfie, personal moment',
        with_friends: 'with friends in background, group vibes',
        with_partner: 'couple selfie, romantic moment',
        with_coworkers: 'with coworkers, team moment',
        with_family: 'family in frame, wholesome moment'
      };
      
      // Start with base
      prompt = `${physicalDesc} taking a selfie`;
      
      // Add activity-specific context (highest priority)
      if (analysis.activity && activityModifiers[analysis.activity]) {
        prompt = `${physicalDesc} ${activityModifiers[analysis.activity]}`;
      }
      // Or location
      else if (analysis.location && locationModifiers[analysis.location]) {
        prompt += `, ${locationModifiers[analysis.location]}`;
      } else {
        prompt += ', natural lighting';
      }
      
      // Add time of day
      if (analysis.timeOfDay && timeModifiers[analysis.timeOfDay]) {
        prompt += `, ${timeModifiers[analysis.timeOfDay]}`;
      }
      
      // Add weather context
      if (analysis.weather && weatherModifiers[analysis.weather]) {
        prompt += `, ${weatherModifiers[analysis.weather]}`;
      }
      
      // Add clothing style
      if (analysis.clothing && clothingModifiers[analysis.clothing]) {
        prompt += `, ${clothingModifiers[analysis.clothing]}`;
      }
      
      // Add social context
      if (analysis.socialContext && socialModifiers[analysis.socialContext]) {
        prompt += `, ${socialModifiers[analysis.socialContext]}`;
      }
      
      // Add mood (very important!)
      if (analysis.mood !== 'neutral' && moodModifiers[analysis.mood]) {
        prompt += `, ${moodModifiers[analysis.mood]}`;
      } else {
        prompt += `, friendly smile, genuine expression`;
      }
      
      // Add lighting aesthetic if specified
      if (analysis.lighting) {
        const lightMap = {
          'golden_hour': 'golden hour lighting, warm sunset glow',
          'natural': 'natural lighting, soft daylight',
          'dark': 'dark moody lighting, dramatic shadows',
          'bright': 'bright well-lit, clear visibility',
          'moody': 'moody dramatic lighting, cinematic feel',
          'soft': 'soft ambient lighting, gentle glow'
        };
        if (lightMap[analysis.lighting]) {
          prompt += `, ${lightMap[analysis.lighting]}`;
        }
      }
      
      // Add pose if mentioned
      if (analysis.pose) {
        const poseMap = {
          'sitting': 'sitting pose, seated position',
          'standing': 'standing pose',
          'lying': 'lying down, horizontal position',
          'leaning': 'leaning pose, casual lean',
          'looking_back': 'looking over shoulder, glance back'
        };
        if (poseMap[analysis.pose]) {
          prompt += `, ${poseMap[analysis.pose]}`;
        }
      }
    }
    
    // THIRST TRAP - Match mood, location, clothing, and confidence level
    else if (postType === 'thirst_trap') {
      const flirtyLevel = personality.flirty || 50;
      let baseDesc = flirtyLevel > 70 
        ? `${physicalDesc} in stylish form-fitting outfit, seductive pose, confident allure`
        : `${physicalDesc} in fashionable outfit, attractive pose, subtle confidence`;
      
      // Location-specific thirst traps
      if (analysis.location === 'gym') {
        baseDesc = `${physicalDesc} in gym clothes, athletic build, form-fitting activewear, mirror selfie, confident pose`;
      } else if (analysis.location === 'office') {
        baseDesc = `${physicalDesc} in fitted business attire, powerful stance, office setting, professional sexy`;
      } else if (analysis.location === 'bedroom') {
        baseDesc = `${physicalDesc} in bedroom setting, intimate casual outfit, soft lighting, confident allure`;
      } else if (analysis.location === 'bathroom') {
        baseDesc = `${physicalDesc} bathroom mirror shot, form-fitting outfit, confident expression, modern aesthetic`;
      } else if (analysis.location === 'car') {
        baseDesc = `${physicalDesc} in car, hand on steering wheel or door, confident cool pose, attractive lighting`;
      } else if (analysis.location === 'outdoor' || analysis.location === 'beach') {
        baseDesc = `${physicalDesc} outdoor setting, natural background, attractive casual pose, golden hour vibes`;
      }
      
      // Clothing-specific adjustments
      if (analysis.clothing === 'athletic') {
        baseDesc = `${physicalDesc} in athletic wear, fit body showcase, gym aesthetic, sporty confidence`;
      } else if (analysis.clothing === 'formal') {
        baseDesc = `${physicalDesc} in elegant formal outfit, sophisticated sexy, dressed to impress, stylish`;
      } else if (analysis.clothing === 'swimwear') {
        baseDesc = `${physicalDesc} in swimwear, beach body confidence, summer vibes, attractive pose`;
      }
      
      // Mood modifications
      const moodAdd = analysis.mood === 'confident' 
        ? ', powerful stance, direct gaze, commanding presence'
        : analysis.mood === 'flirty' 
        ? ', playful seductive expression, knowing smile'
        : analysis.mood === 'sassy'
        ? ', attitude, side glance, confident smirk'
        : ', flattering lighting, stylish aesthetic';
      
      prompt = baseDesc + moodAdd;
      
      // Time of day lighting
      if (analysis.timeOfDay === 'evening' || analysis.lighting === 'golden_hour') {
        prompt += ', golden hour lighting, warm sunset tones';
      } else if (analysis.timeOfDay === 'night') {
        prompt += ', evening lighting, sultry night vibes';
      }
    }
    
    // EXPLICIT - Match caption's suggestiveness, location, and mood
    else if (postType === 'explicit') {
      let explicitPrompts = [
        `Suggestive photo of ${physicalDesc}, intimate lighting, alluring expression, tasteful composition`,
        `${physicalDesc} in revealing outfit, seductive pose, dim romantic lighting, artistic sensuality`,
        `Sultry portrait of ${physicalDesc}, provocative pose, sensual atmosphere, artistic`,
        `${physicalDesc} in silk robe, intimate moment, soft lighting, artistic boudoir style`,
        `Artistic intimate shot of ${physicalDesc}, dramatic shadows, alluring gaze, sensual mood`,
        `${physicalDesc} in lace outfit, romantic lighting, seductive expression, classy provocation`
      ];
      
      // Location-specific explicit content
      if (analysis.location === 'bedroom' || analysis.location === 'home') {
        prompt = `${physicalDesc} bedroom setting, intimate outfit, soft lighting, seductive pose, private moment`;
      } else if (analysis.location === 'bathroom') {
        prompt = `${physicalDesc} bathroom setting, steam or soft lighting, intimate moment, artistic sensuality`;
      } else if (analysis.location === 'office') {
        prompt = `${physicalDesc} in after-hours office, loosened professional clothing, suggestive pose, dramatic lighting`;
      } else {
        prompt = explicitPrompts[Math.floor(Math.random() * explicitPrompts.length)];
      }
      
      // Add flirty/mood emphasis
      if (analysis.mood === 'flirty') {
        prompt += ', extra seductive energy, provocative gaze';
      } else if (analysis.mood === 'confident') {
        prompt += ', bold confident sexuality, powerful allure';
      }
      
      // Time/lighting adjustments
      if (analysis.timeOfDay === 'night' || analysis.timeOfDay === 'latenight') {
        prompt += ', night time intimacy, dim ambient lighting';
      } else if (analysis.lighting === 'moody') {
        prompt += ', moody dramatic lighting, artistic shadows';
      }
    }
    
    // MEME POSTS - Use generic meme templates (captions are the content)
    else if (postType === 'meme') {
      const memePrompts = basePrompts.meme;
      prompt = memePrompts[Math.floor(Math.random() * memePrompts.length)];
    }
    
    // TRAVEL POSTS - Match activity/location/weather from caption + SPECIFIC DETAILS!
    else if (postType === 'travel') {
      // PRIORITY 1: Use specific details from caption (cities, landmarks, features)
      if (analysis.specificDetails && analysis.specificDetails.length > 0) {
        const detail = analysis.specificDetails[0]; // Use first specific detail
        
        // Famous cities
        if (['tokyo', 'kyoto', 'paris', 'london', 'rome', 'barcelona', 'amsterdam', 'berlin', 'dubai', 'bali', 'santorini', 'venice', 'new york', 'nyc', 'manhattan', 'los angeles', 'miami', 'vegas', 'hawaii', 'iceland', 'maldives'].includes(detail)) {
          prompt = `Beautiful scenic view of ${detail}, iconic travel destination, stunning photography`;
          // Add specific features if mentioned
          if (analysis.specificDetails.includes('bamboo')) prompt = `Bamboo forest in ${detail}, tall bamboo trees, serene green path, asian travel aesthetic`;
          else if (analysis.specificDetails.includes('cherry blossom')) prompt = `Cherry blossoms in ${detail}, pink sakura trees, springtime beauty, japanese aesthetic`;
          else if (analysis.specificDetails.includes('temple')) prompt = `Ancient temple in ${detail}, cultural landmark, travel photography, architectural beauty`;
          else if (analysis.specificDetails.includes('beach')) prompt = `Beach paradise in ${detail}, turquoise water, tropical vacation, stunning coastal view`;
          else if (analysis.specificDetails.includes('mountains')) prompt = `Mountain view in ${detail}, scenic peaks, alpine landscape, adventure travel`;
          else if (analysis.specificDetails.includes('skyline')) prompt = `City skyline of ${detail}, urban landscape, metropolitan beauty, travel photography`;
          else if (analysis.timeOfDay === 'night') prompt += ', nighttime city lights, illuminated beauty';
          else if (analysis.weather === 'sunny') prompt += ', bright sunny day, clear blue skies';
        }
        // Unique features (bamboo, cherry blossoms, waterfalls, etc.)
        else if (['bamboo', 'cherry blossom', 'waterfall', 'volcano', 'aurora', 'northern lights', 'castle', 'temple', 'shrine', 'pagoda', 'lighthouse', 'windmill', 'ruins', 'pyramids', 'taj mahal', 'eiffel tower', 'colosseum', 'mount fuji', 'grand canyon'].includes(detail)) {
          prompt = `Stunning ${detail} view, travel destination, breathtaking scenery, wanderlust photography`;
          if (detail === 'bamboo') prompt = `Bamboo forest, tall green bamboo trees lining path, serene peaceful atmosphere, asian travel aesthetic, natural beauty`;
          else if (detail === 'cherry blossom') prompt = `Cherry blossom trees in full bloom, pink sakura petals, springtime beauty, japanese aesthetic, magical scene`;
          else if (detail === 'waterfall') prompt = `Majestic waterfall, cascading water, lush greenery, nature paradise, adventure travel`;
          else if (detail === 'aurora' || detail === 'northern lights') prompt = `Aurora borealis dancing in night sky, northern lights, colorful sky phenomenon, arctic beauty`;
          else if (detail === 'castle') prompt = `Ancient castle, medieval architecture, historical landmark, european travel, fairytale aesthetic`;
          else if (detail === 'temple' || detail === 'shrine') prompt = `Sacred temple, ornate architecture, cultural heritage, spiritual destination, travel photography`;
          else if (detail === 'lighthouse') prompt = `Coastal lighthouse, ocean view, maritime charm, seaside travel, scenic beauty`;
          else if (detail === 'volcano') prompt = `Active volcano, dramatic landscape, adventure travel, powerful nature, unique destination`;
          else if (detail === 'ruins') prompt = `Ancient ruins, historical site, archaeological wonder, travel exploration, timeless beauty`;
        }
        // Specific activities
        else if (['safari', 'cruise', 'yacht', 'snorkeling', 'scuba diving', 'skiing', 'snowboarding', 'hot air balloon', 'helicopter ride'].includes(detail)) {
          if (detail === 'safari') prompt = `Safari adventure, wildlife viewing, african landscape, jeep tour, nature exploration`;
          else if (detail === 'cruise' || detail === 'yacht') prompt = `Luxury cruise/yacht, ocean view, deck relaxation, maritime travel, vacation vibes`;
          else if (detail === 'snorkeling' || detail === 'scuba diving') prompt = `Underwater adventure, tropical reef, marine life, diving/snorkeling, aquatic beauty`;
          else if (detail === 'skiing' || detail === 'snowboarding') prompt = `Ski resort, snowy slopes, winter sports, mountain adventure, alpine scenery`;
          else if (detail === 'hot air balloon') prompt = `Hot air balloon ride, aerial view, floating above landscape, sunrise/sunset adventure`;
          else if (detail === 'helicopter ride') prompt = `Helicopter tour, aerial photography, bird's eye view, scenic flight, adventure travel`;
        }
      }
      // PRIORITY 2: Activity-based travel
      else if (analysis.activity === 'workout' || analysis.activity === 'hiking') {
        prompt = `${physicalDesc} on hiking trail, athletic gear, nature adventure, scenic mountain vista`;
      } else if (analysis.activity === 'swimming') {
        prompt = `${physicalDesc} at pool or beach, swimming, tropical water, vacation mode`;
      }
      // PRIORITY 3: Location-based travel
      else if (analysis.location === 'beach') {
        prompt = `Beautiful beach scene, turquoise water, white sand, palm trees, paradise destination, vacation vibes`;
        if (analysis.weather === 'sunny') prompt += ', bright sunny day, clear blue skies';
      } else if (analysis.location === 'mountains') {
        prompt = `${physicalDesc} at mountain summit, scenic overlook, dramatic peaks, adventure achievement`;
        if (analysis.weather === 'snowy') prompt += ', snow-covered peaks, winter wonderland';
      } else if (analysis.location === 'airport') {
        prompt = `Airport terminal view, planes visible, departure board, travel excitement, wanderlust`;
      } else if (analysis.location === 'hotel') {
        prompt = `Hotel room view, city skyline through window, travel vibes, vacation accommodation`;
      } else if (analysis.location === 'city') {
        prompt = `Stunning city skyline, urban exploration, city lights, travel photography, metropolitan vibes`;
        if (analysis.timeOfDay === 'night') prompt += ', nighttime city lights, illuminated buildings';
      } else if (analysis.location === 'forest') {
        // Check for bamboo specifically in raw caption
        if (analysis.rawCaption && analysis.rawCaption.toLowerCase().includes('bamboo')) {
          prompt = `Bamboo forest, tall green bamboo trees lining path, serene peaceful atmosphere, asian travel aesthetic, natural beauty`;
        } else {
          prompt = `Forest trail scene, nature path, trees, outdoor adventure, peaceful wilderness`;
        }
      } else if (analysis.location === 'countryside') {
        prompt = `Countryside landscape, rural scenery, fields, peaceful nature, escape from city`;
      }
      // Weather-based travel
      else if (analysis.weather === 'snowy') {
        prompt = `Snowy mountain scene, winter sports, ski resort view, alpine scenery, cold weather travel`;
      } else if (analysis.weather === 'sunny' && analysis.season === 'summer') {
        prompt = `Tropical beach paradise, bright sunshine, summer vacation, turquoise water, relaxation`;
      }
      // Season-based travel
      else if (analysis.season === 'fall') {
        prompt = `Autumn landscape, fall foliage, colorful leaves, scenic beauty, seasonal travel`;
      } else if (analysis.season === 'spring') {
        prompt = `Spring scenery, blooming flowers, fresh greenery, beautiful season, nature awakening`;
      }
      // Mood-based travel
      else if (analysis.mood === 'relaxed') {
        prompt = `Peaceful vacation scene, relaxation vibes, tranquil destination, stress-free moment`;
      } else if (analysis.mood === 'excited') {
        prompt = `${physicalDesc} excited at destination, arms raised, adventure energy, travel joy`;
      }
      // Default travel prompts
      else {
        const travelPrompts = basePrompts.travel;
        prompt = travelPrompts[Math.floor(Math.random() * travelPrompts.length)];
      }
    }
    
    // LIFE UPDATE - Match activity, mood, objects from caption + SPECIFIC DETAILS!
    else if (postType === 'life_update') {
      // PRIORITY 1: Use specific activities from caption
      if (analysis.specificDetails && analysis.specificDetails.length > 0) {
        const detail = analysis.specificDetails[0];
        
        if (detail === 'dance party' || detail === 'dancing party') {
          prompt = `${physicalDesc} at dance party, dancing with friends, party lights, music vibes, energetic celebration, fun social gathering`;
          if (analysis.timeOfDay === 'night') prompt += ', nighttime party energy, colorful lights';
        } else if (detail === 'coding session' || detail === 'coding marathon' || detail === 'coding') {
          prompt = `${physicalDesc} at desk coding, laptop screen glow, programmer aesthetic, focused developer, code on screen visible, tech workspace`;
          if (analysis.timeOfDay === 'night' || detail.includes('midnight')) prompt += ', late night coding, dark room with screen glow, night owl developer energy';
        } else if (detail === 'hackathon') {
          prompt = `${physicalDesc} at hackathon event, intense coding, tech competition, developer energy, multiple screens, programming marathon`;
        } else if (detail === 'photoshoot' || detail === 'photo shoot') {
          prompt = `${physicalDesc} during photoshoot, camera equipment visible, professional lighting, model pose, photography session`;
        } else if (detail === 'wine tasting' || detail === 'beer tasting') {
          prompt = `${physicalDesc} at tasting event, wine/beer glasses, elegant setting, sophisticated social gathering, sampling drinks`;
        } else if (detail === 'brunch') {
          prompt = `${physicalDesc} at brunch, restaurant table with food and mimosas, social dining, weekend vibes, friends gathering`;
        } else if (detail === 'karaoke') {
          prompt = `${physicalDesc} singing karaoke, microphone in hand, stage lights, music performance, fun social activity`;
        } else if (detail === 'game night') {
          prompt = `Game night setup, board games or video games visible, friends gathered, snacks and drinks, fun social evening`;
        } else if (detail === 'movie night') {
          prompt = `${physicalDesc} watching movie, cozy couch setting, popcorn and drinks, screen glow, relaxation entertainment`;
        } else if (detail === 'spa day') {
          prompt = `${physicalDesc} at spa, relaxation vibes, face mask or robe, pampering session, self-care luxury, wellness treatment`;
        } else if (detail === 'road trip') {
          prompt = `${physicalDesc} on road trip, car interior view, scenic highway, adventure travel, open road vibes`;
        } else if (detail === 'camping trip' || detail === 'glamping') {
          prompt = `Camping scene, tent or glamping setup, nature outdoor, campfire visible, wilderness adventure, outdoor lifestyle`;
        } else if (detail === 'yacht' || detail === 'sailing') {
          prompt = `${physicalDesc} on yacht/sailboat, ocean water, luxury boating, nautical lifestyle, maritime adventure`;
        }
      }
      
      // PRIORITY 2: Activity-based prompts
      const activityPrompts = {
        workout: `${physicalDesc} in athletic gear, fitness journey, exercise setting, healthy lifestyle`,
        yoga: `${physicalDesc} on yoga mat, meditation space, zen energy, wellness practice`,
        cooking: `${physicalDesc} in kitchen, cooking ingredients visible, culinary hobby, proud chef moment`,
        reading: `${physicalDesc} with book in cozy chair, reading nook, warm lighting, intellectual moment`,
        gaming: `Gaming setup, controller or keyboard, screen glow, colorful RGB lights, gamer lifestyle, focused play`,
        art: `${physicalDesc} with art supplies, creative project, painting or drawing, artistic focus, canvas visible`,
        music: `${physicalDesc} with instrument, music practice, creative hobby, passionate musician`,
        dancing: `${physicalDesc} dancing, movement energy, music vibes, expressive moment`,
        shopping: `${physicalDesc} with shopping bags, retail therapy, new purchases, happy consumer`,
        cleaning: `${physicalDesc} organizing space, cleaning supplies, tidy home, productive vibes`,
        studying: `${physicalDesc} with books and laptop, studying hard, focused learning, academic dedication`,
        diy: `${physicalDesc} with tools, DIY project, building something, hands-on creativity`,
        gardening: `${physicalDesc} in garden, plants and flowers, dirt hands, outdoor hobby, nature connection`,
        pets: `${physicalDesc} with pet, cuddles and love, animal companion, wholesome moment`,
        selfcare: `${physicalDesc} spa day vibes, face mask or pampering, relaxation mode, treating self`,
        celebration: `${physicalDesc} celebrating, party decorations, achievement moment, festive energy`
      };
      
      if (analysis.activity && activityPrompts[analysis.activity]) {
        prompt = activityPrompts[analysis.activity];
      }
      // Location-based life updates
      else if (analysis.location === 'home' || analysis.location === 'bedroom') {
        prompt = `${physicalDesc} cozy at home, relaxed setting, personal space, comfortable vibes`;
        if (analysis.mood === 'relaxed') prompt += ', peaceful calm energy';
      } else if (analysis.location === 'kitchen') {
        prompt = `${physicalDesc} in kitchen, cooking or baking, domestic scene, home chef energy`;
      } else if (analysis.location === 'gym') {
        prompt = `${physicalDesc} at gym, workout equipment visible, fitness dedication, health journey`;
      }
      // Object-based life updates
      else if (analysis.object === 'book') {
        prompt = `${physicalDesc} reading book in cozy chair, home setting, warm lighting, relaxation time`;
      } else if (analysis.object === 'laptop') {
        prompt = `Home office setup, organized desk, laptop, productivity space, work-from-home life`;
      } else if (analysis.object === 'headphones') {
        prompt = `${physicalDesc} with headphones, music listening, relaxed vibes, audio enjoyment`;
      }
      // Mood-based life updates
      else if (analysis.mood === 'proud') {
        prompt = `${physicalDesc} showing off accomplishment, proud moment, achievement display, satisfied expression`;
      } else if (analysis.mood === 'motivated') {
        prompt = `${physicalDesc} motivated energy, goal-focused, determined look, hustle mode`;
      } else if (analysis.mood === 'relaxed') {
        prompt = `${physicalDesc} in relaxation mode, cozy space, calm energy, self-care moment`;
      }
      // Default life update prompts
      else {
        const lifePrompts = basePrompts.life_update;
        prompt = lifePrompts[Math.floor(Math.random() * lifePrompts.length)];
      }
    }
    
    // Fallback to original templates
    else {
      const prompts = basePrompts[postType] || basePrompts.selfie;
      prompt = prompts[Math.floor(Math.random() * prompts.length)];
    }
    
    // Add personality modifiers
    if (personality.confidence > 70 && ['selfie', 'thirst_trap'].includes(postType)) {
      prompt += ', bold confident expression';
    }
    if (personality.flirty > 70 && ['thirst_trap', 'explicit', 'selfie'].includes(postType)) {
      prompt += ', flirtatious energy';
    }
    
    return prompt;
  }
  
  /**
   * Generate autonomous comments on recent posts
   */
  async function generateAutonomousComments() {
    // Get recent posts (last 10)
    const recentPosts = gameState.socialNetwork.posts.slice(0, 10);
    if (recentPosts.length === 0) return;
    
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    // Each employee has a chance to comment on posts
    for (const employee of activeEmployees) {
      // 20% chance to comment
      if (Math.random() > 0.2) continue;
      
      // Select random post (not their own)
      const eligiblePosts = recentPosts.filter(p => 
        p.authorId !== employee.id && 
        !p.comments.some(c => c.authorId === employee.id) // Haven't commented yet
      );
      
      if (eligiblePosts.length === 0) continue;
      
      const post = eligiblePosts[Math.floor(Math.random() * eligiblePosts.length)];
      
      // Get relationship with post author
      const relationship = employee.relationships?.[post.authorId];
      const relationType = relationship?.type || 'neutral';
      
      // Generate comment based on relationship
      const commentText = await generateComment(employee, post, relationType);
      
      const comment = createComment({
        postId: post.id,
        authorId: employee.id,
        authorName: employee.name,
        content: commentText
      });
      
      post.comments.push(comment);
      
      // 🌐 Evaluate relationship between commenter and post author
      const postAuthor = gameState.employees.find(e => e.id === post.authorId);
      
      console.log(`[Autonomous] ${employee.name} commented on ${post.isPlayerPost ? 'player' : postAuthor?.name}'s post`);
      
      if (postAuthor && postAuthor.id !== employee.id) {
        await evaluateNPCReactionToPost(employee, postAuthor, post, commentText);
      }
      
      // AGGRESSIVE FIX: Always update immediately, no visibility checks
      const postEl = document.querySelector(`[data-post-id="${post.id}"]`);
      const commentsSection = document.querySelector(`.post-comments[data-post-id="${post.id}"]`);
      
      if (postEl && commentsSection) {
        console.log(`[Autonomous] FORCE updating comments for post ${post.id}`);
        updateCommentsSection(postEl, post);
      }
      
      // Request smart feed update as backup
      requestSmartFeedUpdate(post.id);
    }
  }
  
  /**
   * Trigger targeted comments from NPCs mentioned in tea-spilling posts
   * NPCs who are called out feel compelled to respond
   */
  async function triggerTeaSpillingComments(post, author) {
    // Extract @mentions from post content using smart extraction
    const extractedMentions = extractMentions(post.content);
    
    if (extractedMentions.length === 0) return;
    
    console.log(`[Social] Tea-spilling post has ${extractedMentions.length} mentions, triggering targeted comments`);
    
    // Get mentioned employee objects
    const mentionedEmployees = extractedMentions
      .map(m => gameState.employees.find(e => e.id === m.employeeId))
      .filter(e => e && e.id !== author.id);
    
    // 70-90% chance each mentioned NPC comments (they feel called out!)
    for (let i = 0; i < mentionedEmployees.length; i++) {
      const npc = mentionedEmployees[i];
      const shouldComment = Math.random() < 0.7 + Math.random() * 0.2;
      
      if (!shouldComment) continue;
      
      const delay = (i + 1) * (2000 + Math.random() * 4000); // 2-6 seconds each
      
      setTimeout(async () => {
        const commentText = await generateTeaSpillingResponse(npc, post, author);
        
        const comment = createComment({
          postId: post.id,
          authorId: npc.id,
          authorName: npc.name,
          content: commentText
        });
        
        post.comments.push(comment);
        
        // Store in memory - they were called out!
        remember(npc, `${author.name} called me out in a post about: "${post.content}"`, 'event', 2.5);
        remember(author, `${npc.name} responded to my tea-spilling post`, 'interaction', 1.5);
        
        // Relationship might change depending on response
        const relationship = npc.relationships?.[author.id];
        if (relationship) {
          // Drama can strain or strengthen relationships
          const isDramatic = Math.random() < 0.3;
          relationship.strength += isDramatic ? -3 : 1;
        }
        
        if (gameState.activeTab === 'social') {
          renderSocialFeed();
        }
      }, delay);
    }
    
    // Others might also comment for the drama (20% of non-mentioned people)
    const activeEmployees = gameState.employees.filter(e => 
      e.employmentStatus === 'active' && 
      e.id !== author.id &&
      !mentionedEmployees.find(m => m.id === e.id)
    );
    
    const bystanders = Math.min(2, Math.floor(activeEmployees.length * 0.2));
    for (let i = 0; i < bystanders; i++) {
      const npc = activeEmployees[Math.floor(Math.random() * activeEmployees.length)];
      const delay = (mentionedEmployees.length + i + 1) * (2000 + Math.random() * 4000);
      
      setTimeout(async () => {
        const reactions = [
          '👀🍿', 'The TEA is hot today', 'I\'m just here for the comments 🍿',
          'This is MESSY 💀', 'Drama!! 🫖', 'Oh wow 😳', 'Spicy 🌶️',
          'Not this on my feed 😂', 'The audacity lol', '💀💀💀'
        ];
        
        const commentText = reactions[Math.floor(Math.random() * reactions.length)];
        
        const comment = createComment({
          postId: post.id,
          authorId: npc.id,
          authorName: npc.name,
          content: commentText
        });
        
        post.comments.push(comment);
        
        if (gameState.activeTab === 'social') {
          renderSocialFeed();
        }
      }, delay);
    }
  }
  
  /**
   * Generate a response from someone called out in a tea-spilling post
   */
  async function generateTeaSpillingResponse(npc, post, author) {
    const affection = npc.stats?.affection || 0;
    const personality = npc.personality || {};
    const relationship = npc.relationships?.[author.id];
    
    // Determine response tone
    const isEmbarrassed = personality.confidence < 50;
    const isDefiant = personality.confidence > 70;
    const isFriendly = relationship?.type === 'friend' || relationship?.type === 'best_friend';
    const intimacy = npc.intimacy || 0;
    
    const prompt = `You are ${npc.name}. ${author.name} just called you out in a social media post that says: "${post.content}"

YOUR PERSONALITY: confidence: ${personality.confidence}/100, outgoing: ${personality.outgoing}/100, flirty: ${personality.flirty}/100
YOUR RELATIONSHIP WITH ${author.name}: ${relationship?.type || 'coworker'}

Write a SHORT comment response (5-15 words) that reacts to being called out. Options:
${isEmbarrassed ? '- Play it off embarrassed/shy' : ''}
${isDefiant ? '- Own it confidently' : ''}
${isFriendly ? '- Playfully banter back' : ''}
${intimacy > 40 ? '- Flirt back' : ''}
- Deny it playfully
- Make a joke about it
- Call them out back

Examples:
- "WHO TOLD YOU 😭"
- "And what about it? 💅"
- "Says the one who... 👀"
- "EXCUSE ME this is slander"
- "You're one to talk 😏"
- "Mind your business lol"
- "Okay but you're not wrong 💀"

Write ONLY the comment:`;

    try {
      const response = await generateText(prompt, { temperature: 1.0, max_tokens: 40 });
      let comment = response.trim().replace(/^["']|["']$/g, '');
      
      if (comment.length > 80) {
        comment = comment.substring(0, 77) + '...';
      }
      
      return comment;
      
    } catch (error) {
      console.error('Tea response generation failed:', error);
      
      // Fallback templates
      if (isDefiant) {
        return ['And what about it? 💅', 'You\'re one to talk 😏', 'Mind your business lol'][Math.floor(Math.random() * 3)];
      } else if (isEmbarrassed) {
        return ['WHO TOLD YOU 😭', 'This is NOT true 💀', 'EXCUSE ME'][Math.floor(Math.random() * 3)];
      } else {
        return ['Okay but you\'re not wrong', 'Says you 👀', 'The audacity lol'][Math.floor(Math.random() * 3)];
      }
    }
  }
  
  /**
   * Generate a comment using AI or templates
   * NOW WITH FULL CONTEXT AWARENESS FOR NPC-TO-NPC INTERACTIONS
   */
  async function generateComment(employee, post, relationType) {
    const postAuthor = gameState.employees.find(e => e.id === post.authorId);
    
    // Get FULL context for this interaction
    const relationship = employee.relationships?.[post.authorId];
    const affection = employee.stats?.affection || 0;
    const desire = employee.stats?.desire || 0;
    const intimacy = employee.intimacy || 0;
    const personality = employee.personality || {};
    
    // Get their relationship with the post author (if NPC)
    const hasRelationship = postAuthor && !post.isPlayerPost;
    const relationshipStrength = relationship?.strength || 0;
    const relationshipHistory = relationship?.history || [];
    
    // Determine if this should be a meaningful comment based on context
    const shouldUseMeaningfulComment = 
      post.isPlayerPost || // ALWAYS use AI for player posts!
      post.explicitLevel >= 2 || // Explicit content
      post.type === 'tea_spilling' || // Drama
      post.type === 'life_update' || // Important updates
      post.type === 'achievement' || // Milestones
      post.type === 'thirst_trap' || // Suggestive posts
      post.type === 'gossip' || // Mysterious posts
      relationshipStrength > 60 || // Close relationship
      affection > 50 || // Employee likes the player
      desire > 50 || // Employee desires the player
      intimacy > 40 || // Intimate relationship with player
      hasRelationship && (relationType === 'best_friend' || relationType === 'romantic' || relationType === 'rival' || relationType === 'enemy');
    
    // Use AI for meaningful comments, quick templates for casual interactions
    if (shouldUseMeaningfulComment) {
      console.log(`[Social] ${employee.name} using AI comment for ${post.isPlayerPost ? 'PLAYER' : postAuthor?.name}'s post (type: ${post.type}, explicit: ${post.explicitLevel})`);
      try {
        return await generateAIComment(employee, post, postAuthor, relationship, relationType);
      } catch (error) {
        console.error('AI comment failed, using enhanced templates:', error);
        return generateEnhancedTemplateComment(employee, post, postAuthor, relationType);
      }
    }
    
    // Quick casual comments for basic interactions
    console.log(`[Social] ${employee.name} using casual comment for ${post.isPlayerPost ? 'PLAYER' : postAuthor?.name}'s post`);
    return generateCasualComment(employee, post, relationType);
  }
  
  /**
   * Generate AI-powered comment with full context awareness
   * THIS IS WHERE THE JUICE HAPPENS
   */
  async function generateAIComment(commenter, post, postAuthor, relationship, relationType) {
    const commenterPersonality = commenter.personality || {};
    const postAuthorPersonality = postAuthor?.personality || {};
    const relationshipStrength = relationship?.strength || 0;
    const relationshipHistory = relationship?.history || [];
    
    // Get recent interactions between these two NPCs
    const recentInteractions = relationshipHistory.slice(-3).map(h => h.description).join('; ') || 'No recent history';
    
    // Build comprehensive context
    const isPlayerPost = post.isPlayerPost;
    const targetName = isPlayerPost ? 'the boss' : postAuthor.name;
    
    // GET CONVERSATION CONTEXT - This is the juicy stuff!
    let conversationContext = '';
    
    // If commenting on player's post, check DM history with player
    if (isPlayerPost) {
      const dmHistory = gameState.chatHistory[commenter.id] || [];
      const recentDMs = dmHistory.slice(-10); // Last 10 messages
      
      if (recentDMs.length > 0) {
        // Extract juicy details from recent DMs
        const juicyDetails = recentDMs
          .filter(msg => msg.content && msg.content.length > 10)
          .slice(-5) // Last 5 meaningful messages
          .map(msg => {
            const speaker = msg.sender === 'player' ? 'Boss' : commenter.name;
            return `${speaker}: "${msg.content.substring(0, 100)}"`;
          })
          .join('\n');
        
        if (juicyDetails) {
          conversationContext = `\n\nRECENT DM CONVERSATION WITH BOSS:
${juicyDetails}

You can reference things from your DMs if relevant! Examples:
- "Well you told me you were working late tonight 👀"
- "That's funny because you said something totally different to me earlier"
- "Didn't you just say you hated this? 😂"
- "Interesting... remember what we talked about?"
- "This contradicts what you told me but ok"`;
        }
      }
    }
    
    // If commenting on another NPC's post, check if we have DM history with the BOSS about this person
    if (!isPlayerPost && postAuthor) {
      const dmHistory = gameState.chatHistory[commenter.id] || [];
      const recentDMs = dmHistory.slice(-20); // Look further back
      
      // Check if we've talked about this person with the boss
      const mentionsOfTarget = recentDMs.filter(msg => 
        msg.content && (
          msg.content.toLowerCase().includes(postAuthor.name.toLowerCase()) ||
          msg.content.toLowerCase().includes(postAuthor.name.split(' ')[0].toLowerCase())
        )
      );
      
      if (mentionsOfTarget.length > 0) {
        const gossipDetails = mentionsOfTarget.slice(-3).map(msg => {
          const speaker = msg.sender === 'player' ? 'Boss' : 'You';
          return `${speaker}: "${msg.content.substring(0, 100)}"`;
        }).join('\n');
        
        conversationContext = `\n\nYOU'VE DISCUSSED ${postAuthor.name.toUpperCase()} WITH THE BOSS:
${gossipDetails}

You can call them out based on what you know! Examples:
- "That's not what I heard 👀"
- "Interesting... the boss told me something different about you"
- "Funny timing after what happened"
- "Everyone's talking about you btw"
- "The boss was just telling me about this actually"`;
      }
    }
    
    // CROSS-REFERENCE: Check if other NPCs have talked about the post author with the player
    if (!isPlayerPost && postAuthor) {
      // Check ALL employee DM histories for mentions of this person
      let heardGossip = '';
      for (const employee of gameState.employees) {
        if (employee.id === commenter.id || employee.id === postAuthor.id) continue;
        
        const theirDMs = gameState.chatHistory[employee.id] || [];
        const theirGossip = theirDMs.filter(msg =>
          msg.content && (
            msg.content.toLowerCase().includes(postAuthor.name.toLowerCase()) ||
            msg.content.toLowerCase().includes(postAuthor.name.split(' ')[0].toLowerCase())
          )
        ).slice(-2); // Just the most recent gossip
        
        if (theirGossip.length > 0 && Math.random() < 0.3) { // 30% chance to reference others' gossip
          heardGossip = `\n\nGOSSIP YOU'VE HEARD:
${employee.name} was talking about ${postAuthor.name}: "${theirGossip[0].content.substring(0, 80)}"

You heard through the grapevine! Examples:
- "Is it true what everyone's saying?"
- "I heard some interesting things about you"
- "People are talking 👀"
- "The whole office has been discussing this"`;
          break; // Just use the first gossip found
        }
      }
      
      if (heardGossip) {
        conversationContext += heardGossip;
      }
    }
    
    // Determine emotional context
    let emotionalContext = '';
    if (relationType === 'romantic') {
      emotionalContext = `You're romantically involved with ${targetName}. Your comments should show affection and intimacy.`;
    } else if (relationType === 'crush') {
      emotionalContext = `You have a crush on ${targetName}. You're trying to flirt subtly but also play it cool.`;
    } else if (relationType === 'best_friend') {
      emotionalContext = `${targetName} is your best friend. You can be playful, supportive, or tease them.`;
    } else if (relationType === 'friend') {
      emotionalContext = `You're friends with ${targetName}. Keep it friendly and supportive.`;
    } else if (relationType === 'rival') {
      emotionalContext = `You and ${targetName} are rivals. There's competitive tension. Be subtly shady or backhanded.`;
    } else if (relationType === 'enemy') {
      emotionalContext = `You don't like ${targetName}. Your comment can be dismissive, sarcastic, or pointedly critical.`;
    } else {
      emotionalContext = `You're coworkers with ${targetName}. Keep it professional but real.`;
    }
    
    // Special context for different post types
    let postTypeContext = '';
    if (post.type === 'tea_spilling') {
      postTypeContext = 'This is DRAMA. They\'re spilling tea about someone. React with appropriate shock, support, or defense of the person being called out.';
    } else if (post.type === 'thirst_trap' || post.explicitLevel >= 2) {
      postTypeContext = 'This is suggestive/explicit content. React appropriately based on your relationship and personality. Could be supportive, flirty, shocked, or disapproving.';
    } else if (post.type === 'life_update') {
      postTypeContext = 'This is an important life update. Show genuine interest or concern.';
    } else if (post.type === 'achievement') {
      postTypeContext = 'They\'re celebrating an achievement. React with congratulations (genuine or backhanded based on relationship).';
    } else if (post.type === 'complaint') {
      postTypeContext = 'They\'re venting or complaining. Commiserate, offer advice, or dismiss them based on your relationship.';
    } else if (post.type === 'gossip') {
      postTypeContext = 'They\'re being cryptic/mysterious about drama. Either ask for details, play along with the mystery, or act concerned.';
    }
    
    const prompt = `You are ${commenter.name}, commenting on ${targetName}'s social media post.

YOUR PERSONALITY:
- Confidence: ${commenterPersonality.confidence || 50}/100
- Outgoing: ${commenterPersonality.outgoing || 50}/100  
- Flirty: ${commenterPersonality.flirty || 50}/100
- Professional: ${commenterPersonality.professional || 50}/100
- Humor: ${commenterPersonality.humor || 50}/100

${isPlayerPost ? 'RELATIONSHIP WITH BOSS:' : `RELATIONSHIP WITH ${postAuthor.name}:`}
- Type: ${relationType}
- Strength: ${relationshipStrength}/100
- Recent History: ${recentInteractions}
${emotionalContext}

THE POST:
"${post.content}"
${post.imageAlt ? `[Image: ${post.imageAlt}]` : ''}
Post Type: ${post.type}
${post.explicitLevel >= 2 ? 'EXPLICIT/SUGGESTIVE CONTENT' : ''}

${postTypeContext}
${conversationContext}

INSTRUCTIONS:
Write a comment that:
1. REFERENCES SPECIFIC CONTENT from the post (not just "nice!" or "cool")
2. Reflects your relationship dynamic with ${targetName}
3. Shows personality (be funny, supportive, shady, flirty, dramatic, etc.)
4. Feels NATURAL and REAL (like actual social media)
5. Length: 5-25 words max
6. Use emojis naturally but not excessively
7. CREATE CONSEQUENCES - your comment should affect the relationship dynamic
8. ${conversationContext ? '**IMPORTANT: You have INSIDER KNOWLEDGE from DMs - use it to create drama, call out contradictions, or reference private info!**' : ''}

GOOD EXAMPLES (context-aware, specific):
- "WAIT you said you were over him?? Girl what happened 😭" (drama response)
- "The AUDACITY to post this after what you said to me yesterday" (calling out hypocrisy)
- "You look way too good in this I can't even be professional rn 🥵" (flirty if close)
- "Not you acting like you didn't copy MY presentation last week 🙄" (rival)
- "I'm so proud of you!! You've been working so hard for this 💕" (supportive friend)
- "Says the person who can't even show up on time lmao" (friendly roast)
- "This giving main character energy and I'm here for ALL of it ✨" (hype)
- "Bestie... we need to TALK about this situation immediately" (concerned)
${conversationContext ? `
**DM-BASED DRAMA EXAMPLES (you have insider info - USE IT!):**
- "Interesting... you told me something VERY different in our DMs 👀"
- "Wait didn't you just tell me you hated doing this? 😂"
- "That's not what you said when we talked earlier but ok"
- "The boss literally just told me about this 💀"
- "Well according to our conversation last night..."
- "Funny you post this NOW after what you told me"
- "Everyone knows btw. Like EVERYONE 🫖"
- "I heard some things about you and I have QUESTIONS"
` : ''}

BAD EXAMPLES (too generic):
- "Nice!"
- "Great post"
- "Love it"
- "Cool"

${relationType === 'rival' || relationType === 'enemy' ? 'Remember: You can be SHADY, backhanded, or critical. Drama is good!' : ''}
${relationType === 'romantic' || relationType === 'crush' ? 'Remember: Show interest, be flirty, reference inside jokes or intimate knowledge.' : ''}
${post.type === 'tea_spilling' ? 'Remember: This is DRAMA. React strongly! Take sides!' : ''}

Write ONLY the comment, no quotation marks:`;

    const response = await generateText(prompt, { 
      temperature: 1.0, // High creativity for varied responses
      max_tokens: 60 
    });
    
    let comment = response.trim();
    
    // AGGRESSIVE meta-commentary removal
    comment = comment.replace(/^["']|["']$/g, ''); // Remove quotes
    
    // Remove "Name:" prefix (e.g., "Laura Rodriguez: Your plant's living...")
    comment = comment.replace(/^[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*:\s*/g, '');
    
    // Remove parenthetical meta-commentary patterns
    comment = comment.split(/\n\s*\(/)[0]; // Remove "(Note: ...)" style
    comment = comment.split(/\n\s*\*/)[0]; // Remove "*(Word count...)" style
    comment = comment.split(/\(Note:/)[0]; // Remove inline notes
    comment = comment.split(/\*\(Word count/i)[0]; // Remove word count
    comment = comment.split(/\*\*Relationship Impact/i)[0]; // Remove relationship analysis
    comment = comment.split(/\(Relationship/i)[0]; // Remove relationship notes
    
    // CRITICAL FIX: Remove standalone parenthetical commentary at end
    comment = comment.replace(/\s*\([^)]*consequence[^)]*\)\s*$/i, ''); // "(Relationship consequence: ...)"
    comment = comment.replace(/\s*\([^)]*sparking[^)]*\)\s*$/i, ''); // Other meta analysis
    comment = comment.replace(/\s*\([^)]*tension[^)]*\)\s*$/i, ''); // Tension notes
    comment = comment.replace(/\s*\([^)]*playful[^)]*\)\s*$/i, ''); // Playful notes
    
    comment = comment.replace(/\s*\*\s*$/g, ''); // Remove trailing asterisks
    comment = comment.trim();
    
    // Ensure reasonable length
    if (comment.length > 150) {
      comment = comment.substring(0, 147) + '...';
    }
    
    // Detect if this comment reveals DM knowledge (spicy!)
    const revealsPrivateInfo = conversationContext && (
      comment.toLowerCase().includes('told me') ||
      comment.toLowerCase().includes('said') ||
      comment.toLowerCase().includes('dm') ||
      comment.toLowerCase().includes('conversation') ||
      comment.toLowerCase().includes('earlier') ||
      comment.toLowerCase().includes('different') ||
      comment.toLowerCase().includes('heard') ||
      comment.toLowerCase().includes('everyone knows')
    );
    
    // Store this interaction in relationship history
    if (relationship && !isPlayerPost) {
      const historyEntry = {
        timestamp: Date.now(),
        description: `Commented on their post: "${comment}"${revealsPrivateInfo ? ' [EXPOSED PRIVATE INFO!]' : ''}`,
        impact: relationType === 'enemy' ? -2 : relationType === 'rival' ? -1 : 1,
        causedDrama: revealsPrivateInfo
      };
      
      if (!relationship.history) relationship.history = [];
      relationship.history.push(historyEntry);
      if (relationship.history.length > 10) relationship.history.shift();
      
      // Adjust relationship strength based on comment tone
      if (relationType === 'enemy' || relationType === 'rival') {
        relationship.strength = Math.max(0, relationship.strength - 1);
      } else {
        relationship.strength = Math.min(100, relationship.strength + 1);
      }
      
      // If revealing private info, damage trust even among friends!
      if (revealsPrivateInfo && relationType !== 'enemy') {
        relationship.strength = Math.max(0, relationship.strength - 3);
        console.log(`[Drama] ${commenter.name} exposed private info about ${postAuthor.name}! Trust -3`);
      }
    }
    
    // If player's post and commenter revealed DM knowledge, they might get confronted later
    if (isPlayerPost && revealsPrivateInfo) {
      // Flag for potential future confrontation/gossip
      if (!commenter.recentBehavior) commenter.recentBehavior = [];
      commenter.recentBehavior.push({
        type: 'revealed_dm_info',
        timestamp: Date.now(),
        comment: comment
      });
      if (commenter.recentBehavior.length > 5) commenter.recentBehavior.shift();
      
      console.log(`[Drama] ${commenter.name} publicly referenced private DMs with boss!`);
    }
    
    console.log(`[Social${revealsPrivateInfo ? ' 🫖' : ''}] ${commenter.name} → ${targetName}: "${comment}"`);
    
    return comment;
  }
  
  /**
   * Enhanced template-based comments (fallback for AI failure)
   * Much better than the old generic ones
   */
  function generateEnhancedTemplateComment(commenter, post, postAuthor, relationType) {
    const personality = commenter.personality || {};
    const isConfident = personality.confidence > 60;
    const isFlirty = personality.flirty > 60;
    const isOutgoing = personality.outgoing > 60;
    
    // Post-type specific templates
    if (post.type === 'tea_spilling') {
      const dramaTemplates = [
        'WAIT what?! I need the full story rn �',
        'The TEA is piping hot today ☕',
        'This is MESSY and I\'m here for it 🍿',
        'SAY IT LOUDER FOR THE PEOPLE IN THE BACK',
        'Not this on my feed ��',
        'The way I gasped at this',
        'Oop- somebody said it finally',
        'This is the content I signed up for 🫖'
      ];
      return dramaTemplates[Math.floor(Math.random() * dramaTemplates.length)];
    }
    
    if (post.explicitLevel >= 2 || post.type === 'thirst_trap') {
      if (relationType === 'romantic' || relationType === 'crush') {
        return ['🥵🥵🥵', 'Stop it you\'re killing me', 'How are you even REAL', 'Not fair 😭🔥'][Math.floor(Math.random() * 4)];
      } else if (isFlirty) {
        return ['Okay WOW 👀', 'The AUDACITY �', 'You really did that huh', 'Damn �'][Math.floor(Math.random() * 4)];
      } else {
        return ['Looking good! 🔥', 'Confidence! ✨', 'Serving looks!', 'Get it! 💯'][Math.floor(Math.random() * 4)];
      }
    }
    
    if (post.type === 'complaint') {
      const sympathyTemplates = [
        'Ugh I felt that in my SOUL',
        'No literally why is it like this',
        'This is so valid honestly',
        'The way this is my daily struggle',
        'Someone needed to say it'
      ];
      const dismissiveTemplates = [
        'It\'s really not that deep',
        'Sure Jan 🙄',
        'Okay but like... why tho',
        'Interesting take'
      ];
      
      if (relationType === 'enemy' || relationType === 'rival') {
        return dismissiveTemplates[Math.floor(Math.random() * dismissiveTemplates.length)];
      }
      return sympathyTemplates[Math.floor(Math.random() * sympathyTemplates.length)];
    }
    
    // Relationship-based templates
    if (relationType === 'best_friend') {
      return [
        'BESTIE!! This is everything 💕',
        'Why are you like this I love you 😂',
        'The way you always serve content',
        'This is why you\'re my favorite person',
        'Not you coming for my whole existence',
        'Okay this made my entire day'
      ][Math.floor(Math.random() * 6)];
    }
    
    if (relationType === 'romantic') {
      return [
        'You\'re stunning I can\'t 😍',
        'Miss you already ❤️',
        'How did I get this lucky',
        'Beautiful inside and out 💕',
        'Come over? 👀'
      ][Math.floor(Math.random() * 5)];
    }
    
    if (relationType === 'crush') {
      return [
        'Wow 😳',
        'This look though 👀',
        'Okay I see you 🔥',
        'Um hello?? 😍',
        'Not me blushing at this'
      ][Math.floor(Math.random() * 5)];
    }
    
    if (relationType === 'rival') {
      return [
        'Interesting choice',
        'Sure that\'s one way to do it',
        'Bold of you 🙄',
        'Okay and?',
        'If you say so',
        'Meh I\'ve seen better'
      ][Math.floor(Math.random() * 6)];
    }
    
    if (relationType === 'enemy') {
      return [
        '🙄',
        'Whatever',
        'Seriously?',
        'Okay cool story',
        'Not interested',
        'Pass'
      ][Math.floor(Math.random() * 6)];
    }
    
    // Friend templates
    if (relationType === 'friend') {
      return [
        'Haha love this energy!',
        'You always have the best posts ✨',
        'This is so YOU I love it',
        'Main character moment!',
        'Living for this vibe',
        'The way you just understood the assignment'
      ][Math.floor(Math.random() * 6)];
    }
    
    // Default neutral but more interesting
    const neutralTemplates = [
      'This hits different',
      'Okay this is actually great',
      'Valid honestly',
      'Needed to see this today',
      'The vibe is immaculate',
      'This energy >>>',
      'No notes this is perfect'
    ];
    
    return neutralTemplates[Math.floor(Math.random() * neutralTemplates.length)];
  }
  
  /**
   * Quick casual comments for low-stakes interactions
   */
  function generateCasualComment(employee, post, relationType) {
    // Special handling for player posts
    if (post.isPlayerPost) {
      const affection = employee.stats?.affection || 0;
      const desire = employee.stats?.desire || 0;
      const intimacy = employee.intimacy || 0;
      
      if (intimacy > 60 || (affection > 60 && desire > 50)) {
        return ['Love this boss! �', 'You look amazing! �', 'Boss energy ✨', 'Stunning! 💕'][Math.floor(Math.random() * 4)];
      } else if (affection > 40) {
        return ['Nice post boss!', 'Love it! 😊', 'Great stuff! �', 'Looking good boss! ✨'][Math.floor(Math.random() * 4)];
      }
    }
    
    // Quick relationship-based responses
    const templates = {
      best_friend: ['Yessss! 🔥', 'Love this!', 'You always slay', 'This! 💯', 'Iconic behavior'],
      friend: ['Haha love it!', 'So good!', 'Amazing! ✨', 'This made my day', 'Yesss 🙌', 'The vibe!'],
      crush: ['😍', 'Wow 🔥', 'Um hello', '👀💕', 'Okay then'],
      romantic: ['Beautiful ❤️', 'Miss you', '😘', 'Love this babe', 'Gorgeous'],
      rival: ['Interesting...', 'Sure', 'Ok 🙄', 'Meh', 'If you say so'],
      enemy: ['🙄', 'Whatever', 'Seriously?', 'Pass', '😒'],
      neutral: ['Nice!', 'Cool vibes', 'This hits', 'Love the energy', 'Valid', '✨']
    };
    
    const options = templates[relationType] || templates.neutral;
    return options[Math.floor(Math.random() * options.length)];
  }
  
  /**
   * Generate "first post" for newly hired employee
   * Called immediately after hiring to create their introduction post
   */
  async function generateFirstEmployeePost(employee) {
    // Ensure social data exists first
    if (!employee.social) {
      initializeEmployeeSocialData(employee);
    }
    
    // Check if employee already has a first post (prevent duplicates)
    if (employee.social.hasFirstPost) return;
    
    // Mark that they've made their first post
    employee.social.hasFirstPost = true;
    
    const personality = employee.personality || {};
    const social = employee.social || {};
    
    // Generate AI-powered first post
    const personalityDesc = `outgoing: ${personality.outgoing || 50}/100, professional: ${personality.professional || 50}/100, confidence: ${personality.confidence || 50}/100`;
    
    // Gender-appropriate description
    const genderDesc = employee.gender ? `, a ${employee.age || 'young'}-year-old ${employee.gender === 'male' ? 'man' : employee.gender === 'transMan' ? 'trans man' : employee.gender === 'transWoman' ? 'trans woman' : employee.gender === 'femaleFuta' ? 'woman' : 'woman'}` : '';
    
    const prompt = `You are ${employee.name}${genderDesc}, posting on an uncensored social media for the FIRST TIME after just getting hired.

Your personality: ${personalityDesc}
Your role: ${employee.position || 'Employee'}
Location: ${employee.location || 'headquarters'}

Write a SHORT (1-2 sentences) first post announcing you just joined the company. Be authentic to your personality. Express excitement about starting. Use 0-2 emojis.

${social.contentStyle === 'casual' ? 'Style: Casual and friendly' : social.contentStyle === 'professional' ? 'Style: Professional but warm' : 'Style: Balanced and personable'}

Examples:
- High outgoing: "Just joined the team and already loving the energy! Can't wait to meet everyone! 🎉✨"
- High professional: "Excited to start my new role at the company. Looking forward to contributing to the team's success. 💼"
- Balanced: "First day at the new job! Feeling great about this opportunity. 😊"

Post:`;

    let content;
    try {
      content = await generateText(prompt);
      content = content.trim();
    } catch (error) {
      console.error('AI generation failed for first post:', error);
      // Fallback templates based on personality
      const fallbacks = {
        high_outgoing: [
          "Just joined the team! So excited to be here! 🎉",
          "New job, new adventures! Let's do this! ✨",
          "First day vibes! Already loving the energy here! 🚀",
          "Officially part of the team! Can't wait to meet everyone! 😊"
        ],
        high_professional: [
          "Excited to join the team and contribute to our success. 💼",
          "Looking forward to starting this new chapter. Happy to be here.",
          "Grateful for this opportunity. Ready to make an impact. 🎯",
          "Pleased to announce I've joined the company. Let's build something great."
        ],
        balanced: [
          "Just started today! Excited for what's ahead. 😊",
          "New team member here! Looking forward to working with everyone. 👋",
          "Day one complete! Great first impression. ✨",
          "Happy to be part of the team! Excited to get started. 🎉"
        ]
      };
      
      // Select template category based on personality
      let category = 'balanced';
      if (personality.outgoing > 70) category = 'high_outgoing';
      else if (personality.professional > 70) category = 'high_professional';
      
      const templates = fallbacks[category];
      content = templates[Math.floor(Math.random() * templates.length)];
    }
    
    // Determine if they want to post a selfie (30% chance if outgoing > 60)
    let imagePrompt = null;
    let imageUrl = null;
    
    if (personality.outgoing > 60 && Math.random() < 0.3) {
      // Use consistent physical description for first post selfie
      const physicalDesc = getPhysicalDescriptionForPrompt(employee);
      imagePrompt = `Professional first-day selfie: ${physicalDesc}, smiling confidently, office setting, welcoming expression, good lighting, business casual attire, friendly and approachable`;
      
      try {
        imageUrl = await generateImage({ prompt: imagePrompt });
      } catch (error) {
        console.error('Image generation failed for first post:', error);
        imageUrl = null;
      }
    }
    
    // Create the first post
    const post = createPost({
      authorId: employee.id,
      authorName: employee.name,
      type: imageUrl ? 'selfie' : 'text',
      content: content,
      imageUrl: imageUrl,
      imageAlt: imagePrompt || 'First day at work',
      explicitLevel: 0, // Always safe for first post
      tags: ['first_post', 'new_hire'],
      location: employee.location || 'headquarters',
      isPlayerPost: false
    });
    
    // Add to feed
    gameState.socialNetwork.posts.unshift(post);
    
    // Refresh dashboard to show new posts/mentions
    if (gameState.activeTab === 'dashboard') {
      refreshDashboardSections();
    }
    
    // Log event
    logCompanyEvent('first_post', {
      authorId: employee.id,
      authorName: employee.name,
      postType: post.type
    });
    
    // Refresh feed if social tab is active
    if (gameState.activeTab === 'social') {
      renderSocialFeed();
    }
    
    console.log(`✅ ${employee.name} made their first post!`);
    
    return post;
  }
  
  /**
   * Generate autonomous likes on recent posts
   */
  async function generateAutonomousLikes() {
    // Get recent posts (last 15)
    const recentPosts = gameState.socialNetwork.posts.slice(0, 15);
    if (recentPosts.length === 0) return;
    
    const activeEmployees = gameState.employees.filter(e => e.employmentStatus === 'active');
    
    for (const employee of activeEmployees) {
      for (const post of recentPosts) {
        // Skip own posts
        if (post.authorId === employee.id) continue;
        
        // Skip if already liked
        if (post.likes.includes(employee.id)) continue;
        
        // Determine like probability based on relationship
        const relationship = employee.relationships?.[post.authorId];
        const relationType = relationship?.type || 'neutral';
        
        let likeProbability = 0.3; // Base 30%
        
        switch (relationType) {
          case 'best_friend': likeProbability = 0.9; break;
          case 'friend': likeProbability = 0.7; break;
          case 'crush': likeProbability = 0.85; break;
          case 'romantic': likeProbability = 0.95; break;
          case 'rival': likeProbability = 0.1; break;
          case 'enemy': likeProbability = 0.05; break;
        }
        
        // Boost probability for explicit content if employee is flirty
        if (post.explicitLevel >= 2 && employee.personality?.flirty > 60) {
          likeProbability += 0.2;
        }
        
        // Random like based on probability
        if (Math.random() < likeProbability) {
          post.likes.push(employee.id);
          
          // 🌐 Evaluate relationship impact from liking (smaller than comments)
          const postAuthor = gameState.employees.find(e => e.id === post.authorId);
          if (postAuthor && postAuthor.id !== employee.id) {
            // Viewing and liking without commenting = smaller relationship impact
            await evaluateNPCReactionToPost(employee, postAuthor, post, null);
          }
        }
      }
    }
  }

  
  // Show notification
  function showNotification(message, type = 'success') {
    // Create notification element
    const colors = {
      success: '#4caf50',
      error: '#e94560',
      warning: '#ffa726',
      info: '#2196f3'
    };
    
    const notification = document.createElement('div');
    notification.style.cssText = `position:fixed; bottom:20px; right:20px; background:${colors[type] || colors.success}; color:white; padding:15px 20px; border-radius:8px; box-shadow:0 4px 15px rgba(0,0,0,0.3); z-index:3000; max-width:300px; animation: slideIn 0.3s;`;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    // Remove after 3 seconds
    setTimeout(() => {
      notification.style.animation = 'fadeOut 0.3s';
      setTimeout(() => notification.remove(), 300);
    }, 3000);
  }
  
  // Save game
  // Flag to prevent saving during reset
  let isResetting = false;
  
  // Save game using kv-plugin (avoids localStorage quota limits)
  async function saveGame(showToast = true) {
    // Don't save if we're in the middle of resetting
    if (isResetting) return;
    
    try {
      // Don't update lastPlayTime here - it should only update when page becomes hidden
      // or when user is actually leaving
      await kv.gameSave.set("gameState", gameState);
      if (showToast) showNotification('Game saved!');
    } catch (error) {
      console.error('Error saving game:', error);
      showNotification('Failed to save game!');
    }
  }

  // Load game using kv-plugin
  async function loadGame() {
    try {
      const savedState = await kv.gameSave.get("gameState");
      if (savedState) {
        const parsed = savedState;
        // Merge saved state with default state to ensure all properties exist
        gameState = {
          ...gameState,
          ...parsed,
          // Ensure activeLocationId defaults to first unlocked location
          activeLocationId: parsed.activeLocationId || 'garage',
          upgradeMultiplier: parsed.upgradeMultiplier || 1,
          // Ensure locations have proper unlock states
          locations: (parsed.locations || gameState.locations).map(loc => ({
            unlocked: loc.unlocked ?? (loc.owned ?? (loc.id === 'garage')), // First location or previously owned
            owned: loc.owned ?? loc.unlocked ?? (loc.id === 'garage'),
            ...loc
          })),
          // Ensure critical objects are properly initialized
          products: (parsed.products || gameState.products).map(p => {
            // Define unlock costs based on product id (for backwards compatibility)
            const defaultUnlockCosts = {
              'website': 0,      // first product is free
              'app': 100,
              'consulting': 400,
              'cloud': 1800,
              'seo': 3000,
              'branding': 5000,
              'ecommerce': 8000,
              'automation': 12000,
              'copywriting': 0, // first in home_office
              'video_editing': 20000,
              'marketing': 35000,
              'consulting_premium': 55000,
              'saas': 85000
            };
            
            return {
              // backfill new balance fields for old saves
              baseUpgradeCost: p.baseUpgradeCost ?? p.upgradeCost ?? 50,
              costGrowth: p.costGrowth ?? 1.35,
              valueExponent: p.valueExponent ?? 0.85,
              managerSpeedCapPct: p.managerSpeedCapPct ?? 0.40,
              // backfill unlock properties
              unlocked: p.unlocked ?? (p.id === 'website' ? true : false), // first product unlocked by default
              unlockCost: p.unlockCost ?? (defaultUnlockCosts[p.id] || 0),
              ...p
            };
          }),
          employees: parsed.employees || gameState.employees,
          settings: {...gameState.settings, ...(parsed.settings || {})},
          chatHistory: parsed.chatHistory || {},
          // Ensure social network data exists (backward compatibility)
          socialNetwork: {
            ...gameState.socialNetwork,
            ...(parsed.socialNetwork || {}),
            posts: parsed.socialNetwork?.posts || [],
            globalEvents: parsed.socialNetwork?.globalEvents || [],
            postIdCounter: parsed.socialNetwork?.postIdCounter || 0
          },
          companyContext: {
            ...gameState.companyContext,
            ...(parsed.companyContext || {})
          }
        };
        
        // Initialize social data for all employees (migration for old saves)
        gameState.employees.forEach(emp => {
          initializeEmployeeSocialData(emp);
          ensureEmployeeMemory(emp);
        });
        
        // Update company awareness on load
        updateCompanyAwareness();
        
        // Generate initial relationships if none exist
        const hasRelationships = gameState.employees.some(emp => 
          emp.relationships && Object.keys(emp.relationships).length > 0
        );
        if (!hasRelationships && gameState.employees.length > 1) {
          generateRandomRelationships();
        }
        
        // Initialize used names from loaded employees
        initializeUsedNames();
        
        showNotification('Game loaded!');
        
        // Check for AFK income
        checkAfkIncome();
      } else {
        // Try to migrate from old localStorage if available
        await migrateFromLocalStorage();
      }
    } catch (error) {
      console.error('Error loading game:', error);
      showNotification('Failed to load saved game. Starting fresh!');
    }
  }
  
  // Check for AFK income when player returns
  function checkAfkIncome() {
    const now = Date.now();
    
    // Use lastInteractionTime if available, otherwise fall back to lastPlayTime
    const lastActiveTime = gameState.lastInteractionTime || gameState.lastPlayTime || now;
    const timeAway = now - lastActiveTime; // milliseconds
    
    // Only show if away for more than 5 minutes
    const MIN_TIME_AWAY = 5 * 60 * 1000; // 5 minutes
    if (timeAway < MIN_TIME_AWAY) {
      // Update interaction time for next session
      gameState.lastInteractionTime = now;
      gameState.lastPlayTime = now;
      return;
    }
    
    // Calculate income per second
    const incomePerSecond = parseFloat(calculateCashPerSecond());
    
    // If no income, skip
    if (incomePerSecond <= 0) {
      gameState.lastInteractionTime = now;
      gameState.lastPlayTime = now;
      return;
    }
    
    // Calculate time away in seconds
    const secondsAway = Math.floor(timeAway / 1000);
    
    // Cap at 24 hours to prevent abuse
    const MAX_AFK_TIME = 24 * 60 * 60; // 24 hours in seconds
    const cappedSecondsAway = Math.min(secondsAway, MAX_AFK_TIME);
    
    // Calculate earnings (50% of full rate for AFK - reduced from 80%)
    const AFK_RATE = 0.5; // 50% of active income rate
    const fullEarnings = incomePerSecond * cappedSecondsAway;
    const afkEarnings = Math.floor(fullEarnings * AFK_RATE);
    
    // Log for debugging
    console.log(`[AFK] Time away: ${(cappedSecondsAway / 60).toFixed(1)} minutes`);
    console.log(`[AFK] Income rate: $${formatNumber(incomePerSecond)}/sec`);
    console.log(`[AFK] Full earnings (100%): $${formatNumber(fullEarnings)}`);
    console.log(`[AFK] AFK earnings (${AFK_RATE * 100}%): $${formatNumber(afkEarnings)}`);
    
    // Format time away
    const hours = Math.floor(cappedSecondsAway / 3600);
    const minutes = Math.floor((cappedSecondsAway % 3600) / 60);
    const timeAwayText = hours > 0 
      ? `${hours}h ${minutes}m` 
      : `${minutes}m`;
    
    // Update modal with earnings info
    const afkModal = document.getElementById('afkIncomeModal');
    const timeAwayEl = document.getElementById('afkTimeAway');
    const incomeRateEl = document.getElementById('afkIncomeRate');
    const fullEarningsEl = document.getElementById('afkFullEarnings');
    const afkEarningsEl = document.getElementById('afkEarnings');
    const afkRateEl = document.getElementById('afkRate');
    const claimBtn = document.getElementById('claimAfkIncome');
    const closeBtn = document.getElementById('closeAfkIncome');
    
    if (timeAwayEl) timeAwayEl.textContent = timeAwayText;
    if (incomeRateEl) incomeRateEl.textContent = `$${formatNumber(incomePerSecond)}/sec`;
    if (fullEarningsEl) fullEarningsEl.textContent = `$${formatNumber(fullEarnings)}`;
    if (afkEarningsEl) afkEarningsEl.textContent = `$${formatNumber(afkEarnings)}`;
    if (afkRateEl) afkRateEl.textContent = `${AFK_RATE * 100}%`;
    
    // Show modal
    if (afkModal) {
      afkModal.style.display = 'flex';
    }
    
    // Claim button handler
    if (claimBtn) {
      claimBtn.onclick = () => {
        gameState.cash += afkEarnings;
        gameState.lastPlayTime = now;
        gameState.lastInteractionTime = now;
        updateUI();
        if (afkModal) afkModal.style.display = 'none';
        showNotification(`Claimed $${formatNumber(afkEarnings)} AFK earnings!`);
      };
    }
    
    // Close button handler
    if (closeBtn) {
      closeBtn.onclick = () => {
        gameState.cash += afkEarnings; // Still give them the money
        gameState.lastPlayTime = now;
        gameState.lastInteractionTime = now;
        updateUI();
        if (afkModal) afkModal.style.display = 'none';
      };
    }
  }
  
  // Migrate old localStorage data to kv-plugin (one-time migration)
  async function migrateFromLocalStorage() {
    try {
      const oldSave = localStorage.gameState;
      if (oldSave) {
        console.log('Migrating old localStorage save to kv-plugin...');
        const parsed = JSON.parse(oldSave);
        await kv.gameSave.set("gameState", parsed);
        // Clear old localStorage to free up space
        delete localStorage.gameState;
        console.log('Migration complete! Old localStorage data cleared.');
        showNotification('Save data migrated to new storage system!');
        // Reload the game with the migrated data
        await loadGame();
      }
    } catch (error) {
      console.error('Error migrating from localStorage:', error);
    }
  }

  // ===== PRESTIGE SYSTEM FUNCTIONS =====
  
  // Define permanent upgrades purchasable with Influence Points
  const influenceUpgrades = {
    incomeMultiplier: {
      id: 'incomeMultiplier',
      name: 'Income Multiplier',
      description: 'Increase all income by 10% per level',
      icon: '💰',
      baseCost: 5,
      costIncrease: 1.3,
      maxLevel: 50,
      getCurrentLevel: () => gameState.influenceUpgrades?.incomeMultiplier || 0,
      effect: (level) => 1 + (level * 0.1) // 10% per level
    },
    startingCash: {
      id: 'startingCash',
      name: 'Starting Capital',
      description: 'Start each prestige with more cash',
      icon: '💵',
      baseCost: 3,
      costIncrease: 1.4,
      maxLevel: 100,
      getCurrentLevel: () => gameState.influenceUpgrades?.startingCash || 0,
      effect: (level) => 50 * level // $50 per level
    },
    clickPower: {
      id: 'clickPower',
      name: 'Quick Hands',
      description: 'Click products to reduce time by +0.05s per level',
      icon: '👆',
      baseCost: 3,
      costIncrease: 1.3,
      maxLevel: 50,
      getCurrentLevel: () => gameState.influenceUpgrades?.clickPower || 0,
      effect: (level) => level * 0.05 // +0.05s time reduction per click per level
    },
    employeeDiscount: {
      id: 'employeeDiscount',
      name: 'HR Efficiency',
      description: 'Reduce employee costs by 5% per level',
      icon: '👔',
      baseCost: 4,
      costIncrease: 1.35,
      maxLevel: 10,
      getCurrentLevel: () => gameState.influenceUpgrades?.employeeDiscount || 0,
      effect: (level) => Math.max(0.5, 1 - (level * 0.05)) // Max 50% discount at level 10
    },
    productDiscount: {
      id: 'productDiscount',
      name: 'Bulk Buying',
      description: 'Reduce product costs by 3% per level',
      icon: '📦',
      baseCost: 4,
      costIncrease: 1.35,
      maxLevel: 15,
      getCurrentLevel: () => gameState.influenceUpgrades?.productDiscount || 0,
      effect: (level) => Math.max(0.55, 1 - (level * 0.03)) // Max 45% discount at level 15
    },
    autoProgress: {
      id: 'autoProgress',
      name: 'Automation Boost',
      description: 'Managers work 5% faster per level',
      icon: '⚡',
      baseCost: 6,
      costIncrease: 1.4,
      maxLevel: 20,
      getCurrentLevel: () => gameState.influenceUpgrades?.autoProgress || 0,
      effect: (level) => 1 + (level * 0.05) // 5% faster per level
    }
  };
  
  // Initialize influence upgrades in gameState if not present
  if (!gameState.influenceUpgrades) {
    gameState.influenceUpgrades = {};
    Object.keys(influenceUpgrades).forEach(key => {
      gameState.influenceUpgrades[key] = 0;
    });
  }
  
  // Calculate how many influence points player will gain from current lifetime earnings
  function calculateInfluenceGain() {
    // Only count earnings that haven't been converted to influence yet
    const unconvertedEarnings = gameState.lifetimeEarnings - (gameState.lifetimeEarningsConverted || 0);
    // Formula: sqrt(earnings / 10000) rounded down
    // This means: $10k = 1 IP, $40k = 2 IP, $90k = 3 IP, $160k = 4 IP, etc.
    return Math.floor(Math.sqrt(unconvertedEarnings / 10000));
  }
  
  // Calculate cost of next level for an influence upgrade
  function getInfluenceUpgradeCost(upgradeId) {
    const upgrade = influenceUpgrades[upgradeId];
    if (!upgrade) return 0;
    
    const currentLevel = upgrade.getCurrentLevel();
    if (currentLevel >= upgrade.maxLevel) return Infinity;
    
    return Math.ceil(upgrade.baseCost * Math.pow(upgrade.costIncrease, currentLevel));
  }
  
  // Purchase an influence upgrade
  function purchaseInfluenceUpgrade(upgradeId) {
    const upgrade = influenceUpgrades[upgradeId];
    if (!upgrade) return false;
    
    const currentLevel = upgrade.getCurrentLevel();
    if (currentLevel >= upgrade.maxLevel) {
      showNotification('Upgrade is at max level!');
      return false;
    }
    
    const cost = getInfluenceUpgradeCost(upgradeId);
    if (gameState.influencePoints < cost) {
      showNotification('Not enough Influence Points!');
      return false;
    }
    
    // Purchase upgrade
    gameState.influencePoints -= cost;
    gameState.influenceUpgrades[upgradeId] = currentLevel + 1;
    
    showNotification(`Upgraded ${upgrade.name} to level ${currentLevel + 1}!`);
    updatePrestigeUI();
    renderInfluenceUpgrades();
    return true;
  }
  
  // Render the influence upgrades shop
  function renderInfluenceUpgrades() {
    const container = document.getElementById('influenceUpgradesContainer');
    if (!container) return;
    
    container.innerHTML = '';
    
    Object.values(influenceUpgrades).forEach(upgrade => {
      const currentLevel = upgrade.getCurrentLevel();
      const cost = getInfluenceUpgradeCost(upgrade.id);
      const isMaxed = currentLevel >= upgrade.maxLevel;
      const canAfford = gameState.influencePoints >= cost && !isMaxed;
      
      const upgradeDiv = document.createElement('div');
      upgradeDiv.style.cssText = `
        background: #16213e;
        border-radius: 12px;
        padding: 20px;
        border: 2px solid ${canAfford ? '#ffd700' : '#2a3f5f'};
        transition: all 0.3s;
        opacity: ${isMaxed ? '0.6' : '1'};
      `;
      
      if (canAfford) {
        upgradeDiv.style.cursor = 'pointer';
        upgradeDiv.style.boxShadow = '0 4px 15px rgba(255,215,0,0.2)';
        upgradeDiv.onmouseenter = () => {
          upgradeDiv.style.transform = 'translateY(-3px)';
          upgradeDiv.style.boxShadow = '0 6px 20px rgba(255,215,0,0.3)';
        };
        upgradeDiv.onmouseleave = () => {
          upgradeDiv.style.transform = 'translateY(0)';
          upgradeDiv.style.boxShadow = '0 4px 15px rgba(255,215,0,0.2)';
        };
        upgradeDiv.onclick = () => purchaseInfluenceUpgrade(upgrade.id);
      }
      
      upgradeDiv.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:12px;">
          <div>
            <div style="font-size:2rem; margin-bottom:8px;">${upgrade.icon}</div>
            <div style="font-weight:700; font-size:1.1rem; color:white; margin-bottom:5px;">${upgrade.name}</div>
            <div style="color:#aaa; font-size:0.85rem; line-height:1.4;">${upgrade.description}</div>
          </div>
        </div>
        <div style="display:flex; justify-content:space-between; align-items:center; margin-top:15px; padding-top:15px; border-top:1px solid #2a3f5f;">
          <div style="color:#00d4ff; font-size:0.9rem;">Level ${currentLevel}/${upgrade.maxLevel}</div>
          <div style="color:${canAfford ? '#ffd700' : isMaxed ? '#2ecc71' : '#666'}; font-weight:700; font-size:1.1rem;">
            ${isMaxed ? '✓ MAXED' : `${cost} IP`}
          </div>
        </div>
      `;
      
      container.appendChild(upgradeDiv);
    });
  }
  
  // Update the prestige UI with current stats
  function updatePrestigeUI() {
    // Update current stats
    const currentPrestigeLevelEl = document.getElementById('currentPrestigeLevel');
    const lifetimeEarningsEl = document.getElementById('lifetimeEarningsDisplay');
    const currentInfluencePointsEl = document.getElementById('currentInfluencePoints');
    const currentMultiplierEl = document.getElementById('currentMultiplier');
    const nextPrestigeInfluenceEl = document.getElementById('nextPrestigeInfluence');
    const prestigeReqEl = document.getElementById('prestigeRequirement');
    
    if (currentPrestigeLevelEl) currentPrestigeLevelEl.textContent = gameState.prestigeLevel;
    if (lifetimeEarningsEl) lifetimeEarningsEl.textContent = `$${formatNumber(gameState.lifetimeEarnings)}`;
    if (currentInfluencePointsEl) currentInfluencePointsEl.textContent = gameState.influencePoints;
    
    // Calculate total multiplier from all sources
    const incomeUpgradeLevel = gameState.influenceUpgrades?.incomeMultiplier || 0;
    const totalMultiplier = influenceUpgrades.incomeMultiplier.effect(incomeUpgradeLevel);
    if (currentMultiplierEl) currentMultiplierEl.textContent = `${totalMultiplier.toFixed(1)}x`;
    
    // Calculate influence gain for next prestige
    const influenceGain = calculateInfluenceGain();
    if (nextPrestigeInfluenceEl) nextPrestigeInfluenceEl.textContent = influenceGain;
    
    // Check if player meets requirement to prestige (at least $100k lifetime earnings)
    const canPrestige = gameState.lifetimeEarnings >= 100000 && influenceGain > 0;
    const prestigeBtn = document.getElementById('prestigeBtn');
    
    if (prestigeBtn) {
      if (canPrestige) {
        prestigeBtn.disabled = false;
        prestigeBtn.style.opacity = '1';
        prestigeBtn.style.cursor = 'pointer';
        if (prestigeReqEl) prestigeReqEl.textContent = '';
      } else {
        prestigeBtn.disabled = true;
        prestigeBtn.style.opacity = '0.5';
        prestigeBtn.style.cursor = 'not-allowed';
        if (prestigeReqEl) {
          const needed = 100000 - gameState.lifetimeEarnings;
          prestigeReqEl.textContent = `Requires $100k total earnings (need $${formatNumber(needed)} more)`;
        }
      }
    }
  }
  
  // Show the prestige confirmation modal
  function showPrestigeModal() {
    const influenceGain = calculateInfluenceGain();
    if (influenceGain <= 0 || gameState.lifetimeEarnings < 100000) {
      showNotification('You need at least $100k lifetime earnings to prestige!');
      return;
    }
    
    const modal = document.getElementById('prestigeModal');
    const gainAmount = document.getElementById('prestigeGainAmount');
    
    if (gainAmount) gainAmount.textContent = `+${influenceGain}`;
    if (modal) modal.style.display = 'flex';
  }
  
  // Execute the prestige (reset game with benefits)
  function executePrestige() {
    const influenceGain = calculateInfluenceGain();
    
    // Award influence points
    gameState.influencePoints += influenceGain;
    gameState.prestigeLevel += 1;
    
    // Mark current lifetime earnings as converted to prevent re-claiming
    gameState.lifetimeEarningsConverted = gameState.lifetimeEarnings;
    
    // Preserve these values
    const preservedInfluencePoints = gameState.influencePoints;
    const preservedPrestigeLevel = gameState.prestigeLevel;
    const preservedLifetimeEarnings = gameState.lifetimeEarnings;
    const preservedLifetimeEarningsConverted = gameState.lifetimeEarningsConverted;
    const preservedInfluenceUpgrades = {...gameState.influenceUpgrades};
    const preservedSettings = {...gameState.settings};
    const preservedPlayerBio = gameState.settings?.playerBio || '';
    
    // NEW: Preserve former employees for rehiring
    const preservedFormerEmployees = gameState.formerEmployees || [];
    
    // Save current employees as former employees (with their product associations)
    gameState.employees.forEach(emp => {
      if (emp.productManaged) {
        // Check if this employee was already a former employee
        const existingFormerIndex = preservedFormerEmployees.findIndex(
          fe => fe.originalId === (emp.originalId || emp.id)
        );
        
        const employeeData = {
          // Preserve original ID for tracking across prestiges
          originalId: emp.originalId || emp.id,
          name: emp.name,
          age: emp.age,
          gender: emp.gender,
          position: emp.position,
          productManaged: emp.productManaged,
          profileImage: emp.profileImage,
          bio: emp.bio,
          personality: emp.personality,
          personalityTraits: emp.personalityTraits,
          hobbies: emp.hobbies,
          kinks: emp.kinks,
          traits: emp.traits,
          keyTrait: emp.keyTrait,
          physical: emp.physical,
          chatHistory: gameState.chatHistory[emp.id] || [],
          photos: emp.photos || [],
          memory: emp.memory,
          stats: emp.stats,
          relationships: emp.relationships,
          intimacy: emp.intimacy,
          // Track loyalty (times rehired)
          timesRehired: existingFormerIndex >= 0 ? (preservedFormerEmployees[existingFormerIndex].timesRehired || 0) + 1 : 1,
          lastPrestigeLevel: preservedPrestigeLevel
        };
        
        if (existingFormerIndex >= 0) {
          // Update existing former employee data
          preservedFormerEmployees[existingFormerIndex] = employeeData;
        } else {
          // Add new former employee
          preservedFormerEmployees.push(employeeData);
        }
      }
    });
    
    // Calculate starting cash from influence upgrades
    const startingCashBonus = influenceUpgrades.startingCash.effect(
      gameState.influenceUpgrades?.startingCash || 0
    );
    
    // Reset game state (this resets everything to defaults)
    const freshState = {
      cash: gameBalance.startingCash + startingCashBonus,
      playerUpgrades: { clickPower: 0 },
      totalEarnings: 0,
      onboarding: [],
      lastPlayTime: Date.now(),
      
      // PRESTIGE SYSTEM (preserved)
      prestigeLevel: preservedPrestigeLevel,
      influencePoints: preservedInfluencePoints,
      lifetimeEarnings: preservedLifetimeEarnings,
      lifetimeEarningsConverted: preservedLifetimeEarningsConverted,
      prestigeMultiplier: 1.0,
      influenceUpgrades: preservedInfluenceUpgrades,
      
      // GLOBAL UPGRADES (reset on prestige)
      globalUpgrades: {
        clickPower: 0,
        incomeBoost: {},
        costReduction: {}
      },
      
      // BOSS FIGHTS (reset)
      bossFights: {
        active: null,
        defeated: [],
        history: []
      },
      
      // Locations (reset to just garage)
      locations: gameState.locations.map(loc => ({
        ...loc,
        owned: loc.id === 'garage',
        unlocked: loc.id === 'garage',
        products: []
      })),
      
      activeLocationId: 'garage',
      
      // Products (reset all progress, keep only base definition properties)
      products: gameState.products.map(p => ({
        // Keep base definition properties
        id: p.id,
        name: p.name,
        locationId: p.locationId,
        nsfwLevel: p.nsfwLevel,
        
        // Economic properties (keep base values)
        valuePerUnit: p.valuePerUnit,
        baseUpgradeCost: p.baseUpgradeCost,
        costGrowth: p.costGrowth,
        valuePerUpgrade: p.valuePerUpgrade,
        valueExponent: p.valueExponent,
        
        // Timing properties (keep base values)
        baseTimeMs: p.baseTimeMs,
        clickSecondsBase: p.clickSecondsBase,
        
        // Manager properties (keep base costs)
        managerHireCost: p.managerHireCost,
        managerUpgradeCost: p.managerUpgradeCost,
        managerSpeedCapPct: p.managerSpeedCapPct,
        
        // Unlock properties
        unlockCost: p.unlockCost,
        
        // RESET all progress properties
        quantity: 0,
        level: 0,
        upgradeCost: p.baseUpgradeCost, // Reset to base cost
        unlocked: false,
        running: false,
        timeRemainingMs: 0,
        managerHired: false,
        managerLevel: 0
      })),
      
      // Employees (reset)
      employees: [],
      
      // Former employees (preserved for rehiring)
      formerEmployees: preservedFormerEmployees,
      
      // Social Network (reset)
      socialNetwork: {
        posts: [],
        globalEvents: [],
        postIdCounter: 0,
        lastPostGeneration: 0,
        postGenerationInterval: 300000,
        feedFilter: 'all',
        feedSort: 'recent',
        recentPostTypes: [],
        playerDraft: {
          caption: '',
          imagePrompt: '',
          altText: '',
          imageUrl: null
        }
      },
      
      // Company Context (reset)
      companyContext: {
        totalEmployees: 0,
        locationEmployeeCounts: {},
        recentHires: [],
        recentFires: [],
        recentPromotions: [],
        interdepartmentalEvents: []
      },
      
      // Social Feed (deprecated but keep for compatibility)
      socialFeed: [],
      socialStats: {
        totalPosts: 0,
        totalLikes: 0,
        totalComments: 0
      },
      chatHistory: {},
      activeChat: null,
      
      // News (reset to defaults)
      news: [
        "Tech startup raises $1M in seed funding",
        "New productivity app trends in office spaces",
        "Remote work policies reshape company cultures",
        "AI integration boosts efficiency across industries"
      ],
      
      // Settings (preserved)
      settings: {
        ...preservedSettings,
        playerBio: preservedPlayerBio
      },
      
      activeTab: 'dashboard',
      upgradeMultiplier: 1
    };
    
    // Replace gameState with fresh state
    Object.keys(gameState).forEach(key => delete gameState[key]);
    Object.assign(gameState, freshState);
    
    // Close modal
    const modal = document.getElementById('prestigeModal');
    if (modal) modal.style.display = 'none';
    
    // Save and refresh UI
    saveGame(false);
    updateUI();
    updatePrestigeUI();
    renderInfluenceUpgrades();
    
    // Show success notification
    showNotification(`✨ Prestiged! Gained ${influenceGain} Influence Points!`, 5000);
    
    // Switch to main tab
    switchTab('main');
  }

  // Autosave setup
  // Store autosave interval ID so we can clear it
  let autosaveIntervalId = null;
  
  function setupAutosave() {
    // Clear any existing autosave interval first
    if (autosaveIntervalId) {
      clearInterval(autosaveIntervalId);
      autosaveIntervalId = null;
    }
    
    if (gameState.settings.autosave) {
      autosaveIntervalId = setInterval(() => saveGame(false), 5000); // every 5s, no toast
    }
  }
  
  // Export save
  function exportSave() {
    const saveData = JSON.stringify(gameState);
    const blob = new Blob([saveData], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'office-empire-save.json';
    a.click();
    
    URL.revokeObjectURL(url);
    showNotification('Save data exported!');
  }
  
  // Reset game
  async function resetGame() {
    if (confirm('Are you sure you want to reset the game? All progress will be lost!')) {
      try {
        // Set reset flag to prevent any saves during reset
        isResetting = true;
        
        // Stop autosave immediately to prevent saving during reset
        if (autosaveIntervalId) {
          clearInterval(autosaveIntervalId);
          autosaveIntervalId = null;
        }
        
        // Wait a moment for any pending saves to complete
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Clear kv storage
        await kv.gameSave.delete("gameState");
        
        // Clear old localStorage
        localStorage.removeItem('gameState');
        
        // Wait another moment to ensure delete operations complete
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Show notification before reload
        showNotification('Game reset! Reloading...');
        
        // Wait a bit for notification to show
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Now reload (isResetting flag will be cleared by reload)
        location.reload();
      } catch (error) {
        console.error('Error resetting game:', error);
        showNotification('Error resetting game. Please try again.');
        isResetting = false; // Reset flag on error
      }
    }
  }
  
  // Unlock location
  function unlockLocation(locationId) {
    const location = gameState.locations.find(l => l.id === locationId);
    if (!location) return showNotification('Location not found!');
    
    if (location.unlocked) return showNotification('Location already unlocked!');
    
    // Check prerequisites
    if (!checkLocationUnlockable(locationId)) {
      return showNotification('Complete all products in previous locations first!');
    }
    
    // Check cost
    if (gameState.cash < location.cost) {
      return showNotification(`Need $${formatNumber(location.cost)} to unlock ${location.name}!`);
    }
    
    // Unlock location
    gameState.cash -= location.cost;
    location.unlocked = true;
    location.owned = true; // backward compatibility
    
    // Switch to the newly unlocked location
    gameState.activeLocationId = locationId;
    
    // Unlock the first product in this location
    const firstProduct = gameState.products.find(p => p.locationId === locationId);
    if (firstProduct && firstProduct.unlockCost === 0) {
      firstProduct.unlocked = true;
    }
    
    showNotification(`${location.name} unlocked!`);
    updateBusinessTab();
    updateUI();
  }
  
  // Purchase location (backward compatibility alias)
  function purchaseLocation(locationId) {
    unlockLocation(locationId);
  }
  
  // Generate initial employees
  function generateInitialEmployees() {
    // Use the massive name pools defined earlier
    const traits = ['Hardworking', 'Creative', 'Analytical', 'Charismatic', 'Detail-oriented', 'Adaptable'];
    const personalities = ['Friendly', 'Reserved', 'Outgoing', 'Thoughtful', 'Energetic', 'Calm'];
    const hobbies = ['Reading', 'Photography', 'Hiking', 'Gaming', 'Cooking', 'Traveling', 'Music', 'Art', 'Yoga', 'Dancing'];
    const kinks = ['Exhibitionism', 'Bondage', 'Roleplay', 'Dominance', 'Submission', 'Voyeurism', 'Teasing', 'Spanking'];
    
    // Generate 2 initial employees
    for (let i = 0; i < 2; i++) {
      // Use gender selection system
      const gender = selectGenderForEmployee();
      const fullName = generateUniqueName(gender); // Use unique name generator with gender
      
      // Generate random traits and personality
      const trait = traits[Math.floor(Math.random() * traits.length)];
      const personality = personalities[Math.floor(Math.random() * personalities.length)];
      
      // Generate 1-3 random hobbies
      const numHobbies = Math.floor(Math.random() * 3) + 1;
      const employeeHobbies = [];
      while (employeeHobbies.length < numHobbies) {
        const hobby = hobbies[Math.floor(Math.random() * hobbies.length)];
        if (!employeeHobbies.includes(hobby)) {
          employeeHobbies.push(hobby);
        }
      }
      
      // Generate 2-4 random kinks
      const numKinks = Math.floor(Math.random() * 3) + 2;
      const employeeKinks = [];
      while (employeeKinks.length < numKinks) {
        const kink = kinks[Math.floor(Math.random() * kinks.length)];
        if (!employeeKinks.includes(kink)) {
          employeeKinks.push(kink);
        }
      }
      
      // Generate initial stats (0-100 scale)
      const stats = {
        affection: 20 + Math.floor(Math.random() * 20),   // How much they like you personally
        comfort: 40 + Math.floor(Math.random() * 30),      // How comfortable they feel around you
        trust: 30 + Math.floor(Math.random() * 30),        // How much they trust you
        desire: 5 + Math.floor(Math.random() * 15),        // Romantic/sexual attraction
        obedience: 40 + Math.floor(Math.random() * 30),    // Willingness to follow instructions
        productivity: 50 + Math.floor(Math.random() * 30)  // Work performance (affects game mechanics)
      };
      
      // Generate detailed physical appearance (NEW SYSTEM!) - Gender-aware
      const detailedPhysical = generateDetailedPhysicalAppearance(gender);
      
      // Generate AI personality attributes (C.O.F.P.H.)
      const aiPersonality = {
        confidence: 30 + Math.floor(Math.random() * 50),    // 30-80 range
        outgoing: 20 + Math.floor(Math.random() * 60),      // 20-80 range
        flirty: 10 + Math.floor(Math.random() * 70),        // 10-80 range
        professional: 30 + Math.floor(Math.random() * 50),  // 30-80 range
        humor: 20 + Math.floor(Math.random() * 60)          // 20-80 range
      };
      
      gameState.employees.push({
        id: `emp_${Date.now()}_${i}`,
        name: fullName, // Use the unique name generated above
        position: 'Employee',
        gender: gender,
        trait: trait,
        personality: aiPersonality,  // AI-readable personality object
        personalityTraits: [personality], // Human-readable personality traits
        hobbies: employeeHobbies,
        kinks: employeeKinks,
        stats: stats,
        level: 1,
        hired: true,
        bio: `A ${personality.toLowerCase()} and ${trait.toLowerCase()} team member who enjoys ${employeeHobbies.join(', ')}.`,
        physical: detailedPhysical, // Use new detailed system
        profileImage: null,
        memory: [] // long-term memory: facts, events, relationship history
      });
    }
  }

  // Expose functions to global scope for external access
  window.selectManagerCandidate = selectManagerCandidate;
  window.closeHiringModal = closeHiringModal;
  window.showNotification = showNotification;
  window.updateUI = updateUI;
  window.updateDashboard = updateDashboard;
  window.updateBusinessTab = updateBusinessTab;
  window.updatePeopleTab = updatePeopleTab;
  window.updateGiftsTab = updateGiftsTab;
  window.updateHRTab = updateHRTab;
  window.updateNewsFeed = updateNewsFeed;
  window.gameTick = gameTick;
  window.updateNews = updateNews;
  window.saveGame = saveGame;
  window.loadGame = loadGame;
  window.migrateFromLocalStorage = migrateFromLocalStorage;
  window.resetGame = resetGame;
  window.exportSave = exportSave;
  window.resetGame = resetGame;
  window.unlockLocation = unlockLocation;
  window.purchaseLocation = purchaseLocation;
  window.checkLocationUnlockable = checkLocationUnlockable;
  window.handleEmployeeAction = handleEmployeeAction;
  window.openChat = openChat;
  window.loadChatHistory = loadChatHistory;
  window.addChatMessage = addChatMessage;
  window.sendChatMessage = sendChatMessage;
  window.updateEmployeeStatsFromChat = updateEmployeeStatsFromChat;
  window.setupEventListeners = setupEventListeners;
  window.switchTab = switchTab;
  window.updateTabContent = updateTabContent;
  window.updateProductsList = updateProductsList;
  window.updateProductProgressBars = updateProductProgressBars;
  window.startOrClickProduct = startOrClickProduct;
  window.upgradeProduct = upgradeProduct;
  window.hireOrUpgradeManager = hireOrUpgradeManager;
  window.createOrLinkManagerNPC = createOrLinkManagerNPC;
  window.buyClickPower = buyClickPower;
  window.buyIncomeBoost = buyIncomeBoost;
  window.buyCostReduction = buyCostReduction;
  window.updateUpgradesTab = updateUpgradesTab;
  
  // Boss fight functions
  window.startBossFight = startBossFight;
  window.bossFightAttack = bossFightAttack;
  window.bossFightRetreat = bossFightRetreat;
  window.closeBossFight = closeBossFight;
  window.checkBossFightRequirements = checkBossFightRequirements;
  window.generateInitialEmployees = generateInitialEmployees;
  window.setupAutosave = setupAutosave;
  window.calculateCashPerSecond = calculateCashPerSecond;
  window.getManagerSpeedMultiplier = getManagerSpeedMultiplier;
  window.currentCycleTimeMs = currentCycleTimeMs;
  window.currentValue = currentValue;
  window.clickReductionMs = clickReductionMs;
  
  // Social Network System Functions (for testing and debugging)
  window.initializeEmployeeSocialData = initializeEmployeeSocialData;
  window.updateRelationship = updateRelationship;
  window.generateRandomRelationships = generateRandomRelationships;
  window.updateCompanyAwareness = updateCompanyAwareness;
  window.logCompanyEvent = logCompanyEvent;
  window.getRelevantEvents = getRelevantEvents;
  window.getCoworkerContext = getCoworkerContext;
  window.getEmployeeAwarenessForPost = getEmployeeAwarenessForPost;
  window.getRandomCoworkerByRelation = getRandomCoworkerByRelation;
  window.getLocationCoworkers = getLocationCoworkers;
  window.getKnownLocations = getKnownLocations;
  window.knowsEmployee = knowsEmployee;
  window.createPost = createPost;
  window.createComment = createComment;
  window.createEvent = createEvent;
  window.createRelationship = createRelationship;
  
  // Social Feed UI Functions
  window.updateSocialTab = updateSocialTab;
  window.renderSocialFeed = renderSocialFeed;
  window.generateTestPost = generateTestPost;
  window.openPlayerPostComposer = openPlayerPostComposer;
  window.closePlayerPostModal = closePlayerPostModal;
  window.submitPlayerPostToFeed = submitPlayerPostToFeed;
  window.regeneratePlayerPostImage = regeneratePlayerPostImage;
  window.handleLikePost = handleLikePost;
  // toggleComments removed - now using modal system (openPostModal)
  window.openPostModal = openPostModal;
  window.submitModalComment = submitModalComment;
  window.addCommentToPost = addCommentToPost;
  window.openImageViewer = openImageViewer;
  window.showEmployeeProfile = showEmployeeProfile;
  window.loadProfileTab = loadProfileTab;
  window.openBioModal = openBioModal;
  window.linkifyMentions = linkifyMentions;
  
  // Autonomous Post Generation Functions
  window.autonomousPostGeneration = autonomousPostGeneration;
  window.generateEmployeePost = generateEmployeePost;
  window.generateFirstEmployeePost = generateFirstEmployeePost;
  window.generateAutonomousComments = generateAutonomousComments;
  window.generateAutonomousLikes = generateAutonomousLikes;
  
  // Initialize game when DOM is loaded
  document.addEventListener('DOMContentLoaded', initGame);
</script>

<style>
  /* General styles */
  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #0f1419;
    color: white;
    overflow-x: hidden;
    transition: background 1s ease-in-out;
  }
  
  /* Card styling */
  .card {
    transition: transform 0.2s;
  }
  
  .card:hover {
    transform: translateY(-5px);
  }
  
  .dashboard-card:hover {
    transform: translateY(-5px) scale(1.02);
    box-shadow: 0 6px 30px rgba(102,126,234,0.5) !important;
  }
  
  /* Custom scrollbar for dashboard sections */
  #dashRecentMessages::-webkit-scrollbar,
  #dashSocialMentions::-webkit-scrollbar,
  #dashTopPerformers::-webkit-scrollbar,
  #newsFeed::-webkit-scrollbar {
    width: 6px;
  }
  
  #dashRecentMessages::-webkit-scrollbar-track,
  #dashSocialMentions::-webkit-scrollbar-track,
  #dashTopPerformers::-webkit-scrollbar-track,
  #newsFeed::-webkit-scrollbar-track {
    background: #0f3460;
    border-radius: 3px;
  }
  
  #dashRecentMessages::-webkit-scrollbar-thumb,
  #dashSocialMentions::-webkit-scrollbar-thumb,
  #dashTopPerformers::-webkit-scrollbar-thumb,
  #newsFeed::-webkit-scrollbar-thumb {
    background: #00d4ff;
    border-radius: 3px;
  }
  
  #dashRecentMessages::-webkit-scrollbar-thumb:hover,
  #dashSocialMentions::-webkit-scrollbar-thumb:hover,
  #dashTopPerformers::-webkit-scrollbar-thumb:hover,
  #newsFeed::-webkit-scrollbar-thumb:hover {
    background: #00a8cc;
  }
  
  /* Button styling */
  button {
    transition: background-color 0.2s;
  }
  
  button:hover {
    opacity: 0.9;
  }
  
  /* Tab active styling */
  .tab-btn.active {
    border-bottom: 3px solid #e94560;
  }
  
  /* Modal styling */
  .modal {
    animation: fadeIn 0.3s;
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  @keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
  }
  
  /* Pulse animation for unlockable locations */
  @keyframes pulse {
    0%, 100% {
      opacity: 1;
      transform: scale(1);
    }
    50% {
      opacity: 0.8;
      transform: scale(1.05);
    }
  }

  /* Chat message styling */
  #chatMessages {
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><rect width="20" height="20" fill="%2316213e"/><circle cx="10" cy="10" r="1" fill="%230f3460"/></svg>');
    background-size: 20px 20px;
  }

  /* Notification animation */
  @keyframes slideIn {
    from { transform: translateX(100%); }
    to { transform: translateX(0); }
  }
  
  @keyframes slideDown {
    from { 
      transform: translateX(-50%) translateY(-20px);
      opacity: 0;
    }
    to { 
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
  }
  
  #newPostsNotification:hover {
    transform: translateX(-50%) scale(1.05) !important;
    box-shadow: 0 6px 30px rgba(0, 212, 255, 0.6) !important;
  }

  /* News ticker animation */
  @keyframes ticker {
    0% { transform: translateX(100%); }
    100% { transform: translateX(-100%); }
  }

  #newsContent {
    display: inline-block;
    animation: ticker 20s linear infinite;
  }

  /* Bulletproof hiring modal overlay */
  #hiringModal {
    position: fixed !important;
    inset: 0 !important;
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
    background: rgba(0,0,0,0.7) !important;
    z-index: 999999 !important; /* above chat/toasts/etc */
    pointer-events: auto !important;
  }
  #hiringModal * { pointer-events: auto !important; }
  #hiringModal[hidden] { display: none !important; }

  /* Bulletproof chat modal overlay */
  #chatModal {
    position: fixed !important;
    inset: 0 !important;
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
    background: rgba(0,0,0,0.7) !important;
    z-index: 999999 !important;
    pointer-events: auto !important;
  }
  #chatModal * { pointer-events: auto !important; }
  #chatModal[hidden], #chatModal[style*="display:none"] { display: none !important; pointer-events: none !important; }
  
  /* Boss fight modal */
  #bossFightModal[hidden], #bossFightModal[style*="display:none"] { display: none !important; }

  /* Cash display glow animations */
  @keyframes cash-glow {
    0%, 100% { 
      text-shadow: 0 0 15px rgba(255, 165, 0, 0.7), 0 0 30px rgba(255, 165, 0, 0.4);
      transform: scale(1);
    }
    50% { 
      text-shadow: 0 0 25px rgba(255, 165, 0, 0.9), 0 0 50px rgba(255, 165, 0, 0.6);
      transform: scale(1.02);
    }
  }

  @keyframes cash-glow-intense {
    0%, 100% { 
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.5), 0 0 60px rgba(255, 215, 0, 0.3);
      transform: scale(1);
    }
    50% { 
      text-shadow: 0 0 35px rgba(255, 215, 0, 1), 0 0 70px rgba(255, 215, 0, 0.8), 0 0 100px rgba(255, 215, 0, 0.5);
      transform: scale(1.05);
    }
  }

  /* Constant stream animation for sub-1-second product cycles */
  @keyframes constantStream {
    0% { 
      background-position: 0% 50%;
    }
    100% { 
      background-position: 200% 50%;
    }
  }

  /* ========== MOBILE RESPONSIVE STYLES ========== */
  
  /* Mobile breakpoint */
  @media screen and (max-width: 768px) {
    
    /* ===== MODAL IMPROVEMENTS ===== */
    
    /* Make modals scrollable and properly sized on mobile */
    .modal {
      padding: 10px !important;
      align-items: flex-start !important; /* Align to top instead of center */
      overflow-y: auto !important;
      -webkit-overflow-scrolling: touch !important; /* Smooth scrolling on iOS */
    }
    
    /* Modal content containers */
    .modal > div {
      width: 95% !important;
      max-width: 95% !important;
      max-height: 95vh !important;
      margin: 10px auto !important;
      overflow-y: auto !important;
      -webkit-overflow-scrolling: touch !important;
    }
    
    /* Chat modal specific */
    #chatModal > div {
      height: 90vh !important;
      max-height: 90vh !important;
    }
    
    /* Player profile modal - make scrollable */
    #playerProfileModal > div {
      max-height: 90vh !important;
      overflow-y: auto !important;
    }
    
    /* Boss fight modal */
    #bossFightModal > div {
      max-height: 90vh !important;
      overflow-y: auto !important;
    }
    
    /* Prestige modal */
    #prestigeModal > div {
      max-height: 90vh !important;
      overflow-y: auto !important;
    }
    
    /* ===== SOCIAL FEED MOBILE LAYOUT ===== */
    
    /* Social tab container - make it stack vertically */
    #socialTab > div {
      flex-direction: column !important;
      height: auto !important;
      gap: 15px !important;
    }
    
    /* Left sidebar - expand to full width */
    #socialTab > div > div:first-child {
      flex: 1 !important;
      width: 100% !important;
    }
    
    /* Feed container - expand to full width */
    #socialTab > div > div:nth-child(2) {
      flex: 1 !important;
      width: 100% !important;
      max-height: none !important;
    }
    
    /* Social feed posts - better mobile layout */
    .social-post {
      padding: 12px !important;
      margin-bottom: 12px !important;
    }
    
    /* Social post content - ensure proper text wrapping */
    .social-post p,
    .social-post div {
      word-wrap: break-word !important;
      overflow-wrap: break-word !important;
      word-break: normal !important;
      white-space: normal !important;
      max-width: 100% !important;
    }
    
    /* Social post images */
    .social-post img {
      max-width: 100% !important;
      height: auto !important;
    }
    
    /* ===== DASHBOARD IMPROVEMENTS ===== */
    
    /* Dashboard stats grid - single column on mobile */
    #dashboardTab > div[style*="grid-template-columns"] {
      grid-template-columns: 1fr !important;
    }
    
    /* Dashboard cards - adjust sizing */
    .dashboard-card {
      padding: 15px !important;
    }
    
    /* Main content grid - stack vertically */
    #dashboardTab > div[style*="grid-template-columns: 1fr 1fr"] {
      grid-template-columns: 1fr !important;
    }
    
    /* ===== TOP BAR IMPROVEMENTS ===== */
    
    /* Top bar - more compact on mobile */
    #topBar {
      padding: 8px 10px !important;
      font-size: 0.85rem !important;
      flex-wrap: wrap !important;
    }
    
    #topBar > div {
      gap: 10px !important;
      flex-wrap: wrap !important;
    }
    
    #topBar > div > div {
      font-size: 0.8rem !important;
    }
    
    /* ===== TAB NAVIGATION ===== */
    
    /* Tab buttons - better touch targets */
    .tab-btn {
      padding: 12px 15px !important;
      font-size: 0.9rem !important;
      min-width: fit-content !important;
    }
    
    #tabNav {
      overflow-x: auto !important;
      -webkit-overflow-scrolling: touch !important;
      white-space: nowrap !important;
    }
    
    /* ===== PEOPLE TAB IMPROVEMENTS ===== */
    
    /* Employee grid - single or double column on mobile */
    #peopleTab [style*="grid-template-columns"] {
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)) !important;
    }
    
    /* ===== BUSINESS TAB IMPROVEMENTS ===== */
    
    /* Products grid - single column on small screens */
    #productsList {
      grid-template-columns: 1fr !important;
      gap: 12px !important;
    }
    
    /* Product cards */
    .product-card {
      padding: 12px !important;
    }
    
    /* ===== TOUCH TARGET IMPROVEMENTS ===== */
    
    /* All buttons - minimum touch size */
    button {
      min-height: 44px !important;
      min-width: 44px !important;
      touch-action: manipulation !important;
    }
    
    /* Small icon buttons can be slightly smaller but still touch-friendly */
    button[style*="font-size:1.5rem"],
    button[style*="font-size:1.2rem"] {
      min-height: 40px !important;
      min-width: 40px !important;
    }
    
    /* Input fields - better touch targets */
    input, textarea, select {
      min-height: 44px !important;
      font-size: 16px !important; /* Prevent iOS zoom on focus */
      padding: 10px !important;
    }
    
    /* ===== HIRE MANAGER MODAL FIX ===== */
    
    /* Make hire manager modal scrollable and properly sized */
    #hiringModal {
      padding: 10px !important;
      overflow-y: auto !important;
      -webkit-overflow-scrolling: touch !important;
    }
    
    #hiringModal .hiring-modal-panel {
      width: 95% !important;
      max-width: 95% !important;
      max-height: 85vh !important;
      overflow-y: auto !important;
      padding: 15px !important;
      -webkit-overflow-scrolling: touch !important;
    }
    
    /* Candidate cards container - stack vertically on mobile */
    #hiringModal .hiring-modal-panel > div[style*="display:flex"] {
      flex-direction: column !important;
      align-items: center !important;
    }
    
    /* Individual candidate cards */
    #hiringModal .candidate-card {
      width: 100% !important;
      max-width: 350px !important;
      margin: 8px 0 !important;
    }
    
    /* Stats grid in candidate cards */
    #hiringModal .candidate-card > div[style*="grid-template-columns"] {
      grid-template-columns: repeat(2, 1fr) !important;
      gap: 6px !important;
    }
    
    /* ===== LOCATION SUBTABS FIX ===== */
    
    /* Location buttons - ensure horizontal scrolling */
    #locationSubtabs {
      display: flex !important;
      gap: 8px !important;
      overflow-x: auto !important;
      overflow-y: hidden !important;
      white-space: nowrap !important;
      -webkit-overflow-scrolling: touch !important;
      padding-bottom: 8px !important;
      scrollbar-width: thin !important;
    }
    
    /* Location buttons - prevent shrinking */
    #locationSubtabs button {
      flex-shrink: 0 !important;
      min-width: fit-content !important;
      padding: 10px 16px !important;
      white-space: nowrap !important;
      display: inline-flex !important;
      align-items: center !important;
      gap: 6px !important;
    }
    
    /* Ensure icons and text don't wrap */
    #locationSubtabs button span,
    #locationSubtabs button {
      white-space: nowrap !important;
    }
    
    /* ===== CHAT IMPROVEMENTS ===== */
    
    /* Chat modal container */
    #chatModal > div {
      width: 95% !important;
      max-width: 500px !important;
      height: 85vh !important;
      max-height: 85vh !important;
    }
    
    /* Chat messages area */
    #chatMessages {
      padding: 10px !important;
      gap: 8px !important;
    }
    
    /* Chat input container - proper flex layout */
    #chatModal > div > div:nth-last-child(2) {
      padding: 10px !important;
      display: flex !important;
      gap: 6px !important;
      flex-wrap: nowrap !important;
      align-items: center !important;
    }
    
    /* Chat attach and emoji buttons - fixed width */
    #chatAttachBtn,
    #chatEmojiBtn {
      flex-shrink: 0 !important;
      width: 40px !important;
      padding: 8px !important;
    }
    
    /* Chat input field - takes remaining space */
    #chatInput {
      flex: 1 1 auto !important;
      min-width: 0 !important;
      max-width: 100% !important;
      width: auto !important;
      margin: 0 !important;
    }
    
    /* Chat send button - fixed width */
    #chatSendBtn {
      flex-shrink: 0 !important;
      padding: 8px 12px !important;
      white-space: nowrap !important;
    }
    
    /* ===== MAIN CONTENT PADDING ===== */
    
    #mainContent {
      padding: 12px !important;
    }
    
    /* ===== CARDS AND CONTAINERS ===== */
    
    .card {
      padding: 12px !important;
      margin-bottom: 12px !important;
    }
    
    /* ===== TEXT SIZING ===== */
    
    h1 {
      font-size: 1.5rem !important;
    }
    
    h2 {
      font-size: 1.3rem !important;
    }
    
    h3 {
      font-size: 1.1rem !important;
    }
    
    /* ===== MODAL CLOSE BUTTONS ===== */
    
    /* Make close buttons larger and easier to tap */
    .modal button[style*="position:absolute"][style*="top:"] {
      width: 44px !important;
      height: 44px !important;
      font-size: 1.5rem !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
    }
    
    /* ===== IMAGE GALLERIES IN MODALS ===== */
    
    /* Request/send image modals - better layout */
    #requestImageModal > div,
    #sendImageModal > div,
    #requestPostModal > div {
      max-height: 85vh !important;
      overflow-y: auto !important;
    }
    
    /* Image preset buttons - grid layout */
    .request-preset,
    .send-preset,
    .request-post-preset {
      min-height: 44px !important;
      padding: 10px !important;
      font-size: 0.9rem !important;
    }
    
    /* ===== PLAYER POST COMPOSER ===== */
    
    #playerPostModal textarea {
      min-height: 120px !important;
      font-size: 16px !important;
    }
    
    /* ===== GIFTS TAB ===== */
    
    #giftsTab [style*="grid-template-columns"] {
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)) !important;
    }
    
    /* ===== HR TAB ===== */
    
    #hrTab [style*="grid-template-columns"] {
      grid-template-columns: 1fr !important;
    }
    
    /* ===== INVEST TAB ===== */
    
    #investTab [style*="grid-template-columns"] {
      grid-template-columns: 1fr !important;
    }
    
    /* ===== LANDSCAPE ORIENTATION IMPROVEMENTS ===== */
    
    @media (orientation: landscape) and (max-height: 500px) {
      /* Modals take full screen in landscape on short screens */
      .modal > div {
        width: 98% !important;
        max-height: 98vh !important;
        margin: 1vh auto !important;
      }
      
      /* Hire manager modal in landscape */
      #hiringModal .hiring-modal-panel {
        max-height: 96vh !important;
      }
      
      /* Reduce padding to maximize space */
      .modal > div > * {
        padding: 8px !important;
      }
      
      /* Top bar even more compact */
      #topBar {
        padding: 5px 8px !important;
        font-size: 0.75rem !important;
      }
      
      /* Tab navigation */
      .tab-btn {
        padding: 8px 12px !important;
        font-size: 0.85rem !important;
      }
      
      /* Location buttons even more compact in landscape */
      #locationSubtabs button {
        padding: 8px 12px !important;
        font-size: 0.85rem !important;
      }
    }
  }
  
  /* ===== TABLET BREAKPOINT (768px - 1024px) ===== */
  @media screen and (min-width: 769px) and (max-width: 1024px) {
    
    /* Slightly adjust layouts for tablets */
    #socialTab > div {
      flex-direction: row !important;
    }
    
    #socialTab > div > div:first-child {
      flex: 0 0 250px !important;
    }
    
    #socialTab > div > div:nth-child(2) {
      flex: 1 !important;
    }
    
    /* Dashboard - 2 columns */
    #dashboardTab > div[style*="grid-template-columns"] {
      grid-template-columns: repeat(2, 1fr) !important;
    }
    
    /* Products - 2 columns */
    #productsList {
      grid-template-columns: repeat(2, 1fr) !important;
    }
  }
  
  /* ===== SMALL MOBILE (< 400px) ===== */
  @media screen and (max-width: 400px) {
    
    /* Even more compact */
    #topBar {
      font-size: 0.75rem !important;
      padding: 6px 8px !important;
    }
    
    .tab-btn {
      padding: 10px 12px !important;
      font-size: 0.85rem !important;
    }
    
    /* Location buttons on very small screens */
    #locationSubtabs button {
      padding: 8px 12px !important;
      font-size: 0.8rem !important;
    }
    
    #mainContent {
      padding: 8px !important;
    }
    
    /* Modal content */
    .modal > div {
      width: 98% !important;
      padding: 15px !important;
    }
    
    /* Hire manager modal on small screens */
    #hiringModal .hiring-modal-panel {
      width: 98% !important;
      padding: 12px !important;
    }
    
    #hiringModal .candidate-card {
      max-width: 100% !important;
      padding: 12px !important;
    }
    
    /* Chat input on very small screens - even more compact */
    #chatAttachBtn,
    #chatEmojiBtn {
      width: 36px !important;
      padding: 6px !important;
      font-size: 1rem !important;
    }
    
    #chatSendBtn {
      padding: 6px 10px !important;
      font-size: 0.9rem !important;
    }
    
    /* Smaller text in tight spaces */
    .dashboard-card {
      font-size: 0.9rem !important;
    }
  }
  
  /* ===== ACCESSIBILITY IMPROVEMENTS ===== */
  
  /* Better focus indicators for keyboard/screen reader users */
  @media (hover: none) and (pointer: coarse) {
    /* Touch devices */
    button:active {
      transform: scale(0.98);
      opacity: 0.9;
    }
  }
  
  /* ========== CHAT MESSAGE EDITING STYLES ========== */
  
  /* Edit and resend buttons */
  .edit-btn, .resend-btn {
    opacity: 0;
    transition: opacity 0.2s ease;
  }
  
  .chat-message:hover .edit-btn,
  .chat-message:hover .resend-btn {
    opacity: 1;
  }
  
  /* Make buttons always visible on touch devices */
  @media (hover: none) and (pointer: coarse) {
    .edit-btn, .resend-btn {
      opacity: 0.7;
    }
    
    .chat-message:active .edit-btn,
    .chat-message:active .resend-btn {
      opacity: 1;
    }
  }
  
  /* Edit mode indicator for send button */
  #chatSendBtn {
    transition: all 0.3s ease;
  }
  
  #chatSendBtn.editing-mode {
    background-color: #ff9800 !important;
    animation: pulse-edit 2s infinite;
  }
  
  @keyframes pulse-edit {
    0%, 100% {
      box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.7);
    }
    50% {
      box-shadow: 0 0 0 10px rgba(255, 152, 0, 0);
    }
  }
  
  /* Regeneration count badge */
  .regenerate-count {
    display: inline-block;
    background: rgba(255, 152, 0, 0.2);
    color: #ff9800;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 10px;
    margin-left: 4px;
    font-weight: bold;
  }
  
  /* High contrast mode support */
  @media (prefers-contrast: high) {
    button {
      border: 2px solid currentColor !important;
    }
  }
  
  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
    
    #chatSendBtn.editing-mode {
      animation: none !important;
    }
  }
</style>
